ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
NsS'dataFileName'
p7
Vdata/C20_infer_design1_no_eyetracking_2015_Oct_16_1026
p8
sS'runtimeInfo'
p9
NsS'name'
p10
S'infer_design1_no_eyetracking'
p11
sS'dataNames'
p12
(lp13
S'instr_main_resp.keys'
p14
aS'instr_main_resp.rt'
p15
aS'instr_bdm_resp.keys'
p16
aS'partnered_pilot_participant'
p17
aS'instr_bdm_resp.rt'
p18
aS'bdm_bid1.response'
p19
aS'bdm_bid1.rt'
p20
aS'bdm_marker_start'
p21
aS'instr_choice_resp.keys'
p22
aS'instr_choice_resp.rt'
p23
aS'key_resp_choice.keys'
p24
aS'key_resp_choice.rt'
p25
aS'confidence_rating1.response'
p26
aS'confidence_rating1.rt'
p27
aS'confidence_marker_start'
p28
aS'instr_infer_intro_resp.keys'
p29
aS'instr_infer_intro_resp.rt'
p30
aS'instr_infer_practice_resp.keys'
p31
aS'instr_infer_practice_resp.rt'
p32
aS'set_feedback.feedback_img'
p33
aS'trial_start_time'
p34
aS'instr_infer_resp.keys'
p35
aS'instr_infer_resp.rt'
p36
aS'get_ready_resp.keys'
p37
aS'infer_resp.keys'
p38
aS'infer_resp.rt'
p39
aS'rest_prompt_resp.keys'
p40
aS'rest_prompt_resp.rt'
p41
aS'correct_counter'
p42
aS'incorrect_counter'
p43
aS'auction.win_item'
p44
aS'auction.price'
p45
aS'auction.bid'
p46
aS'auction.rand_itm_img'
p47
aS'score.base'
p48
aS'score.rwrd'
p49
aS'score.loss'
p50
aS'score.final_pymt'
p51
asS'autoLog'
p52
I01
sS'extraInfo'
p53
(dp54
S'expName'
p55
g11
sVeye
p56
Vr
sVcontacts
p57
Vy
sS'frameRate'
p58
cnumpy.core.multiarray
scalar
p59
(cnumpy
dtype
p60
(S'f8'
I0
I1
tRp61
(I3
S'<'
NNNI-1
I-1
I0
tbS'\xb4,\x8a\xcf\x07\x07N@'
tRp62
sVsession
p63
V001
p64
sS'date'
p65
V2015_Oct_16_1026
p66
sVparticipant
p67
VC20
p68
sVglasses
p69
Vn
ssS'loopsUnfinished'
p70
(lp71
sS'saveWideText'
p72
I01
sS'thisEntry'
p73
(dp74
sS'version'
p75
S''
sS'_paramNamesSoFar'
p76
(lp77
Vbdm_img
p78
aS'choice_left'
p79
aS'choice_right'
p80
aS'img_correct'
p81
aS'img_left'
p82
aS'img_wrong'
p83
aS'img_right'
p84
asS'entries'
p85
(lp86
(dp87
g63
g64
sg56
Vr
sg15
F2.9167676863285124
sg14
S'space'
p88
sg58
g62
sg57
Vy
sg55
g11
sg65
g66
sg67
g68
sg69
Vn
sa(dp89
g63
g64
sg56
Vr
sg57
Vy
sg58
g62
sg16
S'space'
p90
sg55
g11
sg65
g66
sg67
g68
sg18
F12.399830879971432
sg17
cnumpy.core.multiarray
_reconstruct
p91
(cnumpy
ndarray
p92
(I0
tS'b'
tRp93
(I1
(I1
tg60
(S'S3'
I0
I1
tRp94
(I3
S'|'
NNNI3
I1
I0
tbI00
S'P2\x00'
tbsg69
Vn
sa(dp95
g63
g64
sg20
F6.3840000000000003
sg56
Vr
sg57
Vy
sg58
g62
sS'bdm_loop1.thisN'
p96
I0
sg19
F0
sg55
g11
sS'bdm_loop1.thisIndex'
p97
g59
(g60
(S'i4'
I0
I1
tRp98
(I3
S'<'
NNNI-1
I-1
I0
tbS'\x05\x00\x00\x00'
tRp99
sS'bdm_loop1.thisRepN'
p100
I0
sS'bdm_loop1.thisTrialN'
p101
I0
sg65
g66
sg67
g68
sg78
V6-sour_patch_kids.png
p102
sg21
F1.5
sg69
Vn
sa(dp103
g63
g64
sg20
F2.9009999999999998
sg56
Vr
sg57
Vy
sg58
g62
sS'bdm_loop1.thisN'
p104
I1
sg19
F0
sg55
g11
sS'bdm_loop1.thisIndex'
p105
g59
(g98
S'\x19\x00\x00\x00'
tRp106
sS'bdm_loop1.thisRepN'
p107
I0
sS'bdm_loop1.thisTrialN'
p108
I1
sg65
g66
sg67
g68
sg78
V34-hula_hoops_bbq_beef_redo.png
p109
sg21
F1.2
sg69
Vn
sa(dp110
g63
g64
sg20
F2.9670000000000001
sg56
Vr
sg57
Vy
sg58
g62
sS'bdm_loop1.thisN'
p111
I2
sg19
F0
sg55
g11
sS'bdm_loop1.thisIndex'
p112
g59
(g98
S'\x16\x00\x00\x00'
tRp113
sS'bdm_loop1.thisRepN'
p114
I0
sS'bdm_loop1.thisTrialN'
p115
I2
sg65
g66
sg67
g68
sg78
V30-spaghetti_hoops.png
p116
sg21
F2
sg69
Vn
sa(dp117
g63
g64
sg20
F23.050000000000001
sg56
Vr
sg57
Vy
sg58
g62
sS'bdm_loop1.thisN'
p118
I3
sg19
F0
sg55
g11
sS'bdm_loop1.thisIndex'
p119
g59
(g98
S'\x0c\x00\x00\x00'
tRp120
sS'bdm_loop1.thisRepN'
p121
I0
sS'bdm_loop1.thisTrialN'
p122
I3
sg65
g66
sg67
g68
sg78
V18-mms.png
p123
sg21
F1.8
sg69
Vn
sa(dp124
g63
g64
sg20
F2.867
sg56
Vr
sg57
Vy
sg58
g62
sS'bdm_loop1.thisN'
p125
I4
sg19
F0
sg55
g11
sS'bdm_loop1.thisIndex'
p126
g59
(g98
S'\x02\x00\x00\x00'
tRp127
sS'bdm_loop1.thisRepN'
p128
I0
sS'bdm_loop1.thisTrialN'
p129
I4
sg65
g66
sg67
g68
sg78
V3-ellas_strawberries_apples.png
p130
sg21
F1.6000000000000001
sg69
Vn
sa(dp131
g63
g64
sg20
F2.617
sg56
Vr
sg57
Vy
sg58
g62
sS'bdm_loop1.thisN'
p132
I5
sg19
F0
sg55
g11
sS'bdm_loop1.thisIndex'
p133
g59
(g98
S'\x01\x00\x00\x00'
tRp134
sS'bdm_loop1.thisRepN'
p135
I0
sS'bdm_loop1.thisTrialN'
p136
I5
sg65
g66
sg67
g68
sg78
V2-steamed_puddings.png
p137
sg21
F1.3
sg69
Vn
sa(dp138
g63
g64
sg20
F2.8340000000000001
sg56
Vr
sg57
Vy
sg58
g62
sS'bdm_loop1.thisN'
p139
I6
sg19
F0
sg55
g11
sS'bdm_loop1.thisIndex'
p140
g59
(g98
S'\x03\x00\x00\x00'
tRp141
sS'bdm_loop1.thisRepN'
p142
I0
sS'bdm_loop1.thisTrialN'
p143
I6
sg65
g66
sg67
g68
sg78
V4-corn.png
p144
sg21
F1.8
sg69
Vn
sa(dp145
g63
g64
sg20
F6.2510000000000003
sg56
Vr
sg57
Vy
sg58
g62
sS'bdm_loop1.thisN'
p146
I7
sg19
F0
sg55
g11
sS'bdm_loop1.thisIndex'
p147
g59
(g98
S'\x00\x00\x00\x00'
tRp148
sS'bdm_loop1.thisRepN'
p149
I0
sS'bdm_loop1.thisTrialN'
p150
I7
sg65
g66
sg67
g68
sg78
V1-treacle_cookies.png
p151
sg21
F1.3
sg69
Vn
sa(dp152
g63
g64
sg20
F3.6669999999999998
sg56
Vr
sg57
Vy
sg58
g62
sS'bdm_loop1.thisN'
p153
I8
sg19
F0
sg55
g11
sS'bdm_loop1.thisIndex'
p154
g59
(g98
S'\x1e\x00\x00\x00'
tRp155
sS'bdm_loop1.thisRepN'
p156
I0
sS'bdm_loop1.thisTrialN'
p157
I8
sg65
g66
sg67
g68
sg78
V41-peanuts_redo.png
p158
sg21
F1.8999999999999999
sg69
Vn
sa(dp159
g63
g64
sg20
F3.8170000000000002
sg56
Vr
sg57
Vy
sg58
g62
sS'bdm_loop1.thisN'
p160
I9
sg19
F0
sg55
g11
sS'bdm_loop1.thisIndex'
p161
g59
(g98
S'\x18\x00\x00\x00'
tRp162
sS'bdm_loop1.thisRepN'
p163
I0
sS'bdm_loop1.thisTrialN'
p164
I9
sg65
g66
sg67
g68
sg78
V33-ambrosia_rice.png
p165
sg21
F1.6000000000000001
sg69
Vn
sa(dp166
g63
g64
sg20
F3.5840000000000001
sg56
Vr
sg57
Vy
sg58
g62
sS'bdm_loop1.thisN'
p167
I10
sg19
F0
sg55
g11
sS'bdm_loop1.thisIndex'
p168
g59
(g98
S'$\x00\x00\x00'
tRp169
sS'bdm_loop1.thisRepN'
p170
I0
sS'bdm_loop1.thisTrialN'
p171
I10
sg65
g66
sg67
g68
sg78
V48-twix.png
p172
sg21
F1.7
sg69
Vn
sa(dp173
g63
g64
sg20
F3.1339999999999999
sg56
Vr
sg57
Vy
sg58
g62
sS'bdm_loop1.thisN'
p174
I11
sg19
F0
sg55
g11
sS'bdm_loop1.thisIndex'
p175
g59
(g98
S'!\x00\x00\x00'
tRp176
sS'bdm_loop1.thisRepN'
p177
I0
sS'bdm_loop1.thisTrialN'
p178
I11
sg65
g66
sg67
g68
sg78
V44-crunch.png
p179
sg21
F1.3
sg69
Vn
sa(dp180
g63
g64
sg20
F2.4169999999999998
sg56
Vr
sg57
Vy
sg58
g62
sS'bdm_loop1.thisN'
p181
I12
sg19
F0
sg55
g11
sS'bdm_loop1.thisIndex'
p182
g59
(g98
S'\x13\x00\x00\x00'
tRp183
sS'bdm_loop1.thisRepN'
p184
I0
sS'bdm_loop1.thisTrialN'
p185
I12
sg65
g66
sg67
g68
sg78
V26-walkers_smoky_bacon.png
p186
sg21
F1.1000000000000001
sg69
Vn
sa(dp187
g63
g64
sg20
F4.4669999999999996
sg56
Vr
sg57
Vy
sg58
g62
sS'bdm_loop1.thisN'
p188
I13
sg19
F0.059999999999999387
sg55
g11
sS'bdm_loop1.thisIndex'
p189
g59
(g98
S'\x12\x00\x00\x00'
tRp190
sS'bdm_loop1.thisRepN'
p191
I0
sS'bdm_loop1.thisTrialN'
p192
I13
sg65
g66
sg67
g68
sg78
V25-kitkat.png
p193
sg21
F1.1000000000000001
sg69
Vn
sa(dp194
g63
g64
sg20
F2.8490000000000002
sg56
Vr
sg57
Vy
sg58
g62
sS'bdm_loop1.thisN'
p195
I14
sg19
F0
sg55
g11
sS'bdm_loop1.thisIndex'
p196
g59
(g98
S'\x1b\x00\x00\x00'
tRp197
sS'bdm_loop1.thisRepN'
p198
I0
sS'bdm_loop1.thisTrialN'
p199
I14
sg65
g66
sg67
g68
sg78
V36-fig_rolls.png
p200
sg21
F1.6000000000000001
sg69
Vn
sa(dp201
g63
g64
sg20
F8.1189999999999998
sg56
Vr
sg57
Vy
sg58
g62
sS'bdm_loop1.thisN'
p202
I15
sg19
F0
sg55
g11
sS'bdm_loop1.thisIndex'
p203
g59
(g98
S'\x1d\x00\x00\x00'
tRp204
sS'bdm_loop1.thisRepN'
p205
I0
sS'bdm_loop1.thisTrialN'
p206
I15
sg65
g66
sg67
g68
sg78
V40-sardines.png
p207
sg21
F1.3999999999999999
sg69
Vn
sa(dp208
g63
g64
sg20
F2.5510000000000002
sg56
Vr
sg57
Vy
sg58
g62
sS'bdm_loop1.thisN'
p209
I16
sg19
F0
sg55
g11
sS'bdm_loop1.thisIndex'
p210
g59
(g98
S'\x14\x00\x00\x00'
tRp211
sS'bdm_loop1.thisRepN'
p212
I0
sS'bdm_loop1.thisTrialN'
p213
I16
sg65
g66
sg67
g68
sg78
V27-hartleys_raspberries_jelly.png
p214
sg21
F1.3999999999999999
sg69
Vn
sa(dp215
g63
g64
sg20
F5.5339999999999998
sg56
Vr
sg57
Vy
sg58
g62
sS'bdm_loop1.thisN'
p216
I17
sg19
F0
sg55
g11
sS'bdm_loop1.thisIndex'
p217
g59
(g98
S'\x04\x00\x00\x00'
tRp218
sS'bdm_loop1.thisRepN'
p219
I0
sS'bdm_loop1.thisTrialN'
p220
I17
sg65
g66
sg67
g68
sg78
V5-pineapple.png
p221
sg21
F1.8999999999999999
sg69
Vn
sa(dp222
g63
g64
sg20
F3.1509999999999998
sg56
Vr
sg57
Vy
sg58
g62
sS'bdm_loop1.thisN'
p223
I18
sg19
F0
sg55
g11
sS'bdm_loop1.thisIndex'
p224
g59
(g98
S'\x0b\x00\x00\x00'
tRp225
sS'bdm_loop1.thisRepN'
p226
I0
sS'bdm_loop1.thisTrialN'
p227
I18
sg65
g66
sg67
g68
sg78
V17-jacobs_mini_cheddars_redo.png
p228
sg21
F2
sg69
Vn
sa(dp229
g63
g64
sg20
F7.6509999999999998
sg56
Vr
sg57
Vy
sg58
g62
sS'bdm_loop1.thisN'
p230
I19
sg19
F0.079999999999998947
sg55
g11
sS'bdm_loop1.thisIndex'
p231
g59
(g98
S'%\x00\x00\x00'
tRp232
sS'bdm_loop1.thisRepN'
p233
I0
sS'bdm_loop1.thisTrialN'
p234
I19
sg65
g66
sg67
g68
sg78
V49-yorkie.png
p235
sg21
F1.5
sg69
Vn
sa(dp236
g63
g64
sg20
F6.9009999999999998
sg56
Vr
sg57
Vy
sg58
g62
sS'bdm_loop1.thisN'
p237
I20
sg19
F0
sg55
g11
sS'bdm_loop1.thisIndex'
p238
g59
(g98
S'\t\x00\x00\x00'
tRp239
sS'bdm_loop1.thisRepN'
p240
I0
sS'bdm_loop1.thisTrialN'
p241
I20
sg65
g66
sg67
g68
sg78
V13-mccoys_steak_crisps.png
p242
sg21
F1.6000000000000001
sg69
Vn
sa(dp243
g63
g64
sg20
F5.8339999999999996
sg56
Vr
sg57
Vy
sg58
g62
sS'bdm_loop1.thisN'
p244
I21
sg19
F0.15999999999999895
sg55
g11
sS'bdm_loop1.thisIndex'
p245
g59
(g98
S'\x08\x00\x00\x00'
tRp246
sS'bdm_loop1.thisRepN'
p247
I0
sS'bdm_loop1.thisTrialN'
p248
I21
sg65
g66
sg67
g68
sg78
V10-bounty_redo.png
p249
sg21
F1.6000000000000001
sg69
Vn
sa(dp250
g63
g64
sg20
F11.667
sg56
Vr
sg57
Vy
sg58
g62
sS'bdm_loop1.thisN'
p251
I22
sg19
F1.5000000000000002
sg55
g11
sS'bdm_loop1.thisIndex'
p252
g59
(g98
S'\x17\x00\x00\x00'
tRp253
sS'bdm_loop1.thisRepN'
p254
I0
sS'bdm_loop1.thisTrialN'
p255
I22
sg65
g66
sg67
g68
sg78
V31-hobnobs.png
p256
sg21
F1.2
sg69
Vn
sa(dp257
g63
g64
sg20
F6.9169999999999998
sg56
Vr
sg57
Vy
sg58
g62
sS'bdm_loop1.thisN'
p258
I23
sg19
F0.099999999999998729
sg55
g11
sS'bdm_loop1.thisIndex'
p259
g59
(g98
S'\r\x00\x00\x00'
tRp260
sS'bdm_loop1.thisRepN'
p261
I0
sS'bdm_loop1.thisTrialN'
p262
I23
sg65
g66
sg67
g68
sg78
V19-caramello_redo.png
p263
sg21
F1.7
sg69
Vn
sa(dp264
g63
g64
sg20
F7.2169999999999996
sg56
Vr
sg57
Vy
sg58
g62
sS'bdm_loop1.thisN'
p265
I24
sg19
F0.55999999999999917
sg55
g11
sS'bdm_loop1.thisIndex'
p266
g59
(g98
S'#\x00\x00\x00'
tRp267
sS'bdm_loop1.thisRepN'
p268
I0
sS'bdm_loop1.thisTrialN'
p269
I24
sg65
g66
sg67
g68
sg78
V46-pistachios.png
p270
sg21
F1.5
sg69
Vn
sa(dp271
g63
g64
sg20
F2.5499999999999998
sg56
Vr
sg57
Vy
sg58
g62
sS'bdm_loop1.thisN'
p272
I25
sg19
F0
sg55
g11
sS'bdm_loop1.thisIndex'
p273
g59
(g98
S'\x0e\x00\x00\x00'
tRp274
sS'bdm_loop1.thisRepN'
p275
I0
sS'bdm_loop1.thisTrialN'
p276
I25
sg65
g66
sg67
g68
sg78
V20-fruit_pastilles.png
p277
sg21
F1.3
sg69
Vn
sa(dp278
g63
g64
sg20
F8.984
sg56
Vr
sg57
Vy
sg58
g62
sS'bdm_loop1.thisN'
p279
I26
sg19
F0.35999999999999943
sg55
g11
sS'bdm_loop1.thisIndex'
p280
g59
(g98
S'\x1c\x00\x00\x00'
tRp281
sS'bdm_loop1.thisRepN'
p282
I0
sS'bdm_loop1.thisTrialN'
p283
I26
sg65
g66
sg67
g68
sg78
V38-maltesers.png
p284
sg21
F1.1000000000000001
sg69
Vn
sa(dp285
g63
g64
sg20
F2.851
sg56
Vr
sg57
Vy
sg58
g62
sS'bdm_loop1.thisN'
p286
I27
sg19
F0
sg55
g11
sS'bdm_loop1.thisIndex'
p287
g59
(g98
S' \x00\x00\x00'
tRp288
sS'bdm_loop1.thisRepN'
p289
I0
sS'bdm_loop1.thisTrialN'
p290
I27
sg65
g66
sg67
g68
sg78
V43-mrporky_pork_crackles_redo.png
p291
sg21
F1.7
sg69
Vn
sa(dp292
g63
g64
sg20
F3.0169999999999999
sg56
Vr
sg57
Vy
sg58
g62
sS'bdm_loop1.thisN'
p293
I28
sg19
F0
sg55
g11
sS'bdm_loop1.thisIndex'
p294
g59
(g98
S'\x06\x00\x00\x00'
tRp295
sS'bdm_loop1.thisRepN'
p296
I0
sS'bdm_loop1.thisTrialN'
p297
I28
sg65
g66
sg67
g68
sg78
V7-olives.png
p298
sg21
F1
sg69
Vn
sa(dp299
g63
g64
sg20
F2.0670000000000002
sg56
Vr
sg57
Vy
sg58
g62
sS'bdm_loop1.thisN'
p300
I29
sg19
F0
sg55
g11
sS'bdm_loop1.thisIndex'
p301
g59
(g98
S'&\x00\x00\x00'
tRp302
sS'bdm_loop1.thisRepN'
p303
I0
sS'bdm_loop1.thisTrialN'
p304
I29
sg65
g66
sg67
g68
sg78
V50-polo.png
p305
sg21
F1
sg69
Vn
sa(dp306
g63
g64
sg20
F7.2510000000000003
sg56
Vr
sg57
Vy
sg58
g62
sS'bdm_loop1.thisN'
p307
I30
sg19
F0.4399999999999995
sg55
g11
sS'bdm_loop1.thisIndex'
p308
g59
(g98
S'\x0f\x00\x00\x00'
tRp309
sS'bdm_loop1.thisRepN'
p310
I0
sS'bdm_loop1.thisTrialN'
p311
I30
sg65
g66
sg67
g68
sg78
V21-nakd_banana_crunch.png
p312
sg21
F1
sg69
Vn
sa(dp313
g63
g64
sg20
F3.1339999999999999
sg56
Vr
sg57
Vy
sg58
g62
sS'bdm_loop1.thisN'
p314
I31
sg19
F0
sg55
g11
sS'bdm_loop1.thisIndex'
p315
g59
(g98
S'\x07\x00\x00\x00'
tRp316
sS'bdm_loop1.thisRepN'
p317
I0
sS'bdm_loop1.thisTrialN'
p318
I31
sg65
g66
sg67
g68
sg78
V8-liquorice_catherine_wheels.png
p319
sg21
F2
sg69
Vn
sa(dp320
g63
g64
sg20
F8.2170000000000005
sg56
Vr
sg57
Vy
sg58
g62
sS'bdm_loop1.thisN'
p321
I32
sg19
F0.1399999999999994
sg55
g11
sS'bdm_loop1.thisIndex'
p322
g59
(g98
S'\x1f\x00\x00\x00'
tRp323
sS'bdm_loop1.thisRepN'
p324
I0
sS'bdm_loop1.thisTrialN'
p325
I32
sg65
g66
sg67
g68
sg78
V42-mrkipling_lemon_slices.png
p326
sg21
F1
sg69
Vn
sa(dp327
g63
g64
sg20
F4.4509999999999996
sg56
Vr
sg57
Vy
sg58
g62
sS'bdm_loop1.thisN'
p328
I33
sg19
F0.11999999999999895
sg55
g11
sS'bdm_loop1.thisIndex'
p329
g59
(g98
S'\x11\x00\x00\x00'
tRp330
sS'bdm_loop1.thisRepN'
p331
I0
sS'bdm_loop1.thisTrialN'
p332
I33
sg65
g66
sg67
g68
sg78
V23-crunchie_redo.png
p333
sg21
F1.6000000000000001
sg69
Vn
sa(dp334
g63
g64
sg20
F2.617
sg56
Vr
sg57
Vy
sg58
g62
sS'bdm_loop1.thisN'
p335
I34
sg19
F0
sg55
g11
sS'bdm_loop1.thisIndex'
p336
g59
(g98
S'\n\x00\x00\x00'
tRp337
sS'bdm_loop1.thisRepN'
p338
I0
sS'bdm_loop1.thisTrialN'
p339
I34
sg65
g66
sg67
g68
sg78
V16-skips_prawn.png
p340
sg21
F1.6000000000000001
sg69
Vn
sa(dp341
g63
g64
sg20
F2.1669999999999998
sg56
Vr
sg57
Vy
sg58
g62
sS'bdm_loop1.thisN'
p342
I35
sg19
F0
sg55
g11
sS'bdm_loop1.thisIndex'
p343
g59
(g98
S'"\x00\x00\x00'
tRp344
sS'bdm_loop1.thisRepN'
p345
I0
sS'bdm_loop1.thisTrialN'
p346
I35
sg65
g66
sg67
g68
sg78
V45-chewy_nougat_redo.png
p347
sg21
F1.3
sg69
Vn
sa(dp348
g63
g64
sg20
F5.3339999999999996
sg56
Vr
sg57
Vy
sg58
g62
sS'bdm_loop1.thisN'
p349
I36
sg19
F0.17999999999999872
sg55
g11
sS'bdm_loop1.thisIndex'
p350
g59
(g98
S"'\x00\x00\x00"
tRp351
sS'bdm_loop1.thisRepN'
p352
I0
sS'bdm_loop1.thisTrialN'
p353
I36
sg65
g66
sg67
g68
sg78
V51-mars.png
p354
sg21
F1.7
sg69
Vn
sa(dp355
g63
g64
sg20
F5.5170000000000003
sg56
Vr
sg57
Vy
sg58
g62
sS'bdm_loop1.thisN'
p356
I37
sg19
F0.19999999999999871
sg55
g11
sS'bdm_loop1.thisIndex'
p357
g59
(g98
S'\x15\x00\x00\x00'
tRp358
sS'bdm_loop1.thisRepN'
p359
I0
sS'bdm_loop1.thisTrialN'
p360
I37
sg65
g66
sg67
g68
sg78
V29-beans.png
p361
sg21
F1.8
sg69
Vn
sa(dp362
g63
g64
sg20
F5.5010000000000003
sg56
Vr
sg57
Vy
sg58
g62
sS'bdm_loop1.thisN'
p363
I38
sg19
F0.039999999999998939
sg55
g11
sS'bdm_loop1.thisIndex'
p364
g59
(g98
S'\x10\x00\x00\x00'
tRp365
sS'bdm_loop1.thisRepN'
p366
I0
sS'bdm_loop1.thisTrialN'
p367
I38
sg65
g66
sg67
g68
sg78
V22-daim.png
p368
sg21
F1.5
sg69
Vn
sa(dp369
g63
g64
sg20
F5.5010000000000003
sg56
Vr
sg57
Vy
sg58
g62
sS'bdm_loop1.thisN'
p370
I39
sg19
F0.11999999999999895
sg55
g11
sS'bdm_loop1.thisIndex'
p371
g59
(g98
S'\x1a\x00\x00\x00'
tRp372
sS'bdm_loop1.thisRepN'
p373
I0
sS'bdm_loop1.thisTrialN'
p374
I39
sg65
g66
sg67
g68
sg78
V35-raisins.png
p375
sg21
F1.5
sg69
Vn
sa(dp376
g63
g64
sg55
g11
sg56
Vr
sg23
F2.2502280782582602
sg57
Vy
sg58
g62
sg22
S'space'
p377
sg65
g66
sg67
g68
sg69
Vn
sa(dp378
g63
g64
sS'binary.thisRepN'
p379
I0
sg67
g68
sg79
S'49-yorkie.png'
p380
sg26
F1.5999999999999996
sg28
F2.7999999999999998
sg58
g62
sg57
Vy
sg80
S'35-raisins.png'
p381
sg65
g66
sg55
g11
sS'binary.thisN'
p382
I0
sg56
Vr
sS'binary.thisIndex'
p383
g59
(g98
S'\x00\x00\x00\x00'
tRp384
sg24
S'right'
p385
sS'binary.thisTrialN'
p386
I0
sg25
F6.5499787887220009
sg27
F8.9339999999999993
sg69
Vn
sa(dp387
g63
g64
sS'binary.thisRepN'
p388
I0
sg67
g68
sg79
S'8-liquorice_catherine_wheels.png'
p389
sg26
F4.5000000000000009
sg28
F3.7000000000000002
sg58
g62
sg57
Vy
sg80
S'17-jacobs_mini_cheddars_redo.png'
p390
sg65
g66
sg55
g11
sS'binary.thisN'
p391
I1
sg56
Vr
sS'binary.thisIndex'
p392
g59
(g98
S'\x01\x00\x00\x00'
tRp393
sg24
S'right'
p394
sS'binary.thisTrialN'
p395
I1
sg25
F3.2833498880133902
sg27
F7.4009999999999998
sg69
Vn
sa(dp396
g63
g64
sS'binary.thisRepN'
p397
I0
sg67
g68
sg79
S'50-polo.png'
p398
sg26
F5.9999999999999982
sg28
F2.8999999999999999
sg58
g62
sg57
Vy
sg80
S'48-twix.png'
p399
sg65
g66
sg55
g11
sS'binary.thisN'
p400
I2
sg56
Vr
sS'binary.thisIndex'
p401
g59
(g98
S'\x02\x00\x00\x00'
tRp402
sg24
S'right'
p403
sS'binary.thisTrialN'
p404
I2
sg25
F1.3333557610285425
sg27
F5.984
sg69
Vn
sa(dp405
g63
g64
sS'binary.thisRepN'
p406
I0
sg67
g68
sg79
S'21-nakd_banana_crunch.png'
p407
sg26
F5.9999999999999982
sg28
F3
sg58
g62
sg57
Vy
sg80
S'1-treacle_cookies.png'
p408
sg65
g66
sg55
g11
sS'binary.thisN'
p409
I3
sg56
Vr
sS'binary.thisIndex'
p410
g59
(g98
S'\x03\x00\x00\x00'
tRp411
sg24
S'left'
p412
sS'binary.thisTrialN'
p413
I3
sg25
F1.5333781126978465
sg27
F1.6839999999999999
sg69
Vn
sa(dp414
g63
g64
sS'binary.thisRepN'
p415
I0
sg67
g68
sg79
S'45-chewy_nougat_redo.png'
p416
sg26
F5.9999999999999973
sg28
F3.2999999999999998
sg58
g62
sg57
Vy
sg80
S'41-peanuts_redo.png'
p417
sg65
g66
sg55
g11
sS'binary.thisN'
p418
I4
sg56
Vr
sS'binary.thisIndex'
p419
g59
(g98
S'\x04\x00\x00\x00'
tRp420
sg24
S'right'
p421
sS'binary.thisTrialN'
p422
I4
sg25
F2.383338826218278
sg27
F1.8340000000000001
sg69
Vn
sa(dp423
g63
g64
sS'binary.thisRepN'
p424
I0
sg67
g68
sg79
S'43-mrporky_pork_crackles_redo.png'
p425
sg26
F5.9999999999999982
sg28
F2.8999999999999999
sg58
g62
sg57
Vy
sg80
S'18-mms.png'
p426
sg65
g66
sg55
g11
sS'binary.thisN'
p427
I5
sg56
Vr
sS'binary.thisIndex'
p428
g59
(g98
S'\x05\x00\x00\x00'
tRp429
sg24
S'right'
p430
sS'binary.thisTrialN'
p431
I5
sg25
F1.3501845153109571
sg27
F1.3839999999999999
sg69
Vn
sa(dp432
g63
g64
sS'binary.thisRepN'
p433
I0
sg67
g68
sg79
S'27-hartleys_raspberries_jelly.png'
p434
sg26
F5.4999999999999982
sg28
F4.2999999999999998
sg58
g62
sg57
Vy
sg80
S'51-mars.png'
p435
sg65
g66
sg55
g11
sS'binary.thisN'
p436
I6
sg56
Vr
sS'binary.thisIndex'
p437
g59
(g98
S'\x06\x00\x00\x00'
tRp438
sg24
S'right'
p439
sS'binary.thisTrialN'
p440
I6
sg25
F1.2166672178559566
sg27
F3.851
sg69
Vn
sa(dp441
g63
g64
sS'binary.thisRepN'
p442
I0
sg67
g68
sg79
S'26-walkers_smoky_bacon.png'
p443
sg26
F5.0000000000000018
sg28
F2.7999999999999998
sg58
g62
sg57
Vy
sg80
S'44-crunch.png'
p444
sg65
g66
sg55
g11
sS'binary.thisN'
p445
I7
sg56
Vr
sS'binary.thisIndex'
p446
g59
(g98
S'\x07\x00\x00\x00'
tRp447
sg24
S'right'
p448
sS'binary.thisTrialN'
p449
I7
sg25
F3.8167433959943082
sg27
F2.4670000000000001
sg69
Vn
sa(dp450
g63
g64
sS'binary.thisRepN'
p451
I0
sg67
g68
sg79
S'2-steamed_puddings.png'
p452
sg26
F4.7000000000000011
sg28
F4.0999999999999996
sg58
g62
sg57
Vy
sg80
S'20-fruit_pastilles.png'
p453
sg65
g66
sg55
g11
sS'binary.thisN'
p454
I8
sg56
Vr
sS'binary.thisIndex'
p455
g59
(g98
S'\x08\x00\x00\x00'
tRp456
sg24
S'left'
p457
sS'binary.thisTrialN'
p458
I8
sg25
F2.2000551379187527
sg27
F3.2010000000000001
sg69
Vn
sa(dp459
g63
g64
sS'binary.thisRepN'
p460
I0
sg67
g68
sg79
S'34-hula_hoops_bbq_beef_redo.png'
p461
sg26
F3.7000000000000002
sg28
F3.3999999999999999
sg58
g62
sg57
Vy
sg80
S'36-fig_rolls.png'
p462
sg65
g66
sg55
g11
sS'binary.thisN'
p463
I9
sg56
Vr
sS'binary.thisIndex'
p464
g59
(g98
S'\t\x00\x00\x00'
tRp465
sg24
S'right'
p466
sS'binary.thisTrialN'
p467
I9
sg25
F6.1167666599767472
sg27
F7.351
sg69
Vn
sa(dp468
g63
g64
sS'binary.thisRepN'
p469
I0
sg67
g68
sg79
S'44-crunch.png'
p470
sg26
F4.9000000000000004
sg28
F4.0999999999999996
sg58
g62
sg57
Vy
sg80
S'26-walkers_smoky_bacon.png'
p471
sg65
g66
sg55
g11
sS'binary.thisN'
p472
I10
sg56
Vr
sS'binary.thisIndex'
p473
g59
(g98
S'\n\x00\x00\x00'
tRp474
sg24
S'left'
p475
sS'binary.thisTrialN'
p476
I10
sg25
F1.8501095345836802
sg27
F9.4670000000000005
sg69
Vn
sa(dp477
g63
g64
sS'binary.thisRepN'
p478
I0
sg67
g68
sg79
S'6-sour_patch_kids.png'
p479
sg26
F5.9999999999999973
sg28
F3.6000000000000001
sg58
g62
sg57
Vy
sg80
S'38-maltesers.png'
p480
sg65
g66
sg55
g11
sS'binary.thisN'
p481
I11
sg56
Vr
sS'binary.thisIndex'
p482
g59
(g98
S'\x0b\x00\x00\x00'
tRp483
sg24
S'right'
p484
sS'binary.thisTrialN'
p485
I11
sg25
F1.21647477682518
sg27
F2.1840000000000002
sg69
Vn
sa(dp486
g63
g64
sS'binary.thisRepN'
p487
I0
sg67
g68
sg79
S'5-pineapple.png'
p488
sg26
F5.9999999999999982
sg28
F2.7000000000000002
sg58
g62
sg57
Vy
sg80
S'40-sardines.png'
p489
sg65
g66
sg55
g11
sS'binary.thisN'
p490
I12
sg56
Vr
sS'binary.thisIndex'
p491
g59
(g98
S'\x0c\x00\x00\x00'
tRp492
sg24
S'right'
p493
sS'binary.thisTrialN'
p494
I12
sg25
F5.6004279888516066
sg27
F2.101
sg69
Vn
sa(dp495
g63
g64
sS'binary.thisRepN'
p496
I0
sg67
g68
sg79
S'29-beans.png'
p497
sg26
F1.7999999999999994
sg28
F3
sg58
g62
sg57
Vy
sg80
S'46-pistachios.png'
p498
sg65
g66
sg55
g11
sS'binary.thisN'
p499
I13
sg56
Vr
sS'binary.thisIndex'
p500
g59
(g98
S'\r\x00\x00\x00'
tRp501
sg24
S'right'
p502
sS'binary.thisTrialN'
p503
I13
sg25
F5.9999649329679414
sg27
F3.8170000000000002
sg69
Vn
sa(dp504
g63
g64
sS'binary.thisRepN'
p505
I0
sg67
g68
sg79
S'25-kitkat.png'
p506
sg26
F1.9999999999999987
sg28
F3.3999999999999999
sg58
g62
sg57
Vy
sg80
S'31-hobnobs.png'
p507
sg65
g66
sg55
g11
sS'binary.thisN'
p508
I14
sg56
Vr
sS'binary.thisIndex'
p509
g59
(g98
S'\x0e\x00\x00\x00'
tRp510
sg24
S'right'
p511
sS'binary.thisTrialN'
p512
I14
sg25
F8.316657581549407
sg27
F4.484
sg69
Vn
sa(dp513
g63
g64
sS'binary.thisRepN'
p514
I0
sg67
g68
sg79
S'38-maltesers.png'
p515
sg26
F5.9999999999999973
sg28
F3.7000000000000002
sg58
g62
sg57
Vy
sg80
S'6-sour_patch_kids.png'
p516
sg65
g66
sg55
g11
sS'binary.thisN'
p517
I15
sg56
Vr
sS'binary.thisIndex'
p518
g59
(g98
S'\x0f\x00\x00\x00'
tRp519
sg24
S'left'
p520
sS'binary.thisTrialN'
p521
I15
sg25
F1.5164706714167551
sg27
F2.2669999999999999
sg69
Vn
sa(dp522
g63
g64
sS'binary.thisRepN'
p523
I0
sg67
g68
sg79
S'10-bounty_redo.png'
p524
sg26
F5.0000000000000018
sg28
F2.7000000000000002
sg58
g62
sg57
Vy
sg80
S'4-corn.png'
p525
sg65
g66
sg55
g11
sS'binary.thisN'
p526
I16
sg56
Vr
sS'binary.thisIndex'
p527
g59
(g98
S'\x10\x00\x00\x00'
tRp528
sg24
S'left'
p529
sS'binary.thisTrialN'
p530
I16
sg25
F6.6667081008836249
sg27
F1.6839999999999999
sg69
Vn
sa(dp531
g63
g64
sS'binary.thisRepN'
p532
I0
sg67
g68
sg79
S'40-sardines.png'
p533
sg26
F5.9999999999999973
sg28
F3.2999999999999998
sg58
g62
sg57
Vy
sg80
S'5-pineapple.png'
p534
sg65
g66
sg55
g11
sS'binary.thisN'
p535
I17
sg56
Vr
sS'binary.thisIndex'
p536
g59
(g98
S'\x11\x00\x00\x00'
tRp537
sg24
S'left'
p538
sS'binary.thisTrialN'
p539
I17
sg25
F2.2000636908533124
sg27
F1.5669999999999999
sg69
Vn
sa(dp540
g63
g64
sS'binary.thisRepN'
p541
I0
sg67
g68
sg79
S'19-caramello_redo.png'
p542
sg26
F5.9999999999999973
sg28
F4
sg58
g62
sg57
Vy
sg80
S'30-spaghetti_hoops.png'
p543
sg65
g66
sg55
g11
sS'binary.thisN'
p544
I18
sg56
Vr
sS'binary.thisIndex'
p545
g59
(g98
S'\x12\x00\x00\x00'
tRp546
sg24
S'left'
p547
sS'binary.thisTrialN'
p548
I18
sg25
F1.9501229912007148
sg27
F1.534
sg69
Vn
sa(dp549
g63
g64
sS'binary.thisRepN'
p550
I0
sg67
g68
sg79
S'17-jacobs_mini_cheddars_redo.png'
p551
sg26
F5.2999999999999998
sg28
F3.3999999999999999
sg58
g62
sg57
Vy
sg80
S'8-liquorice_catherine_wheels.png'
p552
sg65
g66
sg55
g11
sS'binary.thisN'
p553
I19
sg56
Vr
sS'binary.thisIndex'
p554
g59
(g98
S'\x13\x00\x00\x00'
tRp555
sg24
S'left'
p556
sS'binary.thisTrialN'
p557
I19
sg25
F2.1338508619078311
sg27
F4.601
sg69
Vn
sa(dp558
g63
g64
sS'binary.thisRepN'
p559
I0
sg67
g68
sg79
S'30-spaghetti_hoops.png'
p560
sg26
F5.9999999999999982
sg28
F3
sg58
g62
sg57
Vy
sg80
S'19-caramello_redo.png'
p561
sg65
g66
sg55
g11
sS'binary.thisN'
p562
I20
sg56
Vr
sS'binary.thisIndex'
p563
g59
(g98
S'\x14\x00\x00\x00'
tRp564
sg24
S'right'
p565
sS'binary.thisTrialN'
p566
I20
sg25
F0.9833759459547764
sg27
F1.417
sg69
Vn
sa(dp567
g63
g64
sS'binary.thisRepN'
p568
I0
sg67
g68
sg79
S'48-twix.png'
p569
sg26
F5.9999999999999973
sg28
F3.7999999999999998
sg58
g62
sg57
Vy
sg80
S'50-polo.png'
p570
sg65
g66
sg55
g11
sS'binary.thisN'
p571
I21
sg56
Vr
sS'binary.thisIndex'
p572
g59
(g98
S'\x15\x00\x00\x00'
tRp573
sg24
S'left'
p574
sS'binary.thisTrialN'
p575
I21
sg25
F1.1167179082485745
sg27
F3.851
sg69
Vn
sa(dp576
g63
g64
sS'binary.thisRepN'
p577
I0
sg67
g68
sg79
S'4-corn.png'
p578
sg26
F5.2999999999999998
sg28
F4.0999999999999996
sg58
g62
sg57
Vy
sg80
S'10-bounty_redo.png'
p579
sg65
g66
sg55
g11
sS'binary.thisN'
p580
I22
sg56
Vr
sS'binary.thisIndex'
p581
g59
(g98
S'\x16\x00\x00\x00'
tRp582
sg24
S'right'
p583
sS'binary.thisTrialN'
p584
I22
sg25
F1.4833748055630167
sg27
F2.8839999999999999
sg69
Vn
sa(dp585
g63
g64
sS'binary.thisRepN'
p586
I0
sg67
g68
sg79
S'23-crunchie_redo.png'
p587
sg26
F2.9999999999999996
sg28
F3.2999999999999998
sg58
g62
sg57
Vy
sg80
S'33-ambrosia_rice.png'
p588
sg65
g66
sg55
g11
sS'binary.thisN'
p589
I23
sg56
Vr
sS'binary.thisIndex'
p590
g59
(g98
S'\x17\x00\x00\x00'
tRp591
sg24
S'right'
p592
sS'binary.thisTrialN'
p593
I23
sg25
F7.4836895535595431
sg27
F3.484
sg69
Vn
sa(dp594
g63
g64
sS'binary.thisRepN'
p595
I0
sg67
g68
sg79
S'3-ellas_strawberries_apples.png'
p596
sg26
F1
sg28
F3.3999999999999999
sg58
g62
sg57
Vy
sg80
S'13-mccoys_steak_crisps.png'
p597
sg65
g66
sg55
g11
sS'binary.thisN'
p598
I24
sg56
Vr
sS'binary.thisIndex'
p599
g59
(g98
S'\x18\x00\x00\x00'
tRp600
sg24
S'left'
p601
sS'binary.thisTrialN'
p602
I24
sg25
F2.8999611696767715
sg27
F1.5009999999999999
sg69
Vn
sa(dp603
g63
g64
sS'binary.thisRepN'
p604
I0
sg67
g68
sg79
S'1-treacle_cookies.png'
p605
sg26
F5.9999999999999982
sg28
F2.7999999999999998
sg58
g62
sg57
Vy
sg80
S'21-nakd_banana_crunch.png'
p606
sg65
g66
sg55
g11
sS'binary.thisN'
p607
I25
sg56
Vr
sS'binary.thisIndex'
p608
g59
(g98
S'\x19\x00\x00\x00'
tRp609
sg24
S'right'
p610
sS'binary.thisTrialN'
p611
I25
sg25
F1.2000329002889885
sg27
F3.4670000000000001
sg69
Vn
sa(dp612
g63
g64
sS'binary.thisRepN'
p613
I0
sg67
g68
sg79
S'16-skips_prawn.png'
p614
sg26
F5.9999999999999973
sg28
F3.8999999999999999
sg58
g62
sg57
Vy
sg80
S'42-mrkipling_lemon_slices.png'
p615
sg65
g66
sg55
g11
sS'binary.thisN'
p616
I26
sg56
Vr
sS'binary.thisIndex'
p617
g59
(g98
S'\x1a\x00\x00\x00'
tRp618
sg24
S'right'
p619
sS'binary.thisTrialN'
p620
I26
sg25
F1.3833468089574126
sg27
F2.3839999999999999
sg69
Vn
sa(dp621
g63
g64
sS'binary.thisRepN'
p622
I0
sg67
g68
sg79
S'46-pistachios.png'
p623
sg26
F2.0999999999999992
sg28
F2.8999999999999999
sg58
g62
sg57
Vy
sg80
S'29-beans.png'
p624
sg65
g66
sg55
g11
sS'binary.thisN'
p625
I27
sg56
Vr
sS'binary.thisIndex'
p626
g59
(g98
S'\x1b\x00\x00\x00'
tRp627
sg24
S'left'
p628
sS'binary.thisTrialN'
p629
I27
sg25
F4.6337667580501147
sg27
F5.0339999999999998
sg69
Vn
sa(dp630
g63
g64
sS'binary.thisRepN'
p631
I0
sg67
g68
sg79
S'33-ambrosia_rice.png'
p632
sg26
F2.4999999999999991
sg28
F3.6000000000000001
sg58
g62
sg57
Vy
sg80
S'23-crunchie_redo.png'
p633
sg65
g66
sg55
g11
sS'binary.thisN'
p634
I28
sg56
Vr
sS'binary.thisIndex'
p635
g59
(g98
S'\x1c\x00\x00\x00'
tRp636
sg24
S'left'
p637
sS'binary.thisTrialN'
p638
I28
sg25
F3.8500505193337631
sg27
F2.6339999999999999
sg69
Vn
sa(dp639
g63
g64
sS'binary.thisRepN'
p640
I0
sg67
g68
sg79
S'20-fruit_pastilles.png'
p641
sg26
F5.9999999999999982
sg28
F3.1000000000000001
sg58
g62
sg57
Vy
sg80
S'2-steamed_puddings.png'
p642
sg65
g66
sg55
g11
sS'binary.thisN'
p643
I29
sg56
Vr
sS'binary.thisIndex'
p644
g59
(g98
S'\x1d\x00\x00\x00'
tRp645
sg24
S'right'
p646
sS'binary.thisTrialN'
p647
I29
sg25
F1.599957007248122
sg27
F6.117
sg69
Vn
sa(dp648
g63
g64
sS'binary.thisRepN'
p649
I0
sg67
g68
sg79
S'13-mccoys_steak_crisps.png'
p650
sg26
F1
sg28
F3.2999999999999998
sg58
g62
sg57
Vy
sg80
S'3-ellas_strawberries_apples.png'
p651
sg65
g66
sg55
g11
sS'binary.thisN'
p652
I30
sg56
Vr
sS'binary.thisIndex'
p653
g59
(g98
S'\x1e\x00\x00\x00'
tRp654
sg24
S'right'
p655
sS'binary.thisTrialN'
p656
I30
sg25
F1.2000348959732037
sg27
F2.6509999999999998
sg69
Vn
sa(dp657
g63
g64
sS'binary.thisRepN'
p658
I0
sg67
g68
sg79
S'7-olives.png'
p659
sg26
F2.5999999999999996
sg28
F3.2000000000000002
sg58
g62
sg57
Vy
sg80
S'22-daim.png'
p660
sg65
g66
sg55
g11
sS'binary.thisN'
p661
I31
sg56
Vr
sS'binary.thisIndex'
p662
g59
(g98
S'\x1f\x00\x00\x00'
tRp663
sg24
S'right'
p664
sS'binary.thisTrialN'
p665
I31
sg25
F1.4333757748959215
sg27
F5.617
sg69
Vn
sa(dp666
g63
g64
sS'binary.thisRepN'
p667
I0
sg67
g68
sg79
S'51-mars.png'
p668
sg26
F4.6000000000000014
sg28
F2.8999999999999999
sg58
g62
sg57
Vy
sg80
S'27-hartleys_raspberries_jelly.png'
p669
sg65
g66
sg55
g11
sS'binary.thisN'
p670
I32
sg56
Vr
sS'binary.thisIndex'
p671
g59
(g98
S' \x00\x00\x00'
tRp672
sg24
S'left'
p673
sS'binary.thisTrialN'
p674
I32
sg25
F1.5833651692569219
sg27
F1.9339999999999999
sg69
Vn
sa(dp675
g63
g64
sS'binary.thisRepN'
p676
I0
sg67
g68
sg79
S'18-mms.png'
p677
sg26
F5.9999999999999982
sg28
F3.1000000000000001
sg58
g62
sg57
Vy
sg80
S'43-mrporky_pork_crackles_redo.png'
p678
sg65
g66
sg55
g11
sS'binary.thisN'
p679
I33
sg56
Vr
sS'binary.thisIndex'
p680
g59
(g98
S'!\x00\x00\x00'
tRp681
sg24
S'left'
p682
sS'binary.thisTrialN'
p683
I33
sg25
F2.1000331283667037
sg27
F2.0009999999999999
sg69
Vn
sa(dp684
g63
g64
sS'binary.thisRepN'
p685
I0
sg67
g68
sg79
S'35-raisins.png'
p686
sg26
F2.6999999999999993
sg28
F3.6000000000000001
sg58
g62
sg57
Vy
sg80
S'49-yorkie.png'
p687
sg65
g66
sg55
g11
sS'binary.thisN'
p688
I34
sg56
Vr
sS'binary.thisIndex'
p689
g59
(g98
S'"\x00\x00\x00'
tRp690
sg24
S'left'
p691
sS'binary.thisTrialN'
p692
I34
sg25
F3.3000397996561333
sg27
F4.101
sg69
Vn
sa(dp693
g63
g64
sS'binary.thisRepN'
p694
I0
sg67
g68
sg79
S'31-hobnobs.png'
p695
sg26
F1.7999999999999994
sg28
F3
sg58
g62
sg57
Vy
sg80
S'25-kitkat.png'
p696
sg65
g66
sg55
g11
sS'binary.thisN'
p697
I35
sg56
Vr
sS'binary.thisIndex'
p698
g59
(g98
S'#\x00\x00\x00'
tRp699
sg24
S'left'
p700
sS'binary.thisTrialN'
p701
I35
sg25
F2.683316189451034
sg27
F2.617
sg69
Vn
sa(dp702
g63
g64
sS'binary.thisRepN'
p703
I0
sg67
g68
sg79
S'22-daim.png'
p704
sg26
F1.8999999999999992
sg28
F3
sg58
g62
sg57
Vy
sg80
S'7-olives.png'
p705
sg65
g66
sg55
g11
sS'binary.thisN'
p706
I36
sg56
Vr
sS'binary.thisIndex'
p707
g59
(g98
S'$\x00\x00\x00'
tRp708
sg24
S'left'
p709
sS'binary.thisTrialN'
p710
I36
sg25
F2.0667964241888512
sg27
F1.917
sg69
Vn
sa(dp711
g63
g64
sS'binary.thisRepN'
p712
I0
sg67
g68
sg79
S'42-mrkipling_lemon_slices.png'
p713
sg26
F5.8999999999999977
sg28
F3.7999999999999998
sg58
g62
sg57
Vy
sg80
S'16-skips_prawn.png'
p714
sg65
g66
sg55
g11
sS'binary.thisN'
p715
I37
sg56
Vr
sS'binary.thisIndex'
p716
g59
(g98
S'%\x00\x00\x00'
tRp717
sg24
S'left'
p718
sS'binary.thisTrialN'
p719
I37
sg25
F1.1334180834128347
sg27
F2.8340000000000001
sg69
Vn
sa(dp720
g63
g64
sS'binary.thisRepN'
p721
I0
sg67
g68
sg79
S'41-peanuts_redo.png'
p722
sg26
F5.9999999999999982
sg28
F2.7999999999999998
sg58
g62
sg57
Vy
sg80
S'45-chewy_nougat_redo.png'
p723
sg65
g66
sg55
g11
sS'binary.thisN'
p724
I38
sg56
Vr
sS'binary.thisIndex'
p725
g59
(g98
S'&\x00\x00\x00'
tRp726
sg24
S'left'
p727
sS'binary.thisTrialN'
p728
I38
sg25
F1.5335505968810139
sg27
F1.2170000000000001
sg69
Vn
sa(dp729
g63
g64
sS'binary.thisRepN'
p730
I0
sg67
g68
sg79
S'36-fig_rolls.png'
p731
sg26
F2.3999999999999995
sg28
F2.7999999999999998
sg58
g62
sg57
Vy
sg80
S'34-hula_hoops_bbq_beef_redo.png'
p732
sg65
g66
sg55
g11
sS'binary.thisN'
p733
I39
sg56
Vr
sS'binary.thisIndex'
p734
g59
(g98
S"'\x00\x00\x00"
tRp735
sg24
S'left'
p736
sS'binary.thisTrialN'
p737
I39
sg25
F1.9168609133166683
sg27
F3.9009999999999998
sg69
Vn
sa(dp738
g63
g64
sg56
Vr
sg29
S'space'
p739
sg57
Vy
sg58
g62
sg30
F615.89957600251773
sg55
g11
sg65
g66
sg67
g68
sg69
Vn
sa(dp740
g63
g64
sg56
Vr
sg57
Vy
sg31
S'space'
p741
sg58
g62
sg55
g11
sg32
F1.4000888935011062
sg65
g66
sg67
g68
sg69
Vn
sa(dp742
g63
g64
sg81
S'15-walnut_whip.png'
p743
sg82
S'15-walnut_whip.png'
p744
sg56
Vr
sS'practice_loop.thisN'
p745
I0
sS'practice_loop.thisTrialN'
p746
I0
sg69
Vn
sg57
Vy
sg58
g62
sS'practice_loop.thisRepN'
p747
I0
sg83
S'28-maple_pecan.png'
p748
sg33
g743
sg55
g11
sg65
g66
sg67
g68
sg84
S'28-maple_pecan.png'
p749
sS'practice_loop.thisIndex'
p750
g59
(g98
S'\x00\x00\x00\x00'
tRp751
sg34
cdatetime
datetime
p752
(S'\x07\xdf\n\x10\n/\x06\r\xa0H'
tRp753
sa(dp754
g63
g64
sg81
S'53-cheestrings.png'
p755
sg82
S'53-cheestrings.png'
p756
sg56
Vr
sS'practice_loop.thisN'
p757
I1
sS'practice_loop.thisTrialN'
p758
I1
sg69
Vn
sg57
Vy
sg58
g62
sS'practice_loop.thisRepN'
p759
I0
sg83
S'47-picnic.png'
p760
sg33
g760
sg55
g11
sg65
g66
sg67
g68
sg84
S'47-picnic.png'
p761
sS'practice_loop.thisIndex'
p762
g59
(g98
S'\x01\x00\x00\x00'
tRp763
sg34
g752
(S'\x07\xdf\n\x10\n/\r\x00\x9c@'
tRp764
sa(dp765
g63
g64
sg81
S'32-hovis_crackers.png'
p766
sg82
S'24-food_doctor_apple_walnut_bar.png'
p767
sg56
Vr
sS'practice_loop.thisN'
p768
I2
sS'practice_loop.thisTrialN'
p769
I2
sg69
Vn
sg57
Vy
sg58
g62
sS'practice_loop.thisRepN'
p770
I0
sg83
S'24-food_doctor_apple_walnut_bar.png'
p771
sg33
g766
sg55
g11
sg65
g66
sg67
g68
sg84
S'32-hovis_crackers.png'
p772
sS'practice_loop.thisIndex'
p773
g59
(g98
S'\x02\x00\x00\x00'
tRp774
sg34
g752
(S'\x07\xdf\n\x10\n/\x14\x04\xf5\x88'
tRp775
sa(dp776
g63
g64
sg81
S'12-topic.png'
p777
sg82
S'12-topic.png'
p778
sg56
Vr
sS'practice_loop.thisN'
p779
I3
sS'practice_loop.thisTrialN'
p780
I3
sg69
Vn
sg57
Vy
sg58
g62
sS'practice_loop.thisRepN'
p781
I0
sg83
S'39-mackerel.png'
p782
sg33
g782
sg55
g11
sg65
g66
sg67
g68
sg84
S'39-mackerel.png'
p783
sS'practice_loop.thisIndex'
p784
g59
(g98
S'\x03\x00\x00\x00'
tRp785
sg34
g752
(S'\x07\xdf\n\x10\n/\x1a\x0b\xb8\x00'
tRp786
sa(dp787
g63
g64
sg81
S'37-nakd_cashew_cookie.png'
p788
sg82
S'9-yu_mango_pieces.png'
p789
sg56
Vr
sS'practice_loop.thisN'
p790
I4
sS'practice_loop.thisTrialN'
p791
I4
sg69
Vn
sg57
Vy
sg58
g62
sS'practice_loop.thisRepN'
p792
I0
sg83
S'9-yu_mango_pieces.png'
p793
sg33
g788
sg55
g11
sg65
g66
sg67
g68
sg84
S'37-nakd_cashew_cookie.png'
p794
sS'practice_loop.thisIndex'
p795
g59
(g98
S'\x04\x00\x00\x00'
tRp796
sg34
g752
(S'\x07\xdf\n\x10\n/#\tZ\x88'
tRp797
sa(dp798
g63
g64
sg81
g777
sg82
S'39-mackerel.png'
p799
sg56
Vr
sS'practice_loop.thisN'
p800
I5
sS'practice_loop.thisTrialN'
p801
I5
sg69
Vn
sg57
Vy
sg58
g62
sS'practice_loop.thisRepN'
p802
I0
sg83
g782
sg33
g782
sg55
g11
sg65
g66
sg67
g68
sg84
S'12-topic.png'
p803
sS'practice_loop.thisIndex'
p804
g59
(g98
S'\x05\x00\x00\x00'
tRp805
sg34
g752
(S'\x07\xdf\n\x10\n/+\t\xdfX'
tRp806
sa(dp807
g63
g64
sg81
S'11-snickers.png'
p808
sg82
S'11-snickers.png'
p809
sg56
Vr
sS'practice_loop.thisN'
p810
I6
sS'practice_loop.thisTrialN'
p811
I6
sg69
Vn
sg57
Vy
sg58
g62
sS'practice_loop.thisRepN'
p812
I0
sg83
S'54-frubes_yogurt.png'
p813
sg33
g813
sg55
g11
sg65
g66
sg67
g68
sg84
S'54-frubes_yogurt.png'
p814
sS'practice_loop.thisIndex'
p815
g59
(g98
S'\x06\x00\x00\x00'
tRp816
sg34
g752
(S'\x07\xdf\n\x10\n/4\x08w\xf8'
tRp817
sa(dp818
g63
g64
sg81
g743
sg82
S'28-maple_pecan.png'
p819
sg56
Vr
sS'practice_loop.thisN'
p820
I7
sS'practice_loop.thisTrialN'
p821
I7
sg69
Vn
sg57
Vy
sg58
g62
sS'practice_loop.thisRepN'
p822
I0
sg83
g748
sg33
g743
sg55
g11
sg65
g66
sg67
g68
sg84
S'15-walnut_whip.png'
p823
sS'practice_loop.thisIndex'
p824
g59
(g98
S'\x07\x00\x00\x00'
tRp825
sg34
g752
(S'\x07\xdf\n\x10\n0\x00\x08\xfc\xc8'
tRp826
sa(dp827
g63
g64
sg81
g755
sg82
S'47-picnic.png'
p828
sg56
Vr
sS'practice_loop.thisN'
p829
I8
sS'practice_loop.thisTrialN'
p830
I8
sg69
Vn
sg57
Vy
sg58
g62
sS'practice_loop.thisRepN'
p831
I0
sg83
g760
sg33
g760
sg55
g11
sg65
g66
sg67
g68
sg84
S'53-cheestrings.png'
p832
sS'practice_loop.thisIndex'
p833
g59
(g98
S'\x08\x00\x00\x00'
tRp834
sg34
g752
(S'\x07\xdf\n\x10\n0\x08\x04\xbe\xd8'
tRp835
sa(dp836
g63
g64
sg81
g808
sg82
S'54-frubes_yogurt.png'
p837
sg56
Vr
sS'practice_loop.thisN'
p838
I9
sS'practice_loop.thisTrialN'
p839
I9
sg69
Vn
sg57
Vy
sg58
g62
sS'practice_loop.thisRepN'
p840
I0
sg83
g813
sg33
g808
sg55
g11
sg65
g66
sg67
g68
sg84
S'11-snickers.png'
p841
sS'practice_loop.thisIndex'
p842
g59
(g98
S'\t\x00\x00\x00'
tRp843
sg34
g752
(S'\x07\xdf\n\x10\n0\x0f\x02m\x18'
tRp844
sa(dp845
g63
g64
sg81
S'52-aero_mousse.png'
p846
sg82
S'52-aero_mousse.png'
p847
sg56
Vr
sS'practice_loop.thisN'
p848
I10
sS'practice_loop.thisTrialN'
p849
I10
sg69
Vn
sg57
Vy
sg58
g62
sS'practice_loop.thisRepN'
p850
I0
sg83
S'14-discos_salt_vinegar.png'
p851
sg33
g846
sg55
g11
sg65
g66
sg67
g68
sg84
S'14-discos_salt_vinegar.png'
p852
sS'practice_loop.thisIndex'
p853
g59
(g98
S'\n\x00\x00\x00'
tRp854
sg34
g752
(S'\x07\xdf\n\x10\n0\x15\x04\xabP'
tRp855
sa(dp856
g63
g64
sg81
g788
sg82
S'37-nakd_cashew_cookie.png'
p857
sg56
Vr
sS'practice_loop.thisN'
p858
I11
sS'practice_loop.thisTrialN'
p859
I11
sg69
Vn
sg57
Vy
sg58
g62
sS'practice_loop.thisRepN'
p860
I0
sg83
g793
sg33
g788
sg55
g11
sg65
g66
sg67
g68
sg84
S'9-yu_mango_pieces.png'
p861
sS'practice_loop.thisIndex'
p862
g59
(g98
S'\x0b\x00\x00\x00'
tRp863
sg34
g752
(S'\x07\xdf\n\x10\n0\x1e\x02\x0fX'
tRp864
sa(dp865
g63
g64
sg81
g766
sg82
S'32-hovis_crackers.png'
p866
sg56
Vr
sS'practice_loop.thisN'
p867
I12
sS'practice_loop.thisTrialN'
p868
I12
sg69
Vn
sg57
Vy
sg58
g62
sS'practice_loop.thisRepN'
p869
I0
sg83
g771
sg33
g766
sg55
g11
sg65
g66
sg67
g68
sg84
S'24-food_doctor_apple_walnut_bar.png'
p870
sS'practice_loop.thisIndex'
p871
g59
(g98
S'\x0c\x00\x00\x00'
tRp872
sg34
g752
(S'\x07\xdf\n\x10\n0&\x04\xf5\x88'
tRp873
sa(dp874
g63
g64
sg81
g846
sg82
S'14-discos_salt_vinegar.png'
p875
sg56
Vr
sS'practice_loop.thisN'
p876
I13
sS'practice_loop.thisTrialN'
p877
I13
sg69
Vn
sg57
Vy
sg58
g62
sS'practice_loop.thisRepN'
p878
I0
sg83
g851
sg33
g851
sg55
g11
sg65
g66
sg67
g68
sg84
S'52-aero_mousse.png'
p879
sS'practice_loop.thisIndex'
p880
g59
(g98
S'\r\x00\x00\x00'
tRp881
sg34
g752
(S'\x07\xdf\n\x10\n0-\r\xd6\xf8'
tRp882
sa(dp883
g63
g64
sg56
Vr
sg57
Vy
sg58
g62
sg35
S'space'
p884
sg55
g11
sg36
F56.465368027077602
sg65
g66
sg67
g68
sg69
Vn
sa(dp885
S'block_loop.thisRepN'
p886
I0
sg56
Vr
sS'block_loop.thisIndex'
p887
g59
(g98
S'\x00\x00\x00\x00'
tRp888
sg57
Vy
sg58
g62
sS'block_loop.thisN'
p889
I0
sg37
Nsg55
g11
sg63
g64
sS'block_loop.thisTrial'
p890
Nsg65
g66
sg67
g68
sS'block_loop.thisTrialN'
p891
I0
sg69
Vn
sa(dp892
S'trial_loop.thisTrialN'
p893
I0
sS'img_left'
p894
S'40-sardines.png'
p895
sS'block_loop.thisIndex'
p896
g888
sg38
S'left'
p897
sg58
g62
sS'trial_loop.thisN'
p898
I0
sg33
S'40-sardines.png'
p899
sg63
g64
sS'trial_loop.thisIndex'
p900
g59
(g98
S'\x00\x00\x00\x00'
tRp901
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p902
I0
sS'img_right'
p903
S'5-pineapple.png'
p904
sS'block_loop.thisRepN'
p905
I0
sS'img_correct'
p906
g899
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p907
I0
sS'img_wrong'
p908
S'5-pineapple.png'
p909
sg55
g11
sS'block_loop.thisTrial'
p910
Nsg69
Vn
sS'block_loop.thisTrialN'
p911
I0
sg39
F1.6834136929064698
sg34
g752
(S'\x07\xdf\n\x10\n18\x0e\xb9\x88'
tRp912
sa(dp913
S'trial_loop.thisTrialN'
p914
I1
sg894
S'31-hobnobs.png'
p915
sS'block_loop.thisIndex'
p916
g888
sg38
S'left'
p917
sg58
g62
sS'trial_loop.thisN'
p918
I1
sg33
S'25-kitkat.png'
p919
sg63
g64
sS'trial_loop.thisIndex'
p920
g59
(g98
S'\x01\x00\x00\x00'
tRp921
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p922
I0
sg903
S'25-kitkat.png'
p923
sS'block_loop.thisRepN'
p924
I0
sg906
g919
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p925
I0
sg908
S'31-hobnobs.png'
p926
sg55
g11
sS'block_loop.thisTrial'
p927
Nsg69
Vn
sS'block_loop.thisTrialN'
p928
I0
sg39
F1.0501914716978717
sg34
g752
(S'\x07\xdf\n\x10\n2\x03\nD\xe8'
tRp929
sa(dp930
S'trial_loop.thisTrialN'
p931
I2
sg894
S'44-crunch.png'
p932
sS'block_loop.thisIndex'
p933
g888
sg38
S'left'
p934
sg58
g62
sS'trial_loop.thisN'
p935
I2
sg33
S'44-crunch.png'
p936
sg63
g64
sS'trial_loop.thisIndex'
p937
g59
(g98
S'\x02\x00\x00\x00'
tRp938
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p939
I0
sg903
S'26-walkers_smoky_bacon.png'
p940
sS'block_loop.thisRepN'
p941
I0
sg906
g936
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p942
I0
sg908
S'26-walkers_smoky_bacon.png'
p943
sg55
g11
sS'block_loop.thisTrial'
p944
Nsg69
Vn
sS'block_loop.thisTrialN'
p945
I0
sg39
F1.5001761904545674
sg34
g752
(S'\x07\xdf\n\x10\n2\t\x0b\x8d\x08'
tRp946
sa(dp947
S'trial_loop.thisTrialN'
p948
I3
sg894
S'23-crunchie_redo.png'
p949
sS'block_loop.thisIndex'
p950
g888
sg38
S'right'
p951
sg58
g62
sS'trial_loop.thisN'
p952
I3
sg33
S'33-ambrosia_rice.png'
p953
sg63
g64
sS'trial_loop.thisIndex'
p954
g59
(g98
S'\x03\x00\x00\x00'
tRp955
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p956
I0
sg903
S'33-ambrosia_rice.png'
p957
sS'block_loop.thisRepN'
p958
I0
sg906
g953
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p959
I0
sg908
S'23-crunchie_redo.png'
p960
sg55
g11
sS'block_loop.thisTrial'
p961
Nsg69
Vn
sS'block_loop.thisTrialN'
p962
I0
sg39
F3.7334512117795384
sg34
g752
(S'\x07\xdf\n\x10\n2\x10\x04x\x88'
tRp963
sa(dp964
S'trial_loop.thisTrialN'
p965
I4
sg894
S'41-peanuts_redo.png'
p966
sS'block_loop.thisIndex'
p967
g888
sg38
S'left'
p968
sg58
g62
sS'trial_loop.thisN'
p969
I4
sg33
S'45-chewy_nougat_redo.png'
p970
sg63
g64
sS'trial_loop.thisIndex'
p971
g59
(g98
S'\x04\x00\x00\x00'
tRp972
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p973
I0
sg903
S'45-chewy_nougat_redo.png'
p974
sS'block_loop.thisRepN'
p975
I0
sg906
S'41-peanuts_redo.png'
p976
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p977
I0
sg908
g970
sg55
g11
sS'block_loop.thisTrial'
p978
Nsg69
Vn
sS'block_loop.thisTrialN'
p979
I0
sg39
F1.2338851306658398
sg34
g752
(S'\x07\xdf\n\x10\n2\x19\x00\xeeH'
tRp980
sa(dp981
S'trial_loop.thisTrialN'
p982
I5
sg894
g949
sS'block_loop.thisIndex'
p983
g888
sg38
S'right'
p984
sg58
g62
sS'trial_loop.thisN'
p985
I5
sg33
g953
sg63
g64
sS'trial_loop.thisIndex'
p986
g59
(g98
S'\x05\x00\x00\x00'
tRp987
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p988
I0
sg903
g957
sS'block_loop.thisRepN'
p989
I0
sg906
g953
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p990
I0
sg908
g960
sg55
g11
sS'block_loop.thisTrial'
p991
Nsg69
Vn
sS'block_loop.thisTrialN'
p992
I0
sg39
F1.3666933898357456
sg34
g752
(S'\x07\xdf\n\x10\n2\x1f\x04\xd2`'
tRp993
sa(dp994
S'trial_loop.thisTrialN'
p995
I6
sg894
S'50-polo.png'
p996
sS'block_loop.thisIndex'
p997
g888
sg38
S'right'
p998
sg58
g62
sS'trial_loop.thisN'
p999
I6
sg33
S'50-polo.png'
p1000
sg63
g64
sS'trial_loop.thisIndex'
p1001
g59
(g98
S'\x06\x00\x00\x00'
tRp1002
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1003
I0
sg903
S'48-twix.png'
p1004
sS'block_loop.thisRepN'
p1005
I0
sg906
S'48-twix.png'
p1006
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1007
I0
sg908
g1000
sg55
g11
sS'block_loop.thisTrial'
p1008
Nsg69
Vn
sS'block_loop.thisTrialN'
p1009
I0
sg39
F1.1334317681080393
sg34
g752
(S'\x07\xdf\n\x10\n2%\x0b\x1b\xc0'
tRp1010
sa(dp1011
S'trial_loop.thisTrialN'
p1012
I7
sg894
S'30-spaghetti_hoops.png'
p1013
sS'block_loop.thisIndex'
p1014
g888
sg38
S'right'
p1015
sg58
g62
sS'trial_loop.thisN'
p1016
I7
sg33
S'19-caramello_redo.png'
p1017
sg63
g64
sS'trial_loop.thisIndex'
p1018
g59
(g98
S'\x07\x00\x00\x00'
tRp1019
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1020
I0
sg903
S'19-caramello_redo.png'
p1021
sS'block_loop.thisRepN'
p1022
I0
sg906
g1017
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1023
I0
sg908
S'30-spaghetti_hoops.png'
p1024
sg55
g11
sS'block_loop.thisTrial'
p1025
Nsg69
Vn
sS'block_loop.thisTrialN'
p1026
I0
sg39
F1.1000750377470467
sg34
g752
(S'\x07\xdf\n\x10\n2+\r\x94\x90'
tRp1027
sa(dp1028
S'trial_loop.thisTrialN'
p1029
I8
sg894
S'49-yorkie.png'
p1030
sS'block_loop.thisIndex'
p1031
g888
sg38
S'right'
p1032
sg58
g62
sS'trial_loop.thisN'
p1033
I8
sg33
S'49-yorkie.png'
p1034
sg63
g64
sS'trial_loop.thisIndex'
p1035
g59
(g98
S'\x08\x00\x00\x00'
tRp1036
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1037
I0
sg903
S'35-raisins.png'
p1038
sS'block_loop.thisRepN'
p1039
I0
sg906
g1034
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1040
I0
sg908
S'35-raisins.png'
p1041
sg55
g11
sS'block_loop.thisTrial'
p1042
Nsg69
Vn
sS'block_loop.thisTrialN'
p1043
I0
sg39
F1.6001659839525928
sg34
g752
(S'\x07\xdf\n\x10\n22\x00R\x08'
tRp1044
sa(dp1045
S'trial_loop.thisTrialN'
p1046
I9
sg894
S'51-mars.png'
p1047
sS'block_loop.thisIndex'
p1048
g888
sg38
S'left'
p1049
sg58
g62
sS'trial_loop.thisN'
p1050
I9
sg33
S'51-mars.png'
p1051
sg63
g64
sS'trial_loop.thisIndex'
p1052
g59
(g98
S'\t\x00\x00\x00'
tRp1053
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1054
I0
sg903
S'27-hartleys_raspberries_jelly.png'
p1055
sS'block_loop.thisRepN'
p1056
I0
sg906
g1051
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1057
I0
sg908
S'27-hartleys_raspberries_jelly.png'
p1058
sg55
g11
sS'block_loop.thisTrial'
p1059
Nsg69
Vn
sS'block_loop.thisTrialN'
p1060
I0
sg39
F4.7171014218397431
sg34
g752
(S'\x07\xdf\n\x10\n28\t\xee\xf8'
tRp1061
sa(dp1062
S'trial_loop.thisTrialN'
p1063
I10
sg894
g915
sS'block_loop.thisIndex'
p1064
g888
sg38
S'right'
p1065
sg58
g62
sS'trial_loop.thisN'
p1066
I10
sg33
g926
sg63
g64
sS'trial_loop.thisIndex'
p1067
g59
(g98
S'\n\x00\x00\x00'
tRp1068
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1069
I0
sg903
g923
sS'block_loop.thisRepN'
p1070
I0
sg906
g919
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1071
I0
sg908
g926
sg55
g11
sS'block_loop.thisTrial'
p1072
Nsg69
Vn
sS'block_loop.thisTrialN'
p1073
I0
sg39
F3.9667618703329026
sg34
g752
(S'\x07\xdf\n\x10\n3\x06\x06\x1eh'
tRp1074
sa(dp1075
S'trial_loop.thisTrialN'
p1076
I11
sg894
S'45-chewy_nougat_redo.png'
p1077
sS'block_loop.thisIndex'
p1078
g888
sg38
S'right'
p1079
sg58
g62
sS'trial_loop.thisN'
p1080
I11
sg33
g976
sg63
g64
sS'trial_loop.thisIndex'
p1081
g59
(g98
S'\x0b\x00\x00\x00'
tRp1082
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1083
I0
sg903
S'41-peanuts_redo.png'
p1084
sS'block_loop.thisRepN'
p1085
I0
sg906
g976
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1086
I0
sg908
g970
sg55
g11
sS'block_loop.thisTrial'
p1087
Nsg69
Vn
sS'block_loop.thisTrialN'
p1088
I0
sg39
F7.2333465808787878
sg34
g752
(S'\x07\xdf\n\x10\n3\x0f\x06"P'
tRp1089
sa(dp1090
S'trial_loop.thisTrialN'
p1091
I12
sg894
S'42-mrkipling_lemon_slices.png'
p1092
sS'block_loop.thisIndex'
p1093
g888
sg38
S'left'
p1094
sg58
g62
sS'trial_loop.thisN'
p1095
I12
sg33
S'16-skips_prawn.png'
p1096
sg63
g64
sS'trial_loop.thisIndex'
p1097
g59
(g98
S'\x0c\x00\x00\x00'
tRp1098
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1099
I0
sg903
S'16-skips_prawn.png'
p1100
sS'block_loop.thisRepN'
p1101
I0
sg906
g1096
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1102
I0
sg908
S'42-mrkipling_lemon_slices.png'
p1103
sg55
g11
sS'block_loop.thisTrial'
p1104
Nsg69
Vn
sS'block_loop.thisTrialN'
p1105
I0
sg39
F1.6499942410237054
sg34
g752
(S'\x07\xdf\n\x10\n3\x1b\n\\X'
tRp1106
sa(dp1107
S'trial_loop.thisTrialN'
p1108
I13
sg894
S'27-hartleys_raspberries_jelly.png'
p1109
sS'block_loop.thisIndex'
p1110
g888
sg38
S'right'
p1111
sg58
g62
sS'trial_loop.thisN'
p1112
I13
sg33
g1051
sg63
g64
sS'trial_loop.thisIndex'
p1113
g59
(g98
S'\r\x00\x00\x00'
tRp1114
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1115
I0
sg903
S'51-mars.png'
p1116
sS'block_loop.thisRepN'
p1117
I0
sg906
g1051
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1118
I0
sg908
g1058
sg55
g11
sS'block_loop.thisTrial'
p1119
Nsg69
Vn
sS'block_loop.thisTrialN'
p1120
I0
sg39
F2.53387959976817
sg34
g752
(S'\x07\xdf\n\x10\n3"\x05n\xa0'
tRp1121
sa(dp1122
S'trial_loop.thisTrialN'
p1123
I14
sg894
S'1-treacle_cookies.png'
p1124
sS'block_loop.thisIndex'
p1125
g888
sg38
S'right'
p1126
sg58
g62
sS'trial_loop.thisN'
p1127
I14
sg33
S'1-treacle_cookies.png'
p1128
sg63
g64
sS'trial_loop.thisIndex'
p1129
g59
(g98
S'\x0e\x00\x00\x00'
tRp1130
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1131
I0
sg903
S'21-nakd_banana_crunch.png'
p1132
sS'block_loop.thisRepN'
p1133
I0
sg906
S'21-nakd_banana_crunch.png'
p1134
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1135
I0
sg908
g1128
sg55
g11
sS'block_loop.thisTrial'
p1136
Nsg69
Vn
sS'block_loop.thisTrialN'
p1137
I0
sg39
F1.5834150613759448
sg34
g752
(S'\x07\xdf\n\x10\n3)\x0e\x11\x90'
tRp1138
sa(dp1139
S'trial_loop.thisTrialN'
p1140
I15
sg894
S'48-twix.png'
p1141
sS'block_loop.thisIndex'
p1142
g888
sg38
S'right'
p1143
sg58
g62
sS'trial_loop.thisN'
p1144
I15
sg33
g1006
sg63
g64
sS'trial_loop.thisIndex'
p1145
g59
(g98
S'\x0f\x00\x00\x00'
tRp1146
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1147
I0
sg903
S'50-polo.png'
p1148
sS'block_loop.thisRepN'
p1149
I0
sg906
g1006
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1150
I0
sg908
g1000
sg55
g11
sS'block_loop.thisTrial'
p1151
Nsg69
Vn
sS'block_loop.thisTrialN'
p1152
I0
sg39
F2.4001407813052538
sg34
g752
(S'\x07\xdf\n\x10\n30\x08-\xc0'
tRp1153
sa(dp1154
S'trial_loop.thisTrialN'
p1155
I16
sg894
S'18-mms.png'
p1156
sS'block_loop.thisIndex'
p1157
g888
sg38
S'left'
p1158
sg58
g62
sS'trial_loop.thisN'
p1159
I16
sg33
S'18-mms.png'
p1160
sg63
g64
sS'trial_loop.thisIndex'
p1161
g59
(g98
S'\x10\x00\x00\x00'
tRp1162
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1163
I0
sg903
S'43-mrporky_pork_crackles_redo.png'
p1164
sS'block_loop.thisRepN'
p1165
I0
sg906
g1160
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1166
I0
sg908
S'43-mrporky_pork_crackles_redo.png'
p1167
sg55
g11
sS'block_loop.thisTrial'
p1168
Nsg69
Vn
sS'block_loop.thisTrialN'
p1169
I0
sg39
F1.8335048671901859
sg34
g752
(S'\x07\xdf\n\x10\n37\x0e\xe8h'
tRp1170
sa(dp1171
S'trial_loop.thisTrialN'
p1172
I17
sg894
S'16-skips_prawn.png'
p1173
sS'block_loop.thisIndex'
p1174
g888
sg38
S'left'
p1175
sg58
g62
sS'trial_loop.thisN'
p1176
I17
sg33
g1096
sg63
g64
sS'trial_loop.thisIndex'
p1177
g59
(g98
S'\x11\x00\x00\x00'
tRp1178
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1179
I0
sg903
S'42-mrkipling_lemon_slices.png'
p1180
sS'block_loop.thisRepN'
p1181
I0
sg906
g1096
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1182
I0
sg908
g1103
sg55
g11
sS'block_loop.thisTrial'
p1183
Nsg69
Vn
sS'block_loop.thisTrialN'
p1184
I0
sg39
F2.6166882580751007
sg34
g752
(S'\x07\xdf\n\x10\n4\x02\x0c\xd9\x10'
tRp1185
sa(dp1186
S'trial_loop.thisTrialN'
p1187
I18
sg894
S'10-bounty_redo.png'
p1188
sS'block_loop.thisIndex'
p1189
g888
sg38
S'left'
p1190
sg58
g62
sS'trial_loop.thisN'
p1191
I18
sg33
S'10-bounty_redo.png'
p1192
sg63
g64
sS'trial_loop.thisIndex'
p1193
g59
(g98
S'\x12\x00\x00\x00'
tRp1194
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1195
I0
sg903
S'4-corn.png'
p1196
sS'block_loop.thisRepN'
p1197
I0
sg906
S'4-corn.png'
p1198
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1199
I0
sg908
g1192
sg55
g11
sS'block_loop.thisTrial'
p1200
Nsg69
Vn
sS'block_loop.thisTrialN'
p1201
I0
sg39
F1.3501813792345274
sg34
g752
(S'\x07\xdf\n\x10\n4\n\x07jp'
tRp1202
sa(dp1203
S'trial_loop.thisTrialN'
p1204
I19
sg894
g1092
sS'block_loop.thisIndex'
p1205
g888
sg38
S'right'
p1206
sg58
g62
sS'trial_loop.thisN'
p1207
I19
sg33
g1096
sg63
g64
sS'trial_loop.thisIndex'
p1208
g59
(g98
S'\x13\x00\x00\x00'
tRp1209
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1210
I0
sg903
g1100
sS'block_loop.thisRepN'
p1211
I0
sg906
g1096
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1212
I0
sg908
g1103
sg55
g11
sS'block_loop.thisTrial'
p1213
Nsg69
Vn
sS'block_loop.thisTrialN'
p1214
I0
sg39
F1.3667236102050992
sg34
g752
(S'\x07\xdf\n\x10\n4\x10\r6\xd0'
tRp1215
sa(dp1216
S'trial_loop.thisTrialN'
p1217
I20
sg894
S'3-ellas_strawberries_apples.png'
p1218
sS'block_loop.thisIndex'
p1219
g888
sg38
S'left'
p1220
sg58
g62
sS'trial_loop.thisN'
p1221
I20
sg33
S'3-ellas_strawberries_apples.png'
p1222
sg63
g64
sS'trial_loop.thisIndex'
p1223
g59
(g98
S'\x14\x00\x00\x00'
tRp1224
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1225
I0
sg903
S'13-mccoys_steak_crisps.png'
p1226
sS'block_loop.thisRepN'
p1227
I0
sg906
g1222
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1228
I0
sg908
S'13-mccoys_steak_crisps.png'
p1229
sg55
g11
sS'block_loop.thisTrial'
p1230
Nsg69
Vn
sS'block_loop.thisTrialN'
p1231
I0
sg39
F4.2167687126807323
sg34
g752
(S'\x07\xdf\n\x10\n4\x17\x04=\xf0'
tRp1232
sa(dp1233
S'trial_loop.thisTrialN'
p1234
I21
sg894
S'38-maltesers.png'
p1235
sS'block_loop.thisIndex'
p1236
g888
sg38
S'left'
p1237
sg58
g62
sS'trial_loop.thisN'
p1238
I21
sg33
S'38-maltesers.png'
p1239
sg63
g64
sS'trial_loop.thisIndex'
p1240
g59
(g98
S'\x15\x00\x00\x00'
tRp1241
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1242
I0
sg903
S'6-sour_patch_kids.png'
p1243
sS'block_loop.thisRepN'
p1244
I0
sg906
g1239
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1245
I0
sg908
S'6-sour_patch_kids.png'
p1246
sg55
g11
sS'block_loop.thisTrial'
p1247
Nsg69
Vn
sS'block_loop.thisTrialN'
p1248
I0
sg39
F1.0832559767904968
sg34
g752
(S'\x07\xdf\n\x10\n4 \x08\x0e\x80'
tRp1249
sa(dp1250
S'trial_loop.thisTrialN'
p1251
I22
sg894
g1077
sS'block_loop.thisIndex'
p1252
g888
sg38
S'right'
p1253
sg58
g62
sS'trial_loop.thisN'
p1254
I22
sg33
g976
sg63
g64
sS'trial_loop.thisIndex'
p1255
g59
(g98
S'\x16\x00\x00\x00'
tRp1256
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1257
I0
sg903
g1084
sS'block_loop.thisRepN'
p1258
I0
sg906
g976
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1259
I0
sg908
g970
sg55
g11
sS'block_loop.thisTrial'
p1260
Nsg69
Vn
sS'block_loop.thisTrialN'
p1261
I0
sg39
F1.5835242538419152
sg34
g752
(S'\x07\xdf\n\x10\n4&\t\xd3\xa0'
tRp1262
sa(dp1263
S'trial_loop.thisTrialN'
p1264
I23
sg894
S'46-pistachios.png'
p1265
sS'block_loop.thisIndex'
p1266
g888
sg38
S'left'
p1267
sg58
g62
sS'trial_loop.thisN'
p1268
I23
sg33
S'29-beans.png'
p1269
sg63
g64
sS'trial_loop.thisIndex'
p1270
g59
(g98
S'\x17\x00\x00\x00'
tRp1271
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1272
I0
sg903
S'29-beans.png'
p1273
sS'block_loop.thisRepN'
p1274
I0
sg906
g1269
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1275
I0
sg908
S'46-pistachios.png'
p1276
sg55
g11
sS'block_loop.thisTrial'
p1277
Nsg69
Vn
sS'block_loop.thisTrialN'
p1278
I0
sg39
F5.2000836477009216
sg34
g752
(S'\x07\xdf\n\x10\n4-\x03\xef\xd0'
tRp1279
sa(dp1280
S'trial_loop.thisTrialN'
p1281
I24
sg894
S'26-walkers_smoky_bacon.png'
p1282
sS'block_loop.thisIndex'
p1283
g888
sg38
S'right'
p1284
sg58
g62
sS'trial_loop.thisN'
p1285
I24
sg33
g936
sg63
g64
sS'trial_loop.thisIndex'
p1286
g59
(g98
S'\x18\x00\x00\x00'
tRp1287
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1288
I0
sg903
S'44-crunch.png'
p1289
sS'block_loop.thisRepN'
p1290
I0
sg906
g936
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1291
I0
sg908
g943
sg55
g11
sS'block_loop.thisTrial'
p1292
Nsg69
Vn
sS'block_loop.thisTrialN'
p1293
I0
sg39
F2.8501494482788985
sg34
g752
(S'\x07\xdf\n\x10\n47\x07\x81\xe0'
tRp1294
sa(dp1295
S'trial_loop.thisTrialN'
p1296
I25
sg894
S'6-sour_patch_kids.png'
p1297
sS'block_loop.thisIndex'
p1298
g888
sg38
S'right'
p1299
sg58
g62
sS'trial_loop.thisN'
p1300
I25
sg33
g1239
sg63
g64
sS'trial_loop.thisIndex'
p1301
g59
(g98
S'\x19\x00\x00\x00'
tRp1302
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1303
I0
sg903
S'38-maltesers.png'
p1304
sS'block_loop.thisRepN'
p1305
I0
sg906
g1239
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1306
I0
sg908
g1246
sg55
g11
sS'block_loop.thisTrial'
p1307
Nsg69
Vn
sS'block_loop.thisTrialN'
p1308
I0
sg39
F1.299912360928829
sg34
g752
(S'\x07\xdf\n\x10\n5\x03\x05\xa5P'
tRp1309
sa(dp1310
S'trial_loop.thisTrialN'
p1311
I26
sg894
S'19-caramello_redo.png'
p1312
sS'block_loop.thisIndex'
p1313
g888
sg38
S'left'
p1314
sg58
g62
sS'trial_loop.thisN'
p1315
I26
sg33
g1017
sg63
g64
sS'trial_loop.thisIndex'
p1316
g59
(g98
S'\x1a\x00\x00\x00'
tRp1317
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1318
I0
sg903
S'30-spaghetti_hoops.png'
p1319
sS'block_loop.thisRepN'
p1320
I0
sg906
g1017
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1321
I0
sg908
g1024
sg55
g11
sS'block_loop.thisTrial'
p1322
Nsg69
Vn
sS'block_loop.thisTrialN'
p1323
I0
sg39
F1.4667350711374638
sg34
g752
(S'\x07\xdf\n\x10\n5\t\n\xba\x18'
tRp1324
sa(dp1325
S'trial_loop.thisTrialN'
p1326
I27
sg894
S'20-fruit_pastilles.png'
p1327
sS'block_loop.thisIndex'
p1328
g888
sg38
S'right'
p1329
sg58
g62
sS'trial_loop.thisN'
p1330
I27
sg33
S'20-fruit_pastilles.png'
p1331
sg63
g64
sS'trial_loop.thisIndex'
p1332
g59
(g98
S'\x1b\x00\x00\x00'
tRp1333
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1334
I0
sg903
S'2-steamed_puddings.png'
p1335
sS'block_loop.thisRepN'
p1336
I0
sg906
g1331
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1337
I0
sg908
S'2-steamed_puddings.png'
p1338
sg55
g11
sS'block_loop.thisTrial'
p1339
Nsg69
Vn
sS'block_loop.thisTrialN'
p1340
I0
sg39
F1.8835093147158659
sg34
g752
(S'\x07\xdf\n\x10\n5\x10\x03,\x80'
tRp1341
sa(dp1342
S'trial_loop.thisTrialN'
p1343
I28
sg894
g1109
sS'block_loop.thisIndex'
p1344
g888
sg38
S'right'
p1345
sg58
g62
sS'trial_loop.thisN'
p1346
I28
sg33
g1058
sg63
g64
sS'trial_loop.thisIndex'
p1347
g59
(g98
S'\x1c\x00\x00\x00'
tRp1348
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1349
I0
sg903
g1116
sS'block_loop.thisRepN'
p1350
I0
sg906
g1051
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1351
I0
sg908
g1058
sg55
g11
sS'block_loop.thisTrial'
p1352
Nsg69
Vn
sS'block_loop.thisTrialN'
p1353
I0
sg39
F1.8168540139490688
sg34
g752
(S'\x07\xdf\n\x10\n5\x17\x01\xd0\xd8'
tRp1354
sa(dp1355
S'trial_loop.thisTrialN'
p1356
I29
sg894
g1077
sS'block_loop.thisIndex'
p1357
g888
sg38
S'right'
p1358
sg58
g62
sS'trial_loop.thisN'
p1359
I29
sg33
g976
sg63
g64
sS'trial_loop.thisIndex'
p1360
g59
(g98
S'\x1d\x00\x00\x00'
tRp1361
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1362
I0
sg903
g1084
sS'block_loop.thisRepN'
p1363
I0
sg906
g976
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1364
I0
sg908
g970
sg55
g11
sS'block_loop.thisTrial'
p1365
Nsg69
Vn
sS'block_loop.thisTrialN'
p1366
I0
sg39
F1.1333436728809829
sg34
g752
(S'\x07\xdf\n\x10\n5\x1d\x0e\xc5@'
tRp1367
sa(dp1368
S'trial_loop.thisTrialN'
p1369
I30
sg894
g1297
sS'block_loop.thisIndex'
p1370
g888
sg38
S'right'
p1371
sg58
g62
sS'trial_loop.thisN'
p1372
I30
sg33
g1239
sg63
g64
sS'trial_loop.thisIndex'
p1373
g59
(g98
S'\x1e\x00\x00\x00'
tRp1374
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1375
I0
sg903
g1304
sS'block_loop.thisRepN'
p1376
I0
sg906
g1239
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1377
I0
sg908
g1246
sg55
g11
sS'block_loop.thisTrial'
p1378
Nsg69
Vn
sS'block_loop.thisTrialN'
p1379
I0
sg39
F1.0666495988102724
sg34
g752
(S'\x07\xdf\n\x10\n5$\x026h'
tRp1380
sa(dp1381
S'trial_loop.thisTrialN'
p1382
I31
sg894
S'34-hula_hoops_bbq_beef_redo.png'
p1383
sS'block_loop.thisIndex'
p1384
g888
sg38
S'right'
p1385
sg58
g62
sS'trial_loop.thisN'
p1386
I31
sg33
S'36-fig_rolls.png'
p1387
sg63
g64
sS'trial_loop.thisIndex'
p1388
g59
(g98
S'\x1f\x00\x00\x00'
tRp1389
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1390
I0
sg903
S'36-fig_rolls.png'
p1391
sS'block_loop.thisRepN'
p1392
I0
sg906
g1387
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1393
I0
sg908
S'34-hula_hoops_bbq_beef_redo.png'
p1394
sg55
g11
sS'block_loop.thisTrial'
p1395
Nsg69
Vn
sS'block_loop.thisTrialN'
p1396
I0
sg39
F4.800143005067639
sg34
g752
(S'\x07\xdf\n\x10\n5*\x03\xbd\x08'
tRp1397
sa(dp1398
S'trial_loop.thisTrialN'
p1399
I32
sg894
S'2-steamed_puddings.png'
p1400
sS'block_loop.thisIndex'
p1401
g888
sg38
S'right'
p1402
sg58
g62
sS'trial_loop.thisN'
p1403
I32
sg33
g1331
sg63
g64
sS'trial_loop.thisIndex'
p1404
g59
(g98
S' \x00\x00\x00'
tRp1405
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1406
I0
sg903
S'20-fruit_pastilles.png'
p1407
sS'block_loop.thisRepN'
p1408
I0
sg906
g1331
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1409
I0
sg908
g1338
sg55
g11
sS'block_loop.thisTrial'
p1410
Nsg69
Vn
sS'block_loop.thisTrialN'
p1411
I0
sg39
F2.9005421990395917
sg34
g752
(S'\x07\xdf\n\x10\n54\x01\x1d('
tRp1412
sa(dp1413
S'trial_loop.thisTrialN'
p1414
I33
sg894
S'29-beans.png'
p1415
sS'block_loop.thisIndex'
p1416
g888
sg38
S'left'
p1417
sg58
g62
sS'trial_loop.thisN'
p1418
I33
sg33
g1269
sg63
g64
sS'trial_loop.thisIndex'
p1419
g59
(g98
S'!\x00\x00\x00'
tRp1420
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1421
I0
sg903
S'46-pistachios.png'
p1422
sS'block_loop.thisRepN'
p1423
I0
sg906
g1269
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1424
I0
sg908
g1276
sg55
g11
sS'block_loop.thisTrial'
p1425
Nsg69
Vn
sS'block_loop.thisTrialN'
p1426
I0
sg39
F4.5167765813803271
sg34
g752
(S'\x07\xdf\n\x10\n5;\x0f:p'
tRp1427
sa(dp1428
S'trial_loop.thisTrialN'
p1429
I34
sg894
g996
sS'block_loop.thisIndex'
p1430
g888
sg38
S'left'
p1431
sg58
g62
sS'trial_loop.thisN'
p1432
I34
sg33
g1006
sg63
g64
sS'trial_loop.thisIndex'
p1433
g59
(g98
S'"\x00\x00\x00'
tRp1434
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1435
I0
sg903
g1004
sS'block_loop.thisRepN'
p1436
I0
sg906
g1006
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1437
I0
sg908
g1000
sg55
g11
sS'block_loop.thisTrial'
p1438
Nsg69
Vn
sS'block_loop.thisTrialN'
p1439
I0
sg39
F3.2501476806723986
sg34
g752
(S'\x07\xdf\n\x10\n6\t\x08\x8fh'
tRp1440
sa(dp1441
S'trial_loop.thisTrialN'
p1442
I35
sg894
g1156
sS'block_loop.thisIndex'
p1443
g888
sg38
S'left'
p1444
sg58
g62
sS'trial_loop.thisN'
p1445
I35
sg33
g1160
sg63
g64
sS'trial_loop.thisIndex'
p1446
g59
(g98
S'#\x00\x00\x00'
tRp1447
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1448
I0
sg903
g1164
sS'block_loop.thisRepN'
p1449
I0
sg906
g1160
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1450
I0
sg908
g1167
sg55
g11
sS'block_loop.thisTrial'
p1451
Nsg69
Vn
sS'block_loop.thisTrialN'
p1452
I0
sg39
F1.0834449966473585
sg34
g752
(S'\x07\xdf\n\x10\n6\x11\x0c\xe0\xe0'
tRp1453
sa(dp1454
S'trial_loop.thisTrialN'
p1455
I36
sg894
g1218
sS'block_loop.thisIndex'
p1456
g888
sg38
S'left'
p1457
sg58
g62
sS'trial_loop.thisN'
p1458
I36
sg33
g1222
sg63
g64
sS'trial_loop.thisIndex'
p1459
g59
(g98
S'$\x00\x00\x00'
tRp1460
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1461
I0
sg903
g1226
sS'block_loop.thisRepN'
p1462
I0
sg906
g1222
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1463
I0
sg908
g1229
sg55
g11
sS'block_loop.thisTrial'
p1464
Nsg69
Vn
sS'block_loop.thisTrialN'
p1465
I0
sg39
F4.2003439420136601
sg34
g752
(S'\x07\xdf\n\x10\n6\x17\x0e\xa2\x18'
tRp1466
sa(dp1467
S'trial_loop.thisTrialN'
p1468
I37
sg894
g1415
sS'block_loop.thisIndex'
p1469
g888
sg38
S'left'
p1470
sg58
g62
sS'trial_loop.thisN'
p1471
I37
sg33
g1269
sg63
g64
sS'trial_loop.thisIndex'
p1472
g59
(g98
S'%\x00\x00\x00'
tRp1473
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1474
I0
sg903
g1422
sS'block_loop.thisRepN'
p1475
I0
sg906
g1269
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1476
I0
sg908
g1276
sg55
g11
sS'block_loop.thisTrial'
p1477
Nsg69
Vn
sS'block_loop.thisTrialN'
p1478
I0
sg39
F3.6500583880338127
sg34
g752
(S'\x07\xdf\n\x10\n6!\x02\xf9\xb8'
tRp1479
sa(dp1480
S'trial_loop.thisTrialN'
p1481
I38
sg894
g1218
sS'block_loop.thisIndex'
p1482
g888
sg38
S'left'
p1483
sg58
g62
sS'trial_loop.thisN'
p1484
I38
sg33
g1222
sg63
g64
sS'trial_loop.thisIndex'
p1485
g59
(g98
S'&\x00\x00\x00'
tRp1486
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1487
I0
sg903
g1226
sS'block_loop.thisRepN'
p1488
I0
sg906
g1222
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1489
I0
sg908
g1229
sg55
g11
sS'block_loop.thisTrial'
p1490
Nsg69
Vn
sS'block_loop.thisTrialN'
p1491
I0
sg39
F0.93342167564560441
sg34
g752
(S'\x07\xdf\n\x10\n6)\r>\xa0'
tRp1492
sa(dp1493
S'trial_loop.thisTrialN'
p1494
I39
sg894
S'4-corn.png'
p1495
sS'block_loop.thisIndex'
p1496
g888
sg38
S'right'
p1497
sg58
g62
sS'trial_loop.thisN'
p1498
I39
sg33
g1192
sg63
g64
sS'trial_loop.thisIndex'
p1499
g59
(g98
S"'\x00\x00\x00"
tRp1500
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1501
I0
sg903
S'10-bounty_redo.png'
p1502
sS'block_loop.thisRepN'
p1503
I0
sg906
g1198
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1504
I0
sg908
g1192
sg55
g11
sS'block_loop.thisTrial'
p1505
Nsg69
Vn
sS'block_loop.thisTrialN'
p1506
I0
sg39
F2.7001349653091893
sg34
g752
(S'\x07\xdf\n\x10\n6/\x0c\xdc\xf8'
tRp1507
sa(dp1508
S'trial_loop.thisTrialN'
p1509
I40
sg894
g1235
sS'block_loop.thisIndex'
p1510
g888
sg38
S'left'
p1511
sg58
g62
sS'trial_loop.thisN'
p1512
I40
sg33
g1239
sg63
g64
sS'trial_loop.thisIndex'
p1513
g59
(g98
S'(\x00\x00\x00'
tRp1514
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1515
I0
sg903
g1243
sS'block_loop.thisRepN'
p1516
I0
sg906
g1239
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1517
I0
sg908
g1246
sg55
g11
sS'block_loop.thisTrial'
p1518
Nsg69
Vn
sS'block_loop.thisTrialN'
p1519
I0
sg39
F0.96659394771495499
sg34
g752
(S'\x07\xdf\n\x10\n67\x08\x9f\x08'
tRp1520
sa(dp1521
S'trial_loop.thisTrialN'
p1522
I41
sg894
g1327
sS'block_loop.thisIndex'
p1523
g888
sg38
S'left'
p1524
sg58
g62
sS'trial_loop.thisN'
p1525
I41
sg33
g1331
sg63
g64
sS'trial_loop.thisIndex'
p1526
g59
(g98
S')\x00\x00\x00'
tRp1527
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1528
I0
sg903
g1335
sS'block_loop.thisRepN'
p1529
I0
sg906
g1331
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1530
I0
sg908
g1338
sg55
g11
sS'block_loop.thisTrial'
p1531
Nsg69
Vn
sS'block_loop.thisTrialN'
p1532
I0
sg39
F1.8168591457101684
sg34
g752
(S'\x07\xdf\n\x10\n7\x01\x08\xb6x'
tRp1533
sa(dp1534
S'trial_loop.thisTrialN'
p1535
I42
sg894
S'7-olives.png'
p1536
sS'block_loop.thisIndex'
p1537
g888
sg38
S'right'
p1538
sg58
g62
sS'trial_loop.thisN'
p1539
I42
sg33
S'7-olives.png'
p1540
sg63
g64
sS'trial_loop.thisIndex'
p1541
g59
(g98
S'*\x00\x00\x00'
tRp1542
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1543
I0
sg903
S'22-daim.png'
p1544
sS'block_loop.thisRepN'
p1545
I0
sg906
g1540
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1546
I0
sg908
S'22-daim.png'
p1547
sg55
g11
sS'block_loop.thisTrial'
p1548
Nsg69
Vn
sS'block_loop.thisTrialN'
p1549
I0
sg39
F1.9501626197984478
sg34
g752
(S'\x07\xdf\n\x10\n7\x08\x06d\xb8'
tRp1550
sa(dp1551
S'trial_loop.thisTrialN'
p1552
I43
sg894
S'25-kitkat.png'
p1553
sS'block_loop.thisIndex'
p1554
g888
sg38
S'left'
p1555
sg58
g62
sS'trial_loop.thisN'
p1556
I43
sg33
g919
sg63
g64
sS'trial_loop.thisIndex'
p1557
g59
(g98
S'+\x00\x00\x00'
tRp1558
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1559
I0
sg903
S'31-hobnobs.png'
p1560
sS'block_loop.thisRepN'
p1561
I0
sg906
g919
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1562
I0
sg908
g926
sg55
g11
sS'block_loop.thisTrial'
p1563
Nsg69
Vn
sS'block_loop.thisTrialN'
p1564
I0
sg39
F2.316798990069401
sg34
g752
(S'\x07\xdf\n\x10\n7\x0f\x069\xc0'
tRp1565
sa(dp1566
S'trial_loop.thisTrialN'
p1567
I44
sg894
g1400
sS'block_loop.thisIndex'
p1568
g888
sg38
S'right'
p1569
sg58
g62
sS'trial_loop.thisN'
p1570
I44
sg33
g1331
sg63
g64
sS'trial_loop.thisIndex'
p1571
g59
(g98
S',\x00\x00\x00'
tRp1572
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1573
I0
sg903
g1407
sS'block_loop.thisRepN'
p1574
I0
sg906
g1331
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1575
I0
sg908
g1338
sg55
g11
sS'block_loop.thisTrial'
p1576
Nsg69
Vn
sS'block_loop.thisTrialN'
p1577
I0
sg39
F1.5335112533812207
sg34
g752
(S'\x07\xdf\n\x10\n7\x16\x0b\x89 '
tRp1578
sa(dp1579
S'trial_loop.thisTrialN'
p1580
I45
sg894
S'5-pineapple.png'
p1581
sS'block_loop.thisIndex'
p1582
g888
sg38
S'right'
p1583
sg58
g62
sS'trial_loop.thisN'
p1584
I45
sg33
g899
sg63
g64
sS'trial_loop.thisIndex'
p1585
g59
(g98
S'-\x00\x00\x00'
tRp1586
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1587
I0
sg903
S'40-sardines.png'
p1588
sS'block_loop.thisRepN'
p1589
I0
sg906
g899
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1590
I0
sg908
g909
sg55
g11
sS'block_loop.thisTrial'
p1591
Nsg69
Vn
sS'block_loop.thisTrialN'
p1592
I0
sg39
F2.3501474525942285
sg34
g752
(S'\x07\xdf\n\x10\n7\x1d\x04\xed\xb8'
tRp1593
sa(dp1594
S'trial_loop.thisTrialN'
p1595
I46
sg894
S'43-mrporky_pork_crackles_redo.png'
p1596
sS'block_loop.thisIndex'
p1597
g888
sg38
S'right'
p1598
sg58
g62
sS'trial_loop.thisN'
p1599
I46
sg33
g1160
sg63
g64
sS'trial_loop.thisIndex'
p1600
g59
(g98
S'.\x00\x00\x00'
tRp1601
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1602
I0
sg903
S'18-mms.png'
p1603
sS'block_loop.thisRepN'
p1604
I0
sg906
g1160
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1605
I0
sg908
g1167
sg55
g11
sS'block_loop.thisTrial'
p1606
Nsg69
Vn
sS'block_loop.thisTrialN'
p1607
I0
sg39
F0.88391016225523344
sg34
g752
(S'\x07\xdf\n\x10\n7$\n\xb60'
tRp1608
sa(dp1609
S'trial_loop.thisTrialN'
p1610
I47
sg894
S'33-ambrosia_rice.png'
p1611
sS'block_loop.thisIndex'
p1612
g888
sg38
S'left'
p1613
sg58
g62
sS'trial_loop.thisN'
p1614
I47
sg33
g953
sg63
g64
sS'trial_loop.thisIndex'
p1615
g59
(g98
S'/\x00\x00\x00'
tRp1616
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1617
I0
sg903
S'23-crunchie_redo.png'
p1618
sS'block_loop.thisRepN'
p1619
I0
sg906
g953
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1620
I0
sg908
g960
sg55
g11
sS'block_loop.thisTrial'
p1621
Nsg69
Vn
sS'block_loop.thisTrialN'
p1622
I0
sg39
F1.8667398607813084
sg34
g752
(S'\x07\xdf\n\x10\n7*\tbX'
tRp1623
sa(dp1624
S'trial_loop.thisTrialN'
p1625
I48
sg894
g915
sS'block_loop.thisIndex'
p1626
g888
sg38
S'right'
p1627
sg58
g62
sS'trial_loop.thisN'
p1628
I48
sg33
g919
sg63
g64
sS'trial_loop.thisIndex'
p1629
g59
(g98
S'0\x00\x00\x00'
tRp1630
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1631
I0
sg903
g923
sS'block_loop.thisRepN'
p1632
I0
sg906
g919
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1633
I0
sg908
g926
sg55
g11
sS'block_loop.thisTrial'
p1634
Nsg69
Vn
sS'block_loop.thisTrialN'
p1635
I0
sg39
F5.566615957267004
sg34
g752
(S'\x07\xdf\n\x10\n71\x08\x06\xb0'
tRp1636
sa(dp1637
S'trial_loop.thisTrialN'
p1638
I49
sg894
g1013
sS'block_loop.thisIndex'
p1639
g888
sg38
S'right'
p1640
sg58
g62
sS'trial_loop.thisN'
p1641
I49
sg33
g1017
sg63
g64
sS'trial_loop.thisIndex'
p1642
g59
(g98
S'1\x00\x00\x00'
tRp1643
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1644
I0
sg903
g1021
sS'block_loop.thisRepN'
p1645
I0
sg906
g1017
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1646
I0
sg908
g1024
sg55
g11
sS'block_loop.thisTrial'
p1647
Nsg69
Vn
sS'block_loop.thisTrialN'
p1648
I0
sg39
F1.2168405573320342
sg34
g752
(S'\x07\xdf\n\x10\n8\x00\x01\xcc\xf0'
tRp1649
sa(dp1650
S'trial_loop.thisTrialN'
p1651
I50
sg894
g1141
sS'block_loop.thisIndex'
p1652
g888
sg38
S'right'
p1653
sg58
g62
sS'trial_loop.thisN'
p1654
I50
sg33
g1006
sg63
g64
sS'trial_loop.thisIndex'
p1655
g59
(g98
S'2\x00\x00\x00'
tRp1656
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1657
I0
sg903
g1148
sS'block_loop.thisRepN'
p1658
I0
sg906
g1006
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1659
I0
sg908
g1000
sg55
g11
sS'block_loop.thisTrial'
p1660
Nsg69
Vn
sS'block_loop.thisTrialN'
p1661
I0
sg39
F1.2505890121019547
sg34
g752
(S'\x07\xdf\n\x10\n8\x06\x05\xb4\xf0'
tRp1662
sa(dp1663
S'trial_loop.thisTrialN'
p1664
I51
sg894
g1030
sS'block_loop.thisIndex'
p1665
g888
sg38
S'left'
p1666
sg58
g62
sS'trial_loop.thisN'
p1667
I51
sg33
g1034
sg63
g64
sS'trial_loop.thisIndex'
p1668
g59
(g98
S'3\x00\x00\x00'
tRp1669
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1670
I0
sg903
g1038
sS'block_loop.thisRepN'
p1671
I0
sg906
g1034
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1672
I0
sg908
g1041
sg55
g11
sS'block_loop.thisTrial'
p1673
Nsg69
Vn
sS'block_loop.thisTrialN'
p1674
I0
sg39
F4.3667911783891213
sg34
g752
(S'\x07\xdf\n\x10\n8\x0c\n\x12 '
tRp1675
sa(dp1676
S'trial_loop.thisTrialN'
p1677
I52
sg894
S'17-jacobs_mini_cheddars_redo.png'
p1678
sS'block_loop.thisIndex'
p1679
g888
sg38
S'left'
p1680
sg58
g62
sS'trial_loop.thisN'
p1681
I52
sg33
S'8-liquorice_catherine_wheels.png'
p1682
sg63
g64
sS'trial_loop.thisIndex'
p1683
g59
(g98
S'4\x00\x00\x00'
tRp1684
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1685
I0
sg903
S'8-liquorice_catherine_wheels.png'
p1686
sS'block_loop.thisRepN'
p1687
I0
sg906
S'17-jacobs_mini_cheddars_redo.png'
p1688
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1689
I0
sg908
g1682
sg55
g11
sS'block_loop.thisTrial'
p1690
Nsg69
Vn
sS'block_loop.thisTrialN'
p1691
I0
sg39
F3.0001445445959689
sg34
g752
(S'\x07\xdf\n\x10\n8\x16\x00\xcb '
tRp1692
sa(dp1693
S'trial_loop.thisTrialN'
p1694
I53
sg894
g1047
sS'block_loop.thisIndex'
p1695
g888
sg38
S'left'
p1696
sg58
g62
sS'trial_loop.thisN'
p1697
I53
sg33
g1051
sg63
g64
sS'trial_loop.thisIndex'
p1698
g59
(g98
S'5\x00\x00\x00'
tRp1699
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1700
I0
sg903
g1055
sS'block_loop.thisRepN'
p1701
I0
sg906
g1051
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1702
I0
sg908
g1058
sg55
g11
sS'block_loop.thisTrial'
p1703
Nsg69
Vn
sS'block_loop.thisTrialN'
p1704
I0
sg39
F3.4001171181857899
sg34
g752
(S'\x07\xdf\n\x10\n8\x1e\x01O\xf0'
tRp1705
sa(dp1706
S'trial_loop.thisTrialN'
p1707
I54
sg894
g1141
sS'block_loop.thisIndex'
p1708
g888
sg38
S'left'
p1709
sg58
g62
sS'trial_loop.thisN'
p1710
I54
sg33
g1000
sg63
g64
sS'trial_loop.thisIndex'
p1711
g59
(g98
S'6\x00\x00\x00'
tRp1712
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1713
I0
sg903
g1148
sS'block_loop.thisRepN'
p1714
I0
sg906
g1006
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1715
I0
sg908
g1000
sg55
g11
sS'block_loop.thisTrial'
p1716
Nsg69
Vn
sS'block_loop.thisTrialN'
p1717
I0
sg39
F1.4338652878573157
sg34
g752
(S'\x07\xdf\n\x10\n8&\x08\x02\xc8'
tRp1718
sa(dp1719
S'trial_loop.thisTrialN'
p1720
I55
sg894
g1383
sS'block_loop.thisIndex'
p1721
g888
sg38
S'right'
p1722
sg58
g62
sS'trial_loop.thisN'
p1723
I55
sg33
g1387
sg63
g64
sS'trial_loop.thisIndex'
p1724
g59
(g98
S'7\x00\x00\x00'
tRp1725
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1726
I0
sg903
g1391
sS'block_loop.thisRepN'
p1727
I0
sg906
g1387
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1728
I0
sg908
g1394
sg55
g11
sS'block_loop.thisTrial'
p1729
Nsg69
Vn
sS'block_loop.thisTrialN'
p1730
I0
sg39
F3.3001324564484094
sg34
g752
(S'\x07\xdf\n\x10\n8,\x0f\x03\xc0'
tRp1731
sa(dp1732
S'trial_loop.thisTrialN'
p1733
I56
sg894
g895
sS'block_loop.thisIndex'
p1734
g888
sg38
S'left'
p1735
sg58
g62
sS'trial_loop.thisN'
p1736
I56
sg33
g899
sg63
g64
sS'trial_loop.thisIndex'
p1737
g59
(g98
S'8\x00\x00\x00'
tRp1738
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1739
I0
sg903
g904
sS'block_loop.thisRepN'
p1740
I0
sg906
g899
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1741
I0
sg908
g909
sg55
g11
sS'block_loop.thisTrial'
p1742
Nsg69
Vn
sS'block_loop.thisTrialN'
p1743
I0
sg39
F0.95012356139613985
sg34
g752
(S'\x07\xdf\n\x10\n85\x04\xca\x90'
tRp1744
sa(dp1745
S'trial_loop.thisTrialN'
p1746
I57
sg894
g1047
sS'block_loop.thisIndex'
p1747
g888
sg38
S'left'
p1748
sg58
g62
sS'trial_loop.thisN'
p1749
I57
sg33
g1058
sg63
g64
sS'trial_loop.thisIndex'
p1750
g59
(g98
S'9\x00\x00\x00'
tRp1751
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1752
I0
sg903
g1055
sS'block_loop.thisRepN'
p1753
I0
sg906
g1051
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1754
I0
sg908
g1058
sg55
g11
sS'block_loop.thisTrial'
p1755
Nsg69
Vn
sS'block_loop.thisTrialN'
p1756
I0
sg39
F2.350071331475192
sg34
g752
(S'\x07\xdf\n\x10\n8;\x04\xa3\x80'
tRp1757
sa(dp1758
S'trial_loop.thisTrialN'
p1759
I58
sg894
g1092
sS'block_loop.thisIndex'
p1760
g888
sg38
S'right'
p1761
sg58
g62
sS'trial_loop.thisN'
p1762
I58
sg33
g1096
sg63
g64
sS'trial_loop.thisIndex'
p1763
g59
(g98
S':\x00\x00\x00'
tRp1764
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1765
I0
sg903
g1100
sS'block_loop.thisRepN'
p1766
I0
sg906
g1096
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1767
I0
sg908
g1103
sg55
g11
sS'block_loop.thisTrial'
p1768
Nsg69
Vn
sS'block_loop.thisTrialN'
p1769
I0
sg39
F2.9499773062129862
sg34
g752
(S'\x07\xdf\n\x10\n9\x06\nk\xf8'
tRp1770
sa(dp1771
S'trial_loop.thisTrialN'
p1772
I59
sg894
g932
sS'block_loop.thisIndex'
p1773
g888
sg38
S'left'
p1774
sg58
g62
sS'trial_loop.thisN'
p1775
I59
sg33
g943
sg63
g64
sS'trial_loop.thisIndex'
p1776
g59
(g98
S';\x00\x00\x00'
tRp1777
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1778
I0
sg903
g940
sS'block_loop.thisRepN'
p1779
I0
sg906
g936
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1780
I0
sg908
g943
sg55
g11
sS'block_loop.thisTrial'
p1781
Nsg69
Vn
sS'block_loop.thisTrialN'
p1782
I0
sg39
F1.183477269721152
sg34
g752
(S'\x07\xdf\n\x10\n9\x0e\n90'
tRp1783
sa(dp1784
S'trial_loop.thisTrialN'
p1785
I60
sg894
g1596
sS'block_loop.thisIndex'
p1786
g888
sg38
S'right'
p1787
sg58
g62
sS'trial_loop.thisN'
p1788
I60
sg33
g1160
sg63
g64
sS'trial_loop.thisIndex'
p1789
g59
(g98
S'<\x00\x00\x00'
tRp1790
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1791
I0
sg903
g1603
sS'block_loop.thisRepN'
p1792
I0
sg906
g1160
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1793
I0
sg908
g1167
sg55
g11
sS'block_loop.thisTrial'
p1794
Nsg69
Vn
sS'block_loop.thisTrialN'
p1795
I0
sg39
F0.7835588647176337
sg34
g752
(S'\x07\xdf\n\x10\n9\x14\ri\x98'
tRp1796
sa(dp1797
S'trial_loop.thisTrialN'
p1798
I61
sg894
g1581
sS'block_loop.thisIndex'
p1799
g888
sg38
S'right'
p1800
sg58
g62
sS'trial_loop.thisN'
p1801
I61
sg33
g899
sg63
g64
sS'trial_loop.thisIndex'
p1802
g59
(g98
S'=\x00\x00\x00'
tRp1803
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1804
I0
sg903
g1588
sS'block_loop.thisRepN'
p1805
I0
sg906
g899
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1806
I0
sg908
g909
sg55
g11
sS'block_loop.thisTrial'
p1807
Nsg69
Vn
sS'block_loop.thisTrialN'
p1808
I0
sg39
F0.93344020700396868
sg34
g752
(S'\x07\xdf\n\x10\n9\x1a\n\xa6\x90'
tRp1809
sa(dp1810
S'trial_loop.thisTrialN'
p1811
I62
sg894
g1188
sS'block_loop.thisIndex'
p1812
g888
sg38
S'left'
p1813
sg58
g62
sS'trial_loop.thisN'
p1814
I62
sg33
g1192
sg63
g64
sS'trial_loop.thisIndex'
p1815
g59
(g98
S'>\x00\x00\x00'
tRp1816
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1817
I0
sg903
g1196
sS'block_loop.thisRepN'
p1818
I0
sg906
g1198
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1819
I0
sg908
g1192
sg55
g11
sS'block_loop.thisTrial'
p1820
Nsg69
Vn
sS'block_loop.thisTrialN'
p1821
I0
sg39
F1.0668007006565858
sg34
g752
(S'\x07\xdf\n\x10\n9 \nD\xe8'
tRp1822
sa(dp1823
S'trial_loop.thisTrialN'
p1824
I63
sg894
g1235
sS'block_loop.thisIndex'
p1825
g888
sg38
S'left'
p1826
sg58
g62
sS'trial_loop.thisN'
p1827
I63
sg33
g1246
sg63
g64
sS'trial_loop.thisIndex'
p1828
g59
(g98
S'?\x00\x00\x00'
tRp1829
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1830
I0
sg903
g1243
sS'block_loop.thisRepN'
p1831
I0
sg906
g1239
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1832
I0
sg908
g1246
sg55
g11
sS'block_loop.thisTrial'
p1833
Nsg69
Vn
sS'block_loop.thisTrialN'
p1834
I0
sg39
F1.3498920049446497
sg34
g752
(S'\x07\xdf\n\x10\n9&\x0b\xc7\xa0'
tRp1835
sa(dp1836
S'trial_loop.thisTrialN'
p1837
I64
sg894
g949
sS'block_loop.thisIndex'
p1838
g888
sg38
S'right'
p1839
sg58
g62
sS'trial_loop.thisN'
p1840
I64
sg33
g953
sg63
g64
sS'trial_loop.thisIndex'
p1841
g59
(g98
S'@\x00\x00\x00'
tRp1842
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1843
I0
sg903
g957
sS'block_loop.thisRepN'
p1844
I0
sg906
g953
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1845
I0
sg908
g960
sg55
g11
sS'block_loop.thisTrial'
p1846
Nsg69
Vn
sS'block_loop.thisTrialN'
p1847
I0
sg39
F1.3502902866034674
sg34
g752
(S'\x07\xdf\n\x10\n9-\x02U\xa8'
tRp1848
sa(dp1849
S'trial_loop.thisTrialN'
p1850
I65
sg894
g1327
sS'block_loop.thisIndex'
p1851
g888
sg38
S'left'
p1852
sg58
g62
sS'trial_loop.thisN'
p1853
I65
sg33
g1331
sg63
g64
sS'trial_loop.thisIndex'
p1854
g59
(g98
S'A\x00\x00\x00'
tRp1855
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1856
I0
sg903
g1335
sS'block_loop.thisRepN'
p1857
I0
sg906
g1331
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1858
I0
sg908
g1338
sg55
g11
sS'block_loop.thisTrial'
p1859
Nsg69
Vn
sS'block_loop.thisTrialN'
p1860
I0
sg39
F2.0501156356767751
sg34
g752
(S'\x07\xdf\n\x10\n93\x08"\x08'
tRp1861
sa(dp1862
S'trial_loop.thisTrialN'
p1863
I66
sg894
g1282
sS'block_loop.thisIndex'
p1864
g888
sg38
S'right'
p1865
sg58
g62
sS'trial_loop.thisN'
p1866
I66
sg33
g936
sg63
g64
sS'trial_loop.thisIndex'
p1867
g59
(g98
S'B\x00\x00\x00'
tRp1868
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1869
I0
sg903
g1289
sS'block_loop.thisRepN'
p1870
I0
sg906
g936
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1871
I0
sg908
g943
sg55
g11
sS'block_loop.thisTrial'
p1872
Nsg69
Vn
sS'block_loop.thisTrialN'
p1873
I0
sg39
F1.0835159860052954
sg34
g752
(S'\x07\xdf\n\x10\n9:\tf@'
tRp1874
sa(dp1875
S'trial_loop.thisTrialN'
p1876
I67
sg894
S'8-liquorice_catherine_wheels.png'
p1877
sS'block_loop.thisIndex'
p1878
g888
sg38
S'left'
p1879
sg58
g62
sS'trial_loop.thisN'
p1880
I67
sg33
g1688
sg63
g64
sS'trial_loop.thisIndex'
p1881
g59
(g98
S'C\x00\x00\x00'
tRp1882
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1883
I0
sg903
S'17-jacobs_mini_cheddars_redo.png'
p1884
sS'block_loop.thisRepN'
p1885
I0
sg906
g1688
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1886
I0
sg908
g1682
sg55
g11
sS'block_loop.thisTrial'
p1887
Nsg69
Vn
sS'block_loop.thisTrialN'
p1888
I0
sg39
F3.1835017881335261
sg34
g752
(S"\x07\xdf\n\x10\n:\x04\x0b'x"
tRp1889
sa(dp1890
S'trial_loop.thisTrialN'
p1891
I68
sg894
S'21-nakd_banana_crunch.png'
p1892
sS'block_loop.thisIndex'
p1893
g888
sg38
S'left'
p1894
sg58
g62
sS'trial_loop.thisN'
p1895
I68
sg33
g1134
sg63
g64
sS'trial_loop.thisIndex'
p1896
g59
(g98
S'D\x00\x00\x00'
tRp1897
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1898
I0
sg903
S'1-treacle_cookies.png'
p1899
sS'block_loop.thisRepN'
p1900
I0
sg906
g1134
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1901
I0
sg908
g1128
sg55
g11
sS'block_loop.thisTrial'
p1902
Nsg69
Vn
sS'block_loop.thisTrialN'
p1903
I0
sg39
F5.0338456731274164
sg34
g752
(S'\x07\xdf\n\x10\n:\x0c\x0e\x86\xc0'
tRp1904
sa(dp1905
S'trial_loop.thisTrialN'
p1906
I69
sg894
g1109
sS'block_loop.thisIndex'
p1907
g888
sg38
S'left'
p1908
sg58
g62
sS'trial_loop.thisN'
p1909
I69
sg33
g1058
sg63
g64
sS'trial_loop.thisIndex'
p1910
g59
(g98
S'E\x00\x00\x00'
tRp1911
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1912
I0
sg903
g1116
sS'block_loop.thisRepN'
p1913
I0
sg906
g1051
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1914
I0
sg908
g1058
sg55
g11
sS'block_loop.thisTrial'
p1915
Nsg69
Vn
sS'block_loop.thisTrialN'
p1916
I0
sg39
F3.3667227549112795
sg34
g752
(S'\x07\xdf\n\x10\n:\x17\x006\xb0'
tRp1917
sa(dp1918
S'trial_loop.thisTrialN'
p1919
I70
sg894
g966
sS'block_loop.thisIndex'
p1920
g888
sg38
S'left'
p1921
sg58
g62
sS'trial_loop.thisN'
p1922
I70
sg33
g976
sg63
g64
sS'trial_loop.thisIndex'
p1923
g59
(g98
S'F\x00\x00\x00'
tRp1924
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1925
I0
sg903
g974
sS'block_loop.thisRepN'
p1926
I0
sg906
g976
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1927
I0
sg908
g970
sg55
g11
sS'block_loop.thisTrial'
p1928
Nsg69
Vn
sS'block_loop.thisTrialN'
p1929
I0
sg39
F2.8333708712129919
sg34
g752
(S'\x07\xdf\n\x10\n:\x1f\x06tX'
tRp1930
sa(dp1931
S'trial_loop.thisTrialN'
p1932
I71
sg894
g1124
sS'block_loop.thisIndex'
p1933
g888
sg38
S'right'
p1934
sg58
g62
sS'trial_loop.thisN'
p1935
I71
sg33
g1134
sg63
g64
sS'trial_loop.thisIndex'
p1936
g59
(g98
S'G\x00\x00\x00'
tRp1937
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1938
I0
sg903
g1132
sS'block_loop.thisRepN'
p1939
I0
sg906
g1134
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1940
I0
sg908
g1128
sg55
g11
sS'block_loop.thisTrial'
p1941
Nsg69
Vn
sS'block_loop.thisTrialN'
p1942
I0
sg39
F1.0835159860052954
sg34
g752
(S"\x07\xdf\n\x10\n:'\x04YH"
tRp1943
sa(dp1944
S'trial_loop.thisTrialN'
p1945
I72
sg894
g1495
sS'block_loop.thisIndex'
p1946
g888
sg38
S'right'
p1947
sg58
g62
sS'trial_loop.thisN'
p1948
I72
sg33
g1198
sg63
g64
sS'trial_loop.thisIndex'
p1949
g59
(g98
S'H\x00\x00\x00'
tRp1950
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1951
I0
sg903
g1502
sS'block_loop.thisRepN'
p1952
I0
sg906
g1198
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1953
I0
sg908
g1192
sg55
g11
sS'block_loop.thisTrial'
p1954
Nsg69
Vn
sS'block_loop.thisTrialN'
p1955
I0
sg39
F0.88349391943347655
sg34
g752
(S'\x07\xdf\n\x10\n:-\x06\x1a\x80'
tRp1956
sa(dp1957
S'trial_loop.thisTrialN'
p1958
I73
sg894
g1596
sS'block_loop.thisIndex'
p1959
g888
sg38
S'right'
p1960
sg58
g62
sS'trial_loop.thisN'
p1961
I73
sg33
g1160
sg63
g64
sS'trial_loop.thisIndex'
p1962
g59
(g98
S'I\x00\x00\x00'
tRp1963
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1964
I0
sg903
g1603
sS'block_loop.thisRepN'
p1965
I0
sg906
g1160
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1966
I0
sg908
g1167
sg55
g11
sS'block_loop.thisTrial'
p1967
Nsg69
Vn
sS'block_loop.thisTrialN'
p1968
I0
sg39
F0.93351319204657557
sg34
g752
(S'\x07\xdf\n\x10\n:3\x04\xc6\xa8'
tRp1969
sa(dp1970
S'trial_loop.thisTrialN'
p1971
I74
sg894
S'22-daim.png'
p1972
sS'block_loop.thisIndex'
p1973
g888
sg38
S'right'
p1974
sg58
g62
sS'trial_loop.thisN'
p1975
I74
sg33
g1540
sg63
g64
sS'trial_loop.thisIndex'
p1976
g59
(g98
S'J\x00\x00\x00'
tRp1977
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1978
I0
sg903
S'7-olives.png'
p1979
sS'block_loop.thisRepN'
p1980
I0
sg906
g1540
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1981
I0
sg908
g1547
sg55
g11
sS'block_loop.thisTrial'
p1982
Nsg69
Vn
sS'block_loop.thisTrialN'
p1983
I0
sg39
F4.1000120311282444
sg34
g752
(S'\x07\xdf\n\x10\n:9\x04a\x18'
tRp1984
sa(dp1985
S'trial_loop.thisTrialN'
p1986
I75
sg894
g895
sS'block_loop.thisIndex'
p1987
g888
sg38
S'left'
p1988
sg58
g62
sS'trial_loop.thisN'
p1989
I75
sg33
g899
sg63
g64
sS'trial_loop.thisIndex'
p1990
g59
(g98
S'K\x00\x00\x00'
tRp1991
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p1992
I0
sg903
g904
sS'block_loop.thisRepN'
p1993
I0
sg906
g899
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p1994
I0
sg908
g909
sg55
g11
sS'block_loop.thisTrial'
p1995
Nsg69
Vn
sS'block_loop.thisTrialN'
p1996
I0
sg39
F1.0334798926205622
sg34
g752
(S'\x07\xdf\n\x10\n;\x06\x06MH'
tRp1997
sa(dp1998
S'trial_loop.thisTrialN'
p1999
I76
sg894
g1596
sS'block_loop.thisIndex'
p2000
g888
sg38
S'right'
p2001
sg58
g62
sS'trial_loop.thisN'
p2002
I76
sg33
g1160
sg63
g64
sS'trial_loop.thisIndex'
p2003
g59
(g98
S'L\x00\x00\x00'
tRp2004
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2005
I0
sg903
g1603
sS'block_loop.thisRepN'
p2006
I0
sg906
g1160
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2007
I0
sg908
g1167
sg55
g11
sS'block_loop.thisTrial'
p2008
Nsg69
Vn
sS'block_loop.thisTrialN'
p2009
I0
sg39
F0.81686627315548321
sg34
g752
(S'\x07\xdf\n\x10\n;\x0c\x07Z\xd0'
tRp2010
sa(dp2011
S'trial_loop.thisTrialN'
p2012
I77
sg894
g932
sS'block_loop.thisIndex'
p2013
g888
sg38
S'left'
p2014
sg58
g62
sS'trial_loop.thisN'
p2015
I77
sg33
g936
sg63
g64
sS'trial_loop.thisIndex'
p2016
g59
(g98
S'M\x00\x00\x00'
tRp2017
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2018
I0
sg903
g940
sS'block_loop.thisRepN'
p2019
I0
sg906
g936
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2020
I0
sg908
g943
sg55
g11
sS'block_loop.thisTrial'
p2021
Nsg69
Vn
sS'block_loop.thisTrialN'
p2022
I0
sg39
F1.4834991082138913
sg34
g752
(S'\x07\xdf\n\x10\n;\x12\x05\x10\xe0'
tRp2023
sa(dp2024
S'trial_loop.thisTrialN'
p2025
I78
sg894
g1124
sS'block_loop.thisIndex'
p2026
g888
sg38
S'right'
p2027
sg58
g62
sS'trial_loop.thisN'
p2028
I78
sg33
g1134
sg63
g64
sS'trial_loop.thisIndex'
p2029
g59
(g98
S'N\x00\x00\x00'
tRp2030
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2031
I0
sg903
g1132
sS'block_loop.thisRepN'
p2032
I0
sg906
g1134
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2033
I0
sg908
g1128
sg55
g11
sS'block_loop.thisTrial'
p2034
Nsg69
Vn
sS'block_loop.thisTrialN'
p2035
I0
sg39
F0.88352299941152523
sg34
g752
(S'\x07\xdf\n\x10\n;\x18\r\x04\x08'
tRp2036
sa(dp2037
S'trial_loop.thisTrialN'
p2038
I79
sg894
g1553
sS'block_loop.thisIndex'
p2039
g888
sg38
S'left'
p2040
sg58
g62
sS'trial_loop.thisN'
p2041
I79
sg33
g926
sg63
g64
sS'trial_loop.thisIndex'
p2042
g59
(g98
S'O\x00\x00\x00'
tRp2043
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2044
I0
sg903
g1560
sS'block_loop.thisRepN'
p2045
I0
sg906
g919
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2046
I0
sg908
g926
sg55
g11
sS'block_loop.thisTrial'
p2047
Nsg69
Vn
sS'block_loop.thisTrialN'
p2048
I0
sg39
F1.9501717429284326
sg34
g752
(S'\x07\xdf\n\x10\n;\x1e\x0b\xacH'
tRp2049
sa(dp2050
S'trial_loop.thisTrialN'
p2051
I80
sg894
g1077
sS'block_loop.thisIndex'
p2052
g888
sg38
S'right'
p2053
sg58
g62
sS'trial_loop.thisN'
p2054
I80
sg33
g976
sg63
g64
sS'trial_loop.thisIndex'
p2055
g59
(g98
S'P\x00\x00\x00'
tRp2056
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2057
I0
sg903
g1084
sS'block_loop.thisRepN'
p2058
I0
sg906
g976
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2059
I0
sg908
g970
sg55
g11
sS'block_loop.thisTrial'
p2060
Nsg69
Vn
sS'block_loop.thisTrialN'
p2061
I0
sg39
F1.1001314871159593
sg34
g752
(S'\x07\xdf\n\x10\n;%\x0b\x81P'
tRp2062
sa(dp2063
S'trial_loop.thisTrialN'
p2064
I81
sg894
S'36-fig_rolls.png'
p2065
sS'block_loop.thisIndex'
p2066
g888
sg38
S'left'
p2067
sg58
g62
sS'trial_loop.thisN'
p2068
I81
sg33
g1387
sg63
g64
sS'trial_loop.thisIndex'
p2069
g59
(g98
S'Q\x00\x00\x00'
tRp2070
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2071
I0
sg903
S'34-hula_hoops_bbq_beef_redo.png'
p2072
sS'block_loop.thisRepN'
p2073
I0
sg906
g1387
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2074
I0
sg908
g1394
sg55
g11
sS'block_loop.thisTrial'
p2075
Nsg69
Vn
sS'block_loop.thisTrialN'
p2076
I0
sg39
F1.7167912354084365
sg34
g752
(S'\x07\xdf\n\x10\n;+\r\x81\x08'
tRp2077
sa(dp2078
S'trial_loop.thisTrialN'
p2079
I82
sg894
g1173
sS'block_loop.thisIndex'
p2080
g888
sg38
S'left'
p2081
sg58
g62
sS'trial_loop.thisN'
p2082
I82
sg33
g1096
sg63
g64
sS'trial_loop.thisIndex'
p2083
g59
(g98
S'R\x00\x00\x00'
tRp2084
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2085
I0
sg903
g1180
sS'block_loop.thisRepN'
p2086
I0
sg906
g1096
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2087
I0
sg908
g1103
sg55
g11
sS'block_loop.thisTrial'
p2088
Nsg69
Vn
sS'block_loop.thisTrialN'
p2089
I0
sg39
F1.350402615144958
sg34
g752
(S'\x07\xdf\n\x10\n;2\t\xc4\x00'
tRp2090
sa(dp2091
S'trial_loop.thisTrialN'
p2092
I83
sg894
g1536
sS'block_loop.thisIndex'
p2093
g888
sg38
S'left'
p2094
sg58
g62
sS'trial_loop.thisN'
p2095
I83
sg33
g1540
sg63
g64
sS'trial_loop.thisIndex'
p2096
g59
(g98
S'S\x00\x00\x00'
tRp2097
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2098
I0
sg903
g1544
sS'block_loop.thisRepN'
p2099
I0
sg906
g1540
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2100
I0
sg908
g1547
sg55
g11
sS'block_loop.thisTrial'
p2101
Nsg69
Vn
sS'block_loop.thisTrialN'
p2102
I0
sg39
F1.3501611372889784
sg34
g752
(S'\x07\xdf\n\x10\n;9\x00N '
tRp2103
sa(dp2104
S'trial_loop.thisTrialN'
p2105
I84
sg894
g1282
sS'block_loop.thisIndex'
p2106
g888
sg38
S'right'
p2107
sg58
g62
sS'trial_loop.thisN'
p2108
I84
sg33
g936
sg63
g64
sS'trial_loop.thisIndex'
p2109
g59
(g98
S'T\x00\x00\x00'
tRp2110
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2111
I0
sg903
g1289
sS'block_loop.thisRepN'
p2112
I0
sg906
g936
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2113
I0
sg908
g943
sg55
g11
sS'block_loop.thisTrial'
p2114
Nsg69
Vn
sS'block_loop.thisTrialN'
p2115
I0
sg39
F1.1168516191273739
sg34
g752
(S'\x07\xdf\n\x10\x0b\x00\x03\x06\x1a\x80'
tRp2116
sa(dp2117
S'trial_loop.thisTrialN'
p2118
I85
sg894
g1877
sS'block_loop.thisIndex'
p2119
g888
sg38
S'left'
p2120
sg58
g62
sS'trial_loop.thisN'
p2121
I85
sg33
g1688
sg63
g64
sS'trial_loop.thisIndex'
p2122
g59
(g98
S'U\x00\x00\x00'
tRp2123
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2124
I0
sg903
g1884
sS'block_loop.thisRepN'
p2125
I0
sg906
g1688
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2126
I0
sg908
g1682
sg55
g11
sS'block_loop.thisTrial'
p2127
Nsg69
Vn
sS'block_loop.thisTrialN'
p2128
I0
sg39
F2.3667601027264027
sg34
g752
(S'\x07\xdf\n\x10\x0b\x00\t\x08X\xb8'
tRp2129
sa(dp2130
S'trial_loop.thisTrialN'
p2131
I86
sg894
g1235
sS'block_loop.thisIndex'
p2132
g888
sg38
S'left'
p2133
sg58
g62
sS'trial_loop.thisN'
p2134
I86
sg33
g1239
sg63
g64
sS'trial_loop.thisIndex'
p2135
g59
(g98
S'V\x00\x00\x00'
tRp2136
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2137
I0
sg903
g1243
sS'block_loop.thisRepN'
p2138
I0
sg906
g1239
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2139
I0
sg908
g1246
sg55
g11
sS'block_loop.thisTrial'
p2140
Nsg69
Vn
sS'block_loop.thisTrialN'
p2141
I0
sg39
F1.0498251209951377
sg34
g752
(S'\x07\xdf\n\x10\x0b\x00\x10\x0e\x9aH'
tRp2142
sa(dp2143
S'trial_loop.thisTrialN'
p2144
I87
sg894
g1536
sS'block_loop.thisIndex'
p2145
g888
sg38
S'left'
p2146
sg58
g62
sS'trial_loop.thisN'
p2147
I87
sg33
g1540
sg63
g64
sS'trial_loop.thisIndex'
p2148
g59
(g98
S'W\x00\x00\x00'
tRp2149
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2150
I0
sg903
g1544
sS'block_loop.thisRepN'
p2151
I0
sg906
g1540
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2152
I0
sg908
g1547
sg55
g11
sS'block_loop.thisTrial'
p2153
Nsg69
Vn
sS'block_loop.thisTrialN'
p2154
I0
sg39
F1.1172122678731284
sg34
g752
(S'\x07\xdf\n\x10\x0b\x00\x17\x00\xa0('
tRp2155
sa(dp2156
S'trial_loop.thisTrialN'
p2157
I88
sg894
g1553
sS'block_loop.thisIndex'
p2158
g888
sg38
S'right'
p2159
sg58
g62
sS'trial_loop.thisN'
p2160
I88
sg33
g919
sg63
g64
sS'trial_loop.thisIndex'
p2161
g59
(g98
S'X\x00\x00\x00'
tRp2162
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2163
I0
sg903
g1560
sS'block_loop.thisRepN'
p2164
I0
sg906
g919
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2165
I0
sg908
g926
sg55
g11
sS'block_loop.thisTrial'
p2166
Nsg69
Vn
sS'block_loop.thisTrialN'
p2167
I0
sg39
F1.15012053935925
sg34
g752
(S'\x07\xdf\n\x10\x0b\x00\x1d\x02\xdax'
tRp2168
sa(dp2169
S'trial_loop.thisTrialN'
p2170
I89
sg894
g1282
sS'block_loop.thisIndex'
p2171
g888
sg38
S'right'
p2172
sg58
g62
sS'trial_loop.thisN'
p2173
I89
sg33
g936
sg63
g64
sS'trial_loop.thisIndex'
p2174
g59
(g98
S'Y\x00\x00\x00'
tRp2175
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2176
I0
sg903
g1289
sS'block_loop.thisRepN'
p2177
I0
sg906
g936
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2178
I0
sg908
g943
sg55
g11
sS'block_loop.thisTrial'
p2179
Nsg69
Vn
sS'block_loop.thisTrialN'
p2180
I0
sg39
F0.98352305643084037
sg34
g752
(S'\x07\xdf\n\x10\x0b\x00#\x05\x91\xc8'
tRp2181
sa(dp2182
S'trial_loop.thisTrialN'
p2183
I90
sg894
g1141
sS'block_loop.thisIndex'
p2184
g888
sg38
S'right'
p2185
sg58
g62
sS'trial_loop.thisN'
p2186
I90
sg33
g1000
sg63
g64
sS'trial_loop.thisIndex'
p2187
g59
(g98
S'Z\x00\x00\x00'
tRp2188
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2189
I0
sg903
g1148
sS'block_loop.thisRepN'
p2190
I0
sg906
g1006
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2191
I0
sg908
g1000
sg55
g11
sS'block_loop.thisTrial'
p2192
Nsg69
Vn
sS'block_loop.thisTrialN'
p2193
I0
sg39
F5.9833710992916167
sg34
g752
(S'\x07\xdf\n\x10\x0b\x00)\x05\xe3\xd0'
tRp2194
sa(dp2195
S'trial_loop.thisTrialN'
p2196
I91
sg894
g2065
sS'block_loop.thisIndex'
p2197
g888
sg38
S'left'
p2198
sg58
g62
sS'trial_loop.thisN'
p2199
I91
sg33
g1387
sg63
g64
sS'trial_loop.thisIndex'
p2200
g59
(g98
S'[\x00\x00\x00'
tRp2201
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2202
I0
sg903
g2072
sS'block_loop.thisRepN'
p2203
I0
sg906
g1387
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2204
I0
sg908
g1394
sg55
g11
sS'block_loop.thisTrial'
p2205
Nsg69
Vn
sS'block_loop.thisTrialN'
p2206
I0
sg39
F1.0001017799227157
sg34
g752
(S'\x07\xdf\n\x10\x0b\x004\x06\x1a\x80'
tRp2207
sa(dp2208
S'trial_loop.thisTrialN'
p2209
I92
sg894
g915
sS'block_loop.thisIndex'
p2210
g888
sg38
S'left'
p2211
sg58
g62
sS'trial_loop.thisN'
p2212
I92
sg33
g919
sg63
g64
sS'trial_loop.thisIndex'
p2213
g59
(g98
S'\\\x00\x00\x00'
tRp2214
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2215
I0
sg903
g923
sS'block_loop.thisRepN'
p2216
I0
sg906
g919
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2217
I0
sg908
g926
sg55
g11
sS'block_loop.thisTrial'
p2218
Nsg69
Vn
sS'block_loop.thisTrialN'
p2219
I0
sg39
F2.81682521906896
sg34
g752
(S'\x07\xdf\n\x10\x0b\x00:\x06\xab\x08'
tRp2220
sa(dp2221
S'trial_loop.thisTrialN'
p2222
I93
sg894
g1156
sS'block_loop.thisIndex'
p2223
g888
sg38
S'left'
p2224
sg58
g62
sS'trial_loop.thisN'
p2225
I93
sg33
g1160
sg63
g64
sS'trial_loop.thisIndex'
p2226
g59
(g98
S']\x00\x00\x00'
tRp2227
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2228
I0
sg903
g1164
sS'block_loop.thisRepN'
p2229
I0
sg906
g1160
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2230
I0
sg908
g1167
sg55
g11
sS'block_loop.thisTrial'
p2231
Nsg69
Vn
sS'block_loop.thisTrialN'
p2232
I0
sg39
F1.1001939235388818
sg34
g752
(S'\x07\xdf\n\x10\x0b\x01\x06\x04U`'
tRp2233
sa(dp2234
S'trial_loop.thisTrialN'
p2235
I94
sg894
g1892
sS'block_loop.thisIndex'
p2236
g888
sg38
S'left'
p2237
sg58
g62
sS'trial_loop.thisN'
p2238
I94
sg33
g1128
sg63
g64
sS'trial_loop.thisIndex'
p2239
g59
(g98
S'^\x00\x00\x00'
tRp2240
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2241
I0
sg903
g1899
sS'block_loop.thisRepN'
p2242
I0
sg906
g1134
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2243
I0
sg908
g1128
sg55
g11
sS'block_loop.thisTrial'
p2244
Nsg69
Vn
sS'block_loop.thisTrialN'
p2245
I0
sg39
F1.8168220829934398
sg34
g752
(S'\x07\xdf\n\x10\x0b\x01\x0c\x06U\x18'
tRp2246
sa(dp2247
S'trial_loop.thisTrialN'
p2248
I95
sg894
g1678
sS'block_loop.thisIndex'
p2249
g888
sg38
S'left'
p2250
sg58
g62
sS'trial_loop.thisN'
p2251
I95
sg33
g1682
sg63
g64
sS'trial_loop.thisIndex'
p2252
g59
(g98
S'_\x00\x00\x00'
tRp2253
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2254
I0
sg903
g1686
sS'block_loop.thisRepN'
p2255
I0
sg906
g1688
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2256
I0
sg908
g1682
sg55
g11
sS'block_loop.thisTrial'
p2257
Nsg69
Vn
sS'block_loop.thisTrialN'
p2258
I0
sg39
F1.433478980307882
sg34
g752
(S'\x07\xdf\n\x10\x0b\x01\x13\x04\x03X'
tRp2259
sa(dp2260
S'trial_loop.thisTrialN'
p2261
I96
sg894
g2065
sS'block_loop.thisIndex'
p2262
g888
sg38
S'left'
p2263
sg58
g62
sS'trial_loop.thisN'
p2264
I96
sg33
g1387
sg63
g64
sS'trial_loop.thisIndex'
p2265
g59
(g98
S'`\x00\x00\x00'
tRp2266
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2267
I0
sg903
g2072
sS'block_loop.thisRepN'
p2268
I0
sg906
g1387
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2269
I0
sg908
g1394
sg55
g11
sS'block_loop.thisTrial'
p2270
Nsg69
Vn
sS'block_loop.thisTrialN'
p2271
I0
sg39
F1.0001816073131522
sg34
g752
(S'\x07\xdf\n\x10\x0b\x01\x19\x0b>\xe8'
tRp2272
sa(dp2273
S'trial_loop.thisTrialN'
p2274
I97
sg894
g949
sS'block_loop.thisIndex'
p2275
g888
sg38
S'right'
p2276
sg58
g62
sS'trial_loop.thisN'
p2277
I97
sg33
g953
sg63
g64
sS'trial_loop.thisIndex'
p2278
g59
(g98
S'a\x00\x00\x00'
tRp2279
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2280
I0
sg903
g957
sS'block_loop.thisRepN'
p2281
I0
sg906
g953
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2282
I0
sg908
g960
sg55
g11
sS'block_loop.thisTrial'
p2283
Nsg69
Vn
sS'block_loop.thisTrialN'
p2284
I0
sg39
F1.0172874766790301
sg34
g752
(S'\x07\xdf\n\x10\x0b\x01\x1f\x0b\xd3X'
tRp2285
sa(dp2286
S'trial_loop.thisTrialN'
p2287
I98
sg894
g1156
sS'block_loop.thisIndex'
p2288
g888
sg38
S'left'
p2289
sg58
g62
sS'trial_loop.thisN'
p2290
I98
sg33
g1160
sg63
g64
sS'trial_loop.thisIndex'
p2291
g59
(g98
S'b\x00\x00\x00'
tRp2292
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2293
I0
sg903
g1164
sS'block_loop.thisRepN'
p2294
I0
sg906
g1160
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2295
I0
sg908
g1167
sg55
g11
sS'block_loop.thisTrial'
p2296
Nsg69
Vn
sS'block_loop.thisTrialN'
p2297
I0
sg39
F0.81690732724200643
sg34
g752
(S'\x07\xdf\n\x10\x0b\x01%\x0cc\xe0'
tRp2298
sa(dp2299
S'trial_loop.thisTrialN'
p2300
I99
sg894
g1218
sS'block_loop.thisIndex'
p2301
g888
sg38
S'left'
p2302
sg58
g62
sS'trial_loop.thisN'
p2303
I99
sg33
g1229
sg63
g64
sS'trial_loop.thisIndex'
p2304
g59
(g98
S'c\x00\x00\x00'
tRp2305
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2306
I0
sg903
g1226
sS'block_loop.thisRepN'
p2307
I0
sg906
g1222
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2308
I0
sg908
g1229
sg55
g11
sS'block_loop.thisTrial'
p2309
Nsg69
Vn
sS'block_loop.thisTrialN'
p2310
I0
sg39
F0.9834905552793316
sg34
g752
(S'\x07\xdf\n\x10\x0b\x01+\n\x19\xf0'
tRp2311
sa(dp2312
S'trial_loop.thisTrialN'
p2313
I100
sg894
g1327
sS'block_loop.thisIndex'
p2314
g888
sg38
S'left'
p2315
sg58
g62
sS'trial_loop.thisN'
p2316
I100
sg33
g1331
sg63
g64
sS'trial_loop.thisIndex'
p2317
g59
(g98
S'd\x00\x00\x00'
tRp2318
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2319
I0
sg903
g1335
sS'block_loop.thisRepN'
p2320
I0
sg906
g1331
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2321
I0
sg908
g1338
sg55
g11
sS'block_loop.thisTrial'
p2322
Nsg69
Vn
sS'block_loop.thisTrialN'
p2323
I0
sg39
F1.6334158026302248
sg34
g752
(S'\x07\xdf\n\x10\x0b\x011\nk\xf8'
tRp2324
sa(dp2325
S'trial_loop.thisTrialN'
p2326
I101
sg894
g1124
sS'block_loop.thisIndex'
p2327
g888
sg38
S'right'
p2328
sg58
g62
sS'trial_loop.thisN'
p2329
I101
sg33
g1134
sg63
g64
sS'trial_loop.thisIndex'
p2330
g59
(g98
S'e\x00\x00\x00'
tRp2331
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2332
I0
sg903
g1132
sS'block_loop.thisRepN'
p2333
I0
sg906
g1134
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2334
I0
sg908
g1128
sg55
g11
sS'block_loop.thisTrial'
p2335
Nsg69
Vn
sS'block_loop.thisTrialN'
p2336
I0
sg39
F0.91686262390339834
sg34
g752
(S'\x07\xdf\n\x10\x0b\x018\x05C\xa8'
tRp2337
sa(dp2338
S'trial_loop.thisTrialN'
p2339
I102
sg894
g1297
sS'block_loop.thisIndex'
p2340
g888
sg38
S'right'
p2341
sg58
g62
sS'trial_loop.thisN'
p2342
I102
sg33
g1239
sg63
g64
sS'trial_loop.thisIndex'
p2343
g59
(g98
S'f\x00\x00\x00'
tRp2344
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2345
I0
sg903
g1304
sS'block_loop.thisRepN'
p2346
I0
sg906
g1239
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2347
I0
sg908
g1246
sg55
g11
sS'block_loop.thisTrial'
p2348
Nsg69
Vn
sS'block_loop.thisTrialN'
p2349
I0
sg39
F0.86663950634738285
sg34
g752
(S'\x07\xdf\n\x10\x0b\x02\x02\x04\xa3\x80'
tRp2350
sa(dp2351
S'trial_loop.thisTrialN'
p2352
I103
sg894
g1596
sS'block_loop.thisIndex'
p2353
g888
sg38
S'right'
p2354
sg58
g62
sS'trial_loop.thisN'
p2355
I103
sg33
g1160
sg63
g64
sS'trial_loop.thisIndex'
p2356
g59
(g98
S'g\x00\x00\x00'
tRp2357
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2358
I0
sg903
g1603
sS'block_loop.thisRepN'
p2359
I0
sg906
g1160
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2360
I0
sg908
g1167
sg55
g11
sS'block_loop.thisTrial'
p2361
Nsg69
Vn
sS'block_loop.thisTrialN'
p2362
I0
sg39
F2.6168128458234605
sg34
g752
(S'\x07\xdf\n\x10\x0b\x02\x08\x03\x11('
tRp2363
sa(dp2364
S'trial_loop.thisTrialN'
p2365
I104
sg894
g1400
sS'block_loop.thisIndex'
p2366
g888
sg38
S'right'
p2367
sg58
g62
sS'trial_loop.thisN'
p2368
I104
sg33
g1331
sg63
g64
sS'trial_loop.thisIndex'
p2369
g59
(g98
S'h\x00\x00\x00'
tRp2370
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2371
I0
sg903
g1407
sS'block_loop.thisRepN'
p2372
I0
sg906
g1331
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2373
I0
sg908
g1338
sg55
g11
sS'block_loop.thisTrial'
p2374
Nsg69
Vn
sS'block_loop.thisTrialN'
p2375
I0
sg39
F2.6001474525937738
sg34
g752
(S'\x07\xdf\n\x10\x0b\x02\x0f\x0c\xe4\xc8'
tRp2376
sa(dp2377
S'trial_loop.thisTrialN'
p2378
I105
sg894
g1415
sS'block_loop.thisIndex'
p2379
g888
sg38
S'left'
p2380
sg58
g62
sS'trial_loop.thisN'
p2381
I105
sg33
g1269
sg63
g64
sS'trial_loop.thisIndex'
p2382
g59
(g98
S'i\x00\x00\x00'
tRp2383
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2384
I0
sg903
g1422
sS'block_loop.thisRepN'
p2385
I0
sg906
g1269
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2386
I0
sg908
g1276
sg55
g11
sS'block_loop.thisTrial'
p2387
Nsg69
Vn
sS'block_loop.thisTrialN'
p2388
I0
sg39
F3.9667758401260471
sg34
g752
(S'\x07\xdf\n\x10\x0b\x02\x17\x07v('
tRp2389
sa(dp2390
S'trial_loop.thisTrialN'
p2391
I106
sg894
g1188
sS'block_loop.thisIndex'
p2392
g888
sg38
S'left'
p2393
sg58
g62
sS'trial_loop.thisN'
p2394
I106
sg33
g1198
sg63
g64
sS'trial_loop.thisIndex'
p2395
g59
(g98
S'j\x00\x00\x00'
tRp2396
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2397
I0
sg903
g1196
sS'block_loop.thisRepN'
p2398
I0
sg906
g1198
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2399
I0
sg908
g1192
sg55
g11
sS'block_loop.thisTrial'
p2400
Nsg69
Vn
sS'block_loop.thisTrialN'
p2401
I0
sg39
F0.88352841627011003
sg34
g752
(S'\x07\xdf\n\x10\x0b\x02 \x07z\x10'
tRp2402
sa(dp2403
S'trial_loop.thisTrialN'
p2404
I107
sg894
g2065
sS'block_loop.thisIndex'
p2405
g888
sg38
S'left'
p2406
sg58
g62
sS'trial_loop.thisN'
p2407
I107
sg33
g1387
sg63
g64
sS'trial_loop.thisIndex'
p2408
g59
(g98
S'k\x00\x00\x00'
tRp2409
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2410
I0
sg903
g2072
sS'block_loop.thisRepN'
p2411
I0
sg906
g1387
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2412
I0
sg908
g1394
sg55
g11
sS'block_loop.thisTrial'
p2413
Nsg69
Vn
sS'block_loop.thisTrialN'
p2414
I0
sg39
F1.0834737915274673
sg34
g752
(S'\x07\xdf\n\x10\x0b\x02&\x06"P'
tRp2415
sa(dp2416
S'trial_loop.thisTrialN'
p2417
I108
sg894
g949
sS'block_loop.thisIndex'
p2418
g888
sg38
S'right'
p2419
sg58
g62
sS'trial_loop.thisN'
p2420
I108
sg33
g960
sg63
g64
sS'trial_loop.thisIndex'
p2421
g59
(g98
S'l\x00\x00\x00'
tRp2422
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2423
I0
sg903
g957
sS'block_loop.thisRepN'
p2424
I0
sg906
g953
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2425
I0
sg908
g960
sg55
g11
sS'block_loop.thisTrial'
p2426
Nsg69
Vn
sS'block_loop.thisTrialN'
p2427
I0
sg39
F0.95017887037420223
sg34
g752
(S'\x07\xdf\n\x10\x0b\x02,\x07\xe3\x88'
tRp2428
sa(dp2429
S'trial_loop.thisTrialN'
p2430
I109
sg894
g1047
sS'block_loop.thisIndex'
p2431
g888
sg38
S'right'
p2432
sg58
g62
sS'trial_loop.thisN'
p2433
I109
sg33
g1051
sg63
g64
sS'trial_loop.thisIndex'
p2434
g59
(g98
S'm\x00\x00\x00'
tRp2435
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2436
I0
sg903
g1055
sS'block_loop.thisRepN'
p2437
I0
sg906
g1051
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2438
I0
sg908
g1058
sg55
g11
sS'block_loop.thisTrial'
p2439
Nsg69
Vn
sS'block_loop.thisTrialN'
p2440
I0
sg39
F1.2168473996798639
sg34
g752
(S'\x07\xdf\n\x10\x0b\x022\x07\x81\xe0'
tRp2441
sa(dp2442
S'trial_loop.thisTrialN'
p2443
I110
sg894
S'35-raisins.png'
p2444
sS'block_loop.thisIndex'
p2445
g888
sg38
S'right'
p2446
sg58
g62
sS'trial_loop.thisN'
p2447
I110
sg33
g1034
sg63
g64
sS'trial_loop.thisIndex'
p2448
g59
(g98
S'n\x00\x00\x00'
tRp2449
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2450
I0
sg903
S'49-yorkie.png'
p2451
sS'block_loop.thisRepN'
p2452
I0
sg906
g1034
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2453
I0
sg908
g1041
sg55
g11
sS'block_loop.thisTrial'
p2454
Nsg69
Vn
sS'block_loop.thisTrialN'
p2455
I0
sg39
F1.100140895343884
sg34
g752
(S'\x07\xdf\n\x10\x0b\x028\x0bi\xe0'
tRp2456
sa(dp2457
S'trial_loop.thisTrialN'
p2458
I111
sg894
g1173
sS'block_loop.thisIndex'
p2459
g888
sg38
S'left'
p2460
sg58
g62
sS'trial_loop.thisN'
p2461
I111
sg33
g1096
sg63
g64
sS'trial_loop.thisIndex'
p2462
g59
(g98
S'o\x00\x00\x00'
tRp2463
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2464
I0
sg903
g1180
sS'block_loop.thisRepN'
p2465
I0
sg906
g1096
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2466
I0
sg908
g1103
sg55
g11
sS'block_loop.thisTrial'
p2467
Nsg69
Vn
sS'block_loop.thisTrialN'
p2468
I0
sg39
F0.86714099341770634
sg34
g752
(S'\x07\xdf\n\x10\x0b\x03\x02\ri\x98'
tRp2469
sa(dp2470
S'trial_loop.thisTrialN'
p2471
I112
sg894
g1383
sS'block_loop.thisIndex'
p2472
g888
sg38
S'right'
p2473
sg58
g62
sS'trial_loop.thisN'
p2474
I112
sg33
g1387
sg63
g64
sS'trial_loop.thisIndex'
p2475
g59
(g98
S'p\x00\x00\x00'
tRp2476
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2477
I0
sg903
g1391
sS'block_loop.thisRepN'
p2478
I0
sg906
g1387
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2479
I0
sg908
g1394
sg55
g11
sS'block_loop.thisTrial'
p2480
Nsg69
Vn
sS'block_loop.thisTrialN'
p2481
I0
sg39
F0.85019135765833198
sg34
g752
(S'\x07\xdf\n\x10\x0b\x03\x08\x0b\xd3X'
tRp2482
sa(dp2483
S'trial_loop.thisTrialN'
p2484
I113
sg894
g966
sS'block_loop.thisIndex'
p2485
g888
sg38
S'left'
p2486
sg58
g62
sS'trial_loop.thisN'
p2487
I113
sg33
g976
sg63
g64
sS'trial_loop.thisIndex'
p2488
g59
(g98
S'q\x00\x00\x00'
tRp2489
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2490
I0
sg903
g974
sS'block_loop.thisRepN'
p2491
I0
sg906
g976
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2492
I0
sg908
g970
sg55
g11
sS'block_loop.thisTrial'
p2493
Nsg69
Vn
sS'block_loop.thisTrialN'
p2494
I0
sg39
F1.833410499810725
sg34
g752
(S'\x07\xdf\n\x10\x0b\x03\x0e\nA\x00'
tRp2495
sa(dp2496
S'trial_loop.thisTrialN'
p2497
I114
sg894
g1383
sS'block_loop.thisIndex'
p2498
g888
sg38
S'right'
p2499
sg58
g62
sS'trial_loop.thisN'
p2500
I114
sg33
g1394
sg63
g64
sS'trial_loop.thisIndex'
p2501
g59
(g98
S'r\x00\x00\x00'
tRp2502
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2503
I0
sg903
g1391
sS'block_loop.thisRepN'
p2504
I0
sg906
g1387
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2505
I0
sg908
g1394
sg55
g11
sS'block_loop.thisTrial'
p2506
Nsg69
Vn
sS'block_loop.thisTrialN'
p2507
I0
sg39
F0.80018263366537212
sg34
g752
(S'\x07\xdf\n\x10\x0b\x03\x15\x08-\xc0'
tRp2508
sa(dp2509
S'trial_loop.thisTrialN'
p2510
I115
sg894
S'13-mccoys_steak_crisps.png'
p2511
sS'block_loop.thisIndex'
p2512
g888
sg38
S'right'
p2513
sg58
g62
sS'trial_loop.thisN'
p2514
I115
sg33
g1222
sg63
g64
sS'trial_loop.thisIndex'
p2515
g59
(g98
S's\x00\x00\x00'
tRp2516
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2517
I0
sg903
S'3-ellas_strawberries_apples.png'
p2518
sS'block_loop.thisRepN'
p2519
I0
sg906
g1222
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2520
I0
sg908
g1229
sg55
g11
sS'block_loop.thisTrial'
p2521
Nsg69
Vn
sS'block_loop.thisTrialN'
p2522
I0
sg39
F1.3667732172261822
sg34
g752
(S'\x07\xdf\n\x10\x0b\x03\x1b\x05\xa98'
tRp2523
sa(dp2524
S'trial_loop.thisTrialN'
p2525
I116
sg894
g1892
sS'block_loop.thisIndex'
p2526
g888
sg38
S'left'
p2527
sg58
g62
sS'trial_loop.thisN'
p2528
I116
sg33
g1134
sg63
g64
sS'trial_loop.thisIndex'
p2529
g59
(g98
S't\x00\x00\x00'
tRp2530
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2531
I0
sg903
g1899
sS'block_loop.thisRepN'
p2532
I0
sg906
g1134
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2533
I0
sg908
g1128
sg55
g11
sS'block_loop.thisTrial'
p2534
Nsg69
Vn
sS'block_loop.thisTrialN'
p2535
I0
sg39
F0.86687471205141264
sg34
g752
(S'\x07\xdf\n\x10\x0b\x03!\x0b\xb4\x18'
tRp2536
sa(dp2537
S'trial_loop.thisTrialN'
p2538
I117
sg894
g1030
sS'block_loop.thisIndex'
p2539
g888
sg38
S'left'
p2540
sg58
g62
sS'trial_loop.thisN'
p2541
I117
sg33
g1034
sg63
g64
sS'trial_loop.thisIndex'
p2542
g59
(g98
S'u\x00\x00\x00'
tRp2543
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2544
I0
sg903
g1038
sS'block_loop.thisRepN'
p2545
I0
sg906
g1034
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2546
I0
sg908
g1041
sg55
g11
sS'block_loop.thisTrial'
p2547
Nsg69
Vn
sS'block_loop.thisTrialN'
p2548
I0
sg39
F1.783508402402731
sg34
g752
(S"\x07\xdf\n\x10\x0b\x03'\n!\xc0"
tRp2549
sa(dp2550
S'trial_loop.thisTrialN'
p2551
I118
sg894
g1141
sS'block_loop.thisIndex'
p2552
g888
sg38
S'right'
p2553
sg58
g62
sS'trial_loop.thisN'
p2554
I118
sg33
g1000
sg63
g64
sS'trial_loop.thisIndex'
p2555
g59
(g98
S'v\x00\x00\x00'
tRp2556
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2557
I0
sg903
g1148
sS'block_loop.thisRepN'
p2558
I0
sg906
g1006
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2559
I0
sg908
g1000
sg55
g11
sS'block_loop.thisTrial'
p2560
Nsg69
Vn
sS'block_loop.thisTrialN'
p2561
I0
sg39
F2.2667626115876374
sg34
g752
(S'\x07\xdf\n\x10\x0b\x03.\x07V\xe8'
tRp2562
sa(dp2563
S'trial_loop.thisTrialN'
p2564
I119
sg894
g1030
sS'block_loop.thisIndex'
p2565
g888
sg38
S'left'
p2566
sg58
g62
sS'trial_loop.thisN'
p2567
I119
sg33
g1034
sg63
g64
sS'trial_loop.thisIndex'
p2568
g59
(g98
S'w\x00\x00\x00'
tRp2569
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2570
I0
sg903
g1038
sS'block_loop.thisRepN'
p2571
I0
sg906
g1034
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2572
I0
sg908
g1041
sg55
g11
sS'block_loop.thisTrial'
p2573
Nsg69
Vn
sS'block_loop.thisTrialN'
p2574
I0
sg39
F1.4335077751879908
sg34
g752
(S'\x07\xdf\n\x10\x0b\x035\x0b\xee\xb0'
tRp2575
sa(dp2576
S'trial_loop.thisTrialN'
p2577
I120
sg894
g1678
sS'block_loop.thisIndex'
p2578
g888
sg38
S'left'
p2579
sg58
g62
sS'trial_loop.thisN'
p2580
I120
sg33
g1688
sg63
g64
sS'trial_loop.thisIndex'
p2581
g59
(g98
S'x\x00\x00\x00'
tRp2582
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2583
I0
sg903
g1686
sS'block_loop.thisRepN'
p2584
I0
sg906
g1688
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2585
I0
sg908
g1682
sg55
g11
sS'block_loop.thisTrial'
p2586
Nsg69
Vn
sS'block_loop.thisTrialN'
p2587
I0
sg39
F2.0001941516170518
sg34
g752
(S'\x07\xdf\n\x10\x0b\x04\x00\x03\xe8\x00'
tRp2588
sa(dp2589
S'trial_loop.thisTrialN'
p2590
I121
sg894
g966
sS'block_loop.thisIndex'
p2591
g888
sg38
S'left'
p2592
sg58
g62
sS'trial_loop.thisN'
p2593
I121
sg33
g976
sg63
g64
sS'trial_loop.thisIndex'
p2594
g59
(g98
S'y\x00\x00\x00'
tRp2595
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2596
I0
sg903
g974
sS'block_loop.thisRepN'
p2597
I0
sg906
g976
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2598
I0
sg908
g970
sg55
g11
sS'block_loop.thisTrial'
p2599
Nsg69
Vn
sS'block_loop.thisTrialN'
p2600
I0
sg39
F1.3335350875590848
sg34
g752
(S'\x07\xdf\n\x10\x0b\x04\x07\x046 '
tRp2601
sa(dp2602
S'trial_loop.thisTrialN'
p2603
I122
sg894
g1581
sS'block_loop.thisIndex'
p2604
g888
sg38
S'right'
p2605
sg58
g62
sS'trial_loop.thisN'
p2606
I122
sg33
g899
sg63
g64
sS'trial_loop.thisIndex'
p2607
g59
(g98
S'z\x00\x00\x00'
tRp2608
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2609
I0
sg903
g1588
sS'block_loop.thisRepN'
p2610
I0
sg906
g899
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2611
I0
sg908
g909
sg55
g11
sS'block_loop.thisTrial'
p2612
Nsg69
Vn
sS'block_loop.thisTrialN'
p2613
I0
sg39
F1.0168435793689241
sg34
g752
(S'\x07\xdf\n\x10\x0b\x04\r\n\x02\x80'
tRp2614
sa(dp2615
S'trial_loop.thisTrialN'
p2616
I123
sg894
g1265
sS'block_loop.thisIndex'
p2617
g888
sg38
S'right'
p2618
sg58
g62
sS'trial_loop.thisN'
p2619
I123
sg33
g1269
sg63
g64
sS'trial_loop.thisIndex'
p2620
g59
(g98
S'{\x00\x00\x00'
tRp2621
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2622
I0
sg903
g1273
sS'block_loop.thisRepN'
p2623
I0
sg906
g1269
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2624
I0
sg908
g1276
sg55
g11
sS'block_loop.thisTrial'
p2625
Nsg69
Vn
sS'block_loop.thisTrialN'
p2626
I0
sg39
F1.1834766995252721
sg34
g752
(S'\x07\xdf\n\x10\x0b\x04\x13\n\x93\x08'
tRp2627
sa(dp2628
S'trial_loop.thisTrialN'
p2629
I124
sg894
g1611
sS'block_loop.thisIndex'
p2630
g888
sg38
S'left'
p2631
sg58
g62
sS'trial_loop.thisN'
p2632
I124
sg33
g960
sg63
g64
sS'trial_loop.thisIndex'
p2633
g59
(g98
S'|\x00\x00\x00'
tRp2634
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2635
I0
sg903
g1618
sS'block_loop.thisRepN'
p2636
I0
sg906
g953
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2637
I0
sg908
g960
sg55
g11
sS'block_loop.thisTrial'
p2638
Nsg69
Vn
sS'block_loop.thisTrialN'
p2639
I0
sg39
F2.4668060604958555
sg34
g752
(S'\x07\xdf\n\x10\x0b\x04\x19\x0e\x01\xf0'
tRp2640
sa(dp2641
S'trial_loop.thisTrialN'
p2642
I125
sg894
g932
sS'block_loop.thisIndex'
p2643
g888
sg38
S'left'
p2644
sg58
g62
sS'trial_loop.thisN'
p2645
I125
sg33
g936
sg63
g64
sS'trial_loop.thisIndex'
p2646
g59
(g98
S'}\x00\x00\x00'
tRp2647
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2648
I0
sg903
g940
sS'block_loop.thisRepN'
p2649
I0
sg906
g936
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2650
I0
sg908
g943
sg55
g11
sS'block_loop.thisTrial'
p2651
Nsg69
Vn
sS'block_loop.thisTrialN'
p2652
I0
sg39
F0.96676871268073228
sg34
g752
(S'\x07\xdf\n\x10\x0b\x04!\x06l\x88'
tRp2653
sa(dp2654
S'trial_loop.thisTrialN'
p2655
I126
sg894
g1495
sS'block_loop.thisIndex'
p2656
g888
sg38
S'right'
p2657
sg58
g62
sS'trial_loop.thisN'
p2658
I126
sg33
g1198
sg63
g64
sS'trial_loop.thisIndex'
p2659
g59
(g98
S'~\x00\x00\x00'
tRp2660
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2661
I0
sg903
g1502
sS'block_loop.thisRepN'
p2662
I0
sg906
g1198
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2663
I0
sg908
g1192
sg55
g11
sS'block_loop.thisTrial'
p2664
Nsg69
Vn
sS'block_loop.thisTrialN'
p2665
I0
sg39
F1.5171936794949943
sg34
g752
(S"\x07\xdf\n\x10\x0b\x04'\x06I`"
tRp2666
sa(dp2667
S'trial_loop.thisTrialN'
p2668
I127
sg894
g1400
sS'block_loop.thisIndex'
p2669
g888
sg38
S'right'
p2670
sg58
g62
sS'trial_loop.thisN'
p2671
I127
sg33
g1338
sg63
g64
sS'trial_loop.thisIndex'
p2672
g59
(g98
S'\x7f\x00\x00\x00'
tRp2673
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2674
I0
sg903
g1407
sS'block_loop.thisRepN'
p2675
I0
sg906
g1331
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2676
I0
sg908
g1338
sg55
g11
sS'block_loop.thisTrial'
p2677
Nsg69
Vn
sS'block_loop.thisTrialN'
p2678
I0
sg39
F1.2001794405696273
sg34
g752
(S'\x07\xdf\n\x10\x0b\x04-\x0e\xb5\xa0'
tRp2679
sa(dp2680
S'trial_loop.thisTrialN'
p2681
I128
sg894
g1415
sS'block_loop.thisIndex'
p2682
g888
sg38
S'left'
p2683
sg58
g62
sS'trial_loop.thisN'
p2684
I128
sg33
g1276
sg63
g64
sS'trial_loop.thisIndex'
p2685
g59
(g98
S'\x80\x00\x00\x00'
tRp2686
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2687
I0
sg903
g1422
sS'block_loop.thisRepN'
p2688
I0
sg906
g1269
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2689
I0
sg908
g1276
sg55
g11
sS'block_loop.thisTrial'
p2690
Nsg69
Vn
sS'block_loop.thisTrialN'
p2691
I0
sg39
F1.3000725859055819
sg34
g752
(S'\x07\xdf\n\x10\x0b\x044\x03\x1c\xe0'
tRp2692
sa(dp2693
S'trial_loop.thisTrialN'
p2694
I129
sg894
g1892
sS'block_loop.thisIndex'
p2695
g888
sg38
S'left'
p2696
sg58
g62
sS'trial_loop.thisN'
p2697
I129
sg33
g1134
sg63
g64
sS'trial_loop.thisIndex'
p2698
g59
(g98
S'\x81\x00\x00\x00'
tRp2699
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2700
I0
sg903
g1899
sS'block_loop.thisRepN'
p2701
I0
sg906
g1134
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2702
I0
sg908
g1128
sg55
g11
sS'block_loop.thisTrial'
p2703
Nsg69
Vn
sS'block_loop.thisTrialN'
p2704
I0
sg39
F0.90020236243435647
sg34
g752
(S'\x07\xdf\n\x10\x0b\x04:\x081\xa8'
tRp2705
sa(dp2706
S'trial_loop.thisTrialN'
p2707
I130
sg894
g1400
sS'block_loop.thisIndex'
p2708
g888
sg38
S'right'
p2709
sg58
g62
sS'trial_loop.thisN'
p2710
I130
sg33
g1331
sg63
g64
sS'trial_loop.thisIndex'
p2711
g59
(g98
S'\x82\x00\x00\x00'
tRp2712
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2713
I0
sg903
g1407
sS'block_loop.thisRepN'
p2714
I0
sg906
g1331
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2715
I0
sg908
g1338
sg55
g11
sS'block_loop.thisTrial'
p2716
Nsg69
Vn
sS'block_loop.thisTrialN'
p2717
I0
sg39
F1.2835095427944907
sg34
g752
(S'\x07\xdf\n\x10\x0b\x05\x04\x07\x18h'
tRp2718
sa(dp2719
S'trial_loop.thisTrialN'
p2720
I131
sg894
g1297
sS'block_loop.thisIndex'
p2721
g888
sg38
S'right'
p2722
sg58
g62
sS'trial_loop.thisN'
p2723
I131
sg33
g1239
sg63
g64
sS'trial_loop.thisIndex'
p2724
g59
(g98
S'\x83\x00\x00\x00'
tRp2725
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2726
I0
sg903
g1304
sS'block_loop.thisRepN'
p2727
I0
sg906
g1239
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2728
I0
sg908
g1246
sg55
g11
sS'block_loop.thisTrial'
p2729
Nsg69
Vn
sS'block_loop.thisTrialN'
p2730
I0
sg39
F0.86671847844445438
sg34
g752
(S'\x07\xdf\n\x10\x0b\x05\n\x0b\xf2\x98'
tRp2731
sa(dp2732
S'trial_loop.thisTrialN'
p2733
I132
sg894
g1312
sS'block_loop.thisIndex'
p2734
g888
sg38
S'left'
p2735
sg58
g62
sS'trial_loop.thisN'
p2736
I132
sg33
g1017
sg63
g64
sS'trial_loop.thisIndex'
p2737
g59
(g98
S'\x84\x00\x00\x00'
tRp2738
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2739
I0
sg903
g1319
sS'block_loop.thisRepN'
p2740
I0
sg906
g1017
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2741
I0
sg908
g1024
sg55
g11
sS'block_loop.thisTrial'
p2742
Nsg69
Vn
sS'block_loop.thisTrialN'
p2743
I0
sg39
F1.6001440314203137
sg34
g752
(S'\x07\xdf\n\x10\x0b\x05\x10\n`@'
tRp2744
sa(dp2745
S'trial_loop.thisTrialN'
p2746
I133
sg894
g966
sS'block_loop.thisIndex'
p2747
g888
sg38
S'left'
p2748
sg58
g62
sS'trial_loop.thisN'
p2749
I133
sg33
g976
sg63
g64
sS'trial_loop.thisIndex'
p2750
g59
(g98
S'\x85\x00\x00\x00'
tRp2751
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2752
I0
sg903
g974
sS'block_loop.thisRepN'
p2753
I0
sg906
g976
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2754
I0
sg908
g970
sg55
g11
sS'block_loop.thisTrial'
p2755
Nsg69
Vn
sS'block_loop.thisTrialN'
p2756
I0
sg39
F1.1667939153285261
sg34
g752
(S'\x07\xdf\n\x10\x0b\x05\x17\x04\xba\xf0'
tRp2757
sa(dp2758
S'trial_loop.thisTrialN'
p2759
I134
sg894
g1611
sS'block_loop.thisIndex'
p2760
g888
sg38
S'left'
p2761
sg58
g62
sS'trial_loop.thisN'
p2762
I134
sg33
g953
sg63
g64
sS'trial_loop.thisIndex'
p2763
g59
(g98
S'\x86\x00\x00\x00'
tRp2764
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2765
I0
sg903
g1618
sS'block_loop.thisRepN'
p2766
I0
sg906
g953
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2767
I0
sg908
g960
sg55
g11
sS'block_loop.thisTrial'
p2768
Nsg69
Vn
sS'block_loop.thisTrialN'
p2769
I0
sg39
F0.98342669336670951
sg34
g752
(S'\x07\xdf\n\x10\x0b\x05\x1d\x07\xebX'
tRp2770
sa(dp2771
S'trial_loop.thisTrialN'
p2772
I135
sg894
g1173
sS'block_loop.thisIndex'
p2773
g888
sg38
S'left'
p2774
sg58
g62
sS'trial_loop.thisN'
p2775
I135
sg33
g1096
sg63
g64
sS'trial_loop.thisIndex'
p2776
g59
(g98
S'\x87\x00\x00\x00'
tRp2777
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2778
I0
sg903
g1180
sS'block_loop.thisRepN'
p2779
I0
sg906
g1096
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2780
I0
sg908
g1103
sg55
g11
sS'block_loop.thisTrial'
p2781
Nsg69
Vn
sS'block_loop.thisTrialN'
p2782
I0
sg39
F1.2667822833373066
sg34
g752
(S'\x07\xdf\n\x10\x0b\x05#\x08\x02\xc8'
tRp2783
sa(dp2784
S'trial_loop.thisTrialN'
p2785
I136
sg894
g1877
sS'block_loop.thisIndex'
p2786
g888
sg38
S'right'
p2787
sg58
g62
sS'trial_loop.thisN'
p2788
I136
sg33
g1688
sg63
g64
sS'trial_loop.thisIndex'
p2789
g59
(g98
S'\x88\x00\x00\x00'
tRp2790
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2791
I0
sg903
g1884
sS'block_loop.thisRepN'
p2792
I0
sg906
g1688
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2793
I0
sg908
g1682
sg55
g11
sS'block_loop.thisTrial'
p2794
Nsg69
Vn
sS'block_loop.thisTrialN'
p2795
I0
sg39
F1.2002013931023612
sg34
g752
(S'\x07\xdf\n\x10\x0b\x05)\x0c\x9ex'
tRp2796
sa(dp2797
S'trial_loop.thisTrialN'
p2798
I137
sg894
g1109
sS'block_loop.thisIndex'
p2799
g888
sg38
S'left'
p2800
sg58
g62
sS'trial_loop.thisN'
p2801
I137
sg33
g1051
sg63
g64
sS'trial_loop.thisIndex'
p2802
g59
(g98
S'\x89\x00\x00\x00'
tRp2803
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2804
I0
sg903
g1116
sS'block_loop.thisRepN'
p2805
I0
sg906
g1051
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2806
I0
sg908
g1058
sg55
g11
sS'block_loop.thisTrial'
p2807
Nsg69
Vn
sS'block_loop.thisTrialN'
p2808
I0
sg39
F2.5001425489108442
sg34
g752
(S'\x07\xdf\n\x10\x0b\x050\x01\x05\xb8'
tRp2809
sa(dp2810
S'trial_loop.thisTrialN'
p2811
I138
sg894
g1013
sS'block_loop.thisIndex'
p2812
g888
sg38
S'right'
p2813
sg58
g62
sS'trial_loop.thisN'
p2814
I138
sg33
g1017
sg63
g64
sS'trial_loop.thisIndex'
p2815
g59
(g98
S'\x8a\x00\x00\x00'
tRp2816
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2817
I0
sg903
g1021
sS'block_loop.thisRepN'
p2818
I0
sg906
g1017
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2819
I0
sg908
g1024
sg55
g11
sS'block_loop.thisTrial'
p2820
Nsg69
Vn
sS'block_loop.thisTrialN'
p2821
I0
sg39
F1.0168598299451332
sg34
g752
(S'\x07\xdf\n\x10\x0b\x057\t/\x90'
tRp2822
sa(dp2823
S'trial_loop.thisTrialN'
p2824
I139
sg894
g2444
sS'block_loop.thisIndex'
p2825
g888
sg38
S'right'
p2826
sg58
g62
sS'trial_loop.thisN'
p2827
I139
sg33
g1041
sg63
g64
sS'trial_loop.thisIndex'
p2828
g59
(g98
S'\x8b\x00\x00\x00'
tRp2829
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2830
I0
sg903
g2451
sS'block_loop.thisRepN'
p2831
I0
sg906
g1034
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2832
I0
sg908
g1041
sg55
g11
sS'block_loop.thisTrial'
p2833
Nsg69
Vn
sS'block_loop.thisTrialN'
p2834
I0
sg39
F1.1501772738256477
sg34
g752
(S'\x07\xdf\n\x10\x0b\x06\x01\t\xfe\x98'
tRp2835
sa(dp2836
S'trial_loop.thisTrialN'
p2837
I140
sg894
g1581
sS'block_loop.thisIndex'
p2838
g888
sg38
S'right'
p2839
sg58
g62
sS'trial_loop.thisN'
p2840
I140
sg33
g899
sg63
g64
sS'trial_loop.thisIndex'
p2841
g59
(g98
S'\x8c\x00\x00\x00'
tRp2842
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2843
I0
sg903
g1588
sS'block_loop.thisRepN'
p2844
I0
sg906
g899
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2845
I0
sg908
g909
sg55
g11
sS'block_loop.thisTrial'
p2846
Nsg69
Vn
sS'block_loop.thisTrialN'
p2847
I0
sg39
F0.81677846302682156
sg34
g752
(S'\x07\xdf\n\x10\x0b\x06\x07\x0c\xb5\xe8'
tRp2848
sa(dp2849
S'trial_loop.thisTrialN'
p2850
I141
sg894
g2511
sS'block_loop.thisIndex'
p2851
g888
sg38
S'right'
p2852
sg58
g62
sS'trial_loop.thisN'
p2853
I141
sg33
g1222
sg63
g64
sS'trial_loop.thisIndex'
p2854
g59
(g98
S'\x8d\x00\x00\x00'
tRp2855
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2856
I0
sg903
g2518
sS'block_loop.thisRepN'
p2857
I0
sg906
g1222
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2858
I0
sg908
g1229
sg55
g11
sS'block_loop.thisTrial'
p2859
Nsg69
Vn
sS'block_loop.thisTrialN'
p2860
I0
sg39
F0.88392641283098783
sg34
g752
(S'\x07\xdf\n\x10\x0b\x06\r\nk\xf8'
tRp2861
sa(dp2862
S'trial_loop.thisTrialN'
p2863
I142
sg894
g1013
sS'block_loop.thisIndex'
p2864
g888
sg38
S'right'
p2865
sg58
g62
sS'trial_loop.thisN'
p2866
I142
sg33
g1024
sg63
g64
sS'trial_loop.thisIndex'
p2867
g59
(g98
S'\x8e\x00\x00\x00'
tRp2868
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2869
I0
sg903
g1021
sS'block_loop.thisRepN'
p2870
I0
sg906
g1017
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2871
I0
sg908
g1024
sg55
g11
sS'block_loop.thisTrial'
p2872
Nsg69
Vn
sS'block_loop.thisTrialN'
p2873
I0
sg39
F0.93353229360036494
sg34
g752
(S'\x07\xdf\n\x10\x0b\x06\x13\t\x148'
tRp2874
sa(dp2875
S'trial_loop.thisTrialN'
p2876
I143
sg894
g1092
sS'block_loop.thisIndex'
p2877
g888
sg38
S'right'
p2878
sg58
g62
sS'trial_loop.thisN'
p2879
I143
sg33
g1096
sg63
g64
sS'trial_loop.thisIndex'
p2880
g59
(g98
S'\x8f\x00\x00\x00'
tRp2881
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2882
I0
sg903
g1100
sS'block_loop.thisRepN'
p2883
I0
sg906
g1096
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2884
I0
sg908
g1103
sg55
g11
sS'block_loop.thisTrial'
p2885
Nsg69
Vn
sS'block_loop.thisTrialN'
p2886
I0
sg39
F0.91674801457884314
sg34
g752
(S'\x07\xdf\n\x10\x0b\x06\x19\x08\xb2\x90'
tRp2887
sa(dp2888
S'trial_loop.thisTrialN'
p2889
I144
sg894
g1553
sS'block_loop.thisIndex'
p2890
g888
sg38
S'left'
p2891
sg58
g62
sS'trial_loop.thisN'
p2892
I144
sg33
g919
sg63
g64
sS'trial_loop.thisIndex'
p2893
g59
(g98
S'\x90\x00\x00\x00'
tRp2894
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2895
I0
sg903
g1560
sS'block_loop.thisRepN'
p2896
I0
sg906
g919
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2897
I0
sg908
g926
sg55
g11
sS'block_loop.thisTrial'
p2898
Nsg69
Vn
sS'block_loop.thisTrialN'
p2899
I0
sg39
F4.5666430415603827
sg34
g752
(S'\x07\xdf\n\x10\x0b\x06\x1f\x07\xd3\xe8'
tRp2900
sa(dp2901
S'trial_loop.thisTrialN'
p2902
I145
sg894
g1611
sS'block_loop.thisIndex'
p2903
g888
sg38
S'left'
p2904
sg58
g62
sS'trial_loop.thisN'
p2905
I145
sg33
g953
sg63
g64
sS'trial_loop.thisIndex'
p2906
g59
(g98
S'\x91\x00\x00\x00'
tRp2907
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2908
I0
sg903
g1618
sS'block_loop.thisRepN'
p2909
I0
sg906
g953
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2910
I0
sg908
g960
sg55
g11
sS'block_loop.thisTrial'
p2911
Nsg69
Vn
sS'block_loop.thisTrialN'
p2912
I0
sg39
F1.0668471716016938
sg34
g752
(S'\x07\xdf\n\x10\x0b\x06)\x01\xa1\xf8'
tRp2913
sa(dp2914
S'trial_loop.thisTrialN'
p2915
I146
sg894
g915
sS'block_loop.thisIndex'
p2916
g888
sg38
S'right'
p2917
sg58
g62
sS'trial_loop.thisN'
p2918
I146
sg33
g926
sg63
g64
sS'trial_loop.thisIndex'
p2919
g59
(g98
S'\x92\x00\x00\x00'
tRp2920
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2921
I0
sg903
g923
sS'block_loop.thisRepN'
p2922
I0
sg906
g919
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2923
I0
sg908
g926
sg55
g11
sS'block_loop.thisTrial'
p2924
Nsg69
Vn
sS'block_loop.thisTrialN'
p2925
I0
sg39
F1.350200480789681
sg34
g752
(S'\x07\xdf\n\x10\x0b\x06/\x03(\x98'
tRp2926
sa(dp2927
S'trial_loop.thisTrialN'
p2928
I147
sg894
g1495
sS'block_loop.thisIndex'
p2929
g888
sg38
S'left'
p2930
sg58
g62
sS'trial_loop.thisN'
p2931
I147
sg33
g1198
sg63
g64
sS'trial_loop.thisIndex'
p2932
g59
(g98
S'\x93\x00\x00\x00'
tRp2933
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2934
I0
sg903
g1502
sS'block_loop.thisRepN'
p2935
I0
sg906
g1198
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2936
I0
sg908
g1192
sg55
g11
sS'block_loop.thisTrial'
p2937
Nsg69
Vn
sS'block_loop.thisTrialN'
p2938
I0
sg39
F3.7167835377676965
sg34
g752
(S'\x07\xdf\n\x10\x0b\x065\t3x'
tRp2939
sa(dp2940
S'trial_loop.thisTrialN'
p2941
I148
sg894
g2511
sS'block_loop.thisIndex'
p2942
g888
sg38
S'right'
p2943
sg58
g62
sS'trial_loop.thisN'
p2944
I148
sg33
g1222
sg63
g64
sS'trial_loop.thisIndex'
p2945
g59
(g98
S'\x94\x00\x00\x00'
tRp2946
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2947
I0
sg903
g2518
sS'block_loop.thisRepN'
p2948
I0
sg906
g1222
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2949
I0
sg908
g1229
sg55
g11
sS'block_loop.thisTrial'
p2950
Nsg69
Vn
sS'block_loop.thisTrialN'
p2951
I0
sg39
F0.80018833562189684
sg34
g752
(S'\x07\xdf\n\x10\x0b\x07\x02\x05j\xb8'
tRp2952
sa(dp2953
S'trial_loop.thisTrialN'
p2954
I149
sg894
g1156
sS'block_loop.thisIndex'
p2955
g888
sg38
S'left'
p2956
sg58
g62
sS'trial_loop.thisN'
p2957
I149
sg33
g1160
sg63
g64
sS'trial_loop.thisIndex'
p2958
g59
(g98
S'\x95\x00\x00\x00'
tRp2959
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2960
I0
sg903
g1164
sS'block_loop.thisRepN'
p2961
I0
sg906
g1160
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2962
I0
sg908
g1167
sg55
g11
sS'block_loop.thisTrial'
p2963
Nsg69
Vn
sS'block_loop.thisTrialN'
p2964
I0
sg39
F0.9501272676679946
sg34
g752
(S'\x07\xdf\n\x10\x0b\x07\x08\x02\xa3\xc8'
tRp2965
sa(dp2966
S'trial_loop.thisTrialN'
p2967
I150
sg894
g1972
sS'block_loop.thisIndex'
p2968
g888
sg38
S'right'
p2969
sg58
g62
sS'trial_loop.thisN'
p2970
I150
sg33
g1547
sg63
g64
sS'trial_loop.thisIndex'
p2971
g59
(g98
S'\x96\x00\x00\x00'
tRp2972
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2973
I0
sg903
g1979
sS'block_loop.thisRepN'
p2974
I0
sg906
g1540
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2975
I0
sg908
g1547
sg55
g11
sS'block_loop.thisTrial'
p2976
Nsg69
Vn
sS'block_loop.thisTrialN'
p2977
I0
sg39
F1.4668553824194532
sg34
g752
(S'\x07\xdf\n\x10\x0b\x07\x0e\x02\x80\xa0'
tRp2978
sa(dp2979
S'trial_loop.thisTrialN'
p2980
I151
sg894
g1173
sS'block_loop.thisIndex'
p2981
g888
sg38
S'left'
p2982
sg58
g62
sS'trial_loop.thisN'
p2983
I151
sg33
g1096
sg63
g64
sS'trial_loop.thisIndex'
p2984
g59
(g98
S'\x97\x00\x00\x00'
tRp2985
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2986
I0
sg903
g1180
sS'block_loop.thisRepN'
p2987
I0
sg906
g1096
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p2988
I0
sg908
g1103
sg55
g11
sS'block_loop.thisTrial'
p2989
Nsg69
Vn
sS'block_loop.thisTrialN'
p2990
I0
sg39
F1.5001853135845522
sg34
g752
(S'\x07\xdf\n\x10\x0b\x07\x14\n5H'
tRp2991
sa(dp2992
S'trial_loop.thisTrialN'
p2993
I152
sg894
g2444
sS'block_loop.thisIndex'
p2994
g888
sg38
S'right'
p2995
sg58
g62
sS'trial_loop.thisN'
p2996
I152
sg33
g1034
sg63
g64
sS'trial_loop.thisIndex'
p2997
g59
(g98
S'\x98\x00\x00\x00'
tRp2998
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p2999
I0
sg903
g2451
sS'block_loop.thisRepN'
p3000
I0
sg906
g1034
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3001
I0
sg908
g1041
sg55
g11
sS'block_loop.thisTrial'
p3002
Nsg69
Vn
sS'block_loop.thisTrialN'
p3003
I0
sg39
F0.86683679404086433
sg34
g752
(S'\x07\xdf\n\x10\x0b\x07\x1b\x02\xe60'
tRp3004
sa(dp3005
S'trial_loop.thisTrialN'
p3006
I153
sg894
g1536
sS'block_loop.thisIndex'
p3007
g888
sg38
S'left'
p3008
sg58
g62
sS'trial_loop.thisN'
p3009
I153
sg33
g1540
sg63
g64
sS'trial_loop.thisIndex'
p3010
g59
(g98
S'\x99\x00\x00\x00'
tRp3011
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3012
I0
sg903
g1544
sS'block_loop.thisRepN'
p3013
I0
sg906
g1540
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3014
I0
sg908
g1547
sg55
g11
sS'block_loop.thisTrial'
p3015
Nsg69
Vn
sS'block_loop.thisTrialN'
p3016
I0
sg39
F1.0502034458058915
sg34
g752
(S'\x07\xdf\n\x10\x0b\x07!\x01\x8ep'
tRp3017
sa(dp3018
S'trial_loop.thisTrialN'
p3019
I154
sg894
g1877
sS'block_loop.thisIndex'
p3020
g888
sg38
S'right'
p3021
sg58
g62
sS'trial_loop.thisN'
p3022
I154
sg33
g1688
sg63
g64
sS'trial_loop.thisIndex'
p3023
g59
(g98
S'\x9a\x00\x00\x00'
tRp3024
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3025
I0
sg903
g1884
sS'block_loop.thisRepN'
p3026
I0
sg906
g1688
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3027
I0
sg908
g1682
sg55
g11
sS'block_loop.thisTrial'
p3028
Nsg69
Vn
sS'block_loop.thisTrialN'
p3029
I0
sg39
F0.9667915205063764
sg34
g752
(S"\x07\xdf\n\x10\x0b\x07'\x02\xd6\x90"
tRp3030
sa(dp3031
S'trial_loop.thisTrialN'
p3032
I155
sg894
g2444
sS'block_loop.thisIndex'
p3033
g888
sg38
S'right'
p3034
sg58
g62
sS'trial_loop.thisN'
p3035
I155
sg33
g1041
sg63
g64
sS'trial_loop.thisIndex'
p3036
g59
(g98
S'\x9b\x00\x00\x00'
tRp3037
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3038
I0
sg903
g2451
sS'block_loop.thisRepN'
p3039
I0
sg906
g1034
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3040
I0
sg908
g1041
sg55
g11
sS'block_loop.thisTrial'
p3041
Nsg69
Vn
sS'block_loop.thisTrialN'
p3042
I0
sg39
F0.86687442695347272
sg34
g752
(S'\x07\xdf\n\x10\x0b\x07-\x02\xb3h'
tRp3043
sa(dp3044
S'trial_loop.thisTrialN'
p3045
I156
sg894
g2511
sS'block_loop.thisIndex'
p3046
g888
sg38
S'right'
p3047
sg58
g62
sS'trial_loop.thisN'
p3048
I156
sg33
g1222
sg63
g64
sS'trial_loop.thisIndex'
p3049
g59
(g98
S'\x9c\x00\x00\x00'
tRp3050
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3051
I0
sg903
g2518
sS'block_loop.thisRepN'
p3052
I0
sg906
g1222
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3053
I0
sg908
g1229
sg55
g11
sS'block_loop.thisTrial'
p3054
Nsg69
Vn
sS'block_loop.thisTrialN'
p3055
I0
sg39
F0.85016427336540801
sg34
g752
(S'\x07\xdf\n\x10\x0b\x073\x01!\x10'
tRp3056
sa(dp3057
S'trial_loop.thisTrialN'
p3058
I157
sg894
g1030
sS'block_loop.thisIndex'
p3059
g888
sg38
S'left'
p3060
sg58
g62
sS'trial_loop.thisN'
p3061
I157
sg33
g1034
sg63
g64
sS'trial_loop.thisIndex'
p3062
g59
(g98
S'\x9d\x00\x00\x00'
tRp3063
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3064
I0
sg903
g1038
sS'block_loop.thisRepN'
p3065
I0
sg906
g1034
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3066
I0
sg908
g1041
sg55
g11
sS'block_loop.thisTrial'
p3067
Nsg69
Vn
sS'block_loop.thisTrialN'
p3068
I0
sg39
F0.86724762000358169
sg34
g752
(S'\x07\xdf\n\x10\x0b\x078\x0e\xcd\x10'
tRp3069
sa(dp3070
S'trial_loop.thisTrialN'
p3071
I158
sg894
g1218
sS'block_loop.thisIndex'
p3072
g888
sg38
S'left'
p3073
sg58
g62
sS'trial_loop.thisN'
p3074
I158
sg33
g1222
sg63
g64
sS'trial_loop.thisIndex'
p3075
g59
(g98
S'\x9e\x00\x00\x00'
tRp3076
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3077
I0
sg903
g1226
sS'block_loop.thisRepN'
p3078
I0
sg906
g1222
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3079
I0
sg908
g1229
sg55
g11
sS'block_loop.thisTrial'
p3080
Nsg69
Vn
sS'block_loop.thisTrialN'
p3081
I0
sg39
F0.78354660551212874
sg34
g752
(S'\x07\xdf\n\x10\x0b\x08\x02\r:\xb8'
tRp3082
sa(dp3083
S'trial_loop.thisTrialN'
p3084
I159
sg894
g1188
sS'block_loop.thisIndex'
p3085
g888
sg38
S'right'
p3086
sg58
g62
sS'trial_loop.thisN'
p3087
I159
sg33
g1198
sg63
g64
sS'trial_loop.thisIndex'
p3088
g59
(g98
S'\x9f\x00\x00\x00'
tRp3089
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3090
I0
sg903
g1196
sS'block_loop.thisRepN'
p3091
I0
sg906
g1198
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3092
I0
sg908
g1192
sg55
g11
sS'block_loop.thisTrial'
p3093
Nsg69
Vn
sS'block_loop.thisTrialN'
p3094
I0
sg39
F1.1667522910465777
sg34
g752
(S'\x07\xdf\n\x10\x0b\x08\x08\nw\xb0'
tRp3095
sa(dp3096
S'trial_loop.thisTrialN'
p3097
I160
sg894
g1282
sS'block_loop.thisIndex'
p3098
g888
sg38
S'right'
p3099
sg58
g62
sS'trial_loop.thisN'
p3100
I160
sg33
g936
sg63
g64
sS'trial_loop.thisIndex'
p3101
g59
(g98
S'\xa0\x00\x00\x00'
tRp3102
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3103
I0
sg903
g1289
sS'block_loop.thisRepN'
p3104
I0
sg906
g936
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3105
I0
sg908
g943
sg55
g11
sS'block_loop.thisTrial'
p3106
Nsg69
Vn
sS'block_loop.thisTrialN'
p3107
I0
sg39
F1.0001060563899955
sg34
g752
(S'\x07\xdf\n\x10\x0b\x08\x0e\ri\x98'
tRp3108
sa(dp3109
S'trial_loop.thisTrialN'
p3110
I161
sg894
g1047
sS'block_loop.thisIndex'
p3111
g888
sg38
S'right'
p3112
sg58
g62
sS'trial_loop.thisN'
p3113
I161
sg33
g1051
sg63
g64
sS'trial_loop.thisIndex'
p3114
g59
(g98
S'\xa1\x00\x00\x00'
tRp3115
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3116
I0
sg903
g1055
sS'block_loop.thisRepN'
p3117
I0
sg906
g1051
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3118
I0
sg908
g1058
sg55
g11
sS'block_loop.thisTrial'
p3119
Nsg69
Vn
sS'block_loop.thisTrialN'
p3120
I0
sg39
F2.3833753187391267
sg34
g752
(S'\x07\xdf\n\x10\x0b\x08\x14\r\xfa '
tRp3121
sa(dp3122
S'trial_loop.thisTrialN'
p3123
I162
sg894
g996
sS'block_loop.thisIndex'
p3124
g888
sg38
S'left'
p3125
sg58
g62
sS'trial_loop.thisN'
p3126
I162
sg33
g1006
sg63
g64
sS'trial_loop.thisIndex'
p3127
g59
(g98
S'\xa2\x00\x00\x00'
tRp3128
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3129
I0
sg903
g1004
sS'block_loop.thisRepN'
p3130
I0
sg906
g1006
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3131
I0
sg908
g1000
sg55
g11
sS'block_loop.thisTrial'
p3132
Nsg69
Vn
sS'block_loop.thisTrialN'
p3133
I0
sg39
F1.6005386068063672
sg34
g752
(S'\x07\xdf\n\x10\x0b\x08\x1c\x04\xf9p'
tRp3134
sa(dp3135
S'trial_loop.thisTrialN'
p3136
I163
sg894
g1415
sS'block_loop.thisIndex'
p3137
g888
sg38
S'left'
p3138
sg58
g62
sS'trial_loop.thisN'
p3139
I163
sg33
g1269
sg63
g64
sS'trial_loop.thisIndex'
p3140
g59
(g98
S'\xa3\x00\x00\x00'
tRp3141
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3142
I0
sg903
g1422
sS'block_loop.thisRepN'
p3143
I0
sg906
g1269
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3144
I0
sg908
g1276
sg55
g11
sS'block_loop.thisTrial'
p3145
Nsg69
Vn
sS'block_loop.thisTrialN'
p3146
I0
sg39
F2.6000998412573608
sg34
g752
(S'\x07\xdf\n\x10\x0b\x08"\x0e\x96`'
tRp3147
sa(dp3148
S'trial_loop.thisTrialN'
p3149
I164
sg894
g2444
sS'block_loop.thisIndex'
p3150
g888
sg38
S'right'
p3151
sg58
g62
sS'trial_loop.thisN'
p3152
I164
sg33
g1041
sg63
g64
sS'trial_loop.thisIndex'
p3153
g59
(g98
S'\xa4\x00\x00\x00'
tRp3154
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3155
I0
sg903
g2451
sS'block_loop.thisRepN'
p3156
I0
sg906
g1034
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3157
I0
sg908
g1041
sg55
g11
sS'block_loop.thisTrial'
p3158
Nsg69
Vn
sS'block_loop.thisTrialN'
p3159
I0
sg39
F0.76688206757535227
sg34
g752
(S"\x07\xdf\n\x10\x0b\x08*\t'\xc0"
tRp3160
sa(dp3161
S'trial_loop.thisTrialN'
p3162
I165
sg894
g1109
sS'block_loop.thisIndex'
p3163
g888
sg38
S'left'
p3164
sg58
g62
sS'trial_loop.thisN'
p3165
I165
sg33
g1051
sg63
g64
sS'trial_loop.thisIndex'
p3166
g59
(g98
S'\xa5\x00\x00\x00'
tRp3167
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3168
I0
sg903
g1116
sS'block_loop.thisRepN'
p3169
I0
sg906
g1051
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3170
I0
sg908
g1058
sg55
g11
sS'block_loop.thisTrial'
p3171
Nsg69
Vn
sS'block_loop.thisTrialN'
p3172
I0
sg39
F1.8668487681497936
sg34
g752
(S'\x07\xdf\n\x10\x0b\x080\x06* '
tRp3173
sa(dp3174
S'trial_loop.thisTrialN'
p3175
I166
sg894
g1265
sS'block_loop.thisIndex'
p3176
g888
sg38
S'right'
p3177
sg58
g62
sS'trial_loop.thisN'
p3178
I166
sg33
g1269
sg63
g64
sS'trial_loop.thisIndex'
p3179
g59
(g98
S'\xa6\x00\x00\x00'
tRp3180
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3181
I0
sg903
g1273
sS'block_loop.thisRepN'
p3182
I0
sg906
g1269
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3183
I0
sg908
g1276
sg55
g11
sS'block_loop.thisTrial'
p3184
Nsg69
Vn
sS'block_loop.thisTrialN'
p3185
I0
sg39
F1.2833501731120123
sg34
g752
(S'\x07\xdf\n\x10\x0b\x087\x04\x8f\xf8'
tRp3186
sa(dp3187
S'trial_loop.thisTrialN'
p3188
I167
sg894
g1235
sS'block_loop.thisIndex'
p3189
g888
sg38
S'left'
p3190
sg58
g62
sS'trial_loop.thisN'
p3191
I167
sg33
g1239
sg63
g64
sS'trial_loop.thisIndex'
p3192
g59
(g98
S'\xa7\x00\x00\x00'
tRp3193
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3194
I0
sg903
g1243
sS'block_loop.thisRepN'
p3195
I0
sg906
g1239
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3196
I0
sg908
g1246
sg55
g11
sS'block_loop.thisTrial'
p3197
Nsg69
Vn
sS'block_loop.thisTrialN'
p3198
I0
sg39
F1.566894212742227
sg34
g752
(S'\x07\xdf\n\x10\x0b\t\x01\tj('
tRp3199
sa(dp3200
S'trial_loop.thisTrialN'
p3201
I168
sg894
g1312
sS'block_loop.thisIndex'
p3202
g888
sg38
S'left'
p3203
sg58
g62
sS'trial_loop.thisN'
p3204
I168
sg33
g1017
sg63
g64
sS'trial_loop.thisIndex'
p3205
g59
(g98
S'\xa8\x00\x00\x00'
tRp3206
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3207
I0
sg903
g1319
sS'block_loop.thisRepN'
p3208
I0
sg906
g1017
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3209
I0
sg908
g1024
sg55
g11
sS'block_loop.thisTrial'
p3210
Nsg69
Vn
sS'block_loop.thisTrialN'
p3211
I0
sg39
F0.96683285969083954
sg34
g752
(S'\x07\xdf\n\x10\x0b\t\x08\x03K\xc0'
tRp3212
sa(dp3213
S'trial_loop.thisTrialN'
p3214
I169
sg894
g1536
sS'block_loop.thisIndex'
p3215
g888
sg38
S'left'
p3216
sg58
g62
sS'trial_loop.thisN'
p3217
I169
sg33
g1540
sg63
g64
sS'trial_loop.thisIndex'
p3218
g59
(g98
S'\xa9\x00\x00\x00'
tRp3219
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3220
I0
sg903
g1544
sS'block_loop.thisRepN'
p3221
I0
sg906
g1540
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3222
I0
sg908
g1547
sg55
g11
sS'block_loop.thisTrial'
p3223
Nsg69
Vn
sS'block_loop.thisTrialN'
p3224
I0
sg39
F1.133438325357929
sg34
g752
(S'\x07\xdf\n\x10\x0b\t\x0e\x03$\xb0'
tRp3225
sa(dp3226
S'trial_loop.thisTrialN'
p3227
I170
sg894
g1077
sS'block_loop.thisIndex'
p3228
g888
sg38
S'right'
p3229
sg58
g62
sS'trial_loop.thisN'
p3230
I170
sg33
g970
sg63
g64
sS'trial_loop.thisIndex'
p3231
g59
(g98
S'\xaa\x00\x00\x00'
tRp3232
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3233
I0
sg903
g1084
sS'block_loop.thisRepN'
p3234
I0
sg906
g976
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3235
I0
sg908
g970
sg55
g11
sS'block_loop.thisTrial'
p3236
Nsg69
Vn
sS'block_loop.thisTrialN'
p3237
I0
sg39
F0.98351564388758561
sg34
g752
(S'\x07\xdf\n\x10\x0b\t\x14\x05\xdc\x00'
tRp3238
sa(dp3239
S'trial_loop.thisTrialN'
p3240
I171
sg894
g1265
sS'block_loop.thisIndex'
p3241
g888
sg38
S'right'
p3242
sg58
g62
sS'trial_loop.thisN'
p3243
I171
sg33
g1269
sg63
g64
sS'trial_loop.thisIndex'
p3244
g59
(g98
S'\xab\x00\x00\x00'
tRp3245
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3246
I0
sg903
g1273
sS'block_loop.thisRepN'
p3247
I0
sg906
g1269
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3248
I0
sg908
g1276
sg55
g11
sS'block_loop.thisTrial'
p3249
Nsg69
Vn
sS'block_loop.thisTrialN'
p3250
I0
sg39
F2.8000817090360215
sg34
g752
(S'\x07\xdf\n\x10\x0b\t\x1a\x05\xf3p'
tRp3251
sa(dp3252
S'trial_loop.thisTrialN'
p3253
I172
sg894
g1312
sS'block_loop.thisIndex'
p3254
g888
sg38
S'left'
p3255
sg58
g62
sS'trial_loop.thisN'
p3256
I172
sg33
g1017
sg63
g64
sS'trial_loop.thisIndex'
p3257
g59
(g98
S'\xac\x00\x00\x00'
tRp3258
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3259
I0
sg903
g1319
sS'block_loop.thisRepN'
p3260
I0
sg906
g1017
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3261
I0
sg908
g1024
sg55
g11
sS'block_loop.thisTrial'
p3262
Nsg69
Vn
sS'block_loop.thisTrialN'
p3263
I0
sg39
F0.81722179014104768
sg34
g752
(S'\x07\xdf\n\x10\x0b\t"\x03\x9d\xc8'
tRp3264
sa(dp3265
S'trial_loop.thisTrialN'
p3266
I173
sg894
g2065
sS'block_loop.thisIndex'
p3267
g888
sg38
S'left'
p3268
sg58
g62
sS'trial_loop.thisN'
p3269
I173
sg33
g1387
sg63
g64
sS'trial_loop.thisIndex'
p3270
g59
(g98
S'\xad\x00\x00\x00'
tRp3271
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3272
I0
sg903
g2072
sS'block_loop.thisRepN'
p3273
I0
sg906
g1387
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3274
I0
sg908
g1394
sg55
g11
sS'block_loop.thisTrial'
p3275
Nsg69
Vn
sS'block_loop.thisTrialN'
p3276
I0
sg39
F1.0501390136987538
sg34
g752
(S'\x07\xdf\n\x10\x0b\t(\x01S\xd8'
tRp3277
sa(dp3278
S'trial_loop.thisTrialN'
p3279
I174
sg894
g1581
sS'block_loop.thisIndex'
p3280
g888
sg38
S'right'
p3281
sg58
g62
sS'trial_loop.thisN'
p3282
I174
sg33
g909
sg63
g64
sS'trial_loop.thisIndex'
p3283
g59
(g98
S'\xae\x00\x00\x00'
tRp3284
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3285
I0
sg903
g1588
sS'block_loop.thisRepN'
p3286
I0
sg906
g899
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3287
I0
sg908
g909
sg55
g11
sS'block_loop.thisTrial'
p3288
Nsg69
Vn
sS'block_loop.thisTrialN'
p3289
I0
sg39
F0.75011033285682061
sg34
g752
(S'\x07\xdf\n\x10\x0b\t.\x02]x'
tRp3290
sa(dp3291
S'trial_loop.thisTrialN'
p3292
I175
sg894
g1383
sS'block_loop.thisIndex'
p3293
g888
sg38
S'right'
p3294
sg58
g62
sS'trial_loop.thisN'
p3295
I175
sg33
g1387
sg63
g64
sS'trial_loop.thisIndex'
p3296
g59
(g98
S'\xaf\x00\x00\x00'
tRp3297
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3298
I0
sg903
g1391
sS'block_loop.thisRepN'
p3299
I0
sg906
g1387
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3300
I0
sg908
g1394
sg55
g11
sS'block_loop.thisTrial'
p3301
Nsg69
Vn
sS'block_loop.thisTrialN'
p3302
I0
sg39
F1.0334402640237386
sg34
g752
(S'\x07\xdf\n\x10\x0b\t3\x0ec\x98'
tRp3303
sa(dp3304
S'trial_loop.thisTrialN'
p3305
I176
sg894
g1892
sS'block_loop.thisIndex'
p3306
g888
sg38
S'left'
p3307
sg58
g62
sS'trial_loop.thisN'
p3308
I176
sg33
g1134
sg63
g64
sS'trial_loop.thisIndex'
p3309
g59
(g98
S'\xb0\x00\x00\x00'
tRp3310
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3311
I0
sg903
g1899
sS'block_loop.thisRepN'
p3312
I0
sg906
g1134
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3313
I0
sg908
g1128
sg55
g11
sS'block_loop.thisTrial'
p3314
Nsg69
Vn
sS'block_loop.thisTrialN'
p3315
I0
sg39
F0.86684107050768944
sg34
g752
(S'\x07\xdf\n\x10\x0b\t:\x00*\xf8'
tRp3316
sa(dp3317
S'trial_loop.thisTrialN'
p3318
I177
sg894
g1553
sS'block_loop.thisIndex'
p3319
g888
sg38
S'left'
p3320
sg58
g62
sS'trial_loop.thisN'
p3321
I177
sg33
g926
sg63
g64
sS'trial_loop.thisIndex'
p3322
g59
(g98
S'\xb1\x00\x00\x00'
tRp3323
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3324
I0
sg903
g1560
sS'block_loop.thisRepN'
p3325
I0
sg906
g919
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3326
I0
sg908
g926
sg55
g11
sS'block_loop.thisTrial'
p3327
Nsg69
Vn
sS'block_loop.thisTrialN'
p3328
I0
sg39
F2.1171170451998478
sg34
g752
(S'\x07\xdf\n\x10\x0b\n\x03\r\xda\xe0'
tRp3329
sa(dp3330
S'trial_loop.thisTrialN'
p3331
I178
sg894
g1013
sS'block_loop.thisIndex'
p3332
g888
sg38
S'right'
p3333
sg58
g62
sS'trial_loop.thisN'
p3334
I178
sg33
g1017
sg63
g64
sS'trial_loop.thisIndex'
p3335
g59
(g98
S'\xb2\x00\x00\x00'
tRp3336
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3337
I0
sg903
g1021
sS'block_loop.thisRepN'
p3338
I0
sg906
g1017
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3339
I0
sg908
g1024
sg55
g11
sS'block_loop.thisTrial'
p3340
Nsg69
Vn
sS'block_loop.thisTrialN'
p3341
I0
sg39
F1.2668589746517682
sg34
g752
(S'\x07\xdf\n\x10\x0b\n\x0b\x01\t\xa0'
tRp3342
sa(dp3343
S'trial_loop.thisTrialN'
p3344
I179
sg894
g1124
sS'block_loop.thisIndex'
p3345
g888
sg38
S'right'
p3346
sg58
g62
sS'trial_loop.thisN'
p3347
I179
sg33
g1134
sg63
g64
sS'trial_loop.thisIndex'
p3348
g59
(g98
S'\xb3\x00\x00\x00'
tRp3349
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3350
I0
sg903
g1132
sS'block_loop.thisRepN'
p3351
I0
sg906
g1134
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3352
I0
sg908
g1128
sg55
g11
sS'block_loop.thisTrial'
p3353
Nsg69
Vn
sS'block_loop.thisTrialN'
p3354
I0
sg39
F0.7501682077154328
sg34
g752
(S'\x07\xdf\n\x10\x0b\n\x11\x05j\xb8'
tRp3355
sa(dp3356
S'trial_loop.thisTrialN'
p3357
I180
sg894
g1297
sS'block_loop.thisIndex'
p3358
g888
sg38
S'right'
p3359
sg58
g62
sS'trial_loop.thisN'
p3360
I180
sg33
g1239
sg63
g64
sS'trial_loop.thisIndex'
p3361
g59
(g98
S'\xb4\x00\x00\x00'
tRp3362
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3363
I0
sg903
g1304
sS'block_loop.thisRepN'
p3364
I0
sg906
g1239
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3365
I0
sg908
g1246
sg55
g11
sS'block_loop.thisTrial'
p3366
Nsg69
Vn
sS'block_loop.thisTrialN'
p3367
I0
sg39
F0.98318493041369948
sg34
g752
(S'\x07\xdf\n\x10\x0b\n\x17\x02.\x98'
tRp3368
sa(dp3369
S'trial_loop.thisTrialN'
p3370
I181
sg894
g1972
sS'block_loop.thisIndex'
p3371
g888
sg38
S'right'
p3372
sg58
g62
sS'trial_loop.thisN'
p3373
I181
sg33
g1540
sg63
g64
sS'trial_loop.thisIndex'
p3374
g59
(g98
S'\xb5\x00\x00\x00'
tRp3375
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3376
I0
sg903
g1979
sS'block_loop.thisRepN'
p3377
I0
sg906
g1540
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3378
I0
sg908
g1547
sg55
g11
sS'block_loop.thisTrial'
p3379
Nsg69
Vn
sS'block_loop.thisTrialN'
p3380
I0
sg39
F1.4167950557193763
sg34
g752
(S'\x07\xdf\n\x10\x0b\n\x1d\x02\x80\xa0'
tRp3381
sa(dp3382
S'trial_loop.thisTrialN'
p3383
I182
sg894
g1678
sS'block_loop.thisIndex'
p3384
g888
sg38
S'left'
p3385
sg58
g62
sS'trial_loop.thisN'
p3386
I182
sg33
g1688
sg63
g64
sS'trial_loop.thisIndex'
p3387
g59
(g98
S'\xb6\x00\x00\x00'
tRp3388
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3389
I0
sg903
g1686
sS'block_loop.thisRepN'
p3390
I0
sg906
g1688
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3391
I0
sg908
g1682
sg55
g11
sS'block_loop.thisTrial'
p3392
Nsg69
Vn
sS'block_loop.thisTrialN'
p3393
I0
sg39
F1.0668602861014733
sg34
g752
(S'\x07\xdf\n\x10\x0b\n#\tC\x18'
tRp3394
sa(dp3395
S'trial_loop.thisTrialN'
p3396
I183
sg894
g1611
sS'block_loop.thisIndex'
p3397
g888
sg38
S'left'
p3398
sg58
g62
sS'trial_loop.thisN'
p3399
I183
sg33
g953
sg63
g64
sS'trial_loop.thisIndex'
p3400
g59
(g98
S'\xb7\x00\x00\x00'
tRp3401
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3402
I0
sg903
g1618
sS'block_loop.thisRepN'
p3403
I0
sg906
g953
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3404
I0
sg908
g960
sg55
g11
sS'block_loop.thisTrial'
p3405
Nsg69
Vn
sS'block_loop.thisTrialN'
p3406
I0
sg39
F1.2667703092283773
sg34
g752
(S'\x07\xdf\n\x10\x0b\n)\n\xc9\xb8'
tRp3407
sa(dp3408
S'trial_loop.thisTrialN'
p3409
I184
sg894
g1265
sS'block_loop.thisIndex'
p3410
g888
sg38
S'right'
p3411
sg58
g62
sS'trial_loop.thisN'
p3412
I184
sg33
g1269
sg63
g64
sS'trial_loop.thisIndex'
p3413
g59
(g98
S'\xb8\x00\x00\x00'
tRp3414
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3415
I0
sg903
g1273
sS'block_loop.thisRepN'
p3416
I0
sg906
g1269
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3417
I0
sg908
g1276
sg55
g11
sS'block_loop.thisTrial'
p3418
Nsg69
Vn
sS'block_loop.thisTrialN'
p3419
I0
sg39
F1.1168536148124986
sg34
g752
(S'\x07\xdf\n\x10\x0b\n0\x00#('
tRp3420
sa(dp3421
S'trial_loop.thisTrialN'
p3422
I185
sg894
g1327
sS'block_loop.thisIndex'
p3423
g888
sg38
S'left'
p3424
sg58
g62
sS'trial_loop.thisN'
p3425
I185
sg33
g1331
sg63
g64
sS'trial_loop.thisIndex'
p3426
g59
(g98
S'\xb9\x00\x00\x00'
tRp3427
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3428
I0
sg903
g1335
sS'block_loop.thisRepN'
p3429
I0
sg906
g1331
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3430
I0
sg908
g1338
sg55
g11
sS'block_loop.thisTrial'
p3431
Nsg69
Vn
sS'block_loop.thisTrialN'
p3432
I0
sg39
F1.1501832608810219
sg34
g752
(S'\x07\xdf\n\x10\x0b\n6\x02]x'
tRp3433
sa(dp3434
S'trial_loop.thisTrialN'
p3435
I186
sg894
g2511
sS'block_loop.thisIndex'
p3436
g888
sg38
S'right'
p3437
sg58
g62
sS'trial_loop.thisN'
p3438
I186
sg33
g1222
sg63
g64
sS'trial_loop.thisIndex'
p3439
g59
(g98
S'\xba\x00\x00\x00'
tRp3440
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3441
I0
sg903
g2518
sS'block_loop.thisRepN'
p3442
I0
sg906
g1222
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3443
I0
sg908
g1229
sg55
g11
sS'block_loop.thisTrial'
p3444
Nsg69
Vn
sS'block_loop.thisTrialN'
p3445
I0
sg39
F0.70009106024463108
sg34
g752
(S'\x07\xdf\n\x10\x0b\x0b\x00\x05SH'
tRp3446
sa(dp3447
S'trial_loop.thisTrialN'
p3448
I187
sg894
g1312
sS'block_loop.thisIndex'
p3449
g888
sg38
S'left'
p3450
sg58
g62
sS'trial_loop.thisN'
p3451
I187
sg33
g1017
sg63
g64
sS'trial_loop.thisIndex'
p3452
g59
(g98
S'\xbb\x00\x00\x00'
tRp3453
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3454
I0
sg903
g1319
sS'block_loop.thisRepN'
p3455
I0
sg906
g1017
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3456
I0
sg908
g1024
sg55
g11
sS'block_loop.thisTrial'
p3457
Nsg69
Vn
sS'block_loop.thisTrialN'
p3458
I0
sg39
F0.91716169151914073
sg34
g752
(S'\x07\xdf\n\x10\x0b\x0b\x06\x01!\x10'
tRp3459
sa(dp3460
S'trial_loop.thisTrialN'
p3461
I188
sg894
g1972
sS'block_loop.thisIndex'
p3462
g888
sg38
S'right'
p3463
sg58
g62
sS'trial_loop.thisN'
p3464
I188
sg33
g1540
sg63
g64
sS'trial_loop.thisIndex'
p3465
g59
(g98
S'\xbc\x00\x00\x00'
tRp3466
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3467
I0
sg903
g1979
sS'block_loop.thisRepN'
p3468
I0
sg906
g1540
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3469
I0
sg908
g1547
sg55
g11
sS'block_loop.thisTrial'
p3470
Nsg69
Vn
sS'block_loop.thisTrialN'
p3471
I0
sg39
F1.1167361545094536
sg34
g752
(S'\x07\xdf\n\x10\x0b\x0b\x0c\x00\x80\xe8'
tRp3472
sa(dp3473
S'trial_loop.thisTrialN'
p3474
I189
sg894
g996
sS'block_loop.thisIndex'
p3475
g888
sg38
S'left'
p3476
sg58
g62
sS'trial_loop.thisN'
p3477
I189
sg33
g1006
sg63
g64
sS'trial_loop.thisIndex'
p3478
g59
(g98
S'\xbd\x00\x00\x00'
tRp3479
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3480
I0
sg903
g1004
sS'block_loop.thisRepN'
p3481
I0
sg906
g1006
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3482
I0
sg908
g1000
sg55
g11
sS'block_loop.thisTrial'
p3483
Nsg69
Vn
sS'block_loop.thisTrialN'
p3484
I0
sg39
F0.96686079927803803
sg34
g752
(S'\x07\xdf\n\x10\x0b\x0b\x12\x02\xbf '
tRp3485
sa(dp3486
S'trial_loop.thisTrialN'
p3487
I190
sg894
g932
sS'block_loop.thisIndex'
p3488
g888
sg38
S'left'
p3489
sg58
g62
sS'trial_loop.thisN'
p3490
I190
sg33
g936
sg63
g64
sS'trial_loop.thisIndex'
p3491
g59
(g98
S'\xbe\x00\x00\x00'
tRp3492
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3493
I0
sg903
g940
sS'block_loop.thisRepN'
p3494
I0
sg906
g936
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3495
I0
sg908
g943
sg55
g11
sS'block_loop.thisTrial'
p3496
Nsg69
Vn
sS'block_loop.thisTrialN'
p3497
I0
sg39
F0.96685025065835362
sg34
g752
(S'\x07\xdf\n\x10\x0b\x0b\x18\x02\xd6\x90'
tRp3498
sa(dp3499
S'trial_loop.thisTrialN'
p3500
I191
sg894
g1188
sS'block_loop.thisIndex'
p3501
g888
sg38
S'right'
p3502
sg58
g62
sS'trial_loop.thisN'
p3503
I191
sg33
g1198
sg63
g64
sS'trial_loop.thisIndex'
p3504
g59
(g98
S'\xbf\x00\x00\x00'
tRp3505
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3506
I0
sg903
g1196
sS'block_loop.thisRepN'
p3507
I0
sg906
g1198
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3508
I0
sg908
g1192
sg55
g11
sS'block_loop.thisTrial'
p3509
Nsg69
Vn
sS'block_loop.thisTrialN'
p3510
I0
sg39
F1.6834895289266569
sg34
g752
(S'\x07\xdf\n\x10\x0b\x0b\x1e\x02\xaf\x80'
tRp3511
sa(dp3512
S'trial_loop.thisTrialN'
p3513
I192
sg894
g996
sS'block_loop.thisIndex'
p3514
g888
sg38
S'left'
p3515
sg58
g62
sS'trial_loop.thisN'
p3516
I192
sg33
g1006
sg63
g64
sS'trial_loop.thisIndex'
p3517
g59
(g98
S'\xc0\x00\x00\x00'
tRp3518
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3519
I0
sg903
g1004
sS'block_loop.thisRepN'
p3520
I0
sg906
g1006
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3521
I0
sg908
g1000
sg55
g11
sS'block_loop.thisTrial'
p3522
Nsg69
Vn
sS'block_loop.thisTrialN'
p3523
I0
sg39
F1.3172183689666781
sg34
g752
(S'\x07\xdf\n\x10\x0b\x0b$\r\xbb\xa0'
tRp3524
sa(dp3525
S'trial_loop.thisTrialN'
p3526
I193
sg894
g1678
sS'block_loop.thisIndex'
p3527
g888
sg38
S'left'
p3528
sg58
g62
sS'trial_loop.thisN'
p3529
I193
sg33
g1682
sg63
g64
sS'trial_loop.thisIndex'
p3530
g59
(g98
S'\xc1\x00\x00\x00'
tRp3531
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3532
I0
sg903
g1686
sS'block_loop.thisRepN'
p3533
I0
sg906
g1688
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3534
I0
sg908
g1682
sg55
g11
sS'block_loop.thisTrial'
p3535
Nsg69
Vn
sS'block_loop.thisTrialN'
p3536
I0
sg39
F1.0167406590544488
sg34
g752
(S'\x07\xdf\n\x10\x0b\x0b+\x03\xcc\xa8'
tRp3537
sa(dp3538
S'trial_loop.thisTrialN'
p3539
I194
sg894
g895
sS'block_loop.thisIndex'
p3540
g888
sg38
S'left'
p3541
sg58
g62
sS'trial_loop.thisN'
p3542
I194
sg33
g899
sg63
g64
sS'trial_loop.thisIndex'
p3543
g59
(g98
S'\xc2\x00\x00\x00'
tRp3544
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3545
I0
sg903
g904
sS'block_loop.thisRepN'
p3546
I0
sg906
g899
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3547
I0
sg908
g909
sg55
g11
sS'block_loop.thisTrial'
p3548
Nsg69
Vn
sS'block_loop.thisTrialN'
p3549
I0
sg39
F0.91700944928197714
sg34
g752
(S'\x07\xdf\n\x10\x0b\x0b1\x04\x9b\xb0'
tRp3550
sa(dp3551
S'trial_loop.thisTrialN'
p3552
I195
sg894
g1495
sS'block_loop.thisIndex'
p3553
g888
sg38
S'left'
p3554
sg58
g62
sS'trial_loop.thisN'
p3555
I195
sg33
g1198
sg63
g64
sS'trial_loop.thisIndex'
p3556
g59
(g98
S'\xc3\x00\x00\x00'
tRp3557
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3558
I0
sg903
g1502
sS'block_loop.thisRepN'
p3559
I0
sg906
g1198
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3560
I0
sg908
g1192
sg55
g11
sS'block_loop.thisTrial'
p3561
Nsg69
Vn
sS'block_loop.thisTrialN'
p3562
I0
sg39
F1.1001842302130171
sg34
g752
(S'\x07\xdf\n\x10\x0b\x0b7\x03\xbd\x08'
tRp3563
sa(dp3564
S'trial_loop.thisTrialN'
p3565
I196
sg894
g1877
sS'block_loop.thisIndex'
p3566
g888
sg38
S'right'
p3567
sg58
g62
sS'trial_loop.thisN'
p3568
I196
sg33
g1688
sg63
g64
sS'trial_loop.thisIndex'
p3569
g59
(g98
S'\xc4\x00\x00\x00'
tRp3570
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3571
I0
sg903
g1884
sS'block_loop.thisRepN'
p3572
I0
sg906
g1688
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3573
I0
sg908
g1682
sg55
g11
sS'block_loop.thisTrial'
p3574
Nsg69
Vn
sS'block_loop.thisTrialN'
p3575
I0
sg39
F1.1335267056838347
sg34
g752
(S'\x07\xdf\n\x10\x0b\x0c\x01\x05\xbc\xc0'
tRp3576
sa(dp3577
S'trial_loop.thisTrialN'
p3578
I197
sg894
g1972
sS'block_loop.thisIndex'
p3579
g888
sg38
S'right'
p3580
sg58
g62
sS'trial_loop.thisN'
p3581
I197
sg33
g1540
sg63
g64
sS'trial_loop.thisIndex'
p3582
g59
(g98
S'\xc5\x00\x00\x00'
tRp3583
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3584
I0
sg903
g1979
sS'block_loop.thisRepN'
p3585
I0
sg906
g1540
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3586
I0
sg908
g1547
sg55
g11
sS'block_loop.thisTrial'
p3587
Nsg69
Vn
sS'block_loop.thisTrialN'
p3588
I0
sg39
F1.1505322206148776
sg34
g752
(S'\x07\xdf\n\x10\x0b\x0c\x07\x085\x90'
tRp3589
sa(dp3590
S'trial_loop.thisTrialN'
p3591
I198
sg894
g1092
sS'block_loop.thisIndex'
p3592
g888
sg38
S'right'
p3593
sg58
g62
sS'trial_loop.thisN'
p3594
I198
sg33
g1096
sg63
g64
sS'trial_loop.thisIndex'
p3595
g59
(g98
S'\xc6\x00\x00\x00'
tRp3596
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3597
I0
sg903
g1100
sS'block_loop.thisRepN'
p3598
I0
sg906
g1096
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3599
I0
sg908
g1103
sg55
g11
sS'block_loop.thisTrial'
p3600
Nsg69
Vn
sS'block_loop.thisTrialN'
p3601
I0
sg39
F1.1167324482375989
sg34
g752
(S"\x07\xdf\n\x10\x0b\x0c\r\x0b'x"
tRp3602
sa(dp3603
S'trial_loop.thisTrialN'
p3604
I199
sg894
g895
sS'block_loop.thisIndex'
p3605
g888
sg38
S'left'
p3606
sg58
g62
sS'trial_loop.thisN'
p3607
I199
sg33
g899
sg63
g64
sS'trial_loop.thisIndex'
p3608
g59
(g98
S'\xc7\x00\x00\x00'
tRp3609
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3610
I0
sg903
g904
sS'block_loop.thisRepN'
p3611
I0
sg906
g899
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3612
I0
sg908
g909
sg55
g11
sS'block_loop.thisTrial'
p3613
Nsg69
Vn
sS'block_loop.thisTrialN'
p3614
I0
sg39
F0.85010041145324067
sg34
g752
(S'\x07\xdf\n\x10\x0b\x0c\x13\re\xb0'
tRp3615
sa(dp3616
S'block_loop.thisRepN'
p3617
I0
sg55
g11
sg41
F26.3832977721313
sg56
Vr
sS'block_loop.thisIndex'
p3618
g888
sg57
Vy
sg58
g62
sS'block_loop.thisN'
p3619
I0
sg40
S'space'
p3620
sg63
g64
sS'block_loop.thisTrial'
p3621
Nsg65
g66
sg67
g68
sS'block_loop.thisTrialN'
p3622
I0
sg69
Vn
sa(dp3623
S'block_loop.thisRepN'
p3624
I1
sg56
Vr
sS'block_loop.thisIndex'
p3625
g59
(g98
S'\x00\x00\x00\x00'
tRp3626
sg57
Vy
sg58
g62
sS'block_loop.thisN'
p3627
I1
sg37
Nsg55
g11
sg63
g64
sS'block_loop.thisTrial'
p3628
Nsg65
g66
sg67
g68
sS'block_loop.thisTrialN'
p3629
I0
sg69
Vn
sa(dp3630
S'trial_loop.thisTrialN'
p3631
I0
sS'img_left'
p3632
S'7-olives.png'
p3633
sS'block_loop.thisIndex'
p3634
g3626
sg38
S'left'
p3635
sg58
g62
sS'trial_loop.thisN'
p3636
I0
sg33
S'7-olives.png'
p3637
sg63
g64
sS'trial_loop.thisIndex'
p3638
g59
(g98
S'\x00\x00\x00\x00'
tRp3639
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3640
I0
sS'img_right'
p3641
S'22-daim.png'
p3642
sS'block_loop.thisRepN'
p3643
I1
sS'img_correct'
p3644
g3637
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3645
I1
sS'img_wrong'
p3646
S'22-daim.png'
p3647
sg55
g11
sS'block_loop.thisTrial'
p3648
Nsg69
Vn
sS'block_loop.thisTrialN'
p3649
I0
sg39
F0.85018337491965212
sg34
g752
(S'\x07\xdf\n\x10\x0b\x0c9\x02\xb3h'
tRp3650
sa(dp3651
S'trial_loop.thisTrialN'
p3652
I1
sg3632
S'51-mars.png'
p3653
sS'block_loop.thisIndex'
p3654
g3626
sg38
S'right'
p3655
sg58
g62
sS'trial_loop.thisN'
p3656
I1
sg33
S'27-hartleys_raspberries_jelly.png'
p3657
sg63
g64
sS'trial_loop.thisIndex'
p3658
g59
(g98
S'\x01\x00\x00\x00'
tRp3659
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3660
I0
sg3641
S'27-hartleys_raspberries_jelly.png'
p3661
sS'block_loop.thisRepN'
p3662
I1
sg3644
S'51-mars.png'
p3663
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3664
I1
sg3646
g3657
sg55
g11
sS'block_loop.thisTrial'
p3665
Nsg69
Vn
sS'block_loop.thisTrialN'
p3666
I0
sg39
F0.93344875993898313
sg34
g752
(S'\x07\xdf\n\x10\x0b\r\x03\x00\xe6x'
tRp3667
sa(dp3668
S'trial_loop.thisTrialN'
p3669
I2
sg3632
S'19-caramello_redo.png'
p3670
sS'block_loop.thisIndex'
p3671
g3626
sg38
S'left'
p3672
sg58
g62
sS'trial_loop.thisN'
p3673
I2
sg33
S'19-caramello_redo.png'
p3674
sg63
g64
sS'trial_loop.thisIndex'
p3675
g59
(g98
S'\x02\x00\x00\x00'
tRp3676
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3677
I0
sg3641
S'30-spaghetti_hoops.png'
p3678
sS'block_loop.thisRepN'
p3679
I1
sg3644
g3674
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3680
I1
sg3646
S'30-spaghetti_hoops.png'
p3681
sg55
g11
sS'block_loop.thisTrial'
p3682
Nsg69
Vn
sS'block_loop.thisTrialN'
p3683
I0
sg39
F1.4834771556816122
sg34
g752
(S'\x07\xdf\n\x10\x0b\r\t\x00\x80\xe8'
tRp3684
sa(dp3685
S'trial_loop.thisTrialN'
p3686
I3
sg3632
S'44-crunch.png'
p3687
sS'block_loop.thisIndex'
p3688
g3626
sg38
S'left'
p3689
sg58
g62
sS'trial_loop.thisN'
p3690
I3
sg33
S'44-crunch.png'
p3691
sg63
g64
sS'trial_loop.thisIndex'
p3692
g59
(g98
S'\x03\x00\x00\x00'
tRp3693
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3694
I0
sg3641
S'26-walkers_smoky_bacon.png'
p3695
sS'block_loop.thisRepN'
p3696
I1
sg3644
g3691
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3697
I1
sg3646
S'26-walkers_smoky_bacon.png'
p3698
sg55
g11
sS'block_loop.thisTrial'
p3699
Nsg69
Vn
sS'block_loop.thisTrialN'
p3700
I0
sg39
F0.6667731031875519
sg34
g752
(S'\x07\xdf\n\x10\x0b\r\x0f\x089x'
tRp3701
sa(dp3702
S'trial_loop.thisTrialN'
p3703
I4
sg3632
S'17-jacobs_mini_cheddars_redo.png'
p3704
sS'block_loop.thisIndex'
p3705
g3626
sg38
S'left'
p3706
sg58
g62
sS'trial_loop.thisN'
p3707
I4
sg33
S'8-liquorice_catherine_wheels.png'
p3708
sg63
g64
sS'trial_loop.thisIndex'
p3709
g59
(g98
S'\x04\x00\x00\x00'
tRp3710
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3711
I0
sg3641
S'8-liquorice_catherine_wheels.png'
p3712
sS'block_loop.thisRepN'
p3713
I1
sg3644
S'17-jacobs_mini_cheddars_redo.png'
p3714
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3715
I1
sg3646
g3708
sg55
g11
sS'block_loop.thisTrial'
p3716
Nsg69
Vn
sS'block_loop.thisTrialN'
p3717
I0
sg39
F0.96724226016431203
sg34
g752
(S'\x07\xdf\n\x10\x0b\r\x15\x03\xc8\xc0'
tRp3718
sa(dp3719
S'trial_loop.thisTrialN'
p3720
I5
sg3632
S'40-sardines.png'
p3721
sS'block_loop.thisIndex'
p3722
g3626
sg38
S'left'
p3723
sg58
g62
sS'trial_loop.thisN'
p3724
I5
sg33
S'40-sardines.png'
p3725
sg63
g64
sS'trial_loop.thisIndex'
p3726
g59
(g98
S'\x05\x00\x00\x00'
tRp3727
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3728
I0
sg3641
S'5-pineapple.png'
p3729
sS'block_loop.thisRepN'
p3730
I1
sg3644
g3725
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3731
I1
sg3646
S'5-pineapple.png'
p3732
sg55
g11
sS'block_loop.thisTrial'
p3733
Nsg69
Vn
sS'block_loop.thisTrialN'
p3734
I0
sg39
F0.71685737810366845
sg34
g752
(S'\x07\xdf\n\x10\x0b\r\x1b\x03\xa5\x98'
tRp3735
sa(dp3736
S'trial_loop.thisTrialN'
p3737
I6
sg3632
g3704
sS'block_loop.thisIndex'
p3738
g3626
sg38
S'left'
p3739
sg58
g62
sS'trial_loop.thisN'
p3740
I6
sg33
g3714
sg63
g64
sS'trial_loop.thisIndex'
p3741
g59
(g98
S'\x06\x00\x00\x00'
tRp3742
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3743
I0
sg3641
g3712
sS'block_loop.thisRepN'
p3744
I1
sg3644
g3714
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3745
I1
sg3646
g3708
sg55
g11
sS'block_loop.thisTrial'
p3746
Nsg69
Vn
sS'block_loop.thisTrialN'
p3747
I0
sg39
F0.75020070886785106
sg34
g752
(S'\x07\xdf\n\x10\x0b\r \x0f.\xb8'
tRp3748
sa(dp3749
S'trial_loop.thisTrialN'
p3750
I7
sg3632
S'46-pistachios.png'
p3751
sS'block_loop.thisIndex'
p3752
g3626
sg38
S'right'
p3753
sg58
g62
sS'trial_loop.thisN'
p3754
I7
sg33
S'46-pistachios.png'
p3755
sg63
g64
sS'trial_loop.thisIndex'
p3756
g59
(g98
S'\x07\x00\x00\x00'
tRp3757
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3758
I0
sg3641
S'29-beans.png'
p3759
sS'block_loop.thisRepN'
p3760
I1
sg3644
S'29-beans.png'
p3761
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3762
I1
sg3646
g3755
sg55
g11
sS'block_loop.thisTrial'
p3763
Nsg69
Vn
sS'block_loop.thisTrialN'
p3764
I0
sg39
F1.0834036574624406
sg34
g752
(S'\x07\xdf\n\x10\x0b\r&\x0b\xf2\x98'
tRp3765
sa(dp3766
S'trial_loop.thisTrialN'
p3767
I8
sg3632
S'16-skips_prawn.png'
p3768
sS'block_loop.thisIndex'
p3769
g3626
sg38
S'left'
p3770
sg58
g62
sS'trial_loop.thisN'
p3771
I8
sg33
S'16-skips_prawn.png'
p3772
sg63
g64
sS'trial_loop.thisIndex'
p3773
g59
(g98
S'\x08\x00\x00\x00'
tRp3774
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3775
I0
sg3641
S'42-mrkipling_lemon_slices.png'
p3776
sS'block_loop.thisRepN'
p3777
I1
sg3644
g3772
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3778
I1
sg3646
S'42-mrkipling_lemon_slices.png'
p3779
sg55
g11
sS'block_loop.thisTrial'
p3780
Nsg69
Vn
sS'block_loop.thisTrialN'
p3781
I0
sg39
F1.0499431514945172
sg34
g752
(S'\x07\xdf\n\x10\x0b\r,\r\xb3\xd0'
tRp3782
sa(dp3783
S'trial_loop.thisTrialN'
p3784
I9
sg3632
g3704
sS'block_loop.thisIndex'
p3785
g3626
sg38
S'left'
p3786
sg58
g62
sS'trial_loop.thisN'
p3787
I9
sg33
g3714
sg63
g64
sS'trial_loop.thisIndex'
p3788
g59
(g98
S'\t\x00\x00\x00'
tRp3789
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3790
I0
sg3641
g3712
sS'block_loop.thisRepN'
p3791
I1
sg3644
g3714
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3792
I1
sg3646
g3708
sg55
g11
sS'block_loop.thisTrial'
p3793
Nsg69
Vn
sS'block_loop.thisTrialN'
p3794
I0
sg39
F1.0835484871568042
sg34
g752
(S'\x07\xdf\n\x10\x0b\r2\x0e\xfb\xf0'
tRp3795
sa(dp3796
S'trial_loop.thisTrialN'
p3797
I10
sg3632
S'48-twix.png'
p3798
sS'block_loop.thisIndex'
p3799
g3626
sg38
S'right'
p3800
sg58
g62
sS'trial_loop.thisN'
p3801
I10
sg33
S'48-twix.png'
p3802
sg63
g64
sS'trial_loop.thisIndex'
p3803
g59
(g98
S'\n\x00\x00\x00'
tRp3804
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3805
I0
sg3641
S'50-polo.png'
p3806
sS'block_loop.thisRepN'
p3807
I1
sg3644
g3802
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3808
I1
sg3646
S'50-polo.png'
p3809
sg55
g11
sS'block_loop.thisTrial'
p3810
Nsg69
Vn
sS'block_loop.thisTrialN'
p3811
I0
sg39
F0.78360219958631205
sg34
g752
(S'\x07\xdf\n\x10\x0b\r9\x01z\xe8'
tRp3812
sa(dp3813
S'trial_loop.thisTrialN'
p3814
I11
sg3632
S'31-hobnobs.png'
p3815
sS'block_loop.thisIndex'
p3816
g3626
sg38
S'right'
p3817
sg58
g62
sS'trial_loop.thisN'
p3818
I11
sg33
S'25-kitkat.png'
p3819
sg63
g64
sS'trial_loop.thisIndex'
p3820
g59
(g98
S'\x0b\x00\x00\x00'
tRp3821
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3822
I0
sg3641
S'25-kitkat.png'
p3823
sS'block_loop.thisRepN'
p3824
I1
sg3644
g3819
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3825
I1
sg3646
S'31-hobnobs.png'
p3826
sg55
g11
sS'block_loop.thisTrial'
p3827
Nsg69
Vn
sS'block_loop.thisTrialN'
p3828
I0
sg39
F1.3499359100096626
sg34
g752
(S'\x07\xdf\n\x10\x0b\x0e\x02\r\xfa '
tRp3829
sa(dp3830
S'trial_loop.thisTrialN'
p3831
I12
sg3632
S'35-raisins.png'
p3832
sS'block_loop.thisIndex'
p3833
g3626
sg38
S'right'
p3834
sg58
g62
sS'trial_loop.thisN'
p3835
I12
sg33
S'49-yorkie.png'
p3836
sg63
g64
sS'trial_loop.thisIndex'
p3837
g59
(g98
S'\x0c\x00\x00\x00'
tRp3838
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3839
I0
sg3641
S'49-yorkie.png'
p3840
sS'block_loop.thisRepN'
p3841
I1
sg3644
g3836
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3842
I1
sg3646
S'35-raisins.png'
p3843
sg55
g11
sS'block_loop.thisTrial'
p3844
Nsg69
Vn
sS'block_loop.thisTrialN'
p3845
I0
sg39
F0.71686051417964336
sg34
g752
(S'\x07\xdf\n\x10\x0b\x0e\t\x04\x84@'
tRp3846
sa(dp3847
S'trial_loop.thisTrialN'
p3848
I13
sg3632
S'42-mrkipling_lemon_slices.png'
p3849
sS'block_loop.thisIndex'
p3850
g3626
sg38
S'right'
p3851
sg58
g62
sS'trial_loop.thisN'
p3852
I13
sg33
g3772
sg63
g64
sS'trial_loop.thisIndex'
p3853
g59
(g98
S'\r\x00\x00\x00'
tRp3854
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3855
I0
sg3641
S'16-skips_prawn.png'
p3856
sS'block_loop.thisRepN'
p3857
I1
sg3644
g3772
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3858
I1
sg3646
g3779
sg55
g11
sS'block_loop.thisTrial'
p3859
Nsg69
Vn
sS'block_loop.thisTrialN'
p3860
I0
sg39
F0.95007680535309191
sg34
g752
(S'\x07\xdf\n\x10\x0b\x0e\x0f\x00\x90\x88'
tRp3861
sa(dp3862
S'trial_loop.thisTrialN'
p3863
I14
sg3632
S'5-pineapple.png'
p3864
sS'block_loop.thisIndex'
p3865
g3626
sg38
S'right'
p3866
sg58
g62
sS'trial_loop.thisN'
p3867
I14
sg33
g3732
sg63
g64
sS'trial_loop.thisIndex'
p3868
g59
(g98
S'\x0e\x00\x00\x00'
tRp3869
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3870
I0
sg3641
S'40-sardines.png'
p3871
sS'block_loop.thisRepN'
p3872
I1
sg3644
g3725
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3873
I1
sg3646
g3732
sg55
g11
sS'block_loop.thisTrial'
p3874
Nsg69
Vn
sS'block_loop.thisTrialN'
p3875
I0
sg39
F1.2668333158471796
sg34
g752
(S'\x07\xdf\n\x10\x0b\x0e\x15\x00ix'
tRp3876
sa(dp3877
S'trial_loop.thisTrialN'
p3878
I15
sg3632
g3653
sS'block_loop.thisIndex'
p3879
g3626
sg38
S'right'
p3880
sg58
g62
sS'trial_loop.thisN'
p3881
I15
sg33
g3663
sg63
g64
sS'trial_loop.thisIndex'
p3882
g59
(g98
S'\x0f\x00\x00\x00'
tRp3883
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3884
I0
sg3641
g3661
sS'block_loop.thisRepN'
p3885
I1
sg3644
g3663
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3886
I1
sg3646
g3657
sg55
g11
sS'block_loop.thisTrial'
p3887
Nsg69
Vn
sS'block_loop.thisTrialN'
p3888
I0
sg39
F2.0668822386342072
sg34
g752
(S'\x07\xdf\n\x10\x0b\x0e\x1b\x05\t\x10'
tRp3889
sa(dp3890
S'trial_loop.thisTrialN'
p3891
I16
sg3632
S'30-spaghetti_hoops.png'
p3892
sS'block_loop.thisIndex'
p3893
g3626
sg38
S'right'
p3894
sg58
g62
sS'trial_loop.thisN'
p3895
I16
sg33
g3674
sg63
g64
sS'trial_loop.thisIndex'
p3896
g59
(g98
S'\x10\x00\x00\x00'
tRp3897
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3898
I0
sg3641
S'19-caramello_redo.png'
p3899
sS'block_loop.thisRepN'
p3900
I1
sg3644
g3674
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3901
I1
sg3646
g3681
sg55
g11
sS'block_loop.thisTrial'
p3902
Nsg69
Vn
sS'block_loop.thisTrialN'
p3903
I0
sg39
F0.98343467610538937
sg34
g752
(S'\x07\xdf\n\x10\x0b\x0e"\x06\x87\xe0'
tRp3904
sa(dp3905
S'trial_loop.thisTrialN'
p3906
I17
sg3632
g3768
sS'block_loop.thisIndex'
p3907
g3626
sg38
S'left'
p3908
sg58
g62
sS'trial_loop.thisN'
p3909
I17
sg33
g3772
sg63
g64
sS'trial_loop.thisIndex'
p3910
g59
(g98
S'\x11\x00\x00\x00'
tRp3911
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3912
I0
sg3641
g3776
sS'block_loop.thisRepN'
p3913
I1
sg3644
g3772
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3914
I1
sg3646
g3779
sg55
g11
sS'block_loop.thisTrial'
p3915
Nsg69
Vn
sS'block_loop.thisTrialN'
p3916
I0
sg39
F1.6500298782520986
sg34
g752
(S'\x07\xdf\n\x10\x0b\x0e(\x06\xd9\xe8'
tRp3917
sa(dp3918
S'trial_loop.thisTrialN'
p3919
I18
sg3632
g3721
sS'block_loop.thisIndex'
p3920
g3626
sg38
S'left'
p3921
sg58
g62
sS'trial_loop.thisN'
p3922
I18
sg33
g3725
sg63
g64
sS'trial_loop.thisIndex'
p3923
g59
(g98
S'\x12\x00\x00\x00'
tRp3924
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3925
I0
sg3641
g3729
sS'block_loop.thisRepN'
p3926
I1
sg3644
g3725
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3927
I1
sg3646
g3732
sg55
g11
sS'block_loop.thisTrial'
p3928
Nsg69
Vn
sS'block_loop.thisTrialN'
p3929
I0
sg39
F0.98354957052924874
sg34
g752
(S'\x07\xdf\n\x10\x0b\x0e/\x01\xec0'
tRp3930
sa(dp3931
S'trial_loop.thisTrialN'
p3932
I19
sg3632
S'50-polo.png'
p3933
sS'block_loop.thisIndex'
p3934
g3626
sg38
S'right'
p3935
sg58
g62
sS'trial_loop.thisN'
p3936
I19
sg33
g3802
sg63
g64
sS'trial_loop.thisIndex'
p3937
g59
(g98
S'\x13\x00\x00\x00'
tRp3938
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3939
I0
sg3641
S'48-twix.png'
p3940
sS'block_loop.thisRepN'
p3941
I1
sg3644
g3802
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3942
I1
sg3646
g3809
sg55
g11
sS'block_loop.thisTrial'
p3943
Nsg69
Vn
sS'block_loop.thisTrialN'
p3944
I0
sg39
F1.1002141654844309
sg34
g752
(S'\x07\xdf\n\x10\x0b\x0e5\x02B '
tRp3945
sa(dp3946
S'trial_loop.thisTrialN'
p3947
I20
sg3632
g3633
sS'block_loop.thisIndex'
p3948
g3626
sg38
S'left'
p3949
sg58
g62
sS'trial_loop.thisN'
p3950
I20
sg33
g3637
sg63
g64
sS'trial_loop.thisIndex'
p3951
g59
(g98
S'\x14\x00\x00\x00'
tRp3952
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3953
I0
sg3641
g3642
sS'block_loop.thisRepN'
p3954
I1
sg3644
g3637
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3955
I1
sg3646
g3647
sg55
g11
sS'block_loop.thisTrial'
p3956
Nsg69
Vn
sS'block_loop.thisTrialN'
p3957
I0
sg39
F0.8672057106232387
sg34
g752
(S'\x07\xdf\n\x10\x0b\x0e;\x04A\xd8'
tRp3958
sa(dp3959
S'trial_loop.thisTrialN'
p3960
I21
sg3632
g3751
sS'block_loop.thisIndex'
p3961
g3626
sg38
S'right'
p3962
sg58
g62
sS'trial_loop.thisN'
p3963
I21
sg33
g3761
sg63
g64
sS'trial_loop.thisIndex'
p3964
g59
(g98
S'\x15\x00\x00\x00'
tRp3965
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3966
I0
sg3641
g3759
sS'block_loop.thisRepN'
p3967
I1
sg3644
g3761
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3968
I1
sg3646
g3755
sg55
g11
sS'block_loop.thisTrial'
p3969
Nsg69
Vn
sS'block_loop.thisTrialN'
p3970
I0
sg39
F0.83350714797234104
sg34
g752
(S'\x07\xdf\n\x10\x0b\x0f\x05\x02\xaf\x80'
tRp3971
sa(dp3972
S'trial_loop.thisTrialN'
p3973
I22
sg3632
S'10-bounty_redo.png'
p3974
sS'block_loop.thisIndex'
p3975
g3626
sg38
S'right'
p3976
sg58
g62
sS'trial_loop.thisN'
p3977
I22
sg33
S'10-bounty_redo.png'
p3978
sg63
g64
sS'trial_loop.thisIndex'
p3979
g59
(g98
S'\x16\x00\x00\x00'
tRp3980
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3981
I0
sg3641
S'4-corn.png'
p3982
sS'block_loop.thisRepN'
p3983
I1
sg3644
S'4-corn.png'
p3984
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p3985
I1
sg3646
g3978
sg55
g11
sS'block_loop.thisTrial'
p3986
Nsg69
Vn
sS'block_loop.thisTrialN'
p3987
I0
sg39
F1.1167019427703053
sg34
g752
(S'\x07\xdf\n\x10\x0b\x0f\x0b\x00\xa0('
tRp3988
sa(dp3989
S'trial_loop.thisTrialN'
p3990
I23
sg3632
S'25-kitkat.png'
p3991
sS'block_loop.thisIndex'
p3992
g3626
sg38
S'left'
p3993
sg58
g62
sS'trial_loop.thisN'
p3994
I23
sg33
g3819
sg63
g64
sS'trial_loop.thisIndex'
p3995
g59
(g98
S'\x17\x00\x00\x00'
tRp3996
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p3997
I0
sg3641
S'31-hobnobs.png'
p3998
sS'block_loop.thisRepN'
p3999
I1
sg3644
g3819
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4000
I1
sg3646
g3826
sg55
g11
sS'block_loop.thisTrial'
p4001
Nsg69
Vn
sS'block_loop.thisTrialN'
p4002
I0
sg39
F3.5333276503833986
sg34
g752
(S'\x07\xdf\n\x10\x0b\x0f\x11\x02\xde`'
tRp4003
sa(dp4004
S'trial_loop.thisTrialN'
p4005
I24
sg3632
S'22-daim.png'
p4006
sS'block_loop.thisIndex'
p4007
g3626
sg38
S'right'
p4008
sg58
g62
sS'trial_loop.thisN'
p4009
I24
sg33
g3647
sg63
g64
sS'trial_loop.thisIndex'
p4010
g59
(g98
S'\x18\x00\x00\x00'
tRp4011
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4012
I0
sg3641
S'7-olives.png'
p4013
sS'block_loop.thisRepN'
p4014
I1
sg3644
g3637
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4015
I1
sg3646
g3647
sg55
g11
sS'block_loop.thisTrial'
p4016
Nsg69
Vn
sS'block_loop.thisTrialN'
p4017
I0
sg39
F0.86680657367196545
sg34
g752
(S'\x07\xdf\n\x10\x0b\x0f\x19\x0by\x80'
tRp4018
sa(dp4019
S'trial_loop.thisTrialN'
p4020
I25
sg3632
S'1-treacle_cookies.png'
p4021
sS'block_loop.thisIndex'
p4022
g3626
sg38
S'right'
p4023
sg58
g62
sS'trial_loop.thisN'
p4024
I25
sg33
S'21-nakd_banana_crunch.png'
p4025
sg63
g64
sS'trial_loop.thisIndex'
p4026
g59
(g98
S'\x19\x00\x00\x00'
tRp4027
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4028
I0
sg3641
S'21-nakd_banana_crunch.png'
p4029
sS'block_loop.thisRepN'
p4030
I1
sg3644
g4025
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4031
I1
sg3646
S'1-treacle_cookies.png'
p4032
sg55
g11
sS'block_loop.thisTrial'
p4033
Nsg69
Vn
sS'block_loop.thisTrialN'
p4034
I0
sg39
F0.70020509937421593
sg34
g752
(S'\x07\xdf\n\x10\x0b\x0f\x1f\n!\xc0'
tRp4035
sa(dp4036
S'trial_loop.thisTrialN'
p4037
I26
sg3632
S'26-walkers_smoky_bacon.png'
p4038
sS'block_loop.thisIndex'
p4039
g3626
sg38
S'right'
p4040
sg58
g62
sS'trial_loop.thisN'
p4041
I26
sg33
g3691
sg63
g64
sS'trial_loop.thisIndex'
p4042
g59
(g98
S'\x1a\x00\x00\x00'
tRp4043
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4044
I0
sg3641
S'44-crunch.png'
p4045
sS'block_loop.thisRepN'
p4046
I1
sg3644
g3691
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4047
I1
sg3646
g3698
sg55
g11
sS'block_loop.thisTrial'
p4048
Nsg69
Vn
sS'block_loop.thisTrialN'
p4049
I0
sg39
F0.88353411822663475
sg34
g752
(S'\x07\xdf\n\x10\x0b\x0f%\x05\xf3p'
tRp4050
sa(dp4051
S'trial_loop.thisTrialN'
p4052
I27
sg3632
g3864
sS'block_loop.thisIndex'
p4053
g3626
sg38
S'right'
p4054
sg58
g62
sS'trial_loop.thisN'
p4055
I27
sg33
g3732
sg63
g64
sS'trial_loop.thisIndex'
p4056
g59
(g98
S'\x1b\x00\x00\x00'
tRp4057
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4058
I0
sg3641
g3871
sS'block_loop.thisRepN'
p4059
I1
sg3644
g3725
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4060
I1
sg3646
g3732
sg55
g11
sS'block_loop.thisTrial'
p4061
Nsg69
Vn
sS'block_loop.thisTrialN'
p4062
I0
sg39
F0.76679967430391116
sg34
g752
(S'\x07\xdf\n\x10\x0b\x0f+\x04\x9b\xb0'
tRp4063
sa(dp4064
S'trial_loop.thisTrialN'
p4065
I28
sg3632
g4038
sS'block_loop.thisIndex'
p4066
g3626
sg38
S'right'
p4067
sg58
g62
sS'trial_loop.thisN'
p4068
I28
sg33
g3691
sg63
g64
sS'trial_loop.thisIndex'
p4069
g59
(g98
S'\x1c\x00\x00\x00'
tRp4070
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4071
I0
sg3641
g4045
sS'block_loop.thisRepN'
p4072
I1
sg3644
g3691
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4073
I1
sg3646
g3698
sg55
g11
sS'block_loop.thisTrial'
p4074
Nsg69
Vn
sS'block_loop.thisTrialN'
p4075
I0
sg39
F0.68354255712256418
sg34
g752
(S'\x07\xdf\n\x10\x0b\x0f1\x01\x9a('
tRp4076
sa(dp4077
S'trial_loop.thisTrialN'
p4078
I29
sg3632
S'43-mrporky_pork_crackles_redo.png'
p4079
sS'block_loop.thisIndex'
p4080
g3626
sg38
S'right'
p4081
sg58
g62
sS'trial_loop.thisN'
p4082
I29
sg33
S'18-mms.png'
p4083
sg63
g64
sS'trial_loop.thisIndex'
p4084
g59
(g98
S'\x1d\x00\x00\x00'
tRp4085
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4086
I0
sg3641
S'18-mms.png'
p4087
sS'block_loop.thisRepN'
p4088
I1
sg3644
g4083
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4089
I1
sg3646
S'43-mrporky_pork_crackles_redo.png'
p4090
sg55
g11
sS'block_loop.thisTrial'
p4091
Nsg69
Vn
sS'block_loop.thisTrialN'
p4092
I0
sg39
F0.73353987720292935
sg34
g752
(S'\x07\xdf\n\x10\x0b\x0f6\x0c\xaa0'
tRp4093
sa(dp4094
S'trial_loop.thisTrialN'
p4095
I30
sg3632
S'49-yorkie.png'
p4096
sS'block_loop.thisIndex'
p4097
g3626
sg38
S'left'
p4098
sg58
g62
sS'trial_loop.thisN'
p4099
I30
sg33
g3836
sg63
g64
sS'trial_loop.thisIndex'
p4100
g59
(g98
S'\x1e\x00\x00\x00'
tRp4101
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4102
I0
sg3641
S'35-raisins.png'
p4103
sS'block_loop.thisRepN'
p4104
I1
sg3644
g3836
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4105
I1
sg3646
g3843
sg55
g11
sS'block_loop.thisTrial'
p4106
Nsg69
Vn
sS'block_loop.thisTrialN'
p4107
I0
sg39
F1.5834544048748285
sg34
g752
(S'\x07\xdf\n\x10\x0b\x10\x00\x08\xf4\xf8'
tRp4108
sa(dp4109
S'trial_loop.thisTrialN'
p4110
I31
sg3632
g3633
sS'block_loop.thisIndex'
p4111
g3626
sg38
S'left'
p4112
sg58
g62
sS'trial_loop.thisN'
p4113
I31
sg33
g3637
sg63
g64
sS'trial_loop.thisIndex'
p4114
g59
(g98
S'\x1f\x00\x00\x00'
tRp4115
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4116
I0
sg3641
g3642
sS'block_loop.thisRepN'
p4117
I1
sg3644
g3637
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4118
I1
sg3646
g3647
sg55
g11
sS'block_loop.thisTrial'
p4119
Nsg69
Vn
sS'block_loop.thisTrialN'
p4120
I0
sg39
F0.88328237684891064
sg34
g752
(S'\x07\xdf\n\x10\x0b\x10\x07\x03\x11('
tRp4121
sa(dp4122
S'trial_loop.thisTrialN'
p4123
I32
sg3632
S'41-peanuts_redo.png'
p4124
sS'block_loop.thisIndex'
p4125
g3626
sg38
S'left'
p4126
sg58
g62
sS'trial_loop.thisN'
p4127
I32
sg33
S'41-peanuts_redo.png'
p4128
sg63
g64
sS'trial_loop.thisIndex'
p4129
g59
(g98
S' \x00\x00\x00'
tRp4130
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4131
I0
sg3641
S'45-chewy_nougat_redo.png'
p4132
sS'block_loop.thisRepN'
p4133
I1
sg3644
g4128
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4134
I1
sg3646
S'45-chewy_nougat_redo.png'
p4135
sg55
g11
sS'block_loop.thisTrial'
p4136
Nsg69
Vn
sS'block_loop.thisTrialN'
p4137
I0
sg39
F0.91686889605534816
sg34
g752
(S'\x07\xdf\n\x10\x0b\x10\r\x01\xf7\xe8'
tRp4138
sa(dp4139
S'trial_loop.thisTrialN'
p4140
I33
sg3632
S'4-corn.png'
p4141
sS'block_loop.thisIndex'
p4142
g3626
sg38
S'left'
p4143
sg58
g62
sS'trial_loop.thisN'
p4144
I33
sg33
g3984
sg63
g64
sS'trial_loop.thisIndex'
p4145
g59
(g98
S'!\x00\x00\x00'
tRp4146
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4147
I0
sg3641
S'10-bounty_redo.png'
p4148
sS'block_loop.thisRepN'
p4149
I1
sg3644
g3984
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4150
I1
sg3646
g3978
sg55
g11
sS'block_loop.thisTrial'
p4151
Nsg69
Vn
sS'block_loop.thisTrialN'
p4152
I0
sg39
F1.4501480798089688
sg34
g752
(S'\x07\xdf\n\x10\x0b\x10\x13\x01\x1d('
tRp4153
sa(dp4154
S'trial_loop.thisTrialN'
p4155
I34
sg3632
S'27-hartleys_raspberries_jelly.png'
p4156
sS'block_loop.thisIndex'
p4157
g3626
sg38
S'left'
p4158
sg58
g62
sS'trial_loop.thisN'
p4159
I34
sg33
g3663
sg63
g64
sS'trial_loop.thisIndex'
p4160
g59
(g98
S'"\x00\x00\x00'
tRp4161
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4162
I0
sg3641
S'51-mars.png'
p4163
sS'block_loop.thisRepN'
p4164
I1
sg3644
g3663
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4165
I1
sg3646
g3657
sg55
g11
sS'block_loop.thisTrial'
p4166
Nsg69
Vn
sS'block_loop.thisTrialN'
p4167
I0
sg39
F0.85012207888757985
sg34
g752
(S'\x07\xdf\n\x10\x0b\x10\x19\x08\x93P'
tRp4168
sa(dp4169
S'trial_loop.thisTrialN'
p4170
I35
sg3632
g4141
sS'block_loop.thisIndex'
p4171
g3626
sg38
S'left'
p4172
sg58
g62
sS'trial_loop.thisN'
p4173
I35
sg33
g3984
sg63
g64
sS'trial_loop.thisIndex'
p4174
g59
(g98
S'#\x00\x00\x00'
tRp4175
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4176
I0
sg3641
g4148
sS'block_loop.thisRepN'
p4177
I1
sg3644
g3984
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4178
I1
sg3646
g3978
sg55
g11
sS'block_loop.thisTrial'
p4179
Nsg69
Vn
sS'block_loop.thisTrialN'
p4180
I0
sg39
F0.80008655569963594
sg34
g752
(S'\x07\xdf\n\x10\x0b\x10\x1f\x06\xc6`'
tRp4181
sa(dp4182
S'trial_loop.thisTrialN'
p4183
I36
sg3632
g3704
sS'block_loop.thisIndex'
p4184
g3626
sg38
S'left'
p4185
sg58
g62
sS'trial_loop.thisN'
p4186
I36
sg33
g3714
sg63
g64
sS'trial_loop.thisIndex'
p4187
g59
(g98
S'$\x00\x00\x00'
tRp4188
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4189
I0
sg3641
g3712
sS'block_loop.thisRepN'
p4190
I1
sg3644
g3714
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4191
I1
sg3646
g3708
sg55
g11
sS'block_loop.thisTrial'
p4192
Nsg69
Vn
sS'block_loop.thisTrialN'
p4193
I0
sg39
F1.1168923881168666
sg34
g752
(S'\x07\xdf\n\x10\x0b\x10%\x04=\xf0'
tRp4194
sa(dp4195
S'trial_loop.thisTrialN'
p4196
I37
sg3632
g3849
sS'block_loop.thisIndex'
p4197
g3626
sg38
S'right'
p4198
sg58
g62
sS'trial_loop.thisN'
p4199
I37
sg33
g3772
sg63
g64
sS'trial_loop.thisIndex'
p4200
g59
(g98
S'%\x00\x00\x00'
tRp4201
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4202
I0
sg3641
g3856
sS'block_loop.thisRepN'
p4203
I1
sg3644
g3772
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4204
I1
sg3646
g3779
sg55
g11
sS'block_loop.thisTrial'
p4205
Nsg69
Vn
sS'block_loop.thisTrialN'
p4206
I0
sg39
F1.3333178430184489
sg34
g752
(S'\x07\xdf\n\x10\x0b\x10+\x06|('
tRp4207
sa(dp4208
S'trial_loop.thisTrialN'
p4209
I38
sg3632
S'23-crunchie_redo.png'
p4210
sS'block_loop.thisIndex'
p4211
g3626
sg38
S'right'
p4212
sg58
g62
sS'trial_loop.thisN'
p4213
I38
sg33
S'33-ambrosia_rice.png'
p4214
sg63
g64
sS'trial_loop.thisIndex'
p4215
g59
(g98
S'&\x00\x00\x00'
tRp4216
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4217
I0
sg3641
S'33-ambrosia_rice.png'
p4218
sS'block_loop.thisRepN'
p4219
I1
sg3644
g4214
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4220
I1
sg3646
S'23-crunchie_redo.png'
p4221
sg55
g11
sS'block_loop.thisTrial'
p4222
Nsg69
Vn
sS'block_loop.thisTrialN'
p4223
I0
sg39
F1.0667014866139652
sg34
g752
(S'\x07\xdf\n\x10\x0b\x101\x0c\n\x08'
tRp4224
sa(dp4225
S'trial_loop.thisTrialN'
p4226
I39
sg3632
g3687
sS'block_loop.thisIndex'
p4227
g3626
sg38
S'left'
p4228
sg58
g62
sS'trial_loop.thisN'
p4229
I39
sg33
g3691
sg63
g64
sS'trial_loop.thisIndex'
p4230
g59
(g98
S"'\x00\x00\x00"
tRp4231
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4232
I0
sg3641
g3695
sS'block_loop.thisRepN'
p4233
I1
sg3644
g3691
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4234
I1
sg3646
g3698
sg55
g11
sS'block_loop.thisTrial'
p4235
Nsg69
Vn
sS'block_loop.thisTrialN'
p4236
I0
sg39
F0.75026656646423362
sg34
g752
(S'\x07\xdf\n\x10\x0b\x107\r\x90\xa8'
tRp4237
sa(dp4238
S'trial_loop.thisTrialN'
p4239
I40
sg3632
g3721
sS'block_loop.thisIndex'
p4240
g3626
sg38
S'left'
p4241
sg58
g62
sS'trial_loop.thisN'
p4242
I40
sg33
g3725
sg63
g64
sS'trial_loop.thisIndex'
p4243
g59
(g98
S'(\x00\x00\x00'
tRp4244
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4245
I0
sg3641
g3729
sS'block_loop.thisRepN'
p4246
I1
sg3644
g3725
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4247
I1
sg3646
g3732
sg55
g11
sS'block_loop.thisTrial'
p4248
Nsg69
Vn
sS'block_loop.thisTrialN'
p4249
I0
sg39
F0.75015509321565332
sg34
g752
(S'\x07\xdf\n\x10\x0b\x11\x01\nT\x88'
tRp4250
sa(dp4251
S'trial_loop.thisTrialN'
p4252
I41
sg3632
g3832
sS'block_loop.thisIndex'
p4253
g3626
sg38
S'right'
p4254
sg58
g62
sS'trial_loop.thisN'
p4255
I41
sg33
g3843
sg63
g64
sS'trial_loop.thisIndex'
p4256
g59
(g98
S')\x00\x00\x00'
tRp4257
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4258
I0
sg3641
g3840
sS'block_loop.thisRepN'
p4259
I1
sg3644
g3836
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4260
I1
sg3646
g3843
sg55
g11
sS'block_loop.thisTrial'
p4261
Nsg69
Vn
sS'block_loop.thisTrialN'
p4262
I0
sg39
F0.81686627315502847
sg34
g752
(S'\x07\xdf\n\x10\x0b\x11\x07\x07\x14\x80'
tRp4263
sa(dp4264
S'trial_loop.thisTrialN'
p4265
I42
sg3632
g3768
sS'block_loop.thisIndex'
p4266
g3626
sg38
S'left'
p4267
sg58
g62
sS'trial_loop.thisN'
p4268
I42
sg33
g3779
sg63
g64
sS'trial_loop.thisIndex'
p4269
g59
(g98
S'*\x00\x00\x00'
tRp4270
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4271
I0
sg3641
g3776
sS'block_loop.thisRepN'
p4272
I1
sg3644
g3772
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4273
I1
sg3646
g3779
sg55
g11
sS'block_loop.thisTrial'
p4274
Nsg69
Vn
sS'block_loop.thisTrialN'
p4275
I0
sg39
F1.0000746956302464
sg34
g752
(S'\x07\xdf\n\x10\x0b\x11\r\x04\xca\x90'
tRp4276
sa(dp4277
S'trial_loop.thisTrialN'
p4278
I43
sg3632
S'29-beans.png'
p4279
sS'block_loop.thisIndex'
p4280
g3626
sg38
S'left'
p4281
sg58
g62
sS'trial_loop.thisN'
p4282
I43
sg33
g3755
sg63
g64
sS'trial_loop.thisIndex'
p4283
g59
(g98
S'+\x00\x00\x00'
tRp4284
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4285
I0
sg3641
S'46-pistachios.png'
p4286
sS'block_loop.thisRepN'
p4287
I1
sg3644
g3761
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4288
I1
sg3646
g3755
sg55
g11
sS'block_loop.thisTrial'
p4289
Nsg69
Vn
sS'block_loop.thisTrialN'
p4290
I0
sg39
F0.78353235062058957
sg34
g752
(S'\x07\xdf\n\x10\x0b\x11\x13\x05 \x80'
tRp4291
sa(dp4292
S'trial_loop.thisTrialN'
p4293
I44
sg3632
g4006
sS'block_loop.thisIndex'
p4294
g3626
sg38
S'right'
p4295
sg58
g62
sS'trial_loop.thisN'
p4296
I44
sg33
g3637
sg63
g64
sS'trial_loop.thisIndex'
p4297
g59
(g98
S',\x00\x00\x00'
tRp4298
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4299
I0
sg3641
g4013
sS'block_loop.thisRepN'
p4300
I1
sg3644
g3637
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4301
I1
sg3646
g3647
sg55
g11
sS'block_loop.thisTrial'
p4302
Nsg69
Vn
sS'block_loop.thisTrialN'
p4303
I0
sg39
F1.16682499099079
sg34
g752
(S'\x07\xdf\n\x10\x0b\x11\x19\x02]x'
tRp4304
sa(dp4305
S'trial_loop.thisTrialN'
p4306
I45
sg3632
S'3-ellas_strawberries_apples.png'
p4307
sS'block_loop.thisIndex'
p4308
g3626
sg38
S'left'
p4309
sg58
g62
sS'trial_loop.thisN'
p4310
I45
sg33
S'3-ellas_strawberries_apples.png'
p4311
sg63
g64
sS'trial_loop.thisIndex'
p4312
g59
(g98
S'-\x00\x00\x00'
tRp4313
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4314
I0
sg3641
S'13-mccoys_steak_crisps.png'
p4315
sS'block_loop.thisRepN'
p4316
I1
sg3644
g4311
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4317
I1
sg3646
S'13-mccoys_steak_crisps.png'
p4318
sg55
g11
sS'block_loop.thisTrial'
p4319
Nsg69
Vn
sS'block_loop.thisTrialN'
p4320
I0
sg39
F0.6835465484919041
sg34
g752
(S'\x07\xdf\n\x10\x0b\x11\x1f\x05\x89\xf8'
tRp4321
sa(dp4322
S'trial_loop.thisTrialN'
p4323
I46
sg3632
g3933
sS'block_loop.thisIndex'
p4324
g3626
sg38
S'right'
p4325
sg58
g62
sS'trial_loop.thisN'
p4326
I46
sg33
g3802
sg63
g64
sS'trial_loop.thisIndex'
p4327
g59
(g98
S'.\x00\x00\x00'
tRp4328
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4329
I0
sg3641
g3940
sS'block_loop.thisRepN'
p4330
I1
sg3644
g3802
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4331
I1
sg3646
g3809
sg55
g11
sS'block_loop.thisTrial'
p4332
Nsg69
Vn
sS'block_loop.thisTrialN'
p4333
I0
sg39
F1.1168450618779389
sg34
g752
(S'\x07\xdf\n\x10\x0b\x11%\x01\x1d('
tRp4334
sa(dp4335
S'trial_loop.thisTrialN'
p4336
I47
sg3632
g4279
sS'block_loop.thisIndex'
p4337
g3626
sg38
S'left'
p4338
sg58
g62
sS'trial_loop.thisN'
p4339
I47
sg33
g3761
sg63
g64
sS'trial_loop.thisIndex'
p4340
g59
(g98
S'/\x00\x00\x00'
tRp4341
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4342
I0
sg3641
g4286
sS'block_loop.thisRepN'
p4343
I1
sg3644
g3761
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4344
I1
sg3646
g3755
sg55
g11
sS'block_loop.thisTrial'
p4345
Nsg69
Vn
sS'block_loop.thisTrialN'
p4346
I0
sg39
F1.2836891544229729
sg34
g752
(S'\x07\xdf\n\x10\x0b\x11+\x03Wx'
tRp4347
sa(dp4348
S'trial_loop.thisTrialN'
p4349
I48
sg3632
S'33-ambrosia_rice.png'
p4350
sS'block_loop.thisIndex'
p4351
g3626
sg38
S'left'
p4352
sg58
g62
sS'trial_loop.thisN'
p4353
I48
sg33
g4214
sg63
g64
sS'trial_loop.thisIndex'
p4354
g59
(g98
S'0\x00\x00\x00'
tRp4355
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4356
I0
sg3641
S'23-crunchie_redo.png'
p4357
sS'block_loop.thisRepN'
p4358
I1
sg3644
g4214
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4359
I1
sg3646
g4221
sg55
g11
sS'block_loop.thisTrial'
p4360
Nsg69
Vn
sS'block_loop.thisTrialN'
p4361
I0
sg39
F1.0334773267395576
sg34
g752
(S'\x07\xdf\n\x10\x0b\x111\x081\xa8'
tRp4362
sa(dp4363
S'trial_loop.thisTrialN'
p4364
I49
sg3632
g4124
sS'block_loop.thisIndex'
p4365
g3626
sg38
S'left'
p4366
sg58
g62
sS'trial_loop.thisN'
p4367
I49
sg33
g4128
sg63
g64
sS'trial_loop.thisIndex'
p4368
g59
(g98
S'1\x00\x00\x00'
tRp4369
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4370
I0
sg3641
g4132
sS'block_loop.thisRepN'
p4371
I1
sg3644
g4128
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4372
I1
sg3646
g4135
sg55
g11
sS'block_loop.thisTrial'
p4373
Nsg69
Vn
sS'block_loop.thisTrialN'
p4374
I0
sg39
F0.83346181741853798
sg34
g752
(S'\x07\xdf\n\x10\x0b\x117\t?0'
tRp4375
sa(dp4376
S'trial_loop.thisTrialN'
p4377
I50
sg3632
S'18-mms.png'
p4378
sS'block_loop.thisIndex'
p4379
g3626
sg38
S'left'
p4380
sg58
g62
sS'trial_loop.thisN'
p4381
I50
sg33
g4083
sg63
g64
sS'trial_loop.thisIndex'
p4382
g59
(g98
S'2\x00\x00\x00'
tRp4383
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4384
I0
sg3641
S'43-mrporky_pork_crackles_redo.png'
p4385
sS'block_loop.thisRepN'
p4386
I1
sg3644
g4083
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4387
I1
sg3646
g4090
sg55
g11
sS'block_loop.thisTrial'
p4388
Nsg69
Vn
sS'block_loop.thisTrialN'
p4389
I0
sg39
F0.66677025220906216
sg34
g752
(S'\x07\xdf\n\x10\x0b\x12\x01\x07/\xd8'
tRp4390
sa(dp4391
S'trial_loop.thisTrialN'
p4392
I51
sg3632
g3849
sS'block_loop.thisIndex'
p4393
g3626
sg38
S'right'
p4394
sg58
g62
sS'trial_loop.thisN'
p4395
I51
sg33
g3772
sg63
g64
sS'trial_loop.thisIndex'
p4396
g59
(g98
S'3\x00\x00\x00'
tRp4397
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4398
I0
sg3641
g3856
sS'block_loop.thisRepN'
p4399
I1
sg3644
g3772
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4400
I1
sg3646
g3779
sg55
g11
sS'block_loop.thisTrial'
p4401
Nsg69
Vn
sS'block_loop.thisTrialN'
p4402
I0
sg39
F1.1667465890895983
sg34
g752
(S'\x07\xdf\n\x10\x0b\x12\x07\x02\xc3\x08'
tRp4403
sa(dp4404
S'trial_loop.thisTrialN'
p4405
I52
sg3632
g4307
sS'block_loop.thisIndex'
p4406
g3626
sg38
S'left'
p4407
sg58
g62
sS'trial_loop.thisN'
p4408
I52
sg33
g4311
sg63
g64
sS'trial_loop.thisIndex'
p4409
g59
(g98
S'4\x00\x00\x00'
tRp4410
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4411
I0
sg3641
g4315
sS'block_loop.thisRepN'
p4412
I1
sg3644
g4311
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4413
I1
sg3646
g4318
sg55
g11
sS'block_loop.thisTrial'
p4414
Nsg69
Vn
sS'block_loop.thisTrialN'
p4415
I0
sg39
F0.65014591306589864
sg34
g752
(S'\x07\xdf\n\x10\x0b\x12\r\x05\xb4\xf0'
tRp4416
sa(dp4417
S'trial_loop.thisTrialN'
p4418
I53
sg3632
g3670
sS'block_loop.thisIndex'
p4419
g3626
sg38
S'left'
p4420
sg58
g62
sS'trial_loop.thisN'
p4421
I53
sg33
g3674
sg63
g64
sS'trial_loop.thisIndex'
p4422
g59
(g98
S'5\x00\x00\x00'
tRp4423
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4424
I0
sg3641
g3678
sS'block_loop.thisRepN'
p4425
I1
sg3644
g3674
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4426
I1
sg3646
g3681
sg55
g11
sS'block_loop.thisTrial'
p4427
Nsg69
Vn
sS'block_loop.thisTrialN'
p4428
I0
sg39
F1.1838584455099408
sg34
g752
(S'\x07\xdf\n\x10\x0b\x12\x13\x00\xcf\x08'
tRp4429
sa(dp4430
S'trial_loop.thisTrialN'
p4431
I54
sg3632
g4096
sS'block_loop.thisIndex'
p4432
g3626
sg38
S'left'
p4433
sg58
g62
sS'trial_loop.thisN'
p4434
I54
sg33
g3836
sg63
g64
sS'trial_loop.thisIndex'
p4435
g59
(g98
S'6\x00\x00\x00'
tRp4436
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4437
I0
sg3641
g4103
sS'block_loop.thisRepN'
p4438
I1
sg3644
g3836
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4439
I1
sg3646
g3843
sg55
g11
sS'block_loop.thisTrial'
p4440
Nsg69
Vn
sS'block_loop.thisTrialN'
p4441
I0
sg39
F2.233397043192781
sg34
g752
(S'\x07\xdf\n\x10\x0b\x12\x19\x04:\x08'
tRp4442
sa(dp4443
S'trial_loop.thisTrialN'
p4444
I55
sg3632
S'34-hula_hoops_bbq_beef_redo.png'
p4445
sS'block_loop.thisIndex'
p4446
g3626
sg38
S'right'
p4447
sg58
g62
sS'trial_loop.thisN'
p4448
I55
sg33
S'36-fig_rolls.png'
p4449
sg63
g64
sS'trial_loop.thisIndex'
p4450
g59
(g98
S'7\x00\x00\x00'
tRp4451
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4452
I0
sg3641
S'36-fig_rolls.png'
p4453
sS'block_loop.thisRepN'
p4454
I1
sg3644
g4449
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4455
I1
sg3646
S'34-hula_hoops_bbq_beef_redo.png'
p4456
sg55
g11
sS'block_loop.thisTrial'
p4457
Nsg69
Vn
sS'block_loop.thisTrialN'
p4458
I0
sg39
F1.0501355925243843
sg34
g752
(S'\x07\xdf\n\x10\x0b\x12 \x08X\xb8'
tRp4459
sa(dp4460
S'trial_loop.thisTrialN'
p4461
I56
sg3632
g3798
sS'block_loop.thisIndex'
p4462
g3626
sg38
S'left'
p4463
sg58
g62
sS'trial_loop.thisN'
p4464
I56
sg33
g3809
sg63
g64
sS'trial_loop.thisIndex'
p4465
g59
(g98
S'8\x00\x00\x00'
tRp4466
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4467
I0
sg3641
g3806
sS'block_loop.thisRepN'
p4468
I1
sg3644
g3802
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4469
I1
sg3646
g3809
sg55
g11
sS'block_loop.thisTrial'
p4470
Nsg69
Vn
sS'block_loop.thisTrialN'
p4471
I0
sg39
F2.3335245389398551
sg34
g752
(S'\x07\xdf\n\x10\x0b\x12&\t\xa0\xd8'
tRp4472
sa(dp4473
S'trial_loop.thisTrialN'
p4474
I57
sg3632
g4445
sS'block_loop.thisIndex'
p4475
g3626
sg38
S'right'
p4476
sg58
g62
sS'trial_loop.thisN'
p4477
I57
sg33
g4449
sg63
g64
sS'trial_loop.thisIndex'
p4478
g59
(g98
S'9\x00\x00\x00'
tRp4479
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4480
I0
sg3641
g4453
sS'block_loop.thisRepN'
p4481
I1
sg3644
g4449
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4482
I1
sg3646
g4456
sg55
g11
sS'block_loop.thisTrial'
p4483
Nsg69
Vn
sS'block_loop.thisTrialN'
p4484
I0
sg39
F1.0001054861950252
sg34
g752
(S'\x07\xdf\n\x10\x0b\x12-\x0f*\xd0'
tRp4485
sa(dp4486
S'trial_loop.thisTrialN'
p4487
I58
sg3632
g3687
sS'block_loop.thisIndex'
p4488
g3626
sg38
S'left'
p4489
sg58
g62
sS'trial_loop.thisN'
p4490
I58
sg33
g3691
sg63
g64
sS'trial_loop.thisIndex'
p4491
g59
(g98
S':\x00\x00\x00'
tRp4492
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4493
I0
sg3641
g3695
sS'block_loop.thisRepN'
p4494
I1
sg3644
g3691
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4495
I1
sg3646
g3698
sg55
g11
sS'block_loop.thisTrial'
p4496
Nsg69
Vn
sS'block_loop.thisTrialN'
p4497
I0
sg39
F0.70032427026399091
sg34
g752
(S'\x07\xdf\n\x10\x0b\x124\x00y\x18'
tRp4498
sa(dp4499
S'trial_loop.thisTrialN'
p4500
I59
sg3632
S'21-nakd_banana_crunch.png'
p4501
sS'block_loop.thisIndex'
p4502
g3626
sg38
S'left'
p4503
sg58
g62
sS'trial_loop.thisN'
p4504
I59
sg33
g4025
sg63
g64
sS'trial_loop.thisIndex'
p4505
g59
(g98
S';\x00\x00\x00'
tRp4506
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4507
I0
sg3641
S'1-treacle_cookies.png'
p4508
sS'block_loop.thisRepN'
p4509
I1
sg3644
g4025
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4510
I1
sg3646
g4032
sg55
g11
sS'block_loop.thisTrial'
p4511
Nsg69
Vn
sS'block_loop.thisTrialN'
p4512
I0
sg39
F0.83347920838514256
sg34
g752
(S'\x07\xdf\n\x10\x0b\x129\x0b\x89 '
tRp4513
sa(dp4514
S'trial_loop.thisTrialN'
p4515
I60
sg3632
g3974
sS'block_loop.thisIndex'
p4516
g3626
sg38
S'right'
p4517
sg58
g62
sS'trial_loop.thisN'
p4518
I60
sg33
g3984
sg63
g64
sS'trial_loop.thisIndex'
p4519
g59
(g98
S'<\x00\x00\x00'
tRp4520
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4521
I0
sg3641
g3982
sS'block_loop.thisRepN'
p4522
I1
sg3644
g3984
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4523
I1
sg3646
g3978
sg55
g11
sS'block_loop.thisTrial'
p4524
Nsg69
Vn
sS'block_loop.thisTrialN'
p4525
I0
sg39
F1.0667197328748443
sg34
g752
(S'\x07\xdf\n\x10\x0b\x13\x03\t}\xb0'
tRp4526
sa(dp4527
S'trial_loop.thisTrialN'
p4528
I61
sg3632
g4079
sS'block_loop.thisIndex'
p4529
g3626
sg38
S'right'
p4530
sg58
g62
sS'trial_loop.thisN'
p4531
I61
sg33
g4090
sg63
g64
sS'trial_loop.thisIndex'
p4532
g59
(g98
S'=\x00\x00\x00'
tRp4533
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4534
I0
sg3641
g4087
sS'block_loop.thisRepN'
p4535
I1
sg3644
g4083
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4536
I1
sg3646
g4090
sg55
g11
sS'block_loop.thisTrial'
p4537
Nsg69
Vn
sS'block_loop.thisTrialN'
p4538
I0
sg39
F0.80011535057838046
sg34
g752
(S'\x07\xdf\n\x10\x0b\x13\t\x0b\x04P'
tRp4539
sa(dp4540
S'trial_loop.thisTrialN'
p4541
I62
sg3632
g4156
sS'block_loop.thisIndex'
p4542
g3626
sg38
S'left'
p4543
sg58
g62
sS'trial_loop.thisN'
p4544
I62
sg33
g3663
sg63
g64
sS'trial_loop.thisIndex'
p4545
g59
(g98
S'>\x00\x00\x00'
tRp4546
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4547
I0
sg3641
g4163
sS'block_loop.thisRepN'
p4548
I1
sg3644
g3663
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4549
I1
sg3646
g3657
sg55
g11
sS'block_loop.thisTrial'
p4550
Nsg69
Vn
sS'block_loop.thisTrialN'
p4551
I0
sg39
F1.4335251661550501
sg34
g752
(S'\x07\xdf\n\x10\x0b\x13\x0f\x08{\xe0'
tRp4552
sa(dp4553
S'trial_loop.thisTrialN'
p4554
I63
sg3632
g4350
sS'block_loop.thisIndex'
p4555
g3626
sg38
S'left'
p4556
sg58
g62
sS'trial_loop.thisN'
p4557
I63
sg33
g4214
sg63
g64
sS'trial_loop.thisIndex'
p4558
g59
(g98
S'?\x00\x00\x00'
tRp4559
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4560
I0
sg3641
g4357
sS'block_loop.thisRepN'
p4561
I1
sg3644
g4214
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4562
I1
sg3646
g4221
sg55
g11
sS'block_loop.thisTrial'
p4563
Nsg69
Vn
sS'block_loop.thisTrialN'
p4564
I0
sg39
F1.2335324646592198
sg34
g752
(S'\x07\xdf\n\x10\x0b\x13\x16\x00u0'
tRp4565
sa(dp4566
S'trial_loop.thisTrialN'
p4567
I64
sg3632
g3974
sS'block_loop.thisIndex'
p4568
g3626
sg38
S'right'
p4569
sg58
g62
sS'trial_loop.thisN'
p4570
I64
sg33
g3984
sg63
g64
sS'trial_loop.thisIndex'
p4571
g59
(g98
S'@\x00\x00\x00'
tRp4572
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4573
I0
sg3641
g3982
sS'block_loop.thisRepN'
p4574
I1
sg3644
g3984
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4575
I1
sg3646
g3978
sg55
g11
sS'block_loop.thisTrial'
p4576
Nsg69
Vn
sS'block_loop.thisTrialN'
p4577
I0
sg39
F1.2168513910492038
sg34
g752
(S'\x07\xdf\n\x10\x0b\x13\x1c\x04]0'
tRp4578
sa(dp4579
S'trial_loop.thisTrialN'
p4580
I65
sg3632
g4210
sS'block_loop.thisIndex'
p4581
g3626
sg38
S'right'
p4582
sg58
g62
sS'trial_loop.thisN'
p4583
I65
sg33
g4214
sg63
g64
sS'trial_loop.thisIndex'
p4584
g59
(g98
S'A\x00\x00\x00'
tRp4585
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4586
I0
sg3641
g4218
sS'block_loop.thisRepN'
p4587
I1
sg3644
g4214
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4588
I1
sg3646
g4221
sg55
g11
sS'block_loop.thisTrial'
p4589
Nsg69
Vn
sS'block_loop.thisTrialN'
p4590
I0
sg39
F1.6834849673623467
sg34
g752
(S'\x07\xdf\n\x10\x0b\x13"\x08AH'
tRp4591
sa(dp4592
S'trial_loop.thisTrialN'
p4593
I66
sg3632
g3991
sS'block_loop.thisIndex'
p4594
g3626
sg38
S'left'
p4595
sg58
g62
sS'trial_loop.thisN'
p4596
I66
sg33
g3819
sg63
g64
sS'trial_loop.thisIndex'
p4597
g59
(g98
S'B\x00\x00\x00'
tRp4598
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4599
I0
sg3641
g3998
sS'block_loop.thisRepN'
p4600
I1
sg3644
g3819
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4601
I1
sg3646
g3826
sg55
g11
sS'block_loop.thisTrial'
p4602
Nsg69
Vn
sS'block_loop.thisTrialN'
p4603
I0
sg39
F2.000051032509873
sg34
g752
(S'\x07\xdf\n\x10\x0b\x13)\x03\xcc\xa8'
tRp4604
sa(dp4605
S'trial_loop.thisTrialN'
p4606
I67
sg3632
g3832
sS'block_loop.thisIndex'
p4607
g3626
sg38
S'right'
p4608
sg58
g62
sS'trial_loop.thisN'
p4609
I67
sg33
g3836
sg63
g64
sS'trial_loop.thisIndex'
p4610
g59
(g98
S'C\x00\x00\x00'
tRp4611
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4612
I0
sg3641
g3840
sS'block_loop.thisRepN'
p4613
I1
sg3644
g3836
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4614
I1
sg3646
g3843
sg55
g11
sS'block_loop.thisTrial'
p4615
Nsg69
Vn
sS'block_loop.thisTrialN'
p4616
I0
sg39
F0.95016832175497257
sg34
g752
(S'\x07\xdf\n\x10\x0b\x130\x04YH'
tRp4617
sa(dp4618
S'trial_loop.thisTrialN'
p4619
I68
sg3632
g3687
sS'block_loop.thisIndex'
p4620
g3626
sg38
S'left'
p4621
sg58
g62
sS'trial_loop.thisN'
p4622
I68
sg33
g3691
sg63
g64
sS'trial_loop.thisIndex'
p4623
g59
(g98
S'D\x00\x00\x00'
tRp4624
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4625
I0
sg3641
g3695
sS'block_loop.thisRepN'
p4626
I1
sg3644
g3691
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4627
I1
sg3646
g3698
sg55
g11
sS'block_loop.thisTrial'
p4628
Nsg69
Vn
sS'block_loop.thisTrialN'
p4629
I0
sg39
F0.80060258275807428
sg34
g752
(S'\x07\xdf\n\x10\x0b\x136\x0428'
tRp4630
sa(dp4631
S'trial_loop.thisTrialN'
p4632
I69
sg3632
S'36-fig_rolls.png'
p4633
sS'block_loop.thisIndex'
p4634
g3626
sg38
S'left'
p4635
sg58
g62
sS'trial_loop.thisN'
p4636
I69
sg33
g4449
sg63
g64
sS'trial_loop.thisIndex'
p4637
g59
(g98
S'E\x00\x00\x00'
tRp4638
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4639
I0
sg3641
S'34-hula_hoops_bbq_beef_redo.png'
p4640
sS'block_loop.thisRepN'
p4641
I1
sg3644
g4449
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4642
I1
sg3646
g4456
sg55
g11
sS'block_loop.thisTrial'
p4643
Nsg69
Vn
sS'block_loop.thisTrialN'
p4644
I0
sg39
F0.80023509166403528
sg34
g752
(S'\x07\xdf\n\x10\x0b\x14\x00\x01\xad\xb0'
tRp4645
sa(dp4646
S'trial_loop.thisTrialN'
p4647
I70
sg3632
g3991
sS'block_loop.thisIndex'
p4648
g3626
sg38
S'left'
p4649
sg58
g62
sS'trial_loop.thisN'
p4650
I70
sg33
g3826
sg63
g64
sS'trial_loop.thisIndex'
p4651
g59
(g98
S'F\x00\x00\x00'
tRp4652
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4653
I0
sg3641
g3998
sS'block_loop.thisRepN'
p4654
I1
sg3644
g3819
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4655
I1
sg3646
g3826
sg55
g11
sS'block_loop.thisTrial'
p4656
Nsg69
Vn
sS'block_loop.thisTrialN'
p4657
I0
sg39
F1.3835130209881754
sg34
g752
(S'\x07\xdf\n\x10\x0b\x14\x05\x0eg\x80'
tRp4658
sa(dp4659
S'trial_loop.thisTrialN'
p4660
I71
sg3632
g4156
sS'block_loop.thisIndex'
p4661
g3626
sg38
S'right'
p4662
sg58
g62
sS'trial_loop.thisN'
p4663
I71
sg33
g3657
sg63
g64
sS'trial_loop.thisIndex'
p4664
g59
(g98
S'G\x00\x00\x00'
tRp4665
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4666
I0
sg3641
g4163
sS'block_loop.thisRepN'
p4667
I1
sg3644
g3663
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4668
I1
sg3646
g3657
sg55
g11
sS'block_loop.thisTrial'
p4669
Nsg69
Vn
sS'block_loop.thisTrialN'
p4670
I0
sg39
F1.416770822404942
sg34
g752
(S'\x07\xdf\n\x10\x0b\x14\x0c\x05n\xa0'
tRp4671
sa(dp4672
S'trial_loop.thisTrialN'
p4673
I72
sg3632
S'8-liquorice_catherine_wheels.png'
p4674
sS'block_loop.thisIndex'
p4675
g3626
sg38
S'right'
p4676
sg58
g62
sS'trial_loop.thisN'
p4677
I72
sg33
g3714
sg63
g64
sS'trial_loop.thisIndex'
p4678
g59
(g98
S'H\x00\x00\x00'
tRp4679
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4680
I0
sg3641
S'17-jacobs_mini_cheddars_redo.png'
p4681
sS'block_loop.thisRepN'
p4682
I1
sg3644
g3714
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4683
I1
sg3646
g3708
sg55
g11
sS'block_loop.thisTrial'
p4684
Nsg69
Vn
sS'block_loop.thisTrialN'
p4685
I0
sg39
F1.0501940375788763
sg34
g752
(S'\x07\xdf\n\x10\x0b\x14\x12\x0ck\xb0'
tRp4686
sa(dp4687
S'trial_loop.thisTrialN'
p4688
I73
sg3632
g4006
sS'block_loop.thisIndex'
p4689
g3626
sg38
S'right'
p4690
sg58
g62
sS'trial_loop.thisN'
p4691
I73
sg33
g3637
sg63
g64
sS'trial_loop.thisIndex'
p4692
g59
(g98
S'I\x00\x00\x00'
tRp4693
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4694
I0
sg3641
g4013
sS'block_loop.thisRepN'
p4695
I1
sg3644
g3637
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4696
I1
sg3646
g3647
sg55
g11
sS'block_loop.thisTrial'
p4697
Nsg69
Vn
sS'block_loop.thisTrialN'
p4698
I0
sg39
F0.96687191809269279
sg34
g752
(S'\x07\xdf\n\x10\x0b\x14\x18\ruP'
tRp4699
sa(dp4700
S'trial_loop.thisTrialN'
p4701
I74
sg3632
g3991
sS'block_loop.thisIndex'
p4702
g3626
sg38
S'left'
p4703
sg58
g62
sS'trial_loop.thisN'
p4704
I74
sg33
g3819
sg63
g64
sS'trial_loop.thisIndex'
p4705
g59
(g98
S'J\x00\x00\x00'
tRp4706
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4707
I0
sg3641
g3998
sS'block_loop.thisRepN'
p4708
I1
sg3644
g3819
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4709
I1
sg3646
g3826
sg55
g11
sS'block_loop.thisTrial'
p4710
Nsg69
Vn
sS'block_loop.thisTrialN'
p4711
I0
sg39
F1.2834944326095865
sg34
g752
(S'\x07\xdf\n\x10\x0b\x14\x1e\r\x90\xa8'
tRp4712
sa(dp4713
S'trial_loop.thisTrialN'
p4714
I75
sg3632
g4350
sS'block_loop.thisIndex'
p4715
g3626
sg38
S'left'
p4716
sg58
g62
sS'trial_loop.thisN'
p4717
I75
sg33
g4221
sg63
g64
sS'trial_loop.thisIndex'
p4718
g59
(g98
S'K\x00\x00\x00'
tRp4719
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4720
I0
sg3641
g4357
sS'block_loop.thisRepN'
p4721
I1
sg3644
g4214
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4722
I1
sg3646
g4221
sg55
g11
sS'block_loop.thisTrial'
p4723
Nsg69
Vn
sS'block_loop.thisTrialN'
p4724
I0
sg39
F0.850192212951697
sg34
g752
(S'\x07\xdf\n\x10\x0b\x14%\x03(\x98'
tRp4725
sa(dp4726
S'trial_loop.thisTrialN'
p4727
I76
sg3632
g3849
sS'block_loop.thisIndex'
p4728
g3626
sg38
S'right'
p4729
sg58
g62
sS'trial_loop.thisN'
p4730
I76
sg33
g3772
sg63
g64
sS'trial_loop.thisIndex'
p4731
g59
(g98
S'L\x00\x00\x00'
tRp4732
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4733
I0
sg3641
g3856
sS'block_loop.thisRepN'
p4734
I1
sg3644
g3772
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4735
I1
sg3646
g3779
sg55
g11
sS'block_loop.thisTrial'
p4736
Nsg69
Vn
sS'block_loop.thisTrialN'
p4737
I0
sg39
F1.3499920742806353
sg34
g752
(S'\x07\xdf\n\x10\x0b\x14+\x01W\xc0'
tRp4738
sa(dp4739
S'trial_loop.thisTrialN'
p4740
I77
sg3632
g4350
sS'block_loop.thisIndex'
p4741
g3626
sg38
S'left'
p4742
sg58
g62
sS'trial_loop.thisN'
p4743
I77
sg33
g4214
sg63
g64
sS'trial_loop.thisIndex'
p4744
g59
(g98
S'M\x00\x00\x00'
tRp4745
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4746
I0
sg3641
g4357
sS'block_loop.thisRepN'
p4747
I1
sg3644
g4214
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4748
I1
sg3646
g4221
sg55
g11
sS'block_loop.thisTrial'
p4749
Nsg69
Vn
sS'block_loop.thisTrialN'
p4750
I0
sg39
F0.80018291876331205
sg34
g752
(S'\x07\xdf\n\x10\x0b\x141\x07$ '
tRp4751
sa(dp4752
S'trial_loop.thisTrialN'
p4753
I78
sg3632
g4156
sS'block_loop.thisIndex'
p4754
g3626
sg38
S'left'
p4755
sg58
g62
sS'trial_loop.thisN'
p4756
I78
sg33
g3663
sg63
g64
sS'trial_loop.thisIndex'
p4757
g59
(g98
S'N\x00\x00\x00'
tRp4758
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4759
I0
sg3641
g4163
sS'block_loop.thisRepN'
p4760
I1
sg3644
g3663
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4761
I1
sg3646
g3657
sg55
g11
sS'block_loop.thisTrial'
p4762
Nsg69
Vn
sS'block_loop.thisTrialN'
p4763
I0
sg39
F0.86728753369879996
sg34
g752
(S'\x07\xdf\n\x10\x0b\x147\x04\x9f\x98'
tRp4764
sa(dp4765
S'trial_loop.thisTrialN'
p4766
I79
sg3632
g3832
sS'block_loop.thisIndex'
p4767
g3626
sg38
S'right'
p4768
sg58
g62
sS'trial_loop.thisN'
p4769
I79
sg33
g3836
sg63
g64
sS'trial_loop.thisIndex'
p4770
g59
(g98
S'O\x00\x00\x00'
tRp4771
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4772
I0
sg3641
g3840
sS'block_loop.thisRepN'
p4773
I1
sg3644
g3836
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4774
I1
sg3646
g3843
sg55
g11
sS'block_loop.thisTrial'
p4775
Nsg69
Vn
sS'block_loop.thisTrialN'
p4776
I0
sg39
F1.1002073231375107
sg34
g752
(S'\x07\xdf\n\x10\x0b\x15\x01\x03\tX'
tRp4777
sa(dp4778
S'trial_loop.thisTrialN'
p4779
I80
sg3632
g3815
sS'block_loop.thisIndex'
p4780
g3626
sg38
S'right'
p4781
sg58
g62
sS'trial_loop.thisN'
p4782
I80
sg33
g3819
sg63
g64
sS'trial_loop.thisIndex'
p4783
g59
(g98
S'P\x00\x00\x00'
tRp4784
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4785
I0
sg3641
g3823
sS'block_loop.thisRepN'
p4786
I1
sg3644
g3819
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4787
I1
sg3646
g3826
sg55
g11
sS'block_loop.thisTrial'
p4788
Nsg69
Vn
sS'block_loop.thisTrialN'
p4789
I0
sg39
F1.2171290763290017
sg34
g752
(S'\x07\xdf\n\x10\x0b\x15\x07\x05G\x90'
tRp4790
sa(dp4791
S'trial_loop.thisTrialN'
p4792
I81
sg3632
g3721
sS'block_loop.thisIndex'
p4793
g3626
sg38
S'left'
p4794
sg58
g62
sS'trial_loop.thisN'
p4795
I81
sg33
g3732
sg63
g64
sS'trial_loop.thisIndex'
p4796
g59
(g98
S'Q\x00\x00\x00'
tRp4797
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4798
I0
sg3641
g3729
sS'block_loop.thisRepN'
p4799
I1
sg3644
g3725
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4800
I1
sg3646
g3732
sg55
g11
sS'block_loop.thisTrial'
p4801
Nsg69
Vn
sS'block_loop.thisTrialN'
p4802
I0
sg39
F1.0000963630636761
sg34
g752
(S'\x07\xdf\n\x10\x0b\x15\r\x08\xf1\x10'
tRp4803
sa(dp4804
S'trial_loop.thisTrialN'
p4805
I82
sg3632
g4141
sS'block_loop.thisIndex'
p4806
g3626
sg38
S'left'
p4807
sg58
g62
sS'trial_loop.thisN'
p4808
I82
sg33
g3984
sg63
g64
sS'trial_loop.thisIndex'
p4809
g59
(g98
S'R\x00\x00\x00'
tRp4810
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4811
I0
sg3641
g4148
sS'block_loop.thisRepN'
p4812
I1
sg3644
g3984
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4813
I1
sg3646
g3978
sg55
g11
sS'block_loop.thisTrial'
p4814
Nsg69
Vn
sS'block_loop.thisTrialN'
p4815
I0
sg39
F1.2667440802288183
sg34
g752
(S'\x07\xdf\n\x10\x0b\x15\x13\t\x81\x98'
tRp4816
sa(dp4817
S'trial_loop.thisTrialN'
p4818
I83
sg3632
g4307
sS'block_loop.thisIndex'
p4819
g3626
sg38
S'left'
p4820
sg58
g62
sS'trial_loop.thisN'
p4821
I83
sg33
g4311
sg63
g64
sS'trial_loop.thisIndex'
p4822
g59
(g98
S'S\x00\x00\x00'
tRp4823
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4824
I0
sg3641
g4315
sS'block_loop.thisRepN'
p4825
I1
sg3644
g4311
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4826
I1
sg3646
g4318
sg55
g11
sS'block_loop.thisTrial'
p4827
Nsg69
Vn
sS'block_loop.thisTrialN'
p4828
I0
sg39
F0.83388233670757472
sg34
g752
(S'\x07\xdf\n\x10\x0b\x15\x19\x0e\x1dH'
tRp4829
sa(dp4830
S'trial_loop.thisTrialN'
p4831
I84
sg3632
g3653
sS'block_loop.thisIndex'
p4832
g3626
sg38
S'left'
p4833
sg58
g62
sS'trial_loop.thisN'
p4834
I84
sg33
g3663
sg63
g64
sS'trial_loop.thisIndex'
p4835
g59
(g98
S'T\x00\x00\x00'
tRp4836
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4837
I0
sg3641
g3661
sS'block_loop.thisRepN'
p4838
I1
sg3644
g3663
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4839
I1
sg3646
g3657
sg55
g11
sS'block_loop.thisTrial'
p4840
Nsg69
Vn
sS'block_loop.thisTrialN'
p4841
I0
sg39
F0.95008849436453602
sg34
g752
(S'\x07\xdf\n\x10\x0b\x15\x1f\x0c\x11\xd8'
tRp4842
sa(dp4843
S'trial_loop.thisTrialN'
p4844
I85
sg3632
g4501
sS'block_loop.thisIndex'
p4845
g3626
sg38
S'left'
p4846
sg58
g62
sS'trial_loop.thisN'
p4847
I85
sg33
g4032
sg63
g64
sS'trial_loop.thisIndex'
p4848
g59
(g98
S'U\x00\x00\x00'
tRp4849
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4850
I0
sg3641
g4508
sS'block_loop.thisRepN'
p4851
I1
sg3644
g4025
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4852
I1
sg3646
g4032
sg55
g11
sS'block_loop.thisTrial'
p4853
Nsg69
Vn
sS'block_loop.thisTrialN'
p4854
I0
sg39
F0.75015252733555826
sg34
g752
(S'\x07\xdf\n\x10\x0b\x15%\x0b\xb00'
tRp4855
sa(dp4856
S'trial_loop.thisTrialN'
p4857
I86
sg3632
g3721
sS'block_loop.thisIndex'
p4858
g3626
sg38
S'left'
p4859
sg58
g62
sS'trial_loop.thisN'
p4860
I86
sg33
g3732
sg63
g64
sS'trial_loop.thisIndex'
p4861
g59
(g98
S'V\x00\x00\x00'
tRp4862
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4863
I0
sg3641
g3729
sS'block_loop.thisRepN'
p4864
I1
sg3644
g3725
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4865
I1
sg3646
g3732
sg55
g11
sS'block_loop.thisTrial'
p4866
Nsg69
Vn
sS'block_loop.thisTrialN'
p4867
I0
sg39
F0.76686410641195835
sg34
g752
(S'\x07\xdf\n\x10\x0b\x15+\x08p('
tRp4868
sa(dp4869
S'trial_loop.thisTrialN'
p4870
I87
sg3632
S'6-sour_patch_kids.png'
p4871
sS'block_loop.thisIndex'
p4872
g3626
sg38
S'right'
p4873
sg58
g62
sS'trial_loop.thisN'
p4874
I87
sg33
S'38-maltesers.png'
p4875
sg63
g64
sS'trial_loop.thisIndex'
p4876
g59
(g98
S'W\x00\x00\x00'
tRp4877
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4878
I0
sg3641
S'38-maltesers.png'
p4879
sS'block_loop.thisRepN'
p4880
I1
sg3644
g4875
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4881
I1
sg3646
S'6-sour_patch_kids.png'
p4882
sg55
g11
sS'block_loop.thisTrial'
p4883
Nsg69
Vn
sS'block_loop.thisTrialN'
p4884
I0
sg39
F1.3000001710588549
sg34
g752
(S'\x07\xdf\n\x10\x0b\x151\x05r\x88'
tRp4885
sa(dp4886
S'trial_loop.thisTrialN'
p4887
I88
sg3632
g3933
sS'block_loop.thisIndex'
p4888
g3626
sg38
S'right'
p4889
sg58
g62
sS'trial_loop.thisN'
p4890
I88
sg33
g3802
sg63
g64
sS'trial_loop.thisIndex'
p4891
g59
(g98
S'X\x00\x00\x00'
tRp4892
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4893
I0
sg3641
g3940
sS'block_loop.thisRepN'
p4894
I1
sg3644
g3802
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4895
I1
sg3646
g3809
sg55
g11
sS'block_loop.thisTrial'
p4896
Nsg69
Vn
sS'block_loop.thisTrialN'
p4897
I0
sg39
F1.0835048671897312
sg34
g752
(S'\x07\xdf\n\x10\x0b\x157\n\x87P'
tRp4898
sa(dp4899
S'trial_loop.thisTrialN'
p4900
I89
sg3632
g4871
sS'block_loop.thisIndex'
p4901
g3626
sg38
S'right'
p4902
sg58
g62
sS'trial_loop.thisN'
p4903
I89
sg33
g4875
sg63
g64
sS'trial_loop.thisIndex'
p4904
g59
(g98
S'Y\x00\x00\x00'
tRp4905
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4906
I0
sg3641
g4879
sS'block_loop.thisRepN'
p4907
I1
sg3644
g4875
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4908
I1
sg3646
g4882
sg55
g11
sS'block_loop.thisTrial'
p4909
Nsg69
Vn
sS'block_loop.thisTrialN'
p4910
I0
sg39
F0.69984616121473664
sg34
g752
(S'\x07\xdf\n\x10\x0b\x16\x01\x0cH\x88'
tRp4911
sa(dp4912
S'trial_loop.thisTrialN'
p4913
I90
sg3632
g4279
sS'block_loop.thisIndex'
p4914
g3626
sg38
S'left'
p4915
sg58
g62
sS'trial_loop.thisN'
p4916
I90
sg33
g3761
sg63
g64
sS'trial_loop.thisIndex'
p4917
g59
(g98
S'Z\x00\x00\x00'
tRp4918
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4919
I0
sg3641
g4286
sS'block_loop.thisRepN'
p4920
I1
sg3644
g3761
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4921
I1
sg3646
g3755
sg55
g11
sS'block_loop.thisTrial'
p4922
Nsg69
Vn
sS'block_loop.thisTrialN'
p4923
I0
sg39
F1.033528074152855
sg34
g752
(S'\x07\xdf\n\x10\x0b\x16\x07\x08\x1a8'
tRp4924
sa(dp4925
S'trial_loop.thisTrialN'
p4926
I91
sg3632
g3832
sS'block_loop.thisIndex'
p4927
g3626
sg38
S'right'
p4928
sg58
g62
sS'trial_loop.thisN'
p4929
I91
sg33
g3836
sg63
g64
sS'trial_loop.thisIndex'
p4930
g59
(g98
S'[\x00\x00\x00'
tRp4931
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4932
I0
sg3641
g3840
sS'block_loop.thisRepN'
p4933
I1
sg3644
g3836
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4934
I1
sg3646
g3843
sg55
g11
sS'block_loop.thisTrial'
p4935
Nsg69
Vn
sS'block_loop.thisTrialN'
p4936
I0
sg39
F2.233527047800635
sg34
g752
(S'\x07\xdf\n\x10\x0b\x16\r\t#\xd8'
tRp4937
sa(dp4938
S'trial_loop.thisTrialN'
p4939
I92
sg3632
S'20-fruit_pastilles.png'
p4940
sS'block_loop.thisIndex'
p4941
g3626
sg38
S'left'
p4942
sg58
g62
sS'trial_loop.thisN'
p4943
I92
sg33
S'20-fruit_pastilles.png'
p4944
sg63
g64
sS'trial_loop.thisIndex'
p4945
g59
(g98
S'\\\x00\x00\x00'
tRp4946
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4947
I0
sg3641
S'2-steamed_puddings.png'
p4948
sS'block_loop.thisRepN'
p4949
I1
sg3644
g4944
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4950
I1
sg3646
S'2-steamed_puddings.png'
p4951
sg55
g11
sS'block_loop.thisTrial'
p4952
Nsg69
Vn
sS'block_loop.thisTrialN'
p4953
I0
sg39
F1.0334653526315378
sg34
g752
(S'\x07\xdf\n\x10\x0b\x16\x14\rB\x88'
tRp4954
sa(dp4955
S'trial_loop.thisTrialN'
p4956
I93
sg3632
g4124
sS'block_loop.thisIndex'
p4957
g3626
sg38
S'left'
p4958
sg58
g62
sS'trial_loop.thisN'
p4959
I93
sg33
g4128
sg63
g64
sS'trial_loop.thisIndex'
p4960
g59
(g98
S']\x00\x00\x00'
tRp4961
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4962
I0
sg3641
g4132
sS'block_loop.thisRepN'
p4963
I1
sg3644
g4128
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4964
I1
sg3646
g4135
sg55
g11
sS'block_loop.thisTrial'
p4965
Nsg69
Vn
sS'block_loop.thisTrialN'
p4966
I0
sg39
F1.0672628442271161
sg34
g752
(S'\x07\xdf\n\x10\x0b\x16\x1a\x0eL('
tRp4967
sa(dp4968
S'trial_loop.thisTrialN'
p4969
I94
sg3632
g4445
sS'block_loop.thisIndex'
p4970
g3626
sg38
S'right'
p4971
sg58
g62
sS'trial_loop.thisN'
p4972
I94
sg33
g4449
sg63
g64
sS'trial_loop.thisIndex'
p4973
g59
(g98
S'^\x00\x00\x00'
tRp4974
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4975
I0
sg3641
g4453
sS'block_loop.thisRepN'
p4976
I1
sg3644
g4449
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4977
I1
sg3646
g4456
sg55
g11
sS'block_loop.thisTrial'
p4978
Nsg69
Vn
sS'block_loop.thisTrialN'
p4979
I0
sg39
F0.80012048234038957
sg34
g752
(S'\x07\xdf\n\x10\x0b\x16!\x00\x90\x88'
tRp4980
sa(dp4981
S'trial_loop.thisTrialN'
p4982
I95
sg3632
g3933
sS'block_loop.thisIndex'
p4983
g3626
sg38
S'right'
p4984
sg58
g62
sS'trial_loop.thisN'
p4985
I95
sg33
g3802
sg63
g64
sS'trial_loop.thisIndex'
p4986
g59
(g98
S'_\x00\x00\x00'
tRp4987
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p4988
I0
sg3641
g3940
sS'block_loop.thisRepN'
p4989
I1
sg3644
g3802
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p4990
I1
sg3646
g3809
sg55
g11
sS'block_loop.thisTrial'
p4991
Nsg69
Vn
sS'block_loop.thisTrialN'
p4992
I0
sg39
F0.88352242921610014
sg34
g752
(S'\x07\xdf\n\x10\x0b\x16&\rJX'
tRp4993
sa(dp4994
S'trial_loop.thisTrialN'
p4995
I96
sg3632
g4096
sS'block_loop.thisIndex'
p4996
g3626
sg38
S'left'
p4997
sg58
g62
sS'trial_loop.thisN'
p4998
I96
sg33
g3836
sg63
g64
sS'trial_loop.thisIndex'
p4999
g59
(g98
S'`\x00\x00\x00'
tRp5000
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5001
I0
sg3641
g4103
sS'block_loop.thisRepN'
p5002
I1
sg3644
g3836
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5003
I1
sg3646
g3843
sg55
g11
sS'block_loop.thisTrial'
p5004
Nsg69
Vn
sS'block_loop.thisTrialN'
p5005
I0
sg39
F0.85011837261663459
sg34
g752
(S'\x07\xdf\n\x10\x0b\x16,\x0b\xf6\x80'
tRp5006
sa(dp5007
S'trial_loop.thisTrialN'
p5008
I97
sg3632
S'13-mccoys_steak_crisps.png'
p5009
sS'block_loop.thisIndex'
p5010
g3626
sg38
S'right'
p5011
sg58
g62
sS'trial_loop.thisN'
p5012
I97
sg33
g4311
sg63
g64
sS'trial_loop.thisIndex'
p5013
g59
(g98
S'a\x00\x00\x00'
tRp5014
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5015
I0
sg3641
S'3-ellas_strawberries_apples.png'
p5016
sS'block_loop.thisRepN'
p5017
I1
sg3644
g4311
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5018
I1
sg3646
g4318
sg55
g11
sS'block_loop.thisTrial'
p5019
Nsg69
Vn
sS'block_loop.thisTrialN'
p5020
I0
sg39
F0.98343980786648899
sg34
g752
(S'\x07\xdf\n\x10\x0b\x162\n%\xa8'
tRp5021
sa(dp5022
S'trial_loop.thisTrialN'
p5023
I98
sg3632
g3798
sS'block_loop.thisIndex'
p5024
g3626
sg38
S'left'
p5025
sg58
g62
sS'trial_loop.thisN'
p5026
I98
sg33
g3802
sg63
g64
sS'trial_loop.thisIndex'
p5027
g59
(g98
S'b\x00\x00\x00'
tRp5028
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5029
I0
sg3641
g3806
sS'block_loop.thisRepN'
p5030
I1
sg3644
g3802
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5031
I1
sg3646
g3809
sg55
g11
sS'block_loop.thisTrial'
p5032
Nsg69
Vn
sS'block_loop.thisTrialN'
p5033
I0
sg39
F1.4839564051217167
sg34
g752
(S'\x07\xdf\n\x10\x0b\x168\nw\xb0'
tRp5034
sa(dp5035
S'trial_loop.thisTrialN'
p5036
I99
sg3632
g3864
sS'block_loop.thisIndex'
p5037
g3626
sg38
S'right'
p5038
sg58
g62
sS'trial_loop.thisN'
p5039
I99
sg33
g3732
sg63
g64
sS'trial_loop.thisIndex'
p5040
g59
(g98
S'c\x00\x00\x00'
tRp5041
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5042
I0
sg3641
g3871
sS'block_loop.thisRepN'
p5043
I1
sg3644
g3725
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5044
I1
sg3646
g3732
sg55
g11
sS'block_loop.thisTrial'
p5045
Nsg69
Vn
sS'block_loop.thisTrialN'
p5046
I0
sg39
F0.73359404578968679
sg34
g752
(S'\x07\xdf\n\x10\x0b\x17\x03\x03(\x98'
tRp5047
sa(dp5048
S'trial_loop.thisTrialN'
p5049
I100
sg3632
g3892
sS'block_loop.thisIndex'
p5050
g3626
sg38
S'right'
p5051
sg58
g62
sS'trial_loop.thisN'
p5052
I100
sg33
g3674
sg63
g64
sS'trial_loop.thisIndex'
p5053
g59
(g98
S'd\x00\x00\x00'
tRp5054
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5055
I0
sg3641
g3899
sS'block_loop.thisRepN'
p5056
I1
sg3644
g3674
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5057
I1
sg3646
g3681
sg55
g11
sS'block_loop.thisTrial'
p5058
Nsg69
Vn
sS'block_loop.thisTrialN'
p5059
I0
sg39
F1.5334562295010983
sg34
g752
(S'\x07\xdf\n\x10\x0b\x17\x08\x0e\xb5\xa0'
tRp5060
sa(dp5061
S'trial_loop.thisTrialN'
p5062
I101
sg3632
g4210
sS'block_loop.thisIndex'
p5063
g3626
sg38
S'right'
p5064
sg58
g62
sS'trial_loop.thisN'
p5065
I101
sg33
g4214
sg63
g64
sS'trial_loop.thisIndex'
p5066
g59
(g98
S'e\x00\x00\x00'
tRp5067
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5068
I0
sg3641
g4218
sS'block_loop.thisRepN'
p5069
I1
sg3644
g4214
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5070
I1
sg3646
g4221
sg55
g11
sS'block_loop.thisTrial'
p5071
Nsg69
Vn
sS'block_loop.thisTrialN'
p5072
I0
sg39
F1.2000864986794113
sg34
g752
(S'\x07\xdf\n\x10\x0b\x17\x0f\x08\x1a8'
tRp5073
sa(dp5074
S'trial_loop.thisTrialN'
p5075
I102
sg3632
g4378
sS'block_loop.thisIndex'
p5076
g3626
sg38
S'left'
p5077
sg58
g62
sS'trial_loop.thisN'
p5078
I102
sg33
g4083
sg63
g64
sS'trial_loop.thisIndex'
p5079
g59
(g98
S'f\x00\x00\x00'
tRp5080
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5081
I0
sg3641
g4385
sS'block_loop.thisRepN'
p5082
I1
sg3644
g4083
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5083
I1
sg3646
g4090
sg55
g11
sS'block_loop.thisTrial'
p5084
Nsg69
Vn
sS'block_loop.thisTrialN'
p5085
I0
sg39
F0.7335361709301651
sg34
g752
(S'\x07\xdf\n\x10\x0b\x17\x15\x0b\xc3\xb8'
tRp5086
sa(dp5087
S'trial_loop.thisTrialN'
p5088
I103
sg3632
g3849
sS'block_loop.thisIndex'
p5089
g3626
sg38
S'right'
p5090
sg58
g62
sS'trial_loop.thisN'
p5091
I103
sg33
g3772
sg63
g64
sS'trial_loop.thisIndex'
p5092
g59
(g98
S'g\x00\x00\x00'
tRp5093
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5094
I0
sg3641
g3856
sS'block_loop.thisRepN'
p5095
I1
sg3644
g3772
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5096
I1
sg3646
g3779
sg55
g11
sS'block_loop.thisTrial'
p5097
Nsg69
Vn
sS'block_loop.thisTrialN'
p5098
I0
sg39
F1.3837784470606493
sg34
g752
(S'\x07\xdf\n\x10\x0b\x17\x1b\x08I\x18'
tRp5099
sa(dp5100
S'trial_loop.thisTrialN'
p5101
I104
sg3632
g5009
sS'block_loop.thisIndex'
p5102
g3626
sg38
S'right'
p5103
sg58
g62
sS'trial_loop.thisN'
p5104
I104
sg33
g4311
sg63
g64
sS'trial_loop.thisIndex'
p5105
g59
(g98
S'h\x00\x00\x00'
tRp5106
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5107
I0
sg3641
g5016
sS'block_loop.thisRepN'
p5108
I1
sg3644
g4311
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5109
I1
sg3646
g4318
sg55
g11
sS'block_loop.thisTrial'
p5110
Nsg69
Vn
sS'block_loop.thisTrialN'
p5111
I0
sg39
F0.7501017799222609
sg34
g752
(S'\x07\xdf\n\x10\x0b\x17!\x0e\x92x'
tRp5112
sa(dp5113
S'trial_loop.thisTrialN'
p5114
I105
sg3632
S'2-steamed_puddings.png'
p5115
sS'block_loop.thisIndex'
p5116
g3626
sg38
S'right'
p5117
sg58
g62
sS'trial_loop.thisN'
p5118
I105
sg33
g4944
sg63
g64
sS'trial_loop.thisIndex'
p5119
g59
(g98
S'i\x00\x00\x00'
tRp5120
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5121
I0
sg3641
S'20-fruit_pastilles.png'
p5122
sS'block_loop.thisRepN'
p5123
I1
sg3644
g4944
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5124
I1
sg3646
g4951
sg55
g11
sS'block_loop.thisTrial'
p5125
Nsg69
Vn
sS'block_loop.thisTrialN'
p5126
I0
sg39
F1.2668367370215492
sg34
g752
(S"\x07\xdf\n\x10\x0b\x17'\x0bRp"
tRp5127
sa(dp5128
S'trial_loop.thisTrialN'
p5129
I106
sg3632
g4096
sS'block_loop.thisIndex'
p5130
g3626
sg38
S'left'
p5131
sg58
g62
sS'trial_loop.thisN'
p5132
I106
sg33
g3836
sg63
g64
sS'trial_loop.thisIndex'
p5133
g59
(g98
S'j\x00\x00\x00'
tRp5134
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5135
I0
sg3641
g4103
sS'block_loop.thisRepN'
p5136
I1
sg3644
g3836
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5137
I1
sg3646
g3843
sg55
g11
sS'block_loop.thisTrial'
p5138
Nsg69
Vn
sS'block_loop.thisTrialN'
p5139
I0
sg39
F0.66689769093591167
sg34
g752
(S'\x07\xdf\n\x10\x0b\x17.\x00\xaf\xc8'
tRp5140
sa(dp5141
S'trial_loop.thisTrialN'
p5142
I107
sg3632
g3704
sS'block_loop.thisIndex'
p5143
g3626
sg38
S'left'
p5144
sg58
g62
sS'trial_loop.thisN'
p5145
I107
sg33
g3714
sg63
g64
sS'trial_loop.thisIndex'
p5146
g59
(g98
S'k\x00\x00\x00'
tRp5147
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5148
I0
sg3641
g3712
sS'block_loop.thisRepN'
p5149
I1
sg3644
g3714
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5150
I1
sg3646
g3708
sg55
g11
sS'block_loop.thisTrial'
p5151
Nsg69
Vn
sS'block_loop.thisTrialN'
p5152
I0
sg39
F0.95015663274352846
sg34
g752
(S'\x07\xdf\n\x10\x0b\x173\x0bF\xb8'
tRp5153
sa(dp5154
S'trial_loop.thisTrialN'
p5155
I108
sg3632
g4378
sS'block_loop.thisIndex'
p5156
g3626
sg38
S'left'
p5157
sg58
g62
sS'trial_loop.thisN'
p5158
I108
sg33
g4083
sg63
g64
sS'trial_loop.thisIndex'
p5159
g59
(g98
S'l\x00\x00\x00'
tRp5160
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5161
I0
sg3641
g4385
sS'block_loop.thisRepN'
p5162
I1
sg3644
g4083
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5163
I1
sg3646
g4090
sg55
g11
sS'block_loop.thisTrial'
p5164
Nsg69
Vn
sS'block_loop.thisTrialN'
p5165
I0
sg39
F0.65012339033819444
sg34
g752
(S'\x07\xdf\n\x10\x0b\x179\n\xe5\x10'
tRp5166
sa(dp5167
S'trial_loop.thisTrialN'
p5168
I109
sg3632
S'38-maltesers.png'
p5169
sS'block_loop.thisIndex'
p5170
g3626
sg38
S'left'
p5171
sg58
g62
sS'trial_loop.thisN'
p5172
I109
sg33
g4875
sg63
g64
sS'trial_loop.thisIndex'
p5173
g59
(g98
S'm\x00\x00\x00'
tRp5174
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5175
I0
sg3641
S'6-sour_patch_kids.png'
p5176
sS'block_loop.thisRepN'
p5177
I1
sg3644
g4875
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5178
I1
sg3646
g4882
sg55
g11
sS'block_loop.thisTrial'
p5179
Nsg69
Vn
sS'block_loop.thisTrialN'
p5180
I0
sg39
F0.85010725380016083
sg34
g752
(S'\x07\xdf\n\x10\x0b\x18\x03\x069\xc0'
tRp5181
sa(dp5182
S'trial_loop.thisTrialN'
p5183
I110
sg3632
g3974
sS'block_loop.thisIndex'
p5184
g3626
sg38
S'right'
p5185
sg58
g62
sS'trial_loop.thisN'
p5186
I110
sg33
g3984
sg63
g64
sS'trial_loop.thisIndex'
p5187
g59
(g98
S'n\x00\x00\x00'
tRp5188
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5189
I0
sg3641
g3982
sS'block_loop.thisRepN'
p5190
I1
sg3644
g3984
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5191
I1
sg3646
g3978
sg55
g11
sS'block_loop.thisTrial'
p5192
Nsg69
Vn
sS'block_loop.thisTrialN'
p5193
I0
sg39
F1.0668565798296186
sg34
g752
(S'\x07\xdf\n\x10\x0b\x18\t\x04h\xe8'
tRp5194
sa(dp5195
S'trial_loop.thisTrialN'
p5196
I111
sg3632
g4038
sS'block_loop.thisIndex'
p5197
g3626
sg38
S'right'
p5198
sg58
g62
sS'trial_loop.thisN'
p5199
I111
sg33
g3691
sg63
g64
sS'trial_loop.thisIndex'
p5200
g59
(g98
S'o\x00\x00\x00'
tRp5201
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5202
I0
sg3641
g4045
sS'block_loop.thisRepN'
p5203
I1
sg3644
g3691
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5204
I1
sg3646
g3698
sg55
g11
sS'block_loop.thisTrial'
p5205
Nsg69
Vn
sS'block_loop.thisTrialN'
p5206
I0
sg39
F0.90019152871718688
sg34
g752
(S'\x07\xdf\n\x10\x0b\x18\x0f\x05\xeb\xa0'
tRp5207
sa(dp5208
S'trial_loop.thisTrialN'
p5209
I112
sg3632
g5115
sS'block_loop.thisIndex'
p5210
g3626
sg38
S'right'
p5211
sg58
g62
sS'trial_loop.thisN'
p5212
I112
sg33
g4951
sg63
g64
sS'trial_loop.thisIndex'
p5213
g59
(g98
S'p\x00\x00\x00'
tRp5214
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5215
I0
sg3641
g5122
sS'block_loop.thisRepN'
p5216
I1
sg3644
g4944
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5217
I1
sg3646
g4951
sg55
g11
sS'block_loop.thisTrial'
p5218
Nsg69
Vn
sS'block_loop.thisTrialN'
p5219
I0
sg39
F0.91673147890560358
sg34
g752
(S'\x07\xdf\n\x10\x0b\x18\x15\x04\xd6H'
tRp5220
sa(dp5221
S'trial_loop.thisTrialN'
p5222
I113
sg3632
g4079
sS'block_loop.thisIndex'
p5223
g3626
sg38
S'right'
p5224
sg58
g62
sS'trial_loop.thisN'
p5225
I113
sg33
g4090
sg63
g64
sS'trial_loop.thisIndex'
p5226
g59
(g98
S'q\x00\x00\x00'
tRp5227
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5228
I0
sg3641
g4087
sS'block_loop.thisRepN'
p5229
I1
sg3644
g4083
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5230
I1
sg3646
g4090
sg55
g11
sS'block_loop.thisTrial'
p5231
Nsg69
Vn
sS'block_loop.thisTrialN'
p5232
I0
sg39
F0.73349426155073161
sg34
g752
(S'\x07\xdf\n\x10\x0b\x18\x1b\x046 '
tRp5233
sa(dp5234
S'trial_loop.thisTrialN'
p5235
I114
sg3632
g3974
sS'block_loop.thisIndex'
p5236
g3626
sg38
S'right'
p5237
sg58
g62
sS'trial_loop.thisN'
p5238
I114
sg33
g3984
sg63
g64
sS'trial_loop.thisIndex'
p5239
g59
(g98
S'r\x00\x00\x00'
tRp5240
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5241
I0
sg3641
g3982
sS'block_loop.thisRepN'
p5242
I1
sg3644
g3984
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5243
I1
sg3646
g3978
sg55
g11
sS'block_loop.thisTrial'
p5244
Nsg69
Vn
sS'block_loop.thisTrialN'
p5245
I0
sg39
F0.83356245694994868
sg34
g752
(S'\x07\xdf\n\x10\x0b\x18!\x00}\x00'
tRp5246
sa(dp5247
S'trial_loop.thisTrialN'
p5248
I115
sg3632
g4501
sS'block_loop.thisIndex'
p5249
g3626
sg38
S'left'
p5250
sg58
g62
sS'trial_loop.thisN'
p5251
I115
sg33
g4032
sg63
g64
sS'trial_loop.thisIndex'
p5252
g59
(g98
S's\x00\x00\x00'
tRp5253
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5254
I0
sg3641
g4508
sS'block_loop.thisRepN'
p5255
I1
sg3644
g4025
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5256
I1
sg3646
g4032
sg55
g11
sS'block_loop.thisTrial'
p5257
Nsg69
Vn
sS'block_loop.thisTrialN'
p5258
I0
sg39
F0.78395172951786662
sg34
g752
(S'\x07\xdf\n\x10\x0b\x18&\r\xb3\xd0'
tRp5259
sa(dp5260
S'trial_loop.thisTrialN'
p5261
I116
sg3632
g3751
sS'block_loop.thisIndex'
p5262
g3626
sg38
S'right'
p5263
sg58
g62
sS'trial_loop.thisN'
p5264
I116
sg33
g3761
sg63
g64
sS'trial_loop.thisIndex'
p5265
g59
(g98
S't\x00\x00\x00'
tRp5266
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5267
I0
sg3641
g3759
sS'block_loop.thisRepN'
p5268
I1
sg3644
g3761
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5269
I1
sg3646
g3755
sg55
g11
sS'block_loop.thisTrial'
p5270
Nsg69
Vn
sS'block_loop.thisTrialN'
p5271
I0
sg39
F1.133496770412421
sg34
g752
(S'\x07\xdf\n\x10\x0b\x18,\n\xf0\xc8'
tRp5272
sa(dp5273
S'trial_loop.thisTrialN'
p5274
I117
sg3632
g4210
sS'block_loop.thisIndex'
p5275
g3626
sg38
S'right'
p5276
sg58
g62
sS'trial_loop.thisN'
p5277
I117
sg33
g4214
sg63
g64
sS'trial_loop.thisIndex'
p5278
g59
(g98
S'u\x00\x00\x00'
tRp5279
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5280
I0
sg3641
g4218
sS'block_loop.thisRepN'
p5281
I1
sg3644
g4214
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5282
I1
sg3646
g4221
sg55
g11
sS'block_loop.thisTrial'
p5283
Nsg69
Vn
sS'block_loop.thisTrialN'
p5284
I0
sg39
F1.0335166702398055
sg34
g752
(S'\x07\xdf\n\x10\x0b\x182\r\xa40'
tRp5285
sa(dp5286
S'trial_loop.thisTrialN'
p5287
I118
sg3632
g3815
sS'block_loop.thisIndex'
p5288
g3626
sg38
S'right'
p5289
sg58
g62
sS'trial_loop.thisN'
p5290
I118
sg33
g3819
sg63
g64
sS'trial_loop.thisIndex'
p5291
g59
(g98
S'v\x00\x00\x00'
tRp5292
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5293
I0
sg3641
g3823
sS'block_loop.thisRepN'
p5294
I1
sg3644
g3819
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5295
I1
sg3646
g3826
sg55
g11
sS'block_loop.thisTrial'
p5296
Nsg69
Vn
sS'block_loop.thisTrialN'
p5297
I0
sg39
F1.0335106831862504
sg34
g752
(S'\x07\xdf\n\x10\x0b\x188\x0es8'
tRp5298
sa(dp5299
S'trial_loop.thisTrialN'
p5300
I119
sg3632
g4279
sS'block_loop.thisIndex'
p5301
g3626
sg38
S'left'
p5302
sg58
g62
sS'trial_loop.thisN'
p5303
I119
sg33
g3761
sg63
g64
sS'trial_loop.thisIndex'
p5304
g59
(g98
S'w\x00\x00\x00'
tRp5305
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5306
I0
sg3641
g4286
sS'block_loop.thisRepN'
p5307
I1
sg3644
g3761
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5308
I1
sg3646
g3755
sg55
g11
sS'block_loop.thisTrial'
p5309
Nsg69
Vn
sS'block_loop.thisTrialN'
p5310
I0
sg39
F1.35010839419283
sg34
g752
(S'\x07\xdf\n\x10\x0b\x19\x03\x00:\x98'
tRp5311
sa(dp5312
S'trial_loop.thisTrialN'
p5313
I120
sg3632
g4871
sS'block_loop.thisIndex'
p5314
g3626
sg38
S'right'
p5315
sg58
g62
sS'trial_loop.thisN'
p5316
I120
sg33
g4875
sg63
g64
sS'trial_loop.thisIndex'
p5317
g59
(g98
S'x\x00\x00\x00'
tRp5318
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5319
I0
sg3641
g4879
sS'block_loop.thisRepN'
p5320
I1
sg3644
g4875
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5321
I1
sg3646
g4882
sg55
g11
sS'block_loop.thisTrial'
p5322
Nsg69
Vn
sS'block_loop.thisTrialN'
p5323
I0
sg39
F0.91701315555383189
sg34
g752
(S'\x07\xdf\n\x10\x0b\x19\t\x06\n\xe0'
tRp5324
sa(dp5325
S'trial_loop.thisTrialN'
p5326
I121
sg3632
S'45-chewy_nougat_redo.png'
p5327
sS'block_loop.thisIndex'
p5328
g3626
sg38
S'right'
p5329
sg58
g62
sS'trial_loop.thisN'
p5330
I121
sg33
g4128
sg63
g64
sS'trial_loop.thisIndex'
p5331
g59
(g98
S'y\x00\x00\x00'
tRp5332
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5333
I0
sg3641
S'41-peanuts_redo.png'
p5334
sS'block_loop.thisRepN'
p5335
I1
sg3644
g4128
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5336
I1
sg3646
g4135
sg55
g11
sS'block_loop.thisTrial'
p5337
Nsg69
Vn
sS'block_loop.thisTrialN'
p5338
I0
sg39
F0.8169001997957821
sg34
g752
(S'\x07\xdf\n\x10\x0b\x19\x0f\x05j\xb8'
tRp5339
sa(dp5340
S'trial_loop.thisTrialN'
p5341
I122
sg3632
g4156
sS'block_loop.thisIndex'
p5342
g3626
sg38
S'right'
p5343
sg58
g62
sS'trial_loop.thisN'
p5344
I122
sg33
g3663
sg63
g64
sS'trial_loop.thisIndex'
p5345
g59
(g98
S'z\x00\x00\x00'
tRp5346
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5347
I0
sg3641
g4163
sS'block_loop.thisRepN'
p5348
I1
sg3644
g3663
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5349
I1
sg3646
g3657
sg55
g11
sS'block_loop.thisTrial'
p5350
Nsg69
Vn
sS'block_loop.thisTrialN'
p5351
I0
sg39
F1.2168528165384487
sg34
g752
(S'\x07\xdf\n\x10\x0b\x19\x15\x03 \xc8'
tRp5352
sa(dp5353
S'trial_loop.thisTrialN'
p5354
I123
sg3632
g3933
sS'block_loop.thisIndex'
p5355
g3626
sg38
S'right'
p5356
sg58
g62
sS'trial_loop.thisN'
p5357
I123
sg33
g3802
sg63
g64
sS'trial_loop.thisIndex'
p5358
g59
(g98
S'{\x00\x00\x00'
tRp5359
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5360
I0
sg3641
g3940
sS'block_loop.thisRepN'
p5361
I1
sg3644
g3802
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5362
I1
sg3646
g3809
sg55
g11
sS'block_loop.thisTrial'
p5363
Nsg69
Vn
sS'block_loop.thisTrialN'
p5364
I0
sg39
F1.1667939153285261
sg34
g752
(S'\x07\xdf\n\x10\x0b\x19\x1b\x07\x08\xc8'
tRp5365
sa(dp5366
S'trial_loop.thisTrialN'
p5367
I124
sg3632
g5009
sS'block_loop.thisIndex'
p5368
g3626
sg38
S'right'
p5369
sg58
g62
sS'trial_loop.thisN'
p5370
I124
sg33
g4318
sg63
g64
sS'trial_loop.thisIndex'
p5371
g59
(g98
S'|\x00\x00\x00'
tRp5372
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5373
I0
sg3641
g5016
sS'block_loop.thisRepN'
p5374
I1
sg3644
g4311
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5375
I1
sg3646
g4318
sg55
g11
sS'block_loop.thisTrial'
p5376
Nsg69
Vn
sS'block_loop.thisTrialN'
p5377
I0
sg39
F0.98352248623632477
sg34
g752
(S'\x07\xdf\n\x10\x0b\x19!\t\xfa\xb0'
tRp5378
sa(dp5379
S'trial_loop.thisTrialN'
p5380
I125
sg3632
g4940
sS'block_loop.thisIndex'
p5381
g3626
sg38
S'left'
p5382
sg58
g62
sS'trial_loop.thisN'
p5383
I125
sg33
g4944
sg63
g64
sS'trial_loop.thisIndex'
p5384
g59
(g98
S'}\x00\x00\x00'
tRp5385
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5386
I0
sg3641
g4948
sS'block_loop.thisRepN'
p5387
I1
sg3644
g4944
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5388
I1
sg3646
g4951
sg55
g11
sS'block_loop.thisTrial'
p5389
Nsg69
Vn
sS'block_loop.thisTrialN'
p5390
I0
sg39
F1.0005488133092513
sg34
g752
(S"\x07\xdf\n\x10\x0b\x19'\nL\xb8"
tRp5391
sa(dp5392
S'trial_loop.thisTrialN'
p5393
I126
sg3632
g4006
sS'block_loop.thisIndex'
p5394
g3626
sg38
S'right'
p5395
sg58
g62
sS'trial_loop.thisN'
p5396
I126
sg33
g3637
sg63
g64
sS'trial_loop.thisIndex'
p5397
g59
(g98
S'~\x00\x00\x00'
tRp5398
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5399
I0
sg3641
g4013
sS'block_loop.thisRepN'
p5400
I1
sg3644
g3637
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5401
I1
sg3646
g3647
sg55
g11
sS'block_loop.thisTrial'
p5402
Nsg69
Vn
sS'block_loop.thisTrialN'
p5403
I0
sg39
F1.0834760723100771
sg34
g752
(S'\x07\xdf\n\x10\x0b\x19-\n\xa2\xa8'
tRp5404
sa(dp5405
S'trial_loop.thisTrialN'
p5406
I127
sg3632
g4096
sS'block_loop.thisIndex'
p5407
g3626
sg38
S'left'
p5408
sg58
g62
sS'trial_loop.thisN'
p5409
I127
sg33
g3836
sg63
g64
sS'trial_loop.thisIndex'
p5410
g59
(g98
S'\x7f\x00\x00\x00'
tRp5411
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5412
I0
sg3641
g4103
sS'block_loop.thisRepN'
p5413
I1
sg3644
g3836
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5414
I1
sg3646
g3843
sg55
g11
sS'block_loop.thisTrial'
p5415
Nsg69
Vn
sS'block_loop.thisTrialN'
p5416
I0
sg39
F1.1335056084444659
sg34
g752
(S'\x07\xdf\n\x10\x0b\x193\x0cc\xe0'
tRp5417
sa(dp5418
S'trial_loop.thisTrialN'
p5419
I128
sg3632
g4633
sS'block_loop.thisIndex'
p5420
g3626
sg38
S'left'
p5421
sg58
g62
sS'trial_loop.thisN'
p5422
I128
sg33
g4449
sg63
g64
sS'trial_loop.thisIndex'
p5423
g59
(g98
S'\x80\x00\x00\x00'
tRp5424
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5425
I0
sg3641
g4640
sS'block_loop.thisRepN'
p5426
I1
sg3644
g4449
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5427
I1
sg3646
g4456
sg55
g11
sS'block_loop.thisTrial'
p5428
Nsg69
Vn
sS'block_loop.thisTrialN'
p5429
I0
sg39
F0.78342344325210433
sg34
g752
(S'\x07\xdf\n\x10\x0b\x199\x0f\x1b0'
tRp5430
sa(dp5431
S'trial_loop.thisTrialN'
p5432
I129
sg3632
g4378
sS'block_loop.thisIndex'
p5433
g3626
sg38
S'left'
p5434
sg58
g62
sS'trial_loop.thisN'
p5435
I129
sg33
g4083
sg63
g64
sS'trial_loop.thisIndex'
p5436
g59
(g98
S'\x81\x00\x00\x00'
tRp5437
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5438
I0
sg3641
g4385
sS'block_loop.thisRepN'
p5439
I1
sg3644
g4083
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5440
I1
sg3646
g4090
sg55
g11
sS'block_loop.thisTrial'
p5441
Nsg69
Vn
sS'block_loop.thisTrialN'
p5442
I0
sg39
F0.66686148351163865
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1a\x03\x0cX('
tRp5443
sa(dp5444
S'trial_loop.thisTrialN'
p5445
I130
sg3632
g3864
sS'block_loop.thisIndex'
p5446
g3626
sg38
S'right'
p5447
sg58
g62
sS'trial_loop.thisN'
p5448
I130
sg33
g3725
sg63
g64
sS'trial_loop.thisIndex'
p5449
g59
(g98
S'\x82\x00\x00\x00'
tRp5450
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5451
I0
sg3641
g3871
sS'block_loop.thisRepN'
p5452
I1
sg3644
g3725
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5453
I1
sg3646
g3732
sg55
g11
sS'block_loop.thisTrial'
p5454
Nsg69
Vn
sS'block_loop.thisTrialN'
p5455
I0
sg39
F1.350327919515621
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1a\t\x07\xac\xd8'
tRp5456
sa(dp5457
S'trial_loop.thisTrialN'
p5458
I131
sg3632
g3670
sS'block_loop.thisIndex'
p5459
g3626
sg38
S'left'
p5460
sg58
g62
sS'trial_loop.thisN'
p5461
I131
sg33
g3674
sg63
g64
sS'trial_loop.thisIndex'
p5462
g59
(g98
S'\x83\x00\x00\x00'
tRp5463
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5464
I0
sg3641
g3678
sS'block_loop.thisRepN'
p5465
I1
sg3644
g3674
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5466
I1
sg3646
g3681
sg55
g11
sS'block_loop.thisTrial'
p5467
Nsg69
Vn
sS'block_loop.thisTrialN'
p5468
I0
sg39
F0.95018058096138702
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1a\x0f\ry8'
tRp5469
sa(dp5470
S'trial_loop.thisTrialN'
p5471
I132
sg3632
g4871
sS'block_loop.thisIndex'
p5472
g3626
sg38
S'right'
p5473
sg58
g62
sS'trial_loop.thisN'
p5474
I132
sg33
g4875
sg63
g64
sS'trial_loop.thisIndex'
p5475
g59
(g98
S'\x84\x00\x00\x00'
tRp5476
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5477
I0
sg3641
g4879
sS'block_loop.thisRepN'
p5478
I1
sg3644
g4875
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5479
I1
sg3646
g4882
sg55
g11
sS'block_loop.thisTrial'
p5480
Nsg69
Vn
sS'block_loop.thisTrialN'
p5481
I0
sg39
F0.73326247702152614
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1a\x15\rV\x10'
tRp5482
sa(dp5483
S'trial_loop.thisTrialN'
p5484
I133
sg3632
g4501
sS'block_loop.thisIndex'
p5485
g3626
sg38
S'left'
p5486
sg58
g62
sS'trial_loop.thisN'
p5487
I133
sg33
g4025
sg63
g64
sS'trial_loop.thisIndex'
p5488
g59
(g98
S'\x85\x00\x00\x00'
tRp5489
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5490
I0
sg3641
g4508
sS'block_loop.thisRepN'
p5491
I1
sg3644
g4025
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5492
I1
sg3646
g4032
sg55
g11
sS'block_loop.thisTrial'
p5493
Nsg69
Vn
sS'block_loop.thisTrialN'
p5494
I0
sg39
F0.83351370522268553
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1a\x1b\t\x9c\xf0'
tRp5495
sa(dp5496
S'trial_loop.thisTrialN'
p5497
I134
sg3632
g3687
sS'block_loop.thisIndex'
p5498
g3626
sg38
S'left'
p5499
sg58
g62
sS'trial_loop.thisN'
p5500
I134
sg33
g3698
sg63
g64
sS'trial_loop.thisIndex'
p5501
g59
(g98
S'\x86\x00\x00\x00'
tRp5502
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5503
I0
sg3641
g3695
sS'block_loop.thisRepN'
p5504
I1
sg3644
g3691
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5505
I1
sg3646
g3698
sg55
g11
sS'block_loop.thisTrial'
p5506
Nsg69
Vn
sS'block_loop.thisTrialN'
p5507
I0
sg39
F0.93358959826309729
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1a!\x07\x91\x80'
tRp5508
sa(dp5509
S'trial_loop.thisTrialN'
p5510
I135
sg3632
g3633
sS'block_loop.thisIndex'
p5511
g3626
sg38
S'left'
p5512
sg58
g62
sS'trial_loop.thisN'
p5513
I135
sg33
g3637
sg63
g64
sS'trial_loop.thisIndex'
p5514
g59
(g98
S'\x87\x00\x00\x00'
tRp5515
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5516
I0
sg3641
g3642
sS'block_loop.thisRepN'
p5517
I1
sg3644
g3637
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5518
I1
sg3646
g3647
sg55
g11
sS'block_loop.thisTrial'
p5519
Nsg69
Vn
sS'block_loop.thisTrialN'
p5520
I0
sg39
F0.80018263366582687
sg34
g752
(S"\x07\xdf\n\x10\x0b\x1a'\x07+\xf0"
tRp5521
sa(dp5522
S'trial_loop.thisTrialN'
p5523
I136
sg3632
g4079
sS'block_loop.thisIndex'
p5524
g3626
sg38
S'right'
p5525
sg58
g62
sS'trial_loop.thisN'
p5526
I136
sg33
g4090
sg63
g64
sS'trial_loop.thisIndex'
p5527
g59
(g98
S'\x88\x00\x00\x00'
tRp5528
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5529
I0
sg3641
g4087
sS'block_loop.thisRepN'
p5530
I1
sg3644
g4083
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5531
I1
sg3646
g4090
sg55
g11
sS'block_loop.thisTrial'
p5532
Nsg69
Vn
sS'block_loop.thisTrialN'
p5533
I0
sg39
F0.7502260825731355
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1a-\x04\xa7h'
tRp5534
sa(dp5535
S'trial_loop.thisTrialN'
p5536
I137
sg3632
g4307
sS'block_loop.thisIndex'
p5537
g3626
sg38
S'left'
p5538
sg58
g62
sS'trial_loop.thisN'
p5539
I137
sg33
g4311
sg63
g64
sS'trial_loop.thisIndex'
p5540
g59
(g98
S'\x89\x00\x00\x00'
tRp5541
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5542
I0
sg3641
g4315
sS'block_loop.thisRepN'
p5543
I1
sg3644
g4311
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5544
I1
sg3646
g4318
sg55
g11
sS'block_loop.thisTrial'
p5545
Nsg69
Vn
sS'block_loop.thisTrialN'
p5546
I0
sg39
F0.81686997942688322
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1a3\x01g`'
tRp5547
sa(dp5548
S'trial_loop.thisTrialN'
p5549
I138
sg3632
g5169
sS'block_loop.thisIndex'
p5550
g3626
sg38
S'right'
p5551
sg58
g62
sS'trial_loop.thisN'
p5552
I138
sg33
g4875
sg63
g64
sS'trial_loop.thisIndex'
p5553
g59
(g98
S'\x8a\x00\x00\x00'
tRp5554
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5555
I0
sg3641
g5176
sS'block_loop.thisRepN'
p5556
I1
sg3644
g4875
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5557
I1
sg3646
g4882
sg55
g11
sS'block_loop.thisTrial'
p5558
Nsg69
Vn
sS'block_loop.thisTrialN'
p5559
I0
sg39
F0.69994794113790704
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1a8\x0e_\xb0'
tRp5560
sa(dp5561
S'trial_loop.thisTrialN'
p5562
I139
sg3632
g4038
sS'block_loop.thisIndex'
p5563
g3626
sg38
S'right'
p5564
sg58
g62
sS'trial_loop.thisN'
p5565
I139
sg33
g3698
sg63
g64
sS'trial_loop.thisIndex'
p5566
g59
(g98
S'\x8b\x00\x00\x00'
tRp5567
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5568
I0
sg3641
g4045
sS'block_loop.thisRepN'
p5569
I1
sg3644
g3691
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5570
I1
sg3646
g3698
sg55
g11
sS'block_loop.thisTrial'
p5571
Nsg69
Vn
sS'block_loop.thisTrialN'
p5572
I0
sg39
F0.71686165457140305
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1b\x02\n1`'
tRp5573
sa(dp5574
S'trial_loop.thisTrialN'
p5575
I140
sg3632
g3768
sS'block_loop.thisIndex'
p5576
g3626
sg38
S'left'
p5577
sg58
g62
sS'trial_loop.thisN'
p5578
I140
sg33
g3772
sg63
g64
sS'trial_loop.thisIndex'
p5579
g59
(g98
S'\x8c\x00\x00\x00'
tRp5580
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5581
I0
sg3641
g3776
sS'block_loop.thisRepN'
p5582
I1
sg3644
g3772
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5583
I1
sg3646
g3779
sg55
g11
sS'block_loop.thisTrial'
p5584
Nsg69
Vn
sS'block_loop.thisTrialN'
p5585
I0
sg39
F0.83330273283354472
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1b\x08\x06x@'
tRp5586
sa(dp5587
S'trial_loop.thisTrialN'
p5588
I141
sg3632
g4633
sS'block_loop.thisIndex'
p5589
g3626
sg38
S'left'
p5590
sg58
g62
sS'trial_loop.thisN'
p5591
I141
sg33
g4449
sg63
g64
sS'trial_loop.thisIndex'
p5592
g59
(g98
S'\x8d\x00\x00\x00'
tRp5593
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5594
I0
sg3641
g4640
sS'block_loop.thisRepN'
p5595
I1
sg3644
g4449
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5596
I1
sg3646
g4456
sg55
g11
sS'block_loop.thisTrial'
p5597
Nsg69
Vn
sS'block_loop.thisTrialN'
p5598
I0
sg39
F0.75018160731360695
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1b\x0e\x04l\xd0'
tRp5599
sa(dp5600
S'trial_loop.thisTrialN'
p5601
I142
sg3632
g3798
sS'block_loop.thisIndex'
p5602
g3626
sg38
S'left'
p5603
sg58
g62
sS'trial_loop.thisN'
p5604
I142
sg33
g3802
sg63
g64
sS'trial_loop.thisIndex'
p5605
g59
(g98
S'\x8e\x00\x00\x00'
tRp5606
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5607
I0
sg3641
g3806
sS'block_loop.thisRepN'
p5608
I1
sg3644
g3802
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5609
I1
sg3646
g3809
sg55
g11
sS'block_loop.thisTrial'
p5610
Nsg69
Vn
sS'block_loop.thisTrialN'
p5611
I0
sg39
F1.1338748101252349
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1b\x14\x00\xf20'
tRp5612
sa(dp5613
S'trial_loop.thisTrialN'
p5614
I143
sg3632
g4445
sS'block_loop.thisIndex'
p5615
g3626
sg38
S'right'
p5616
sg58
g62
sS'trial_loop.thisN'
p5617
I143
sg33
g4449
sg63
g64
sS'trial_loop.thisIndex'
p5618
g59
(g98
S'\x8f\x00\x00\x00'
tRp5619
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5620
I0
sg3641
g4453
sS'block_loop.thisRepN'
p5621
I1
sg3644
g4449
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5622
I1
sg3646
g4456
sg55
g11
sS'block_loop.thisTrial'
p5623
Nsg69
Vn
sS'block_loop.thisTrialN'
p5624
I0
sg39
F0.98345634354063804
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1b\x1a\x03\xa5\x98'
tRp5625
sa(dp5626
S'trial_loop.thisTrialN'
p5627
I144
sg3632
g5327
sS'block_loop.thisIndex'
p5628
g3626
sg38
S'right'
p5629
sg58
g62
sS'trial_loop.thisN'
p5630
I144
sg33
g4128
sg63
g64
sS'trial_loop.thisIndex'
p5631
g59
(g98
S'\x90\x00\x00\x00'
tRp5632
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5633
I0
sg3641
g5334
sS'block_loop.thisRepN'
p5634
I1
sg3644
g4128
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5635
I1
sg3646
g4135
sg55
g11
sS'block_loop.thisTrial'
p5636
Nsg69
Vn
sS'block_loop.thisTrialN'
p5637
I0
sg39
F1.1834587383618782
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1b \x03\xbd\x08'
tRp5638
sa(dp5639
S'trial_loop.thisTrialN'
p5640
I145
sg3632
g3892
sS'block_loop.thisIndex'
p5641
g3626
sg38
S'right'
p5642
sg58
g62
sS'trial_loop.thisN'
p5643
I145
sg33
g3681
sg63
g64
sS'trial_loop.thisIndex'
p5644
g59
(g98
S'\x91\x00\x00\x00'
tRp5645
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5646
I0
sg3641
g3899
sS'block_loop.thisRepN'
p5647
I1
sg3644
g3674
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5648
I1
sg3646
g3681
sg55
g11
sS'block_loop.thisTrial'
p5649
Nsg69
Vn
sS'block_loop.thisTrialN'
p5650
I0
sg39
F0.93350406891568127
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1b&\x07+\xf0'
tRp5651
sa(dp5652
S'trial_loop.thisTrialN'
p5653
I146
sg3632
g4940
sS'block_loop.thisIndex'
p5654
g3626
sg38
S'left'
p5655
sg58
g62
sS'trial_loop.thisN'
p5656
I146
sg33
g4944
sg63
g64
sS'trial_loop.thisIndex'
p5657
g59
(g98
S'\x92\x00\x00\x00'
tRp5658
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5659
I0
sg3641
g4948
sS'block_loop.thisRepN'
p5660
I1
sg3644
g4944
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5661
I1
sg3646
g4951
sg55
g11
sS'block_loop.thisTrial'
p5662
Nsg69
Vn
sS'block_loop.thisTrialN'
p5663
I0
sg39
F1.2001817213522372
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1b,\x06\x8b\xc8'
tRp5664
sa(dp5665
S'trial_loop.thisTrialN'
p5666
I147
sg3632
g5327
sS'block_loop.thisIndex'
p5667
g3626
sg38
S'right'
p5668
sg58
g62
sS'trial_loop.thisN'
p5669
I147
sg33
g4128
sg63
g64
sS'trial_loop.thisIndex'
p5670
g59
(g98
S'\x93\x00\x00\x00'
tRp5671
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5672
I0
sg3641
g5334
sS'block_loop.thisRepN'
p5673
I1
sg3644
g4128
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5674
I1
sg3646
g4135
sg55
g11
sS'block_loop.thisTrial'
p5675
Nsg69
Vn
sS'block_loop.thisTrialN'
p5676
I0
sg39
F1.100540032295612
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1b2\n5H'
tRp5677
sa(dp5678
S'trial_loop.thisTrialN'
p5679
I148
sg3632
g4445
sS'block_loop.thisIndex'
p5680
g3626
sg38
S'right'
p5681
sg58
g62
sS'trial_loop.thisN'
p5682
I148
sg33
g4449
sg63
g64
sS'trial_loop.thisIndex'
p5683
g59
(g98
S'\x94\x00\x00\x00'
tRp5684
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5685
I0
sg3641
g4453
sS'block_loop.thisRepN'
p5686
I1
sg3644
g4449
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5687
I1
sg3646
g4456
sg55
g11
sS'block_loop.thisTrial'
p5688
Nsg69
Vn
sS'block_loop.thisTrialN'
p5689
I0
sg39
F1.5002052704321613
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1b8\x0c5\x00'
tRp5690
sa(dp5691
S'trial_loop.thisTrialN'
p5692
I149
sg3632
g3864
sS'block_loop.thisIndex'
p5693
g3626
sg38
S'right'
p5694
sg58
g62
sS'trial_loop.thisN'
p5695
I149
sg33
g3725
sg63
g64
sS'trial_loop.thisIndex'
p5696
g59
(g98
S'\x95\x00\x00\x00'
tRp5697
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5698
I0
sg3641
g3871
sS'block_loop.thisRepN'
p5699
I1
sg3644
g3725
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5700
I1
sg3646
g3732
sg55
g11
sS'block_loop.thisTrial'
p5701
Nsg69
Vn
sS'block_loop.thisTrialN'
p5702
I0
sg39
F1.1001235043768247
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1c\x03\x05 \x80'
tRp5703
sa(dp5704
S'trial_loop.thisTrialN'
p5705
I150
sg3632
g3633
sS'block_loop.thisIndex'
p5706
g3626
sg38
S'left'
p5707
sg58
g62
sS'trial_loop.thisN'
p5708
I150
sg33
g3637
sg63
g64
sS'trial_loop.thisIndex'
p5709
g59
(g98
S'\x96\x00\x00\x00'
tRp5710
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5711
I0
sg3641
g3642
sS'block_loop.thisRepN'
p5712
I1
sg3644
g3637
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5713
I1
sg3646
g3647
sg55
g11
sS'block_loop.thisTrial'
p5714
Nsg69
Vn
sS'block_loop.thisTrialN'
p5715
I0
sg39
F1.08353166638517
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1c\t\x07 8'
tRp5716
sa(dp5717
S'trial_loop.thisTrialN'
p5718
I151
sg3632
g5169
sS'block_loop.thisIndex'
p5719
g3626
sg38
S'left'
p5720
sg58
g62
sS'trial_loop.thisN'
p5721
I151
sg33
g4882
sg63
g64
sS'trial_loop.thisIndex'
p5722
g59
(g98
S'\x97\x00\x00\x00'
tRp5723
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5724
I0
sg3641
g5176
sS'block_loop.thisRepN'
p5725
I1
sg3644
g4875
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5726
I1
sg3646
g4882
sg55
g11
sS'block_loop.thisTrial'
p5727
Nsg69
Vn
sS'block_loop.thisTrialN'
p5728
I0
sg39
F1.1332715431317411
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1c\x0f\x08\xe1p'
tRp5729
sa(dp5730
S'trial_loop.thisTrialN'
p5731
I152
sg3632
g4674
sS'block_loop.thisIndex'
p5732
g3626
sg38
S'right'
p5733
sg58
g62
sS'trial_loop.thisN'
p5734
I152
sg33
g3714
sg63
g64
sS'trial_loop.thisIndex'
p5735
g59
(g98
S'\x98\x00\x00\x00'
tRp5736
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5737
I0
sg3641
g4681
sS'block_loop.thisRepN'
p5738
I1
sg3644
g3714
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5739
I1
sg3646
g3708
sg55
g11
sS'block_loop.thisTrial'
p5740
Nsg69
Vn
sS'block_loop.thisTrialN'
p5741
I0
sg39
F0.91697438225037331
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1c\x15\x0bZ@'
tRp5742
sa(dp5743
S'trial_loop.thisTrialN'
p5744
I153
sg3632
g4038
sS'block_loop.thisIndex'
p5745
g3626
sg38
S'right'
p5746
sg58
g62
sS'trial_loop.thisN'
p5747
I153
sg33
g3691
sg63
g64
sS'trial_loop.thisIndex'
p5748
g59
(g98
S'\x99\x00\x00\x00'
tRp5749
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5750
I0
sg3641
g4045
sS'block_loop.thisRepN'
p5751
I1
sg3644
g3691
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5752
I1
sg3646
g3698
sg55
g11
sS'block_loop.thisTrial'
p5753
Nsg69
Vn
sS'block_loop.thisTrialN'
p5754
I0
sg39
F0.85008701185597602
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1c\x1b\n\xba\x18'
tRp5755
sa(dp5756
S'trial_loop.thisTrialN'
p5757
I154
sg3632
g4124
sS'block_loop.thisIndex'
p5758
g3626
sg38
S'left'
p5759
sg58
g62
sS'trial_loop.thisN'
p5760
I154
sg33
g4128
sg63
g64
sS'trial_loop.thisIndex'
p5761
g59
(g98
S'\x9a\x00\x00\x00'
tRp5762
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5763
I0
sg3641
g4132
sS'block_loop.thisRepN'
p5764
I1
sg3644
g4128
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5765
I1
sg3646
g4135
sg55
g11
sS'block_loop.thisTrial'
p5766
Nsg69
Vn
sS'block_loop.thisTrialN'
p5767
I0
sg39
F1.116737579997789
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1c!\x08\xed('
tRp5768
sa(dp5769
S'trial_loop.thisTrialN'
p5770
I155
sg3632
g5009
sS'block_loop.thisIndex'
p5771
g3626
sg38
S'right'
p5772
sg58
g62
sS'trial_loop.thisN'
p5773
I155
sg33
g4311
sg63
g64
sS'trial_loop.thisIndex'
p5774
g59
(g98
S'\x9b\x00\x00\x00'
tRp5775
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5776
I0
sg3641
g5016
sS'block_loop.thisRepN'
p5777
I1
sg3644
g4311
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5778
I1
sg3646
g4318
sg55
g11
sS'block_loop.thisTrial'
p5779
Nsg69
Vn
sS'block_loop.thisTrialN'
p5780
I0
sg39
F0.90010514407731534
sg34
g752
(S"\x07\xdf\n\x10\x0b\x1c'\x0b'x"
tRp5781
sa(dp5782
S'trial_loop.thisTrialN'
p5783
I156
sg3632
g3798
sS'block_loop.thisIndex'
p5784
g3626
sg38
S'left'
p5785
sg58
g62
sS'trial_loop.thisN'
p5786
I156
sg33
g3809
sg63
g64
sS'trial_loop.thisIndex'
p5787
g59
(g98
S'\x9c\x00\x00\x00'
tRp5788
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5789
I0
sg3641
g3806
sS'block_loop.thisRepN'
p5790
I1
sg3644
g3802
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5791
I1
sg3646
g3809
sg55
g11
sS'block_loop.thisTrial'
p5792
Nsg69
Vn
sS'block_loop.thisTrialN'
p5793
I0
sg39
F0.78354375453272951
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1c-\nL\xb8'
tRp5794
sa(dp5795
S'trial_loop.thisTrialN'
p5796
I157
sg3632
g3892
sS'block_loop.thisIndex'
p5797
g3626
sg38
S'right'
p5798
sg58
g62
sS'trial_loop.thisN'
p5799
I157
sg33
g3681
sg63
g64
sS'trial_loop.thisIndex'
p5800
g59
(g98
S'\x9d\x00\x00\x00'
tRp5801
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5802
I0
sg3641
g3899
sS'block_loop.thisRepN'
p5803
I1
sg3644
g3674
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5804
I1
sg3646
g3681
sg55
g11
sS'block_loop.thisTrial'
p5805
Nsg69
Vn
sS'block_loop.thisTrialN'
p5806
I0
sg39
F0.8667814850632567
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1c3\x07K0'
tRp5807
sa(dp5808
S'trial_loop.thisTrialN'
p5809
I158
sg3632
g4871
sS'block_loop.thisIndex'
p5810
g3626
sg38
S'right'
p5811
sg58
g62
sS'trial_loop.thisN'
p5812
I158
sg33
g4875
sg63
g64
sS'trial_loop.thisIndex'
p5813
g59
(g98
S'\x9e\x00\x00\x00'
tRp5814
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5815
I0
sg3641
g4879
sS'block_loop.thisRepN'
p5816
I1
sg3644
g4875
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5817
I1
sg3646
g4882
sg55
g11
sS'block_loop.thisTrial'
p5818
Nsg69
Vn
sS'block_loop.thisTrialN'
p5819
I0
sg39
F0.74998346432676044
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1c9\x05\xf3p'
tRp5820
sa(dp5821
S'trial_loop.thisTrialN'
p5822
I159
sg3632
g3653
sS'block_loop.thisIndex'
p5823
g3626
sg38
S'left'
p5824
sg58
g62
sS'trial_loop.thisN'
p5825
I159
sg33
g3663
sg63
g64
sS'trial_loop.thisIndex'
p5826
g59
(g98
S'\x9f\x00\x00\x00'
tRp5827
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5828
I0
sg3641
g3661
sS'block_loop.thisRepN'
p5829
I1
sg3644
g3663
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5830
I1
sg3646
g3657
sg55
g11
sS'block_loop.thisTrial'
p5831
Nsg69
Vn
sS'block_loop.thisTrialN'
p5832
I0
sg39
F1.1834322242648341
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1d\x03\x02x\xd0'
tRp5833
sa(dp5834
S'trial_loop.thisTrialN'
p5835
I160
sg3632
g5327
sS'block_loop.thisIndex'
p5836
g3626
sg38
S'right'
p5837
sg58
g62
sS'trial_loop.thisN'
p5838
I160
sg33
g4128
sg63
g64
sS'trial_loop.thisIndex'
p5839
g59
(g98
S'\xa0\x00\x00\x00'
tRp5840
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5841
I0
sg3641
g5334
sS'block_loop.thisRepN'
p5842
I1
sg3644
g4128
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5843
I1
sg3646
g4135
sg55
g11
sS'block_loop.thisTrial'
p5844
Nsg69
Vn
sS'block_loop.thisTrialN'
p5845
I0
sg39
F0.78337469152393169
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1d\t\x05\xe7\xb8'
tRp5846
sa(dp5847
S'trial_loop.thisTrialN'
p5848
I161
sg3632
g4633
sS'block_loop.thisIndex'
p5849
g3626
sg38
S'left'
p5850
sg58
g62
sS'trial_loop.thisN'
p5851
I161
sg33
g4449
sg63
g64
sS'trial_loop.thisIndex'
p5852
g59
(g98
S'\xa1\x00\x00\x00'
tRp5853
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5854
I0
sg3641
g4640
sS'block_loop.thisRepN'
p5855
I1
sg3644
g4449
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5856
I1
sg3646
g4456
sg55
g11
sS'block_loop.thisTrial'
p5857
Nsg69
Vn
sS'block_loop.thisTrialN'
p5858
I0
sg39
F0.7668763656183728
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1d\x0f\x03 \xc8'
tRp5859
sa(dp5860
S'trial_loop.thisTrialN'
p5861
I162
sg3632
g4307
sS'block_loop.thisIndex'
p5862
g3626
sg38
S'left'
p5863
sg58
g62
sS'trial_loop.thisN'
p5864
I162
sg33
g4311
sg63
g64
sS'trial_loop.thisIndex'
p5865
g59
(g98
S'\xa2\x00\x00\x00'
tRp5866
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5867
I0
sg3641
g4315
sS'block_loop.thisRepN'
p5868
I1
sg3644
g4311
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5869
I1
sg3646
g4318
sg55
g11
sS'block_loop.thisTrial'
p5870
Nsg69
Vn
sS'block_loop.thisTrialN'
p5871
I0
sg39
F0.85011067497453041
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1d\x15\x00#('
tRp5872
sa(dp5873
S'trial_loop.thisTrialN'
p5874
I163
sg3632
g4378
sS'block_loop.thisIndex'
p5875
g3626
sg38
S'left'
p5876
sg58
g62
sS'trial_loop.thisN'
p5877
I163
sg33
g4083
sg63
g64
sS'trial_loop.thisIndex'
p5878
g59
(g98
S'\xa3\x00\x00\x00'
tRp5879
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5880
I0
sg3641
g4385
sS'block_loop.thisRepN'
p5881
I1
sg3644
g4083
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5882
I1
sg3646
g4090
sg55
g11
sS'block_loop.thisTrial'
p5883
Nsg69
Vn
sS'block_loop.thisTrialN'
p5884
I0
sg39
F0.83346523859290755
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1d\x1a\r\x94\x90'
tRp5885
sa(dp5886
S'trial_loop.thisTrialN'
p5887
I164
sg3632
g5009
sS'block_loop.thisIndex'
p5888
g3626
sg38
S'right'
p5889
sg58
g62
sS'trial_loop.thisN'
p5890
I164
sg33
g4311
sg63
g64
sS'trial_loop.thisIndex'
p5891
g59
(g98
S'\xa4\x00\x00\x00'
tRp5892
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5893
I0
sg3641
g5016
sS'block_loop.thisRepN'
p5894
I1
sg3644
g4311
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5895
I1
sg3646
g4318
sg55
g11
sS'block_loop.thisTrial'
p5896
Nsg69
Vn
sS'block_loop.thisTrialN'
p5897
I0
sg39
F0.78354289923936449
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1d \x0b\x858'
tRp5898
sa(dp5899
S'trial_loop.thisTrialN'
p5900
I165
sg3632
g3991
sS'block_loop.thisIndex'
p5901
g3626
sg38
S'left'
p5902
sg58
g62
sS'trial_loop.thisN'
p5903
I165
sg33
g3819
sg63
g64
sS'trial_loop.thisIndex'
p5904
g59
(g98
S'\xa5\x00\x00\x00'
tRp5905
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5906
I0
sg3641
g3998
sS'block_loop.thisRepN'
p5907
I1
sg3644
g3819
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5908
I1
sg3646
g3826
sg55
g11
sS'block_loop.thisTrial'
p5909
Nsg69
Vn
sS'block_loop.thisTrialN'
p5910
I0
sg39
F1.3501334828006293
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1d&\x08\xc20'
tRp5911
sa(dp5912
S'trial_loop.thisTrialN'
p5913
I166
sg3632
g4021
sS'block_loop.thisIndex'
p5914
g3626
sg38
S'right'
p5915
sg58
g62
sS'trial_loop.thisN'
p5916
I166
sg33
g4025
sg63
g64
sS'trial_loop.thisIndex'
p5917
g59
(g98
S'\xa6\x00\x00\x00'
tRp5918
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5919
I0
sg3641
g4029
sS'block_loop.thisRepN'
p5920
I1
sg3644
g4025
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5921
I1
sg3646
g4032
sg55
g11
sS'block_loop.thisTrial'
p5922
Nsg69
Vn
sS'block_loop.thisTrialN'
p5923
I0
sg39
F0.80009738941680553
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1d,\x0e\x92x'
tRp5924
sa(dp5925
S'trial_loop.thisTrialN'
p5926
I167
sg3632
g5327
sS'block_loop.thisIndex'
p5927
g3626
sg38
S'right'
p5928
sg58
g62
sS'trial_loop.thisN'
p5929
I167
sg33
g4135
sg63
g64
sS'trial_loop.thisIndex'
p5930
g59
(g98
S'\xa7\x00\x00\x00'
tRp5931
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5932
I0
sg3641
g5334
sS'block_loop.thisRepN'
p5933
I1
sg3644
g4128
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5934
I1
sg3646
g4135
sg55
g11
sS'block_loop.thisTrial'
p5935
Nsg69
Vn
sS'block_loop.thisTrialN'
p5936
I0
sg39
F0.88351131040053588
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1d2\x0c\n\x08'
tRp5937
sa(dp5938
S'trial_loop.thisTrialN'
p5939
I168
sg3632
g4940
sS'block_loop.thisIndex'
p5940
g3626
sg38
S'left'
p5941
sg58
g62
sS'trial_loop.thisN'
p5942
I168
sg33
g4944
sg63
g64
sS'trial_loop.thisIndex'
p5943
g59
(g98
S'\xa8\x00\x00\x00'
tRp5944
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5945
I0
sg3641
g4948
sS'block_loop.thisRepN'
p5946
I1
sg3644
g4944
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5947
I1
sg3646
g4951
sg55
g11
sS'block_loop.thisTrial'
p5948
Nsg69
Vn
sS'block_loop.thisTrialN'
p5949
I0
sg39
F1.0669204417417859
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1d8\n\xb2H'
tRp5950
sa(dp5951
S'trial_loop.thisTrialN'
p5952
I169
sg3632
g4124
sS'block_loop.thisIndex'
p5953
g3626
sg38
S'left'
p5954
sg58
g62
sS'trial_loop.thisN'
p5955
I169
sg33
g4128
sg63
g64
sS'trial_loop.thisIndex'
p5956
g59
(g98
S'\xa9\x00\x00\x00'
tRp5957
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5958
I0
sg3641
g4132
sS'block_loop.thisRepN'
p5959
I1
sg3644
g4128
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5960
I1
sg3646
g4135
sg55
g11
sS'block_loop.thisTrial'
p5961
Nsg69
Vn
sS'block_loop.thisTrialN'
p5962
I0
sg39
F0.86723479060219688
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1e\x02\x0c8\xe8'
tRp5963
sa(dp5964
S'trial_loop.thisTrialN'
p5965
I170
sg3632
g5115
sS'block_loop.thisIndex'
p5966
g3626
sg38
S'right'
p5967
sg58
g62
sS'trial_loop.thisN'
p5968
I170
sg33
g4944
sg63
g64
sS'trial_loop.thisIndex'
p5969
g59
(g98
S'\xaa\x00\x00\x00'
tRp5970
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5971
I0
sg3641
g5122
sS'block_loop.thisRepN'
p5972
I1
sg3644
g4944
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5973
I1
sg3646
g4951
sg55
g11
sS'block_loop.thisTrial'
p5974
Nsg69
Vn
sS'block_loop.thisTrialN'
p5975
I0
sg39
F2.5666983505379903
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1e\x08\n\xa6\x90'
tRp5976
sa(dp5977
S'trial_loop.thisTrialN'
p5978
I171
sg3632
g4350
sS'block_loop.thisIndex'
p5979
g3626
sg38
S'left'
p5980
sg58
g62
sS'trial_loop.thisN'
p5981
I171
sg33
g4221
sg63
g64
sS'trial_loop.thisIndex'
p5982
g59
(g98
S'\xab\x00\x00\x00'
tRp5983
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5984
I0
sg3641
g4357
sS'block_loop.thisRepN'
p5985
I1
sg3644
g4214
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5986
I1
sg3646
g4221
sg55
g11
sS'block_loop.thisTrial'
p5987
Nsg69
Vn
sS'block_loop.thisTrialN'
p5988
I0
sg39
F0.80010366156875534
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1e\x10\x04\x80X'
tRp5989
sa(dp5990
S'trial_loop.thisTrialN'
p5991
I172
sg3632
g4674
sS'block_loop.thisIndex'
p5992
g3626
sg38
S'right'
p5993
sg58
g62
sS'trial_loop.thisN'
p5994
I172
sg33
g3714
sg63
g64
sS'trial_loop.thisIndex'
p5995
g59
(g98
S'\xac\x00\x00\x00'
tRp5996
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p5997
I0
sg3641
g4681
sS'block_loop.thisRepN'
p5998
I1
sg3644
g3714
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p5999
I1
sg3646
g3708
sg55
g11
sS'block_loop.thisTrial'
p6000
Nsg69
Vn
sS'block_loop.thisTrialN'
p6001
I0
sg39
F0.80017237014362763
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1e\x16\x01\xfb\xd0'
tRp6002
sa(dp6003
S'trial_loop.thisTrialN'
p6004
I173
sg3632
g5115
sS'block_loop.thisIndex'
p6005
g3626
sg38
S'right'
p6006
sg58
g62
sS'trial_loop.thisN'
p6007
I173
sg33
g4944
sg63
g64
sS'trial_loop.thisIndex'
p6008
g59
(g98
S'\xad\x00\x00\x00'
tRp6009
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6010
I0
sg3641
g5122
sS'block_loop.thisRepN'
p6011
I1
sg3644
g4944
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6012
I1
sg3646
g4951
sg55
g11
sS'block_loop.thisTrial'
p6013
Nsg69
Vn
sS'block_loop.thisTrialN'
p6014
I0
sg39
F0.86687186107337766
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1e\x1b\x0e\xb5\xa0'
tRp6015
sa(dp6016
S'trial_loop.thisTrialN'
p6017
I174
sg3632
g5169
sS'block_loop.thisIndex'
p6018
g3626
sg38
S'left'
p6019
sg58
g62
sS'trial_loop.thisN'
p6020
I174
sg33
g4875
sg63
g64
sS'trial_loop.thisIndex'
p6021
g59
(g98
S'\xae\x00\x00\x00'
tRp6022
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6023
I0
sg3641
g5176
sS'block_loop.thisRepN'
p6024
I1
sg3644
g4875
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6025
I1
sg3646
g4882
sg55
g11
sS'block_loop.thisTrial'
p6026
Nsg69
Vn
sS'block_loop.thisTrialN'
p6027
I0
sg39
F0.84969329176237807
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1e!\r#H'
tRp6028
sa(dp6029
S'trial_loop.thisTrialN'
p6030
I175
sg3632
g4940
sS'block_loop.thisIndex'
p6031
g3626
sg38
S'left'
p6032
sg58
g62
sS'trial_loop.thisN'
p6033
I175
sg33
g4944
sg63
g64
sS'trial_loop.thisIndex'
p6034
g59
(g98
S'\xaf\x00\x00\x00'
tRp6035
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6036
I0
sg3641
g4948
sS'block_loop.thisRepN'
p6037
I1
sg3644
g4944
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6038
I1
sg3646
g4951
sg55
g11
sS'block_loop.thisTrial'
p6039
Nsg69
Vn
sS'block_loop.thisTrialN'
p6040
I0
sg39
F0.83353138128677529
sg34
g752
(S"\x07\xdf\n\x10\x0b\x1e'\x0b\x90\xf0"
tRp6041
sa(dp6042
S'trial_loop.thisTrialN'
p6043
I176
sg3632
g3670
sS'block_loop.thisIndex'
p6044
g3626
sg38
S'left'
p6045
sg58
g62
sS'trial_loop.thisN'
p6046
I176
sg33
g3674
sg63
g64
sS'trial_loop.thisIndex'
p6047
g59
(g98
S'\xb0\x00\x00\x00'
tRp6048
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6049
I0
sg3641
g3678
sS'block_loop.thisRepN'
p6050
I1
sg3644
g3674
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6051
I1
sg3646
g3681
sg55
g11
sS'block_loop.thisTrial'
p6052
Nsg69
Vn
sS'block_loop.thisTrialN'
p6053
I0
sg39
F1.0000989289446807
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1e-\t\x81\x98'
tRp6054
sa(dp6055
S'trial_loop.thisTrialN'
p6056
I177
sg3632
g4674
sS'block_loop.thisIndex'
p6057
g3626
sg38
S'right'
p6058
sg58
g62
sS'trial_loop.thisN'
p6059
I177
sg33
g3714
sg63
g64
sS'trial_loop.thisIndex'
p6060
g59
(g98
S'\xb1\x00\x00\x00'
tRp6061
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6062
I0
sg3641
g4681
sS'block_loop.thisRepN'
p6063
I1
sg3644
g3714
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6064
I1
sg3646
g3708
sg55
g11
sS'block_loop.thisTrial'
p6065
Nsg69
Vn
sS'block_loop.thisTrialN'
p6066
I0
sg39
F0.9668804710272525
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1e3\t\xd7\x88'
tRp6067
sa(dp6068
S'trial_loop.thisTrialN'
p6069
I178
sg3632
g4210
sS'block_loop.thisIndex'
p6070
g3626
sg38
S'right'
p6071
sg58
g62
sS'trial_loop.thisN'
p6072
I178
sg33
g4214
sg63
g64
sS'trial_loop.thisIndex'
p6073
g59
(g98
S'\xb2\x00\x00\x00'
tRp6074
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6075
I0
sg3641
g4218
sS'block_loop.thisRepN'
p6076
I1
sg3644
g4214
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6077
I1
sg3646
g4221
sg55
g11
sS'block_loop.thisTrial'
p6078
Nsg69
Vn
sS'block_loop.thisTrialN'
p6079
I0
sg39
F0.9168309780452546
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1e9\t\xee\xf8'
tRp6080
sa(dp6081
S'trial_loop.thisTrialN'
p6082
I179
sg3632
g3751
sS'block_loop.thisIndex'
p6083
g3626
sg38
S'right'
p6084
sg58
g62
sS'trial_loop.thisN'
p6085
I179
sg33
g3755
sg63
g64
sS'trial_loop.thisIndex'
p6086
g59
(g98
S'\xb3\x00\x00\x00'
tRp6087
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6088
I0
sg3641
g3759
sS'block_loop.thisRepN'
p6089
I1
sg3644
g3761
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6090
I1
sg3646
g3755
sg55
g11
sS'block_loop.thisTrial'
p6091
Nsg69
Vn
sS'block_loop.thisTrialN'
p6092
I0
sg39
F1.1000756079429266
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1f\x03\t\x10P'
tRp6093
sa(dp6094
S'trial_loop.thisTrialN'
p6095
I180
sg3632
g3815
sS'block_loop.thisIndex'
p6096
g3626
sg38
S'right'
p6097
sg58
g62
sS'trial_loop.thisN'
p6098
I180
sg33
g3819
sg63
g64
sS'trial_loop.thisIndex'
p6099
g59
(g98
S'\xb4\x00\x00\x00'
tRp6100
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6101
I0
sg3641
g3823
sS'block_loop.thisRepN'
p6102
I1
sg3644
g3819
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6103
I1
sg3646
g3826
sg55
g11
sS'block_loop.thisTrial'
p6104
Nsg69
Vn
sS'block_loop.thisTrialN'
p6105
I0
sg39
F1.0668557245362535
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1f\t\x0bN\x88'
tRp6106
sa(dp6107
S'trial_loop.thisTrialN'
p6108
I181
sg3632
g3670
sS'block_loop.thisIndex'
p6109
g3626
sg38
S'left'
p6110
sg58
g62
sS'trial_loop.thisN'
p6111
I181
sg33
g3674
sg63
g64
sS'trial_loop.thisIndex'
p6112
g59
(g98
S'\xb5\x00\x00\x00'
tRp6113
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6114
I0
sg3641
g3678
sS'block_loop.thisRepN'
p6115
I1
sg3644
g3674
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6116
I1
sg3646
g3681
sg55
g11
sS'block_loop.thisTrial'
p6117
Nsg69
Vn
sS'block_loop.thisTrialN'
p6118
I0
sg39
F0.9668536718318137
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1f\x0f\x0c\xd1@'
tRp6119
sa(dp6120
S'trial_loop.thisTrialN'
p6121
I182
sg3632
g4021
sS'block_loop.thisIndex'
p6122
g3626
sg38
S'right'
p6123
sg58
g62
sS'trial_loop.thisN'
p6124
I182
sg33
g4025
sg63
g64
sS'trial_loop.thisIndex'
p6125
g59
(g98
S'\xb6\x00\x00\x00'
tRp6126
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6127
I0
sg3641
g4029
sS'block_loop.thisRepN'
p6128
I1
sg3644
g4025
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6129
I1
sg3646
g4032
sg55
g11
sS'block_loop.thisTrial'
p6130
Nsg69
Vn
sS'block_loop.thisTrialN'
p6131
I0
sg39
F1.0001821775085773
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1f\x15\x0c\xae\x18'
tRp6132
sa(dp6133
S'trial_loop.thisTrialN'
p6134
I183
sg3632
g5115
sS'block_loop.thisIndex'
p6135
g3626
sg38
S'right'
p6136
sg58
g62
sS'trial_loop.thisN'
p6137
I183
sg33
g4944
sg63
g64
sS'trial_loop.thisIndex'
p6138
g59
(g98
S'\xb7\x00\x00\x00'
tRp6139
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6140
I0
sg3641
g5122
sS'block_loop.thisRepN'
p6141
I1
sg3644
g4944
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6142
I1
sg3646
g4951
sg55
g11
sS'block_loop.thisTrial'
p6143
Nsg69
Vn
sS'block_loop.thisTrialN'
p6144
I0
sg39
F2.4834275486600745
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1f\x1b\r>\xa0'
tRp6145
sa(dp6146
S'trial_loop.thisTrialN'
p6147
I184
sg3632
g4674
sS'block_loop.thisIndex'
p6148
g3626
sg38
S'right'
p6149
sg58
g62
sS'trial_loop.thisN'
p6150
I184
sg33
g3714
sg63
g64
sS'trial_loop.thisIndex'
p6151
g59
(g98
S'\xb8\x00\x00\x00'
tRp6152
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6153
I0
sg3641
g4681
sS'block_loop.thisRepN'
p6154
I1
sg3644
g3714
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6155
I1
sg3646
g3708
sg55
g11
sS'block_loop.thisTrial'
p6156
Nsg69
Vn
sS'block_loop.thisTrialN'
p6157
I0
sg39
F0.93388125333603966
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1f#\x05\xe7\xb8'
tRp6158
sa(dp6159
S'trial_loop.thisTrialN'
p6160
I185
sg3632
g3653
sS'block_loop.thisIndex'
p6161
g3626
sg38
S'left'
p6162
sg58
g62
sS'trial_loop.thisN'
p6163
I185
sg33
g3663
sg63
g64
sS'trial_loop.thisIndex'
p6164
g59
(g98
S'\xb9\x00\x00\x00'
tRp6165
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6166
I0
sg3641
g3661
sS'block_loop.thisRepN'
p6167
I1
sg3644
g3663
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6168
I1
sg3646
g3657
sg55
g11
sS'block_loop.thisTrial'
p6169
Nsg69
Vn
sS'block_loop.thisTrialN'
p6170
I0
sg39
F1.5001733394765324
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1f)\x05G\x90'
tRp6171
sa(dp6172
S'trial_loop.thisTrialN'
p6173
I186
sg3632
g4141
sS'block_loop.thisIndex'
p6174
g3626
sg38
S'left'
p6175
sg58
g62
sS'trial_loop.thisN'
p6176
I186
sg33
g3978
sg63
g64
sS'trial_loop.thisIndex'
p6177
g59
(g98
S'\xba\x00\x00\x00'
tRp6178
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6179
I0
sg3641
g4148
sS'block_loop.thisRepN'
p6180
I1
sg3644
g3984
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6181
I1
sg3646
g3978
sg55
g11
sS'block_loop.thisTrial'
p6182
Nsg69
Vn
sS'block_loop.thisTrialN'
p6183
I0
sg39
F0.91684865411025385
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1f/\ry8'
tRp6184
sa(dp6185
S'trial_loop.thisTrialN'
p6186
I187
sg3632
g3892
sS'block_loop.thisIndex'
p6187
g3626
sg38
S'right'
p6188
sg58
g62
sS'trial_loop.thisN'
p6189
I187
sg33
g3681
sg63
g64
sS'trial_loop.thisIndex'
p6190
g59
(g98
S'\xbb\x00\x00\x00'
tRp6191
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6192
I0
sg3641
g3899
sS'block_loop.thisRepN'
p6193
I1
sg3644
g3674
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6194
I1
sg3646
g3681
sg55
g11
sS'block_loop.thisTrial'
p6195
Nsg69
Vn
sS'block_loop.thisTrialN'
p6196
I0
sg39
F1.0834700852556125
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1f5\x0c\x9ex'
tRp6197
sa(dp6198
S'trial_loop.thisTrialN'
p6199
I188
sg3632
g4279
sS'block_loop.thisIndex'
p6200
g3626
sg38
S'left'
p6201
sg58
g62
sS'trial_loop.thisN'
p6202
I188
sg33
g3761
sg63
g64
sS'trial_loop.thisIndex'
p6203
g59
(g98
S'\xbc\x00\x00\x00'
tRp6204
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6205
I0
sg3641
g4286
sS'block_loop.thisRepN'
p6206
I1
sg3644
g3761
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6207
I1
sg3646
g3755
sg55
g11
sS'block_loop.thisTrial'
p6208
Nsg69
Vn
sS'block_loop.thisTrialN'
p6209
I0
sg39
F4.8000688796346367
sg34
g752
(S'\x07\xdf\n\x10\x0b\x1f;\x0e\x9aH'
tRp6210
sa(dp6211
S'trial_loop.thisTrialN'
p6212
I189
sg3632
g5169
sS'block_loop.thisIndex'
p6213
g3626
sg38
S'left'
p6214
sg58
g62
sS'trial_loop.thisN'
p6215
I189
sg33
g4882
sg63
g64
sS'trial_loop.thisIndex'
p6216
g59
(g98
S'\xbd\x00\x00\x00'
tRp6217
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6218
I0
sg3641
g5176
sS'block_loop.thisRepN'
p6219
I1
sg3644
g4875
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6220
I1
sg3646
g4882
sg55
g11
sS'block_loop.thisTrial'
p6221
Nsg69
Vn
sS'block_loop.thisTrialN'
p6222
I0
sg39
F1.0168951820751317
sg34
g752
(S'\x07\xdf\n\x10\x0b \t\x0b\xfah'
tRp6223
sa(dp6224
S'trial_loop.thisTrialN'
p6225
I190
sg3632
g4501
sS'block_loop.thisIndex'
p6226
g3626
sg38
S'left'
p6227
sg58
g62
sS'trial_loop.thisN'
p6228
I190
sg33
g4025
sg63
g64
sS'trial_loop.thisIndex'
p6229
g59
(g98
S'\xbe\x00\x00\x00'
tRp6230
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6231
I0
sg3641
g4508
sS'block_loop.thisRepN'
p6232
I1
sg3644
g4025
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6233
I1
sg3646
g4032
sg55
g11
sS'block_loop.thisTrial'
p6234
Nsg69
Vn
sS'block_loop.thisTrialN'
p6235
I0
sg39
F0.71686707142907835
sg34
g752
(S'\x07\xdf\n\x10\x0b \x0f\x0c\xc9p'
tRp6236
sa(dp6237
S'trial_loop.thisTrialN'
p6238
I191
sg3632
g4079
sS'block_loop.thisIndex'
p6239
g3626
sg38
S'right'
p6240
sg58
g62
sS'trial_loop.thisN'
p6241
I191
sg33
g4083
sg63
g64
sS'trial_loop.thisIndex'
p6242
g59
(g98
S'\xbf\x00\x00\x00'
tRp6243
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6244
I0
sg3641
g4087
sS'block_loop.thisRepN'
p6245
I1
sg3644
g4083
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6246
I1
sg3646
g4090
sg55
g11
sS'block_loop.thisTrial'
p6247
Nsg69
Vn
sS'block_loop.thisTrialN'
p6248
I0
sg39
F0.74996265218578628
sg34
g752
(S'\x07\xdf\n\x10\x0b \x15\x08\xd5\xb8'
tRp6249
sa(dp6250
S'trial_loop.thisTrialN'
p6251
I192
sg3632
g3751
sS'block_loop.thisIndex'
p6252
g3626
sg38
S'right'
p6253
sg58
g62
sS'trial_loop.thisN'
p6254
I192
sg33
g3755
sg63
g64
sS'trial_loop.thisIndex'
p6255
g59
(g98
S'\xc0\x00\x00\x00'
tRp6256
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6257
I0
sg3641
g3759
sS'block_loop.thisRepN'
p6258
I1
sg3644
g3761
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6259
I1
sg3646
g3755
sg55
g11
sS'block_loop.thisTrial'
p6260
Nsg69
Vn
sS'block_loop.thisTrialN'
p6261
I0
sg39
F2.0501963183605767
sg34
g752
(S'\x07\xdf\n\x10\x0b \x1b\x05\x99\x98'
tRp6262
sa(dp6263
S'trial_loop.thisTrialN'
p6264
I193
sg3632
g4021
sS'block_loop.thisIndex'
p6265
g3626
sg38
S'right'
p6266
sg58
g62
sS'trial_loop.thisN'
p6267
I193
sg33
g4025
sg63
g64
sS'trial_loop.thisIndex'
p6268
g59
(g98
S'\xc1\x00\x00\x00'
tRp6269
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6270
I0
sg3641
g4029
sS'block_loop.thisRepN'
p6271
I1
sg3644
g4025
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6272
I1
sg3646
g4032
sg55
g11
sS'block_loop.thisTrial'
p6273
Nsg69
Vn
sS'block_loop.thisTrialN'
p6274
I0
sg39
F0.66684551803427894
sg34
g752
(S'\x07\xdf\n\x10\x0b "\x06\xd9\xe8'
tRp6275
sa(dp6276
S'trial_loop.thisTrialN'
p6277
I194
sg3632
g4006
sS'block_loop.thisIndex'
p6278
g3626
sg38
S'right'
p6279
sg58
g62
sS'trial_loop.thisN'
p6280
I194
sg33
g3637
sg63
g64
sS'trial_loop.thisIndex'
p6281
g59
(g98
S'\xc2\x00\x00\x00'
tRp6282
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6283
I0
sg3641
g4013
sS'block_loop.thisRepN'
p6284
I1
sg3644
g3637
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6285
I1
sg3646
g3647
sg55
g11
sS'block_loop.thisTrial'
p6286
Nsg69
Vn
sS'block_loop.thisTrialN'
p6287
I0
sg39
F1.1668728874246881
sg34
g752
(S'\x07\xdf\n\x10\x0b (\x02.\x98'
tRp6288
sa(dp6289
S'trial_loop.thisTrialN'
p6290
I195
sg3632
g4141
sS'block_loop.thisIndex'
p6291
g3626
sg38
S'left'
p6292
sg58
g62
sS'trial_loop.thisN'
p6293
I195
sg33
g3984
sg63
g64
sS'trial_loop.thisIndex'
p6294
g59
(g98
S'\xc3\x00\x00\x00'
tRp6295
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6296
I0
sg3641
g4148
sS'block_loop.thisRepN'
p6297
I1
sg3644
g3984
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6298
I1
sg3646
g3978
sg55
g11
sS'block_loop.thisTrial'
p6299
Nsg69
Vn
sS'block_loop.thisTrialN'
p6300
I0
sg39
F0.88352870136804995
sg34
g752
(S'\x07\xdf\n\x10\x0b .\x05_\x00'
tRp6301
sa(dp6302
S'trial_loop.thisTrialN'
p6303
I196
sg3632
g4633
sS'block_loop.thisIndex'
p6304
g3626
sg38
S'left'
p6305
sg58
g62
sS'trial_loop.thisN'
p6306
I196
sg33
g4449
sg63
g64
sS'trial_loop.thisIndex'
p6307
g59
(g98
S'\xc4\x00\x00\x00'
tRp6308
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6309
I0
sg3641
g4640
sS'block_loop.thisRepN'
p6310
I1
sg3644
g4449
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6311
I1
sg3646
g4456
sg55
g11
sS'block_loop.thisTrial'
p6312
Nsg69
Vn
sS'block_loop.thisTrialN'
p6313
I0
sg39
F0.83344385625605355
sg34
g752
(S'\x07\xdf\n\x10\x0b 4\x04\x07@'
tRp6314
sa(dp6315
S'trial_loop.thisTrialN'
p6316
I197
sg3632
g3815
sS'block_loop.thisIndex'
p6317
g3626
sg38
S'right'
p6318
sg58
g62
sS'trial_loop.thisN'
p6319
I197
sg33
g3819
sg63
g64
sS'trial_loop.thisIndex'
p6320
g59
(g98
S'\xc5\x00\x00\x00'
tRp6321
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6322
I0
sg3641
g3823
sS'block_loop.thisRepN'
p6323
I1
sg3644
g3819
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6324
I1
sg3646
g3826
sg55
g11
sS'block_loop.thisTrial'
p6325
Nsg69
Vn
sS'block_loop.thisTrialN'
p6326
I0
sg39
F1.0501834889582824
sg34
g752
(S'\x07\xdf\n\x10\x0b :\x01\xfb\xd0'
tRp6327
sa(dp6328
S'trial_loop.thisTrialN'
p6329
I198
sg3632
g4021
sS'block_loop.thisIndex'
p6330
g3626
sg38
S'right'
p6331
sg58
g62
sS'trial_loop.thisN'
p6332
I198
sg33
g4025
sg63
g64
sS'trial_loop.thisIndex'
p6333
g59
(g98
S'\xc6\x00\x00\x00'
tRp6334
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6335
I0
sg3641
g4029
sS'block_loop.thisRepN'
p6336
I1
sg3644
g4025
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6337
I1
sg3646
g4032
sg55
g11
sS'block_loop.thisTrial'
p6338
Nsg69
Vn
sS'block_loop.thisTrialN'
p6339
I0
sg39
F0.96686165457140305
sg34
g752
(S'\x07\xdf\n\x10\x0b!\x04\x03C\xf0'
tRp6340
sa(dp6341
S'trial_loop.thisTrialN'
p6342
I199
sg3632
g3768
sS'block_loop.thisIndex'
p6343
g3626
sg38
S'left'
p6344
sg58
g62
sS'trial_loop.thisN'
p6345
I199
sg33
g3779
sg63
g64
sS'trial_loop.thisIndex'
p6346
g59
(g98
S'\xc7\x00\x00\x00'
tRp6347
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6348
I0
sg3641
g3776
sS'block_loop.thisRepN'
p6349
I1
sg3644
g3772
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6350
I1
sg3646
g3779
sg55
g11
sS'block_loop.thisTrial'
p6351
Nsg69
Vn
sS'block_loop.thisTrialN'
p6352
I0
sg39
F1.3338082112741176
sg34
g752
(S'\x07\xdf\n\x10\x0b!\n\x03[`'
tRp6353
sa(dp6354
S'block_loop.thisRepN'
p6355
I1
sg55
g11
sg41
F222.87759011371963
sg56
Vr
sS'block_loop.thisIndex'
p6356
g3626
sg57
Vy
sg58
g62
sS'block_loop.thisN'
p6357
I1
sg40
S'space'
p6358
sg63
g64
sS'block_loop.thisTrial'
p6359
Nsg65
g66
sg67
g68
sS'block_loop.thisTrialN'
p6360
I0
sg69
Vn
sa(dp6361
S'block_loop.thisRepN'
p6362
I2
sg56
Vr
sS'block_loop.thisIndex'
p6363
g59
(g98
S'\x00\x00\x00\x00'
tRp6364
sg57
Vy
sg58
g62
sS'block_loop.thisN'
p6365
I2
sg37
Nsg55
g11
sg63
g64
sS'block_loop.thisTrial'
p6366
Nsg65
g66
sg67
g68
sS'block_loop.thisTrialN'
p6367
I0
sg69
Vn
sa(dp6368
S'trial_loop.thisTrialN'
p6369
I0
sS'img_left'
p6370
S'5-pineapple.png'
p6371
sS'block_loop.thisIndex'
p6372
g6364
sg38
S'right'
p6373
sg58
g62
sS'trial_loop.thisN'
p6374
I0
sg33
S'5-pineapple.png'
p6375
sg63
g64
sS'trial_loop.thisIndex'
p6376
g59
(g98
S'\x00\x00\x00\x00'
tRp6377
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6378
I0
sS'img_right'
p6379
S'40-sardines.png'
p6380
sS'block_loop.thisRepN'
p6381
I2
sS'img_correct'
p6382
S'40-sardines.png'
p6383
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6384
I2
sS'img_wrong'
p6385
g6375
sg55
g11
sS'block_loop.thisTrial'
p6386
Nsg69
Vn
sS'block_loop.thisTrialN'
p6387
I0
sg39
F1.1001038326276102
sg34
g752
(S'\x07\xdf\n\x10\x0b%\x04\x07f\x88'
tRp6388
sa(dp6389
S'trial_loop.thisTrialN'
p6390
I1
sg6370
S'38-maltesers.png'
p6391
sS'block_loop.thisIndex'
p6392
g6364
sg38
S'left'
p6393
sg58
g62
sS'trial_loop.thisN'
p6394
I1
sg33
S'38-maltesers.png'
p6395
sg63
g64
sS'trial_loop.thisIndex'
p6396
g59
(g98
S'\x01\x00\x00\x00'
tRp6397
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6398
I0
sg6379
S'6-sour_patch_kids.png'
p6399
sS'block_loop.thisRepN'
p6400
I2
sg6382
g6395
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6401
I2
sg6385
S'6-sour_patch_kids.png'
p6402
sg55
g11
sS'block_loop.thisTrial'
p6403
Nsg69
Vn
sS'block_loop.thisTrialN'
p6404
I0
sg39
F0.68323750245235715
sg34
g752
(S'\x07\xdf\n\x10\x0b%\n\tf@'
tRp6405
sa(dp6406
S'trial_loop.thisTrialN'
p6407
I2
sg6370
S'27-hartleys_raspberries_jelly.png'
p6408
sS'block_loop.thisIndex'
p6409
g6364
sg38
S'right'
p6410
sg58
g62
sS'trial_loop.thisN'
p6411
I2
sg33
S'51-mars.png'
p6412
sg63
g64
sS'trial_loop.thisIndex'
p6413
g59
(g98
S'\x02\x00\x00\x00'
tRp6414
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6415
I0
sg6379
S'51-mars.png'
p6416
sS'block_loop.thisRepN'
p6417
I2
sg6382
g6412
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6418
I2
sg6385
S'27-hartleys_raspberries_jelly.png'
p6419
sg55
g11
sS'block_loop.thisTrial'
p6420
Nsg69
Vn
sS'block_loop.thisTrialN'
p6421
I0
sg39
F0.83342589509356912
sg34
g752
(S'\x07\xdf\n\x10\x0b%\x10\x04\xf9p'
tRp6422
sa(dp6423
S'trial_loop.thisTrialN'
p6424
I3
sg6370
S'17-jacobs_mini_cheddars_redo.png'
p6425
sS'block_loop.thisIndex'
p6426
g6364
sg38
S'left'
p6427
sg58
g62
sS'trial_loop.thisN'
p6428
I3
sg33
S'17-jacobs_mini_cheddars_redo.png'
p6429
sg63
g64
sS'trial_loop.thisIndex'
p6430
g59
(g98
S'\x03\x00\x00\x00'
tRp6431
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6432
I0
sg6379
S'8-liquorice_catherine_wheels.png'
p6433
sS'block_loop.thisRepN'
p6434
I2
sg6382
g6429
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6435
I2
sg6385
S'8-liquorice_catherine_wheels.png'
p6436
sg55
g11
sS'block_loop.thisTrial'
p6437
Nsg69
Vn
sS'block_loop.thisTrialN'
p6438
I0
sg39
F1.4668904494510571
sg34
g752
(S'\x07\xdf\n\x10\x0b%\x16\x02\xea\x18'
tRp6439
sa(dp6440
S'trial_loop.thisTrialN'
p6441
I4
sg6370
S'33-ambrosia_rice.png'
p6442
sS'block_loop.thisIndex'
p6443
g6364
sg38
S'left'
p6444
sg58
g62
sS'trial_loop.thisN'
p6445
I4
sg33
S'33-ambrosia_rice.png'
p6446
sg63
g64
sS'trial_loop.thisIndex'
p6447
g59
(g98
S'\x04\x00\x00\x00'
tRp6448
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6449
I0
sg6379
S'23-crunchie_redo.png'
p6450
sS'block_loop.thisRepN'
p6451
I2
sg6382
g6446
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6452
I2
sg6385
S'23-crunchie_redo.png'
p6453
sg55
g11
sS'block_loop.thisTrial'
p6454
Nsg69
Vn
sS'block_loop.thisTrialN'
p6455
I0
sg39
F0.81687824726486724
sg34
g752
(S'\x07\xdf\n\x10\x0b%\x1c\n\xa2\xa8'
tRp6456
sa(dp6457
S'trial_loop.thisTrialN'
p6458
I5
sg6370
S'46-pistachios.png'
p6459
sS'block_loop.thisIndex'
p6460
g6364
sg38
S'right'
p6461
sg58
g62
sS'trial_loop.thisN'
p6462
I5
sg33
S'29-beans.png'
p6463
sg63
g64
sS'trial_loop.thisIndex'
p6464
g59
(g98
S'\x05\x00\x00\x00'
tRp6465
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6466
I0
sg6379
S'29-beans.png'
p6467
sS'block_loop.thisRepN'
p6468
I2
sg6382
g6463
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6469
I2
sg6385
S'46-pistachios.png'
p6470
sg55
g11
sS'block_loop.thisTrial'
p6471
Nsg69
Vn
sS'block_loop.thisTrialN'
p6472
I0
sg39
F0.96670228488801513
sg34
g752
(S'\x07\xdf\n\x10\x0b%"\x08X\xb8'
tRp6473
sa(dp6474
S'trial_loop.thisTrialN'
p6475
I6
sg6370
S'6-sour_patch_kids.png'
p6476
sS'block_loop.thisIndex'
p6477
g6364
sg38
S'right'
p6478
sg58
g62
sS'trial_loop.thisN'
p6479
I6
sg33
g6395
sg63
g64
sS'trial_loop.thisIndex'
p6480
g59
(g98
S'\x06\x00\x00\x00'
tRp6481
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6482
I0
sg6379
S'38-maltesers.png'
p6483
sS'block_loop.thisRepN'
p6484
I2
sg6382
g6395
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6485
I2
sg6385
g6402
sg55
g11
sS'block_loop.thisTrial'
p6486
Nsg69
Vn
sS'block_loop.thisTrialN'
p6487
I0
sg39
F0.89991412853578368
sg34
g752
(S'\x07\xdf\n\x10\x0b%(\x08p('
tRp6488
sa(dp6489
S'trial_loop.thisTrialN'
p6490
I7
sg6370
S'23-crunchie_redo.png'
p6491
sS'block_loop.thisIndex'
p6492
g6364
sg38
S'right'
p6493
sg58
g62
sS'trial_loop.thisN'
p6494
I7
sg33
g6446
sg63
g64
sS'trial_loop.thisIndex'
p6495
g59
(g98
S'\x07\x00\x00\x00'
tRp6496
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6497
I0
sg6379
S'33-ambrosia_rice.png'
p6498
sS'block_loop.thisRepN'
p6499
I2
sg6382
g6446
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6500
I2
sg6385
g6453
sg55
g11
sS'block_loop.thisTrial'
p6501
Nsg69
Vn
sS'block_loop.thisTrialN'
p6502
I0
sg39
F1.1501319432718446
sg34
g752
(S'\x07\xdf\n\x10\x0b%.\x07V\xe8'
tRp6503
sa(dp6504
S'trial_loop.thisTrialN'
p6505
I8
sg6370
S'41-peanuts_redo.png'
p6506
sS'block_loop.thisIndex'
p6507
g6364
sg38
S'left'
p6508
sg58
g62
sS'trial_loop.thisN'
p6509
I8
sg33
S'41-peanuts_redo.png'
p6510
sg63
g64
sS'trial_loop.thisIndex'
p6511
g59
(g98
S'\x08\x00\x00\x00'
tRp6512
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6513
I0
sg6379
S'45-chewy_nougat_redo.png'
p6514
sS'block_loop.thisRepN'
p6515
I2
sg6382
g6510
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6516
I2
sg6385
S'45-chewy_nougat_redo.png'
p6517
sg55
g11
sS'block_loop.thisTrial'
p6518
Nsg69
Vn
sS'block_loop.thisTrialN'
p6519
I0
sg39
F0.86685304461661872
sg34
g752
(S'\x07\xdf\n\x10\x0b%4\n\nP'
tRp6520
sa(dp6521
S'trial_loop.thisTrialN'
p6522
I9
sg6370
S'16-skips_prawn.png'
p6523
sS'block_loop.thisIndex'
p6524
g6364
sg38
S'left'
p6525
sg58
g62
sS'trial_loop.thisN'
p6526
I9
sg33
S'16-skips_prawn.png'
p6527
sg63
g64
sS'trial_loop.thisIndex'
p6528
g59
(g98
S'\t\x00\x00\x00'
tRp6529
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6530
I0
sg6379
S'42-mrkipling_lemon_slices.png'
p6531
sS'block_loop.thisRepN'
p6532
I2
sg6382
g6527
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6533
I2
sg6385
S'42-mrkipling_lemon_slices.png'
p6534
sg55
g11
sS'block_loop.thisTrial'
p6535
Nsg69
Vn
sS'block_loop.thisTrialN'
p6536
I0
sg39
F0.90005810293678223
sg34
g752
(S'\x07\xdf\n\x10\x0b%:\x08w\xf8'
tRp6537
sa(dp6538
S'trial_loop.thisTrialN'
p6539
I10
sg6370
S'13-mccoys_steak_crisps.png'
p6540
sS'block_loop.thisIndex'
p6541
g6364
sg38
S'right'
p6542
sg58
g62
sS'trial_loop.thisN'
p6543
I10
sg33
S'3-ellas_strawberries_apples.png'
p6544
sg63
g64
sS'trial_loop.thisIndex'
p6545
g59
(g98
S'\n\x00\x00\x00'
tRp6546
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6547
I0
sg6379
S'3-ellas_strawberries_apples.png'
p6548
sS'block_loop.thisRepN'
p6549
I2
sg6382
g6544
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6550
I2
sg6385
S'13-mccoys_steak_crisps.png'
p6551
sg55
g11
sS'block_loop.thisTrial'
p6552
Nsg69
Vn
sS'block_loop.thisTrialN'
p6553
I0
sg39
F0.75023092923674994
sg34
g752
(S'\x07\xdf\n\x10\x0b&\x04\x07\x9d8'
tRp6554
sa(dp6555
S'trial_loop.thisTrialN'
p6556
I11
sg6370
S'25-kitkat.png'
p6557
sS'block_loop.thisIndex'
p6558
g6364
sg38
S'left'
p6559
sg58
g62
sS'trial_loop.thisN'
p6560
I11
sg33
S'25-kitkat.png'
p6561
sg63
g64
sS'trial_loop.thisIndex'
p6562
g59
(g98
S'\x0b\x00\x00\x00'
tRp6563
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6564
I0
sg6379
S'31-hobnobs.png'
p6565
sS'block_loop.thisRepN'
p6566
I2
sg6382
g6561
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6567
I2
sg6385
S'31-hobnobs.png'
p6568
sg55
g11
sS'block_loop.thisTrial'
p6569
Nsg69
Vn
sS'block_loop.thisTrialN'
p6570
I0
sg39
F2.2334891297905415
sg34
g752
(S'\x07\xdf\n\x10\x0b&\n\x04]0'
tRp6571
sa(dp6572
S'trial_loop.thisTrialN'
p6573
I12
sg6370
S'34-hula_hoops_bbq_beef_redo.png'
p6574
sS'block_loop.thisIndex'
p6575
g6364
sg38
S'right'
p6576
sg58
g62
sS'trial_loop.thisN'
p6577
I12
sg33
S'36-fig_rolls.png'
p6578
sg63
g64
sS'trial_loop.thisIndex'
p6579
g59
(g98
S'\x0c\x00\x00\x00'
tRp6580
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6581
I0
sg6379
S'36-fig_rolls.png'
p6582
sS'block_loop.thisRepN'
p6583
I2
sg6382
g6578
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6584
I2
sg6385
S'34-hula_hoops_bbq_beef_redo.png'
p6585
sg55
g11
sS'block_loop.thisTrial'
p6586
Nsg69
Vn
sS'block_loop.thisTrialN'
p6587
I0
sg39
F0.88354409665043931
sg34
g752
(S'\x07\xdf\n\x10\x0b&\x11\x08=`'
tRp6588
sa(dp6589
S'trial_loop.thisTrialN'
p6590
I13
sg6370
S'35-raisins.png'
p6591
sS'block_loop.thisIndex'
p6592
g6364
sg38
S'right'
p6593
sg58
g62
sS'trial_loop.thisN'
p6594
I13
sg33
S'49-yorkie.png'
p6595
sg63
g64
sS'trial_loop.thisIndex'
p6596
g59
(g98
S'\r\x00\x00\x00'
tRp6597
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6598
I0
sg6379
S'49-yorkie.png'
p6599
sS'block_loop.thisRepN'
p6600
I2
sg6382
g6595
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6601
I2
sg6385
S'35-raisins.png'
p6602
sg55
g11
sS'block_loop.thisTrial'
p6603
Nsg69
Vn
sS'block_loop.thisTrialN'
p6604
I0
sg39
F0.86683993011683924
sg34
g752
(S'\x07\xdf\n\x10\x0b&\x17\x07$ '
tRp6605
sa(dp6606
S'trial_loop.thisTrialN'
p6607
I14
sg6370
g6371
sS'block_loop.thisIndex'
p6608
g6364
sg38
S'right'
p6609
sg58
g62
sS'trial_loop.thisN'
p6610
I14
sg33
g6383
sg63
g64
sS'trial_loop.thisIndex'
p6611
g59
(g98
S'\x0e\x00\x00\x00'
tRp6612
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6613
I0
sg6379
g6380
sS'block_loop.thisRepN'
p6614
I2
sg6382
g6383
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6615
I2
sg6385
g6375
sg55
g11
sS'block_loop.thisTrial'
p6616
Nsg69
Vn
sS'block_loop.thisTrialN'
p6617
I0
sg39
F0.95054664656527166
sg34
g752
(S'\x07\xdf\n\x10\x0b&\x1d\x05\x91\xc8'
tRp6618
sa(dp6619
S'trial_loop.thisTrialN'
p6620
I15
sg6370
g6425
sS'block_loop.thisIndex'
p6621
g6364
sg38
S'left'
p6622
sg58
g62
sS'trial_loop.thisN'
p6623
I15
sg33
g6429
sg63
g64
sS'trial_loop.thisIndex'
p6624
g59
(g98
S'\x0f\x00\x00\x00'
tRp6625
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6626
I0
sg6379
g6433
sS'block_loop.thisRepN'
p6627
I2
sg6382
g6429
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6628
I2
sg6385
g6436
sg55
g11
sS'block_loop.thisTrial'
p6629
Nsg69
Vn
sS'block_loop.thisTrialN'
p6630
I0
sg39
F1.4001906734238219
sg34
g752
(S'\x07\xdf\n\x10\x0b&#\x050 '
tRp6631
sa(dp6632
S'trial_loop.thisTrialN'
p6633
I16
sg6370
S'29-beans.png'
p6634
sS'block_loop.thisIndex'
p6635
g6364
sg38
S'left'
p6636
sg58
g62
sS'trial_loop.thisN'
p6637
I16
sg33
g6463
sg63
g64
sS'trial_loop.thisIndex'
p6638
g59
(g98
S'\x10\x00\x00\x00'
tRp6639
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6640
I0
sg6379
S'46-pistachios.png'
p6641
sS'block_loop.thisRepN'
p6642
I2
sg6382
g6463
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6643
I2
sg6385
g6470
sg55
g11
sS'block_loop.thisTrial'
p6644
Nsg69
Vn
sS'block_loop.thisTrialN'
p6645
I0
sg39
F1.0835456361783145
sg34
g752
(S'\x07\xdf\n\x10\x0b&)\x0b\xf2\x98'
tRp6646
sa(dp6647
S'trial_loop.thisTrialN'
p6648
I17
sg6370
g6540
sS'block_loop.thisIndex'
p6649
g6364
sg38
S'right'
p6650
sg58
g62
sS'trial_loop.thisN'
p6651
I17
sg33
g6544
sg63
g64
sS'trial_loop.thisIndex'
p6652
g59
(g98
S'\x11\x00\x00\x00'
tRp6653
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6654
I0
sg6379
g6548
sS'block_loop.thisRepN'
p6655
I2
sg6382
g6544
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6656
I2
sg6385
g6551
sg55
g11
sS'block_loop.thisTrial'
p6657
Nsg69
Vn
sS'block_loop.thisTrialN'
p6658
I0
sg39
F2.1668805850667923
sg34
g752
(S'\x07\xdf\n\x10\x0b&/\r\xb3\xd0'
tRp6659
sa(dp6660
S'trial_loop.thisTrialN'
p6661
I18
sg6370
S'21-nakd_banana_crunch.png'
p6662
sS'block_loop.thisIndex'
p6663
g6364
sg38
S'left'
p6664
sg58
g62
sS'trial_loop.thisN'
p6665
I18
sg33
S'1-treacle_cookies.png'
p6666
sg63
g64
sS'trial_loop.thisIndex'
p6667
g59
(g98
S'\x12\x00\x00\x00'
tRp6668
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6669
I0
sg6379
S'1-treacle_cookies.png'
p6670
sS'block_loop.thisRepN'
p6671
I2
sg6382
S'21-nakd_banana_crunch.png'
p6672
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6673
I2
sg6385
g6666
sg55
g11
sS'block_loop.thisTrial'
p6674
Nsg69
Vn
sS'block_loop.thisTrialN'
p6675
I0
sg39
F0.93352031949234515
sg34
g752
(S'\x07\xdf\n\x10\x0b&7\x01_\x90'
tRp6676
sa(dp6677
S'trial_loop.thisTrialN'
p6678
I19
sg6370
g6574
sS'block_loop.thisIndex'
p6679
g6364
sg38
S'right'
p6680
sg58
g62
sS'trial_loop.thisN'
p6681
I19
sg33
g6578
sg63
g64
sS'trial_loop.thisIndex'
p6682
g59
(g98
S'\x13\x00\x00\x00'
tRp6683
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6684
I0
sg6379
g6582
sS'block_loop.thisRepN'
p6685
I2
sg6382
g6578
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6686
I2
sg6385
g6585
sg55
g11
sS'block_loop.thisTrial'
p6687
Nsg69
Vn
sS'block_loop.thisTrialN'
p6688
I0
sg39
F1.0505700816065655
sg34
g752
(S"\x07\xdf\n\x10\x0b'\x01\x00\xfa\x00"
tRp6689
sa(dp6690
S'trial_loop.thisTrialN'
p6691
I20
sg6370
S'51-mars.png'
p6692
sS'block_loop.thisIndex'
p6693
g6364
sg38
S'left'
p6694
sg58
g62
sS'trial_loop.thisN'
p6695
I20
sg33
g6412
sg63
g64
sS'trial_loop.thisIndex'
p6696
g59
(g98
S'\x14\x00\x00\x00'
tRp6697
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6698
I0
sg6379
S'27-hartleys_raspberries_jelly.png'
p6699
sS'block_loop.thisRepN'
p6700
I2
sg6382
g6412
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6701
I2
sg6385
g6419
sg55
g11
sS'block_loop.thisTrial'
p6702
Nsg69
Vn
sS'block_loop.thisTrialN'
p6703
I0
sg39
F1.3501044028225806
sg34
g752
(S"\x07\xdf\n\x10\x0b'\x07\x02B "
tRp6704
sa(dp6705
S'trial_loop.thisTrialN'
p6706
I21
sg6370
S'36-fig_rolls.png'
p6707
sS'block_loop.thisIndex'
p6708
g6364
sg38
S'left'
p6709
sg58
g62
sS'trial_loop.thisN'
p6710
I21
sg33
g6578
sg63
g64
sS'trial_loop.thisIndex'
p6711
g59
(g98
S'\x15\x00\x00\x00'
tRp6712
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6713
I0
sg6379
S'34-hula_hoops_bbq_beef_redo.png'
p6714
sS'block_loop.thisRepN'
p6715
I2
sg6382
g6578
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6716
I2
sg6385
g6585
sg55
g11
sS'block_loop.thisTrial'
p6717
Nsg69
Vn
sS'block_loop.thisTrialN'
p6718
I0
sg39
F0.83355276362453878
sg34
g752
(S"\x07\xdf\n\x10\x0b'\r\x08\x12h"
tRp6719
sa(dp6720
S'trial_loop.thisTrialN'
p6721
I22
sg6370
S'30-spaghetti_hoops.png'
p6722
sS'block_loop.thisIndex'
p6723
g6364
sg38
S'right'
p6724
sg58
g62
sS'trial_loop.thisN'
p6725
I22
sg33
S'19-caramello_redo.png'
p6726
sg63
g64
sS'trial_loop.thisIndex'
p6727
g59
(g98
S'\x16\x00\x00\x00'
tRp6728
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6729
I0
sg6379
S'19-caramello_redo.png'
p6730
sS'block_loop.thisRepN'
p6731
I2
sg6382
g6726
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6732
I2
sg6385
S'30-spaghetti_hoops.png'
p6733
sg55
g11
sS'block_loop.thisTrial'
p6734
Nsg69
Vn
sS'block_loop.thisTrialN'
p6735
I0
sg39
F1.0668617115907182
sg34
g752
(S"\x07\xdf\n\x10\x0b'\x13\x06\x03\x10"
tRp6736
sa(dp6737
S'trial_loop.thisTrialN'
p6738
I23
sg6370
g6476
sS'block_loop.thisIndex'
p6739
g6364
sg38
S'right'
p6740
sg58
g62
sS'trial_loop.thisN'
p6741
I23
sg33
g6395
sg63
g64
sS'trial_loop.thisIndex'
p6742
g59
(g98
S'\x17\x00\x00\x00'
tRp6743
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6744
I0
sg6379
g6483
sS'block_loop.thisRepN'
p6745
I2
sg6382
g6395
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6746
I2
sg6385
g6402
sg55
g11
sS'block_loop.thisTrial'
p6747
Nsg69
Vn
sS'block_loop.thisTrialN'
p6748
I0
sg39
F0.78334960291613243
sg34
g752
(S"\x07\xdf\n\x10\x0b'\x19\x07\x89\xb0"
tRp6749
sa(dp6750
S'trial_loop.thisTrialN'
p6751
I24
sg6370
S'7-olives.png'
p6752
sS'block_loop.thisIndex'
p6753
g6364
sg38
S'left'
p6754
sg58
g62
sS'trial_loop.thisN'
p6755
I24
sg33
S'7-olives.png'
p6756
sg63
g64
sS'trial_loop.thisIndex'
p6757
g59
(g98
S'\x18\x00\x00\x00'
tRp6758
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6759
I0
sg6379
S'22-daim.png'
p6760
sS'block_loop.thisRepN'
p6761
I2
sg6382
g6756
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6762
I2
sg6385
S'22-daim.png'
p6763
sg55
g11
sS'block_loop.thisTrial'
p6764
Nsg69
Vn
sS'block_loop.thisTrialN'
p6765
I0
sg39
F0.91727031379014079
sg34
g752
(S"\x07\xdf\n\x10\x0b'\x1f\x04\xc6\xa8"
tRp6766
sa(dp6767
S'trial_loop.thisTrialN'
p6768
I25
sg6370
g6442
sS'block_loop.thisIndex'
p6769
g6364
sg38
S'left'
p6770
sg58
g62
sS'trial_loop.thisN'
p6771
I25
sg33
g6446
sg63
g64
sS'trial_loop.thisIndex'
p6772
g59
(g98
S'\x19\x00\x00\x00'
tRp6773
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6774
I0
sg6379
g6450
sS'block_loop.thisRepN'
p6775
I2
sg6382
g6446
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6776
I2
sg6385
g6453
sg55
g11
sS'block_loop.thisTrial'
p6777
Nsg69
Vn
sS'block_loop.thisTrialN'
p6778
I0
sg39
F1.2501408383241142
sg34
g752
(S"\x07\xdf\n\x10\x0b'%\x03\xeb\xe8"
tRp6779
sa(dp6780
S'trial_loop.thisTrialN'
p6781
I26
sg6370
g6540
sS'block_loop.thisIndex'
p6782
g6364
sg38
S'right'
p6783
sg58
g62
sS'trial_loop.thisN'
p6784
I26
sg33
g6544
sg63
g64
sS'trial_loop.thisIndex'
p6785
g59
(g98
S'\x1a\x00\x00\x00'
tRp6786
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6787
I0
sg6379
g6548
sS'block_loop.thisRepN'
p6788
I2
sg6382
g6544
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6789
I2
sg6385
g6551
sg55
g11
sS'block_loop.thisTrial'
p6790
Nsg69
Vn
sS'block_loop.thisTrialN'
p6791
I0
sg39
F0.73349340625827608
sg34
g752
(S"\x07\xdf\n\x10\x0b'+\x08I\x18"
tRp6792
sa(dp6793
S'trial_loop.thisTrialN'
p6794
I27
sg6370
S'31-hobnobs.png'
p6795
sS'block_loop.thisIndex'
p6796
g6364
sg38
S'right'
p6797
sg58
g62
sS'trial_loop.thisN'
p6798
I27
sg33
g6561
sg63
g64
sS'trial_loop.thisIndex'
p6799
g59
(g98
S'\x1b\x00\x00\x00'
tRp6800
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6801
I0
sg6379
S'25-kitkat.png'
p6802
sS'block_loop.thisRepN'
p6803
I2
sg6382
g6561
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6804
I2
sg6385
g6568
sg55
g11
sS'block_loop.thisTrial'
p6805
Nsg69
Vn
sS'block_loop.thisTrialN'
p6806
I0
sg39
F1.1168356536500141
sg34
g752
(S"\x07\xdf\n\x10\x0b'1\x04\xcex"
tRp6807
sa(dp6808
S'trial_loop.thisTrialN'
p6809
I28
sg6370
S'42-mrkipling_lemon_slices.png'
p6810
sS'block_loop.thisIndex'
p6811
g6364
sg38
S'right'
p6812
sg58
g62
sS'trial_loop.thisN'
p6813
I28
sg33
g6534
sg63
g64
sS'trial_loop.thisIndex'
p6814
g59
(g98
S'\x1c\x00\x00\x00'
tRp6815
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6816
I0
sg6379
S'16-skips_prawn.png'
p6817
sS'block_loop.thisRepN'
p6818
I2
sg6382
g6527
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6819
I2
sg6385
g6534
sg55
g11
sS'block_loop.thisTrial'
p6820
Nsg69
Vn
sS'block_loop.thisTrialN'
p6821
I0
sg39
F1.5999695515529311
sg34
g752
(S"\x07\xdf\n\x10\x0b'7\x07\x0c\xb0"
tRp6822
sa(dp6823
S'trial_loop.thisTrialN'
p6824
I29
sg6370
S'45-chewy_nougat_redo.png'
p6825
sS'block_loop.thisIndex'
p6826
g6364
sg38
S'right'
p6827
sg58
g62
sS'trial_loop.thisN'
p6828
I29
sg33
g6510
sg63
g64
sS'trial_loop.thisIndex'
p6829
g59
(g98
S'\x1d\x00\x00\x00'
tRp6830
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6831
I0
sg6379
S'41-peanuts_redo.png'
p6832
sS'block_loop.thisRepN'
p6833
I2
sg6382
g6510
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6834
I2
sg6385
g6517
sg55
g11
sS'block_loop.thisTrial'
p6835
Nsg69
Vn
sS'block_loop.thisTrialN'
p6836
I0
sg39
F1.3837556392345505
sg34
g752
(S'\x07\xdf\n\x10\x0b(\x02\x01g`'
tRp6837
sa(dp6838
S'trial_loop.thisTrialN'
p6839
I30
sg6370
S'49-yorkie.png'
p6840
sS'block_loop.thisIndex'
p6841
g6364
sg38
S'left'
p6842
sg58
g62
sS'trial_loop.thisN'
p6843
I30
sg33
g6595
sg63
g64
sS'trial_loop.thisIndex'
p6844
g59
(g98
S'\x1e\x00\x00\x00'
tRp6845
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6846
I0
sg6379
S'35-raisins.png'
p6847
sS'block_loop.thisRepN'
p6848
I2
sg6382
g6595
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6849
I2
sg6385
g6602
sg55
g11
sS'block_loop.thisTrial'
p6850
Nsg69
Vn
sS'block_loop.thisTrialN'
p6851
I0
sg39
F1.533537197282385
sg34
g752
(S'\x07\xdf\n\x10\x0b(\x08\x07\xebX'
tRp6852
sa(dp6853
S'trial_loop.thisTrialN'
p6854
I31
sg6370
g6442
sS'block_loop.thisIndex'
p6855
g6364
sg38
S'left'
p6856
sg58
g62
sS'trial_loop.thisN'
p6857
I31
sg33
g6446
sg63
g64
sS'trial_loop.thisIndex'
p6858
g59
(g98
S'\x1f\x00\x00\x00'
tRp6859
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6860
I0
sg6379
g6450
sS'block_loop.thisRepN'
p6861
I2
sg6382
g6446
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6862
I2
sg6385
g6453
sg55
g11
sS'block_loop.thisTrial'
p6863
Nsg69
Vn
sS'block_loop.thisTrialN'
p6864
I0
sg39
F1.0335400482617842
sg34
g752
(S'\x07\xdf\n\x10\x0b(\x0f\x01\x15X'
tRp6865
sa(dp6866
S'trial_loop.thisTrialN'
p6867
I32
sg6370
S'20-fruit_pastilles.png'
p6868
sS'block_loop.thisIndex'
p6869
g6364
sg38
S'left'
p6870
sg58
g62
sS'trial_loop.thisN'
p6871
I32
sg33
S'20-fruit_pastilles.png'
p6872
sg63
g64
sS'trial_loop.thisIndex'
p6873
g59
(g98
S' \x00\x00\x00'
tRp6874
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6875
I0
sg6379
S'2-steamed_puddings.png'
p6876
sS'block_loop.thisRepN'
p6877
I2
sg6382
g6872
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6878
I2
sg6385
S'2-steamed_puddings.png'
p6879
sg55
g11
sS'block_loop.thisTrial'
p6880
Nsg69
Vn
sS'block_loop.thisTrialN'
p6881
I0
sg39
F3.9000737833166568
sg34
g752
(S'\x07\xdf\n\x10\x0b(\x15\x02\x1e\xf8'
tRp6882
sa(dp6883
S'trial_loop.thisTrialN'
p6884
I33
sg6370
g6391
sS'block_loop.thisIndex'
p6885
g6364
sg38
S'left'
p6886
sg58
g62
sS'trial_loop.thisN'
p6887
I33
sg33
g6402
sg63
g64
sS'trial_loop.thisIndex'
p6888
g59
(g98
S'!\x00\x00\x00'
tRp6889
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6890
I0
sg6379
g6399
sS'block_loop.thisRepN'
p6891
I2
sg6382
g6395
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6892
I2
sg6385
g6402
sg55
g11
sS'block_loop.thisTrial'
p6893
Nsg69
Vn
sS'block_loop.thisTrialN'
p6894
I0
sg39
F1.3832535819692566
sg34
g752
(S'\x07\xdf\n\x10\x0b(\x1e\x010\xb0'
tRp6895
sa(dp6896
S'trial_loop.thisTrialN'
p6897
I34
sg6370
g6425
sS'block_loop.thisIndex'
p6898
g6364
sg38
S'left'
p6899
sg58
g62
sS'trial_loop.thisN'
p6900
I34
sg33
g6429
sg63
g64
sS'trial_loop.thisIndex'
p6901
g59
(g98
S'"\x00\x00\x00'
tRp6902
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6903
I0
sg6379
g6433
sS'block_loop.thisRepN'
p6904
I2
sg6382
g6429
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6905
I2
sg6385
g6436
sg55
g11
sS'block_loop.thisTrial'
p6906
Nsg69
Vn
sS'block_loop.thisTrialN'
p6907
I0
sg39
F0.7835138192613158
sg34
g752
(S'\x07\xdf\n\x10\x0b($\x07z\x10'
tRp6908
sa(dp6909
S'trial_loop.thisTrialN'
p6910
I35
sg6370
g6391
sS'block_loop.thisIndex'
p6911
g6364
sg38
S'left'
p6912
sg58
g62
sS'trial_loop.thisN'
p6913
I35
sg33
g6402
sg63
g64
sS'trial_loop.thisIndex'
p6914
g59
(g98
S'#\x00\x00\x00'
tRp6915
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6916
I0
sg6379
g6399
sS'block_loop.thisRepN'
p6917
I2
sg6382
g6395
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6918
I2
sg6385
g6402
sg55
g11
sS'block_loop.thisTrial'
p6919
Nsg69
Vn
sS'block_loop.thisTrialN'
p6920
I0
sg39
F1.1499380767527327
sg34
g752
(S'\x07\xdf\n\x10\x0b(*\x04\xb7\x08'
tRp6921
sa(dp6922
S'trial_loop.thisTrialN'
p6923
I36
sg6370
g6442
sS'block_loop.thisIndex'
p6924
g6364
sg38
S'left'
p6925
sg58
g62
sS'trial_loop.thisN'
p6926
I36
sg33
g6446
sg63
g64
sS'trial_loop.thisIndex'
p6927
g59
(g98
S'$\x00\x00\x00'
tRp6928
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6929
I0
sg6379
g6450
sS'block_loop.thisRepN'
p6930
I2
sg6382
g6446
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6931
I2
sg6385
g6453
sg55
g11
sS'block_loop.thisTrial'
p6932
Nsg69
Vn
sS'block_loop.thisTrialN'
p6933
I0
sg39
F0.78352066160914546
sg34
g752
(S'\x07\xdf\n\x10\x0b(0\x07\xa8\xf0'
tRp6934
sa(dp6935
S'trial_loop.thisTrialN'
p6936
I37
sg6370
S'19-caramello_redo.png'
p6937
sS'block_loop.thisIndex'
p6938
g6364
sg38
S'left'
p6939
sg58
g62
sS'trial_loop.thisN'
p6940
I37
sg33
g6726
sg63
g64
sS'trial_loop.thisIndex'
p6941
g59
(g98
S'%\x00\x00\x00'
tRp6942
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6943
I0
sg6379
S'30-spaghetti_hoops.png'
p6944
sS'block_loop.thisRepN'
p6945
I2
sg6382
g6726
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6946
I2
sg6385
g6733
sg55
g11
sS'block_loop.thisTrial'
p6947
Nsg69
Vn
sS'block_loop.thisTrialN'
p6948
I0
sg39
F0.9501412374611391
sg34
g752
(S'\x07\xdf\n\x10\x0b(6\x04\xa7h'
tRp6949
sa(dp6950
S'trial_loop.thisTrialN'
p6951
I38
sg6370
g6692
sS'block_loop.thisIndex'
p6952
g6364
sg38
S'left'
p6953
sg58
g62
sS'trial_loop.thisN'
p6954
I38
sg33
g6412
sg63
g64
sS'trial_loop.thisIndex'
p6955
g59
(g98
S'&\x00\x00\x00'
tRp6956
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6957
I0
sg6379
g6699
sS'block_loop.thisRepN'
p6958
I2
sg6382
g6412
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6959
I2
sg6385
g6419
sg55
g11
sS'block_loop.thisTrial'
p6960
Nsg69
Vn
sS'block_loop.thisTrialN'
p6961
I0
sg39
F0.81675907637418277
sg34
g752
(S'\x07\xdf\n\x10\x0b)\x00\x04\x80X'
tRp6962
sa(dp6963
S'trial_loop.thisTrialN'
p6964
I39
sg6370
S'44-crunch.png'
p6965
sS'block_loop.thisIndex'
p6966
g6364
sg38
S'left'
p6967
sg58
g62
sS'trial_loop.thisN'
p6968
I39
sg33
S'44-crunch.png'
p6969
sg63
g64
sS'trial_loop.thisIndex'
p6970
g59
(g98
S"'\x00\x00\x00"
tRp6971
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6972
I0
sg6379
S'26-walkers_smoky_bacon.png'
p6973
sS'block_loop.thisRepN'
p6974
I2
sg6382
g6969
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6975
I2
sg6385
S'26-walkers_smoky_bacon.png'
p6976
sg55
g11
sS'block_loop.thisTrial'
p6977
Nsg69
Vn
sS'block_loop.thisTrialN'
p6978
I0
sg39
F0.86685760618183849
sg34
g752
(S'\x07\xdf\n\x10\x0b)\x06\x026h'
tRp6979
sa(dp6980
S'trial_loop.thisTrialN'
p6981
I40
sg6370
S'40-sardines.png'
p6982
sS'block_loop.thisIndex'
p6983
g6364
sg38
S'left'
p6984
sg58
g62
sS'trial_loop.thisN'
p6985
I40
sg33
g6383
sg63
g64
sS'trial_loop.thisIndex'
p6986
g59
(g98
S'(\x00\x00\x00'
tRp6987
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p6988
I0
sg6379
S'5-pineapple.png'
p6989
sS'block_loop.thisRepN'
p6990
I2
sg6382
g6383
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p6991
I2
sg6385
g6375
sg55
g11
sS'block_loop.thisTrial'
p6992
Nsg69
Vn
sS'block_loop.thisTrialN'
p6993
I0
sg39
F0.80058775767156476
sg34
g752
(S'\x07\xdf\n\x10\x0b)\x0c\x00\xa4\x10'
tRp6994
sa(dp6995
S'trial_loop.thisTrialN'
p6996
I41
sg6370
g6408
sS'block_loop.thisIndex'
p6997
g6364
sg38
S'right'
p6998
sg58
g62
sS'trial_loop.thisN'
p6999
I41
sg33
g6419
sg63
g64
sS'trial_loop.thisIndex'
p7000
g59
(g98
S')\x00\x00\x00'
tRp7001
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7002
I0
sg6379
g6416
sS'block_loop.thisRepN'
p7003
I2
sg6382
g6412
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7004
I2
sg6385
g6419
sg55
g11
sS'block_loop.thisTrial'
p7005
Nsg69
Vn
sS'block_loop.thisTrialN'
p7006
I0
sg39
F0.73354529406060465
sg34
g752
(S'\x07\xdf\n\x10\x0b)\x11\ra\xc8'
tRp7007
sa(dp7008
S'trial_loop.thisTrialN'
p7009
I42
sg6370
g6795
sS'block_loop.thisIndex'
p7010
g6364
sg38
S'right'
p7011
sg58
g62
sS'trial_loop.thisN'
p7012
I42
sg33
g6568
sg63
g64
sS'trial_loop.thisIndex'
p7013
g59
(g98
S'*\x00\x00\x00'
tRp7014
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7015
I0
sg6379
g6802
sS'block_loop.thisRepN'
p7016
I2
sg6382
g6561
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7017
I2
sg6385
g6568
sg55
g11
sS'block_loop.thisTrial'
p7018
Nsg69
Vn
sS'block_loop.thisTrialN'
p7019
I0
sg39
F1.0500677392419675
sg34
g752
(S'\x07\xdf\n\x10\x0b)\x17\t\xe7('
tRp7020
sa(dp7021
S'trial_loop.thisTrialN'
p7022
I43
sg6370
S'2-steamed_puddings.png'
p7023
sS'block_loop.thisIndex'
p7024
g6364
sg38
S'right'
p7025
sg58
g62
sS'trial_loop.thisN'
p7026
I43
sg33
g6872
sg63
g64
sS'trial_loop.thisIndex'
p7027
g59
(g98
S'+\x00\x00\x00'
tRp7028
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7029
I0
sg6379
S'20-fruit_pastilles.png'
p7030
sS'block_loop.thisRepN'
p7031
I2
sg6382
g6872
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7032
I2
sg6385
g6879
sg55
g11
sS'block_loop.thisTrial'
p7033
Nsg69
Vn
sS'block_loop.thisTrialN'
p7034
I0
sg39
F0.96684911026659393
sg34
g752
(S'\x07\xdf\n\x10\x0b)\x1d\x0b/H'
tRp7035
sa(dp7036
S'trial_loop.thisTrialN'
p7037
I44
sg6370
g6540
sS'block_loop.thisIndex'
p7038
g6364
sg38
S'right'
p7039
sg58
g62
sS'trial_loop.thisN'
p7040
I44
sg33
g6551
sg63
g64
sS'trial_loop.thisIndex'
p7041
g59
(g98
S',\x00\x00\x00'
tRp7042
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7043
I0
sg6379
g6548
sS'block_loop.thisRepN'
p7044
I2
sg6382
g6544
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7045
I2
sg6385
g6551
sg55
g11
sS'block_loop.thisTrial'
p7046
Nsg69
Vn
sS'block_loop.thisTrialN'
p7047
I0
sg39
F1.0668691241344277
sg34
g752
(S'\x07\xdf\n\x10\x0b)#\x0b\x088'
tRp7048
sa(dp7049
S'trial_loop.thisTrialN'
p7050
I45
sg6370
g6634
sS'block_loop.thisIndex'
p7051
g6364
sg38
S'left'
p7052
sg58
g62
sS'trial_loop.thisN'
p7053
I45
sg33
g6463
sg63
g64
sS'trial_loop.thisIndex'
p7054
g59
(g98
S'-\x00\x00\x00'
tRp7055
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7056
I0
sg6379
g6641
sS'block_loop.thisRepN'
p7057
I2
sg6382
g6463
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7058
I2
sg6385
g6470
sg55
g11
sS'block_loop.thisTrial'
p7059
Nsg69
Vn
sS'block_loop.thisTrialN'
p7060
I0
sg39
F2.2505821697532156
sg34
g752
(S'\x07\xdf\n\x10\x0b))\x0c\x8e\xd8'
tRp7061
sa(dp7062
S'trial_loop.thisTrialN'
p7063
I46
sg6370
g6591
sS'block_loop.thisIndex'
p7064
g6364
sg38
S'right'
p7065
sg58
g62
sS'trial_loop.thisN'
p7066
I46
sg33
g6595
sg63
g64
sS'trial_loop.thisIndex'
p7067
g59
(g98
S'.\x00\x00\x00'
tRp7068
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7069
I0
sg6379
g6599
sS'block_loop.thisRepN'
p7070
I2
sg6382
g6595
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7071
I2
sg6385
g6602
sg55
g11
sS'block_loop.thisTrial'
p7072
Nsg69
Vn
sS'block_loop.thisTrialN'
p7073
I0
sg39
F1.1335187229442454
sg34
g752
(S'\x07\xdf\n\x10\x0b)1\x01\xa5\xe0'
tRp7074
sa(dp7075
S'trial_loop.thisTrialN'
p7076
I47
sg6370
S'43-mrporky_pork_crackles_redo.png'
p7077
sS'block_loop.thisIndex'
p7078
g6364
sg38
S'right'
p7079
sg58
g62
sS'trial_loop.thisN'
p7080
I47
sg33
S'43-mrporky_pork_crackles_redo.png'
p7081
sg63
g64
sS'trial_loop.thisIndex'
p7082
g59
(g98
S'/\x00\x00\x00'
tRp7083
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7084
I0
sg6379
S'18-mms.png'
p7085
sS'block_loop.thisRepN'
p7086
I2
sg6382
S'18-mms.png'
p7087
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7088
I2
sg6385
g7081
sg55
g11
sS'block_loop.thisTrial'
p7089
Nsg69
Vn
sS'block_loop.thisTrialN'
p7090
I0
sg39
F0.7335393070070495
sg34
g752
(S'\x07\xdf\n\x10\x0b)7\x04\x1e\xb0'
tRp7091
sa(dp7092
S'trial_loop.thisTrialN'
p7093
I48
sg6370
S'4-corn.png'
p7094
sS'block_loop.thisIndex'
p7095
g6364
sg38
S'left'
p7096
sg58
g62
sS'trial_loop.thisN'
p7097
I48
sg33
S'4-corn.png'
p7098
sg63
g64
sS'trial_loop.thisIndex'
p7099
g59
(g98
S'0\x00\x00\x00'
tRp7100
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7101
I0
sg6379
S'10-bounty_redo.png'
p7102
sS'block_loop.thisRepN'
p7103
I2
sg6382
g7098
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7104
I2
sg6385
S'10-bounty_redo.png'
p7105
sg55
g11
sS'block_loop.thisTrial'
p7106
Nsg69
Vn
sS'block_loop.thisTrialN'
p7107
I0
sg39
F1.2335062356596609
sg34
g752
(S'\x07\xdf\n\x10\x0b*\x01\x00\xa4\x10'
tRp7108
sa(dp7109
S'trial_loop.thisTrialN'
p7110
I49
sg6370
S'26-walkers_smoky_bacon.png'
p7111
sS'block_loop.thisIndex'
p7112
g6364
sg38
S'right'
p7113
sg58
g62
sS'trial_loop.thisN'
p7114
I49
sg33
g6969
sg63
g64
sS'trial_loop.thisIndex'
p7115
g59
(g98
S'1\x00\x00\x00'
tRp7116
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7117
I0
sg6379
S'44-crunch.png'
p7118
sS'block_loop.thisRepN'
p7119
I2
sg6382
g6969
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7120
I2
sg6385
g6976
sg55
g11
sS'block_loop.thisTrial'
p7121
Nsg69
Vn
sS'block_loop.thisTrialN'
p7122
I0
sg39
F0.78354717570709909
sg34
g752
(S'\x07\xdf\n\x10\x0b*\x07\x04\xc6\xa8'
tRp7123
sa(dp7124
S'trial_loop.thisTrialN'
p7125
I50
sg6370
g6591
sS'block_loop.thisIndex'
p7126
g6364
sg38
S'right'
p7127
sg58
g62
sS'trial_loop.thisN'
p7128
I50
sg33
g6595
sg63
g64
sS'trial_loop.thisIndex'
p7129
g59
(g98
S'2\x00\x00\x00'
tRp7130
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7131
I0
sg6379
g6599
sS'block_loop.thisRepN'
p7132
I2
sg6382
g6595
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7133
I2
sg6385
g6602
sg55
g11
sS'block_loop.thisTrial'
p7134
Nsg69
Vn
sS'block_loop.thisTrialN'
p7135
I0
sg39
F1.0502151348173356
sg34
g752
(S'\x07\xdf\n\x10\x0b*\r\x02\x03\xa0'
tRp7136
sa(dp7137
S'trial_loop.thisTrialN'
p7138
I51
sg6370
g6965
sS'block_loop.thisIndex'
p7139
g6364
sg38
S'left'
p7140
sg58
g62
sS'trial_loop.thisN'
p7141
I51
sg33
g6969
sg63
g64
sS'trial_loop.thisIndex'
p7142
g59
(g98
S'3\x00\x00\x00'
tRp7143
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7144
I0
sg6379
g6973
sS'block_loop.thisRepN'
p7145
I2
sg6382
g6969
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7146
I2
sg6385
g6976
sg55
g11
sS'block_loop.thisTrial'
p7147
Nsg69
Vn
sS'block_loop.thisTrialN'
p7148
I0
sg39
F1.0168293244778397
sg34
g752
(S'\x07\xdf\n\x10\x0b*\x13\x03K\xc0'
tRp7149
sa(dp7150
S'trial_loop.thisTrialN'
p7151
I52
sg6370
g6491
sS'block_loop.thisIndex'
p7152
g6364
sg38
S'right'
p7153
sg58
g62
sS'trial_loop.thisN'
p7154
I52
sg33
g6446
sg63
g64
sS'trial_loop.thisIndex'
p7155
g59
(g98
S'4\x00\x00\x00'
tRp7156
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7157
I0
sg6379
g6498
sS'block_loop.thisRepN'
p7158
I2
sg6382
g6446
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7159
I2
sg6385
g6453
sg55
g11
sS'block_loop.thisTrial'
p7160
Nsg69
Vn
sS'block_loop.thisTrialN'
p7161
I0
sg39
F1.0001801818234526
sg34
g752
(S'\x07\xdf\n\x10\x0b*\x19\x03\xdcH'
tRp7162
sa(dp7163
S'trial_loop.thisTrialN'
p7164
I53
sg6370
S'50-polo.png'
p7165
sS'block_loop.thisIndex'
p7166
g6364
sg38
S'right'
p7167
sg58
g62
sS'trial_loop.thisN'
p7168
I53
sg33
S'48-twix.png'
p7169
sg63
g64
sS'trial_loop.thisIndex'
p7170
g59
(g98
S'5\x00\x00\x00'
tRp7171
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7172
I0
sg6379
S'48-twix.png'
p7173
sS'block_loop.thisRepN'
p7174
I2
sg6382
g7169
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7175
I2
sg6385
S'50-polo.png'
p7176
sg55
g11
sS'block_loop.thisTrial'
p7177
Nsg69
Vn
sS'block_loop.thisTrialN'
p7178
I0
sg39
F1.1668517901862288
sg34
g752
(S'\x07\xdf\n\x10\x0b*\x1f\x04l\xd0'
tRp7179
sa(dp7180
S'trial_loop.thisTrialN'
p7181
I54
sg6370
g6442
sS'block_loop.thisIndex'
p7182
g6364
sg38
S'left'
p7183
sg58
g62
sS'trial_loop.thisN'
p7184
I54
sg33
g6446
sg63
g64
sS'trial_loop.thisIndex'
p7185
g59
(g98
S'6\x00\x00\x00'
tRp7186
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7187
I0
sg6379
g6450
sS'block_loop.thisRepN'
p7188
I2
sg6382
g6446
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7189
I2
sg6385
g6453
sg55
g11
sS'block_loop.thisTrial'
p7190
Nsg69
Vn
sS'block_loop.thisTrialN'
p7191
I0
sg39
F1.3335367981462696
sg34
g752
(S'\x07\xdf\n\x10\x0b*%\x07\x9d8'
tRp7192
sa(dp7193
S'trial_loop.thisTrialN'
p7194
I55
sg6370
g7165
sS'block_loop.thisIndex'
p7195
g6364
sg38
S'right'
p7196
sg58
g62
sS'trial_loop.thisN'
p7197
I55
sg33
g7169
sg63
g64
sS'trial_loop.thisIndex'
p7198
g59
(g98
S'7\x00\x00\x00'
tRp7199
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7200
I0
sg6379
g7173
sS'block_loop.thisRepN'
p7201
I2
sg6382
g7169
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7202
I2
sg6385
g7176
sg55
g11
sS'block_loop.thisTrial'
p7203
Nsg69
Vn
sS'block_loop.thisTrialN'
p7204
I0
sg39
F0.70021707348223572
sg34
g752
(S'\x07\xdf\n\x10\x0b*+\r/\x00'
tRp7205
sa(dp7206
S'trial_loop.thisTrialN'
p7207
I56
sg6370
g6459
sS'block_loop.thisIndex'
p7208
g6364
sg38
S'right'
p7209
sg58
g62
sS'trial_loop.thisN'
p7210
I56
sg33
g6463
sg63
g64
sS'trial_loop.thisIndex'
p7211
g59
(g98
S'8\x00\x00\x00'
tRp7212
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7213
I0
sg6379
g6467
sS'block_loop.thisRepN'
p7214
I2
sg6382
g6463
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7215
I2
sg6385
g6470
sg55
g11
sS'block_loop.thisTrial'
p7216
Nsg69
Vn
sS'block_loop.thisTrialN'
p7217
I0
sg39
F0.85013918475760875
sg34
g752
(S'\x07\xdf\n\x10\x0b*1\x08\xfc\xc8'
tRp7218
sa(dp7219
S'trial_loop.thisTrialN'
p7220
I57
sg6370
g6982
sS'block_loop.thisIndex'
p7221
g6364
sg38
S'left'
p7222
sg58
g62
sS'trial_loop.thisN'
p7223
I57
sg33
g6383
sg63
g64
sS'trial_loop.thisIndex'
p7224
g59
(g98
S'9\x00\x00\x00'
tRp7225
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7226
I0
sg6379
g6989
sS'block_loop.thisRepN'
p7227
I2
sg6382
g6383
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7228
I2
sg6385
g6375
sg55
g11
sS'block_loop.thisTrial'
p7229
Nsg69
Vn
sS'block_loop.thisTrialN'
p7230
I0
sg39
F0.83352881540668022
sg34
g752
(S'\x07\xdf\n\x10\x0b*7\x07+\xf0'
tRp7231
sa(dp7232
S'trial_loop.thisTrialN'
p7233
I58
sg6370
g6825
sS'block_loop.thisIndex'
p7234
g6364
sg38
S'right'
p7235
sg58
g62
sS'trial_loop.thisN'
p7236
I58
sg33
g6510
sg63
g64
sS'trial_loop.thisIndex'
p7237
g59
(g98
S':\x00\x00\x00'
tRp7238
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7239
I0
sg6379
g6832
sS'block_loop.thisRepN'
p7240
I2
sg6382
g6510
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7241
I2
sg6385
g6517
sg55
g11
sS'block_loop.thisTrial'
p7242
Nsg69
Vn
sS'block_loop.thisTrialN'
p7243
I0
sg39
F0.93347926540627668
sg34
g752
(S'\x07\xdf\n\x10\x0b+\x01\x05 \x80'
tRp7244
sa(dp7245
S'trial_loop.thisTrialN'
p7246
I59
sg6370
g6557
sS'block_loop.thisIndex'
p7247
g6364
sg38
S'left'
p7248
sg58
g62
sS'trial_loop.thisN'
p7249
I59
sg33
g6568
sg63
g64
sS'trial_loop.thisIndex'
p7250
g59
(g98
S';\x00\x00\x00'
tRp7251
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7252
I0
sg6379
g6565
sS'block_loop.thisRepN'
p7253
I2
sg6382
g6561
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7254
I2
sg6385
g6568
sg55
g11
sS'block_loop.thisTrial'
p7255
Nsg69
Vn
sS'block_loop.thisTrialN'
p7256
I0
sg39
F1.5334251538388344
sg34
g752
(S'\x07\xdf\n\x10\x0b+\x07\x04\xbe\xd8'
tRp7257
sa(dp7258
S'trial_loop.thisTrialN'
p7259
I60
sg6370
g6825
sS'block_loop.thisIndex'
p7260
g6364
sg38
S'right'
p7261
sg58
g62
sS'trial_loop.thisN'
p7262
I60
sg33
g6517
sg63
g64
sS'trial_loop.thisIndex'
p7263
g59
(g98
S'<\x00\x00\x00'
tRp7264
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7265
I0
sg6379
g6832
sS'block_loop.thisRepN'
p7266
I2
sg6382
g6510
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7267
I2
sg6385
g6517
sg55
g11
sS'block_loop.thisTrial'
p7268
Nsg69
Vn
sS'block_loop.thisTrialN'
p7269
I0
sg39
F0.76726324336414109
sg34
g752
(S'\x07\xdf\n\x10\x0b+\r\re\xb0'
tRp7270
sa(dp7271
S'trial_loop.thisTrialN'
p7272
I61
sg6370
S'3-ellas_strawberries_apples.png'
p7273
sS'block_loop.thisIndex'
p7274
g6364
sg38
S'left'
p7275
sg58
g62
sS'trial_loop.thisN'
p7276
I61
sg33
g6544
sg63
g64
sS'trial_loop.thisIndex'
p7277
g59
(g98
S'=\x00\x00\x00'
tRp7278
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7279
I0
sg6379
S'13-mccoys_steak_crisps.png'
p7280
sS'block_loop.thisRepN'
p7281
I2
sg6382
g6544
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7282
I2
sg6385
g6551
sg55
g11
sS'block_loop.thisTrial'
p7283
Nsg69
Vn
sS'block_loop.thisTrialN'
p7284
I0
sg39
F1.2501607951726328
sg34
g752
(S'\x07\xdf\n\x10\x0b+\x13\nh\x10'
tRp7285
sa(dp7286
S'trial_loop.thisTrialN'
p7287
I62
sg6370
g6722
sS'block_loop.thisIndex'
p7288
g6364
sg38
S'right'
p7289
sg58
g62
sS'trial_loop.thisN'
p7290
I62
sg33
g6726
sg63
g64
sS'trial_loop.thisIndex'
p7291
g59
(g98
S'>\x00\x00\x00'
tRp7292
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7293
I0
sg6379
g6730
sS'block_loop.thisRepN'
p7294
I2
sg6382
g6726
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7295
I2
sg6385
g6733
sg55
g11
sS'block_loop.thisTrial'
p7296
Nsg69
Vn
sS'block_loop.thisTrialN'
p7297
I0
sg39
F0.90017442284806748
sg34
g752
(S'\x07\xdf\n\x10\x0b+\x19\x0e\x8a\xa8'
tRp7298
sa(dp7299
S'trial_loop.thisTrialN'
p7300
I63
sg6370
g7094
sS'block_loop.thisIndex'
p7301
g6364
sg38
S'left'
p7302
sg58
g62
sS'trial_loop.thisN'
p7303
I63
sg33
g7105
sg63
g64
sS'trial_loop.thisIndex'
p7304
g59
(g98
S'?\x00\x00\x00'
tRp7305
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7306
I0
sg6379
g7102
sS'block_loop.thisRepN'
p7307
I2
sg6382
g7098
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7308
I2
sg6385
g7105
sg55
g11
sS'block_loop.thisTrial'
p7309
Nsg69
Vn
sS'block_loop.thisTrialN'
p7310
I0
sg39
F0.8668918179209868
sg34
g752
(S'\x07\xdf\n\x10\x0b+\x1f\r\xaf\xe8'
tRp7311
sa(dp7312
S'trial_loop.thisTrialN'
p7313
I64
sg6370
g6523
sS'block_loop.thisIndex'
p7314
g6364
sg38
S'left'
p7315
sg58
g62
sS'trial_loop.thisN'
p7316
I64
sg33
g6527
sg63
g64
sS'trial_loop.thisIndex'
p7317
g59
(g98
S'@\x00\x00\x00'
tRp7318
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7319
I0
sg6379
g6531
sS'block_loop.thisRepN'
p7320
I2
sg6382
g6527
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7321
I2
sg6385
g6534
sg55
g11
sS'block_loop.thisTrial'
p7322
Nsg69
Vn
sS'block_loop.thisTrialN'
p7323
I0
sg39
F1.1334197939995647
sg34
g752
(S'\x07\xdf\n\x10\x0b+%\x0c\x19\xa8'
tRp7324
sa(dp7325
S'trial_loop.thisTrialN'
p7326
I65
sg6370
g6634
sS'block_loop.thisIndex'
p7327
g6364
sg38
S'left'
p7328
sg58
g62
sS'trial_loop.thisN'
p7329
I65
sg33
g6470
sg63
g64
sS'trial_loop.thisIndex'
p7330
g59
(g98
S'A\x00\x00\x00'
tRp7331
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7332
I0
sg6379
g6641
sS'block_loop.thisRepN'
p7333
I2
sg6382
g6463
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7334
I2
sg6385
g6470
sg55
g11
sS'block_loop.thisTrial'
p7335
Nsg69
Vn
sS'block_loop.thisTrialN'
p7336
I0
sg39
F1.0505943149209998
sg34
g752
(S'\x07\xdf\n\x10\x0b++\x0e\x92x'
tRp7337
sa(dp7338
S'trial_loop.thisTrialN'
p7339
I66
sg6370
g6523
sS'block_loop.thisIndex'
p7340
g6364
sg38
S'left'
p7341
sg58
g62
sS'trial_loop.thisN'
p7342
I66
sg33
g6527
sg63
g64
sS'trial_loop.thisIndex'
p7343
g59
(g98
S'B\x00\x00\x00'
tRp7344
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7345
I0
sg6379
g6531
sS'block_loop.thisRepN'
p7346
I2
sg6382
g6527
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7347
I2
sg6385
g6534
sg55
g11
sS'block_loop.thisTrial'
p7348
Nsg69
Vn
sS'block_loop.thisTrialN'
p7349
I0
sg39
F0.71674904093106306
sg34
g752
(S'\x07\xdf\n\x10\x0b+2\x00\x98X'
tRp7350
sa(dp7351
S'trial_loop.thisTrialN'
p7352
I67
sg6370
S'10-bounty_redo.png'
p7353
sS'block_loop.thisIndex'
p7354
g6364
sg38
S'right'
p7355
sg58
g62
sS'trial_loop.thisN'
p7356
I67
sg33
g7098
sg63
g64
sS'trial_loop.thisIndex'
p7357
g59
(g98
S'C\x00\x00\x00'
tRp7358
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7359
I0
sg6379
S'4-corn.png'
p7360
sS'block_loop.thisRepN'
p7361
I2
sg6382
g7098
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7362
I2
sg6385
g7105
sg55
g11
sS'block_loop.thisTrial'
p7363
Nsg69
Vn
sS'block_loop.thisTrialN'
p7364
I0
sg39
F0.75010947756345558
sg34
g752
(S'\x07\xdf\n\x10\x0b+7\x0c%`'
tRp7365
sa(dp7366
S'trial_loop.thisTrialN'
p7367
I68
sg6370
g6868
sS'block_loop.thisIndex'
p7368
g6364
sg38
S'left'
p7369
sg58
g62
sS'trial_loop.thisN'
p7370
I68
sg33
g6872
sg63
g64
sS'trial_loop.thisIndex'
p7371
g59
(g98
S'D\x00\x00\x00'
tRp7372
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7373
I0
sg6379
g6876
sS'block_loop.thisRepN'
p7374
I2
sg6382
g6872
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7375
I2
sg6385
g6879
sg55
g11
sS'block_loop.thisTrial'
p7376
Nsg69
Vn
sS'block_loop.thisTrialN'
p7377
I0
sg39
F0.9168694662521375
sg34
g752
(S'\x07\xdf\n\x10\x0b,\x01\x08\xe5X'
tRp7378
sa(dp7379
S'trial_loop.thisTrialN'
p7380
I69
sg6370
g6937
sS'block_loop.thisIndex'
p7381
g6364
sg38
S'left'
p7382
sg58
g62
sS'trial_loop.thisN'
p7383
I69
sg33
g6726
sg63
g64
sS'trial_loop.thisIndex'
p7384
g59
(g98
S'E\x00\x00\x00'
tRp7385
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7386
I0
sg6379
g6944
sS'block_loop.thisRepN'
p7387
I2
sg6382
g6726
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7388
I2
sg6385
g6733
sg55
g11
sS'block_loop.thisTrial'
p7389
Nsg69
Vn
sS'block_loop.thisTrialN'
p7390
I0
sg39
F0.96680377971279086
sg34
g752
(S'\x07\xdf\n\x10\x0b,\x07\x08\n\x98'
tRp7391
sa(dp7392
S'trial_loop.thisTrialN'
p7393
I70
sg6370
g6574
sS'block_loop.thisIndex'
p7394
g6364
sg38
S'right'
p7395
sg58
g62
sS'trial_loop.thisN'
p7396
I70
sg33
g6578
sg63
g64
sS'trial_loop.thisIndex'
p7397
g59
(g98
S'F\x00\x00\x00'
tRp7398
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7399
I0
sg6379
g6582
sS'block_loop.thisRepN'
p7400
I2
sg6382
g6578
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7401
I2
sg6385
g6585
sg55
g11
sS'block_loop.thisTrial'
p7402
Nsg69
Vn
sS'block_loop.thisTrialN'
p7403
I0
sg39
F0.96677926130087144
sg34
g752
(S'\x07\xdf\n\x10\x0b,\r\x08"\x08'
tRp7404
sa(dp7405
S'trial_loop.thisTrialN'
p7406
I71
sg6370
g6752
sS'block_loop.thisIndex'
p7407
g6364
sg38
S'left'
p7408
sg58
g62
sS'trial_loop.thisN'
p7409
I71
sg33
g6756
sg63
g64
sS'trial_loop.thisIndex'
p7410
g59
(g98
S'G\x00\x00\x00'
tRp7411
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7412
I0
sg6379
g6760
sS'block_loop.thisRepN'
p7413
I2
sg6382
g6756
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7414
I2
sg6385
g6763
sg55
g11
sS'block_loop.thisTrial'
p7415
Nsg69
Vn
sS'block_loop.thisTrialN'
p7416
I0
sg39
F0.83388860885952454
sg34
g752
(S'\x07\xdf\n\x10\x0b,\x13\x07\xfa\xf8'
tRp7417
sa(dp7418
S'trial_loop.thisTrialN'
p7419
I72
sg6370
g6459
sS'block_loop.thisIndex'
p7420
g6364
sg38
S'right'
p7421
sg58
g62
sS'trial_loop.thisN'
p7422
I72
sg33
g6463
sg63
g64
sS'trial_loop.thisIndex'
p7423
g59
(g98
S'H\x00\x00\x00'
tRp7424
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7425
I0
sg6379
g6467
sS'block_loop.thisRepN'
p7426
I2
sg6382
g6463
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7427
I2
sg6385
g6470
sg55
g11
sS'block_loop.thisTrial'
p7428
Nsg69
Vn
sS'block_loop.thisTrialN'
p7429
I0
sg39
F2.1001731113974529
sg34
g752
(S'\x07\xdf\n\x10\x0b,\x19\x05\xef\x88'
tRp7430
sa(dp7431
S'trial_loop.thisTrialN'
p7432
I73
sg6370
g6840
sS'block_loop.thisIndex'
p7433
g6364
sg38
S'left'
p7434
sg58
g62
sS'trial_loop.thisN'
p7435
I73
sg33
g6595
sg63
g64
sS'trial_loop.thisIndex'
p7436
g59
(g98
S'I\x00\x00\x00'
tRp7437
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7438
I0
sg6379
g6847
sS'block_loop.thisRepN'
p7439
I2
sg6382
g6595
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7440
I2
sg6385
g6602
sg55
g11
sS'block_loop.thisTrial'
p7441
Nsg69
Vn
sS'block_loop.thisTrialN'
p7442
I0
sg39
F0.81684089944883453
sg34
g752
(S'\x07\xdf\n\x10\x0b, \x07\xe7p'
tRp7443
sa(dp7444
S'trial_loop.thisTrialN'
p7445
I74
sg6370
S'8-liquorice_catherine_wheels.png'
p7446
sS'block_loop.thisIndex'
p7447
g6364
sg38
S'right'
p7448
sg58
g62
sS'trial_loop.thisN'
p7449
I74
sg33
g6429
sg63
g64
sS'trial_loop.thisIndex'
p7450
g59
(g98
S'J\x00\x00\x00'
tRp7451
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7452
I0
sg6379
S'17-jacobs_mini_cheddars_redo.png'
p7453
sS'block_loop.thisRepN'
p7454
I2
sg6382
g6429
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7455
I2
sg6385
g6436
sg55
g11
sS'block_loop.thisTrial'
p7456
Nsg69
Vn
sS'block_loop.thisTrialN'
p7457
I0
sg39
F0.88353582881336479
sg34
g752
(S'\x07\xdf\n\x10\x0b,&\x05\x9d\x80'
tRp7458
sa(dp7459
S'trial_loop.thisTrialN'
p7460
I75
sg6370
g6825
sS'block_loop.thisIndex'
p7461
g6364
sg38
S'right'
p7462
sg58
g62
sS'trial_loop.thisN'
p7463
I75
sg33
g6510
sg63
g64
sS'trial_loop.thisIndex'
p7464
g59
(g98
S'K\x00\x00\x00'
tRp7465
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7466
I0
sg6379
g6832
sS'block_loop.thisRepN'
p7467
I2
sg6382
g6510
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7468
I2
sg6385
g6517
sg55
g11
sS'block_loop.thisTrial'
p7469
Nsg69
Vn
sS'block_loop.thisTrialN'
p7470
I0
sg39
F0.90017784402243706
sg34
g752
(S'\x07\xdf\n\x10\x0b,,\x04\x84@'
tRp7471
sa(dp7472
S'trial_loop.thisTrialN'
p7473
I76
sg6370
g7023
sS'block_loop.thisIndex'
p7474
g6364
sg38
S'right'
p7475
sg58
g62
sS'trial_loop.thisN'
p7476
I76
sg33
g6872
sg63
g64
sS'trial_loop.thisIndex'
p7477
g59
(g98
S'L\x00\x00\x00'
tRp7478
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7479
I0
sg6379
g7030
sS'block_loop.thisRepN'
p7480
I2
sg6382
g6872
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7481
I2
sg6385
g6879
sg55
g11
sS'block_loop.thisTrial'
p7482
Nsg69
Vn
sS'block_loop.thisTrialN'
p7483
I0
sg39
F0.81690305077518133
sg34
g752
(S'\x07\xdf\n\x10\x0b,2\x03k\x00'
tRp7484
sa(dp7485
S'trial_loop.thisTrialN'
p7486
I77
sg6370
g6722
sS'block_loop.thisIndex'
p7487
g6364
sg38
S'right'
p7488
sg58
g62
sS'trial_loop.thisN'
p7489
I77
sg33
g6726
sg63
g64
sS'trial_loop.thisIndex'
p7490
g59
(g98
S'M\x00\x00\x00'
tRp7491
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7492
I0
sg6379
g6730
sS'block_loop.thisRepN'
p7493
I2
sg6382
g6726
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7494
I2
sg6385
g6733
sg55
g11
sS'block_loop.thisTrial'
p7495
Nsg69
Vn
sS'block_loop.thisTrialN'
p7496
I0
sg39
F0.91680503414318082
sg34
g752
(S'\x07\xdf\n\x10\x0b,8\x01!\x10'
tRp7497
sa(dp7498
S'trial_loop.thisTrialN'
p7499
I78
sg6370
g6557
sS'block_loop.thisIndex'
p7500
g6364
sg38
S'left'
p7501
sg58
g62
sS'trial_loop.thisN'
p7502
I78
sg33
g6568
sg63
g64
sS'trial_loop.thisIndex'
p7503
g59
(g98
S'N\x00\x00\x00'
tRp7504
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7505
I0
sg6379
g6565
sS'block_loop.thisRepN'
p7506
I2
sg6382
g6561
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7507
I2
sg6385
g6568
sg55
g11
sS'block_loop.thisTrial'
p7508
Nsg69
Vn
sS'block_loop.thisTrialN'
p7509
I0
sg39
F2.3501522992564787
sg34
g752
(S'\x07\xdf\n\x10\x0b-\x02\x00FP'
tRp7510
sa(dp7511
S'trial_loop.thisTrialN'
p7512
I79
sg6370
S'18-mms.png'
p7513
sS'block_loop.thisIndex'
p7514
g6364
sg38
S'left'
p7515
sg58
g62
sS'trial_loop.thisN'
p7516
I79
sg33
g7087
sg63
g64
sS'trial_loop.thisIndex'
p7517
g59
(g98
S'O\x00\x00\x00'
tRp7518
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7519
I0
sg6379
S'43-mrporky_pork_crackles_redo.png'
p7520
sS'block_loop.thisRepN'
p7521
I2
sg6382
g7087
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7522
I2
sg6385
g7081
sg55
g11
sS'block_loop.thisTrial'
p7523
Nsg69
Vn
sS'block_loop.thisTrialN'
p7524
I0
sg39
F0.90011854367458
sg34
g752
(S'\x07\xdf\n\x10\x0b-\t\x06I`'
tRp7525
sa(dp7526
S'trial_loop.thisTrialN'
p7527
I80
sg6370
g7165
sS'block_loop.thisIndex'
p7528
g6364
sg38
S'right'
p7529
sg58
g62
sS'trial_loop.thisN'
p7530
I80
sg33
g7169
sg63
g64
sS'trial_loop.thisIndex'
p7531
g59
(g98
S'P\x00\x00\x00'
tRp7532
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7533
I0
sg6379
g7173
sS'block_loop.thisRepN'
p7534
I2
sg6382
g7169
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7535
I2
sg6385
g7176
sg55
g11
sS'block_loop.thisTrial'
p7536
Nsg69
Vn
sS'block_loop.thisTrialN'
p7537
I0
sg39
F1.316891076666252
sg34
g752
(S'\x07\xdf\n\x10\x0b-\x0f\x050 '
tRp7538
sa(dp7539
S'trial_loop.thisTrialN'
p7540
I81
sg6370
g6491
sS'block_loop.thisIndex'
p7541
g6364
sg38
S'right'
p7542
sg58
g62
sS'trial_loop.thisN'
p7543
I81
sg33
g6446
sg63
g64
sS'trial_loop.thisIndex'
p7544
g59
(g98
S'Q\x00\x00\x00'
tRp7545
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7546
I0
sg6379
g6498
sS'block_loop.thisRepN'
p7547
I2
sg6382
g6446
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7548
I2
sg6385
g6453
sg55
g11
sS'block_loop.thisTrial'
p7549
Nsg69
Vn
sS'block_loop.thisTrialN'
p7550
I0
sg39
F1.1838034216298183
sg34
g752
(S'\x07\xdf\n\x10\x0b-\x15\n\x87P'
tRp7551
sa(dp7552
S'trial_loop.thisTrialN'
p7553
I82
sg6370
g6840
sS'block_loop.thisIndex'
p7554
g6364
sg38
S'left'
p7555
sg58
g62
sS'trial_loop.thisN'
p7556
I82
sg33
g6595
sg63
g64
sS'trial_loop.thisIndex'
p7557
g59
(g98
S'R\x00\x00\x00'
tRp7558
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7559
I0
sg6379
g6847
sS'block_loop.thisRepN'
p7560
I2
sg6382
g6595
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7561
I2
sg6385
g6602
sg55
g11
sS'block_loop.thisTrial'
p7562
Nsg69
Vn
sS'block_loop.thisTrialN'
p7563
I0
sg39
F2.1168108501387906
sg34
g752
(S'\x07\xdf\n\x10\x0b-\x1b\r\xf2P'
tRp7564
sa(dp7565
S'trial_loop.thisTrialN'
p7566
I83
sg6370
g6408
sS'block_loop.thisIndex'
p7567
g6364
sg38
S'right'
p7568
sg58
g62
sS'trial_loop.thisN'
p7569
I83
sg33
g6412
sg63
g64
sS'trial_loop.thisIndex'
p7570
g59
(g98
S'S\x00\x00\x00'
tRp7571
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7572
I0
sg6379
g6416
sS'block_loop.thisRepN'
p7573
I2
sg6382
g6412
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7574
I2
sg6385
g6419
sg55
g11
sS'block_loop.thisTrial'
p7575
Nsg69
Vn
sS'block_loop.thisTrialN'
p7576
I0
sg39
F1.4335120516552706
sg34
g752
(S'\x07\xdf\n\x10\x0b-#\x00\xe6x'
tRp7577
sa(dp7578
S'trial_loop.thisTrialN'
p7579
I84
sg6370
g6965
sS'block_loop.thisIndex'
p7580
g6364
sg38
S'left'
p7581
sg58
g62
sS'trial_loop.thisN'
p7582
I84
sg33
g6969
sg63
g64
sS'trial_loop.thisIndex'
p7583
g59
(g98
S'T\x00\x00\x00'
tRp7584
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7585
I0
sg6379
g6973
sS'block_loop.thisRepN'
p7586
I2
sg6382
g6969
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7587
I2
sg6385
g6976
sg55
g11
sS'block_loop.thisTrial'
p7588
Nsg69
Vn
sS'block_loop.thisTrialN'
p7589
I0
sg39
F0.83353537265702471
sg34
g752
(S'\x07\xdf\n\x10\x0b-)\x07\xe3\x88'
tRp7590
sa(dp7591
S'trial_loop.thisTrialN'
p7592
I85
sg6370
g6810
sS'block_loop.thisIndex'
p7593
g6364
sg38
S'right'
p7594
sg58
g62
sS'trial_loop.thisN'
p7595
I85
sg33
g6527
sg63
g64
sS'trial_loop.thisIndex'
p7596
g59
(g98
S'U\x00\x00\x00'
tRp7597
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7598
I0
sg6379
g6817
sS'block_loop.thisRepN'
p7599
I2
sg6382
g6527
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7600
I2
sg6385
g6534
sg55
g11
sS'block_loop.thisTrial'
p7601
Nsg69
Vn
sS'block_loop.thisTrialN'
p7602
I0
sg39
F1.4500673971251672
sg34
g752
(S'\x07\xdf\n\x10\x0b-/\x06\x12\xb0'
tRp7603
sa(dp7604
S'trial_loop.thisTrialN'
p7605
I86
sg6370
S'22-daim.png'
p7606
sS'block_loop.thisIndex'
p7607
g6364
sg38
S'right'
p7608
sg58
g62
sS'trial_loop.thisN'
p7609
I86
sg33
g6763
sg63
g64
sS'trial_loop.thisIndex'
p7610
g59
(g98
S'V\x00\x00\x00'
tRp7611
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7612
I0
sg6379
S'7-olives.png'
p7613
sS'block_loop.thisRepN'
p7614
I2
sg6382
g6756
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7615
I2
sg6385
g6763
sg55
g11
sS'block_loop.thisTrial'
p7616
Nsg69
Vn
sS'block_loop.thisTrialN'
p7617
I0
sg39
F1.0003948604844481
sg34
g752
(S'\x07\xdf\n\x10\x0b-5\rN@'
tRp7618
sa(dp7619
S'trial_loop.thisTrialN'
p7620
I87
sg6370
g7353
sS'block_loop.thisIndex'
p7621
g6364
sg38
S'right'
p7622
sg58
g62
sS'trial_loop.thisN'
p7623
I87
sg33
g7105
sg63
g64
sS'trial_loop.thisIndex'
p7624
g59
(g98
S'W\x00\x00\x00'
tRp7625
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7626
I0
sg6379
g7360
sS'block_loop.thisRepN'
p7627
I2
sg6382
g7098
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7628
I2
sg6385
g7105
sg55
g11
sS'block_loop.thisTrial'
p7629
Nsg69
Vn
sS'block_loop.thisTrialN'
p7630
I0
sg39
F1.3002074371752315
sg34
g752
(S'\x07\xdf\n\x10\x0b-;\r\xe2\xb0'
tRp7631
sa(dp7632
S'trial_loop.thisTrialN'
p7633
I88
sg6370
g6707
sS'block_loop.thisIndex'
p7634
g6364
sg38
S'left'
p7635
sg58
g62
sS'trial_loop.thisN'
p7636
I88
sg33
g6578
sg63
g64
sS'trial_loop.thisIndex'
p7637
g59
(g98
S'X\x00\x00\x00'
tRp7638
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7639
I0
sg6379
g6714
sS'block_loop.thisRepN'
p7640
I2
sg6382
g6578
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7641
I2
sg6385
g6585
sg55
g11
sS'block_loop.thisTrial'
p7642
Nsg69
Vn
sS'block_loop.thisTrialN'
p7643
I0
sg39
F0.95007823084233678
sg34
g752
(S'\x07\xdf\n\x10\x0b.\x06\x03\xb58'
tRp7644
sa(dp7645
S'trial_loop.thisTrialN'
p7646
I89
sg6370
g6634
sS'block_loop.thisIndex'
p7647
g6364
sg38
S'left'
p7648
sg58
g62
sS'trial_loop.thisN'
p7649
I89
sg33
g6463
sg63
g64
sS'trial_loop.thisIndex'
p7650
g59
(g98
S'Y\x00\x00\x00'
tRp7651
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7652
I0
sg6379
g6641
sS'block_loop.thisRepN'
p7653
I2
sg6382
g6463
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7654
I2
sg6385
g6470
sg55
g11
sS'block_loop.thisTrial'
p7655
Nsg69
Vn
sS'block_loop.thisTrialN'
p7656
I0
sg39
F0.91675770790516253
sg34
g752
(S'\x07\xdf\n\x10\x0b.\x0c\x03S\x90'
tRp7657
sa(dp7658
S'trial_loop.thisTrialN'
p7659
I90
sg6370
g6540
sS'block_loop.thisIndex'
p7660
g6364
sg38
S'right'
p7661
sg58
g62
sS'trial_loop.thisN'
p7662
I90
sg33
g6544
sg63
g64
sS'trial_loop.thisIndex'
p7663
g59
(g98
S'Z\x00\x00\x00'
tRp7664
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7665
I0
sg6379
g6548
sS'block_loop.thisRepN'
p7666
I2
sg6382
g6544
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7667
I2
sg6385
g6551
sg55
g11
sS'block_loop.thisTrial'
p7668
Nsg69
Vn
sS'block_loop.thisTrialN'
p7669
I0
sg39
F0.7335264776047552
sg34
g752
(S'\x07\xdf\n\x10\x0b.\x12\x02\xb3h'
tRp7670
sa(dp7671
S'trial_loop.thisTrialN'
p7672
I91
sg6370
g6752
sS'block_loop.thisIndex'
p7673
g6364
sg38
S'left'
p7674
sg58
g62
sS'trial_loop.thisN'
p7675
I91
sg33
g6756
sg63
g64
sS'trial_loop.thisIndex'
p7676
g59
(g98
S'[\x00\x00\x00'
tRp7677
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7678
I0
sg6379
g6760
sS'block_loop.thisRepN'
p7679
I2
sg6382
g6756
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7680
I2
sg6385
g6763
sg55
g11
sS'block_loop.thisTrial'
p7681
Nsg69
Vn
sS'block_loop.thisTrialN'
p7682
I0
sg39
F0.76685982994513324
sg34
g752
(S'\x07\xdf\n\x10\x0b.\x17\x0e@p'
tRp7683
sa(dp7684
S'trial_loop.thisTrialN'
p7685
I92
sg6370
S'48-twix.png'
p7686
sS'block_loop.thisIndex'
p7687
g6364
sg38
S'left'
p7688
sg58
g62
sS'trial_loop.thisN'
p7689
I92
sg33
g7169
sg63
g64
sS'trial_loop.thisIndex'
p7690
g59
(g98
S'\\\x00\x00\x00'
tRp7691
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7692
I0
sg6379
S'50-polo.png'
p7693
sS'block_loop.thisRepN'
p7694
I2
sg6382
g7169
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7695
I2
sg6385
g7176
sg55
g11
sS'block_loop.thisTrial'
p7696
Nsg69
Vn
sS'block_loop.thisTrialN'
p7697
I0
sg39
F0.81687682177471288
sg34
g752
(S'\x07\xdf\n\x10\x0b.\x1d\x0b>\xe8'
tRp7698
sa(dp7699
S'trial_loop.thisTrialN'
p7700
I93
sg6370
g6591
sS'block_loop.thisIndex'
p7701
g6364
sg38
S'right'
p7702
sg58
g62
sS'trial_loop.thisN'
p7703
I93
sg33
g6595
sg63
g64
sS'trial_loop.thisIndex'
p7704
g59
(g98
S']\x00\x00\x00'
tRp7705
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7706
I0
sg6379
g6599
sS'block_loop.thisRepN'
p7707
I2
sg6382
g6595
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7708
I2
sg6385
g6602
sg55
g11
sS'block_loop.thisTrial'
p7709
Nsg69
Vn
sS'block_loop.thisTrialN'
p7710
I0
sg39
F0.91684751371849416
sg34
g752
(S'\x07\xdf\n\x10\x0b.#\x08\xf4\xf8'
tRp7711
sa(dp7712
S'trial_loop.thisTrialN'
p7713
I94
sg6370
g6476
sS'block_loop.thisIndex'
p7714
g6364
sg38
S'right'
p7715
sg58
g62
sS'trial_loop.thisN'
p7716
I94
sg33
g6395
sg63
g64
sS'trial_loop.thisIndex'
p7717
g59
(g98
S'^\x00\x00\x00'
tRp7718
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7719
I0
sg6379
g6483
sS'block_loop.thisRepN'
p7720
I2
sg6382
g6395
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7721
I2
sg6385
g6402
sg55
g11
sS'block_loop.thisTrial'
p7722
Nsg69
Vn
sS'block_loop.thisTrialN'
p7723
I0
sg39
F0.96662701906279835
sg34
g752
(S'\x07\xdf\n\x10\x0b.)\x08T\xd0'
tRp7724
sa(dp7725
S'trial_loop.thisTrialN'
p7726
I95
sg6370
g6810
sS'block_loop.thisIndex'
p7727
g6364
sg38
S'right'
p7728
sg58
g62
sS'trial_loop.thisN'
p7729
I95
sg33
g6534
sg63
g64
sS'trial_loop.thisIndex'
p7730
g59
(g98
S'_\x00\x00\x00'
tRp7731
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7732
I0
sg6379
g6817
sS'block_loop.thisRepN'
p7733
I2
sg6382
g6527
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7734
I2
sg6385
g6534
sg55
g11
sS'block_loop.thisTrial'
p7735
Nsg69
Vn
sS'block_loop.thisTrialN'
p7736
I0
sg39
F0.81665130939745723
sg34
g752
(S'\x07\xdf\n\x10\x0b./\x08-\xc0'
tRp7737
sa(dp7738
S'trial_loop.thisTrialN'
p7739
I96
sg6370
g7023
sS'block_loop.thisIndex'
p7740
g6364
sg38
S'right'
p7741
sg58
g62
sS'trial_loop.thisN'
p7742
I96
sg33
g6872
sg63
g64
sS'trial_loop.thisIndex'
p7743
g59
(g98
S'`\x00\x00\x00'
tRp7744
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7745
I0
sg6379
g7030
sS'block_loop.thisRepN'
p7746
I2
sg6382
g6872
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7747
I2
sg6385
g6879
sg55
g11
sS'block_loop.thisTrial'
p7748
Nsg69
Vn
sS'block_loop.thisTrialN'
p7749
I0
sg39
F0.93350749009005085
sg34
g752
(S'\x07\xdf\n\x10\x0b.5\x05\xe3\xd0'
tRp7750
sa(dp7751
S'trial_loop.thisTrialN'
p7752
I97
sg6370
g6574
sS'block_loop.thisIndex'
p7753
g6364
sg38
S'right'
p7754
sg58
g62
sS'trial_loop.thisN'
p7755
I97
sg33
g6578
sg63
g64
sS'trial_loop.thisIndex'
p7756
g59
(g98
S'a\x00\x00\x00'
tRp7757
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7758
I0
sg6379
g6582
sS'block_loop.thisRepN'
p7759
I2
sg6382
g6578
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7760
I2
sg6385
g6585
sg55
g11
sS'block_loop.thisTrial'
p7761
Nsg69
Vn
sS'block_loop.thisTrialN'
p7762
I0
sg39
F0.96726364250025654
sg34
g752
(S'\x07\xdf\n\x10\x0b.;\x05\x82('
tRp7763
sa(dp7764
S'trial_loop.thisTrialN'
p7765
I98
sg6370
g7111
sS'block_loop.thisIndex'
p7766
g6364
sg38
S'right'
p7767
sg58
g62
sS'trial_loop.thisN'
p7768
I98
sg33
g6969
sg63
g64
sS'trial_loop.thisIndex'
p7769
g59
(g98
S'b\x00\x00\x00'
tRp7770
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7771
I0
sg6379
g7118
sS'block_loop.thisRepN'
p7772
I2
sg6382
g6969
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7773
I2
sg6385
g6976
sg55
g11
sS'block_loop.thisTrial'
p7774
Nsg69
Vn
sS'block_loop.thisTrialN'
p7775
I0
sg39
F0.86686644421479286
sg34
g752
(S'\x07\xdf\n\x10\x0b/\x05\x05_\x00'
tRp7776
sa(dp7777
S'trial_loop.thisTrialN'
p7778
I99
sg6370
g7606
sS'block_loop.thisIndex'
p7779
g6364
sg38
S'right'
p7780
sg58
g62
sS'trial_loop.thisN'
p7781
I99
sg33
g6756
sg63
g64
sS'trial_loop.thisIndex'
p7782
g59
(g98
S'c\x00\x00\x00'
tRp7783
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7784
I0
sg6379
g7613
sS'block_loop.thisRepN'
p7785
I2
sg6382
g6756
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7786
I2
sg6385
g6763
sg55
g11
sS'block_loop.thisTrial'
p7787
Nsg69
Vn
sS'block_loop.thisTrialN'
p7788
I0
sg39
F1.7501280089227294
sg34
g752
(S'\x07\xdf\n\x10\x0b/\x0b\x04\x07@'
tRp7789
sa(dp7790
S'trial_loop.thisTrialN'
p7791
I100
sg6370
g6795
sS'block_loop.thisIndex'
p7792
g6364
sg38
S'right'
p7793
sg58
g62
sS'trial_loop.thisN'
p7794
I100
sg33
g6561
sg63
g64
sS'trial_loop.thisIndex'
p7795
g59
(g98
S'd\x00\x00\x00'
tRp7796
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7797
I0
sg6379
g6802
sS'block_loop.thisRepN'
p7798
I2
sg6382
g6561
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7799
I2
sg6385
g6568
sg55
g11
sS'block_loop.thisTrial'
p7800
Nsg69
Vn
sS'block_loop.thisTrialN'
p7801
I0
sg39
F1.0335178106306557
sg34
g752
(S'\x07\xdf\n\x10\x0b/\x12\x00\x88\xb8'
tRp7802
sa(dp7803
S'trial_loop.thisTrialN'
p7804
I101
sg6370
g6965
sS'block_loop.thisIndex'
p7805
g6364
sg38
S'left'
p7806
sg58
g62
sS'trial_loop.thisN'
p7807
I101
sg33
g6976
sg63
g64
sS'trial_loop.thisIndex'
p7808
g59
(g98
S'e\x00\x00\x00'
tRp7809
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7810
I0
sg6379
g6973
sS'block_loop.thisRepN'
p7811
I2
sg6382
g6969
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7812
I2
sg6385
g6976
sg55
g11
sS'block_loop.thisTrial'
p7813
Nsg69
Vn
sS'block_loop.thisTrialN'
p7814
I0
sg39
F0.83343672881073871
sg34
g752
(S'\x07\xdf\n\x10\x0b/\x18\x01\x92X'
tRp7815
sa(dp7816
S'trial_loop.thisTrialN'
p7817
I102
sg6370
g7353
sS'block_loop.thisIndex'
p7818
g6364
sg38
S'right'
p7819
sg58
g62
sS'trial_loop.thisN'
p7820
I102
sg33
g7098
sg63
g64
sS'trial_loop.thisIndex'
p7821
g59
(g98
S'f\x00\x00\x00'
tRp7822
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7823
I0
sg6379
g7360
sS'block_loop.thisRepN'
p7824
I2
sg6382
g7098
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7825
I2
sg6385
g7105
sg55
g11
sS'block_loop.thisTrial'
p7826
Nsg69
Vn
sS'block_loop.thisTrialN'
p7827
I0
sg39
F0.86687613754020276
sg34
g752
(S'\x07\xdf\n\x10\x0b/\x1d\x0e\xc9('
tRp7828
sa(dp7829
S'trial_loop.thisTrialN'
p7830
I103
sg6370
g6506
sS'block_loop.thisIndex'
p7831
g6364
sg38
S'left'
p7832
sg58
g62
sS'trial_loop.thisN'
p7833
I103
sg33
g6517
sg63
g64
sS'trial_loop.thisIndex'
p7834
g59
(g98
S'g\x00\x00\x00'
tRp7835
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7836
I0
sg6379
g6514
sS'block_loop.thisRepN'
p7837
I2
sg6382
g6510
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7838
I2
sg6385
g6517
sg55
g11
sS'block_loop.thisTrial'
p7839
Nsg69
Vn
sS'block_loop.thisTrialN'
p7840
I0
sg39
F0.83352596442909999
sg34
g752
(S'\x07\xdf\n\x10\x0b/#\rqh'
tRp7841
sa(dp7842
S'trial_loop.thisTrialN'
p7843
I104
sg6370
g6795
sS'block_loop.thisIndex'
p7844
g6364
sg38
S'right'
p7845
sg58
g62
sS'trial_loop.thisN'
p7846
I104
sg33
g6568
sg63
g64
sS'trial_loop.thisIndex'
p7847
g59
(g98
S'h\x00\x00\x00'
tRp7848
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7849
I0
sg6379
g6802
sS'block_loop.thisRepN'
p7850
I2
sg6382
g6561
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7851
I2
sg6385
g6568
sg55
g11
sS'block_loop.thisTrial'
p7852
Nsg69
Vn
sS'block_loop.thisTrialN'
p7853
I0
sg39
F1.1335258503895602
sg34
g752
(S'\x07\xdf\n\x10\x0b/)\x0be\xf8'
tRp7854
sa(dp7855
S'trial_loop.thisTrialN'
p7856
I105
sg6370
g6840
sS'block_loop.thisIndex'
p7857
g6364
sg38
S'left'
p7858
sg58
g62
sS'trial_loop.thisN'
p7859
I105
sg33
g6602
sg63
g64
sS'trial_loop.thisIndex'
p7860
g59
(g98
S'i\x00\x00\x00'
tRp7861
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7862
I0
sg6379
g6847
sS'block_loop.thisRepN'
p7863
I2
sg6382
g6595
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7864
I2
sg6385
g6602
sg55
g11
sS'block_loop.thisTrial'
p7865
Nsg69
Vn
sS'block_loop.thisTrialN'
p7866
I0
sg39
F0.88344003594556852
sg34
g752
(S'\x07\xdf\n\x10\x0b//\r\xde\xc8'
tRp7867
sa(dp7868
S'trial_loop.thisTrialN'
p7869
I106
sg6370
g6491
sS'block_loop.thisIndex'
p7870
g6364
sg38
S'right'
p7871
sg58
g62
sS'trial_loop.thisN'
p7872
I106
sg33
g6446
sg63
g64
sS'trial_loop.thisIndex'
p7873
g59
(g98
S'j\x00\x00\x00'
tRp7874
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7875
I0
sg6379
g6498
sS'block_loop.thisRepN'
p7876
I2
sg6382
g6446
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7877
I2
sg6385
g6453
sg55
g11
sS'block_loop.thisTrial'
p7878
Nsg69
Vn
sS'block_loop.thisTrialN'
p7879
I0
sg39
F0.94995706426743709
sg34
g752
(S'\x07\xdf\n\x10\x0b/5\x0c\x87\x08'
tRp7880
sa(dp7881
S'trial_loop.thisTrialN'
p7882
I107
sg6370
g7023
sS'block_loop.thisIndex'
p7883
g6364
sg38
S'right'
p7884
sg58
g62
sS'trial_loop.thisN'
p7885
I107
sg33
g6872
sg63
g64
sS'trial_loop.thisIndex'
p7886
g59
(g98
S'k\x00\x00\x00'
tRp7887
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7888
I0
sg6379
g7030
sS'block_loop.thisRepN'
p7889
I2
sg6382
g6872
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7890
I2
sg6385
g6879
sg55
g11
sS'block_loop.thisTrial'
p7891
Nsg69
Vn
sS'block_loop.thisTrialN'
p7892
I0
sg39
F0.86679317407379131
sg34
g752
(S'\x07\xdf\n\x10\x0b/;\x0c_\xf8'
tRp7893
sa(dp7894
S'trial_loop.thisTrialN'
p7895
I108
sg6370
g6523
sS'block_loop.thisIndex'
p7896
g6364
sg38
S'left'
p7897
sg58
g62
sS'trial_loop.thisN'
p7898
I108
sg33
g6527
sg63
g64
sS'trial_loop.thisIndex'
p7899
g59
(g98
S'l\x00\x00\x00'
tRp7900
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7901
I0
sg6379
g6531
sS'block_loop.thisRepN'
p7902
I2
sg6382
g6527
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7903
I2
sg6385
g6534
sg55
g11
sS'block_loop.thisTrial'
p7904
Nsg69
Vn
sS'block_loop.thisTrialN'
p7905
I0
sg39
F1.0337718327909897
sg34
g752
(S'\x07\xdf\n\x10\x0b0\x05\n\xcd\xa0'
tRp7906
sa(dp7907
S'trial_loop.thisTrialN'
p7908
I109
sg6370
g6722
sS'block_loop.thisIndex'
p7909
g6364
sg38
S'right'
p7910
sg58
g62
sS'trial_loop.thisN'
p7911
I109
sg33
g6726
sg63
g64
sS'trial_loop.thisIndex'
p7912
g59
(g98
S'm\x00\x00\x00'
tRp7913
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7914
I0
sg6379
g6730
sS'block_loop.thisRepN'
p7915
I2
sg6382
g6726
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7916
I2
sg6385
g6733
sg55
g11
sS'block_loop.thisTrial'
p7917
Nsg69
Vn
sS'block_loop.thisTrialN'
p7918
I0
sg39
F1.4501503605915786
sg34
g752
(S'\x07\xdf\n\x10\x0b0\x0b\x0b\xdb('
tRp7919
sa(dp7920
S'trial_loop.thisTrialN'
p7921
I110
sg6370
g6371
sS'block_loop.thisIndex'
p7922
g6364
sg38
S'right'
p7923
sg58
g62
sS'trial_loop.thisN'
p7924
I110
sg33
g6383
sg63
g64
sS'trial_loop.thisIndex'
p7925
g59
(g98
S'n\x00\x00\x00'
tRp7926
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7927
I0
sg6379
g6380
sS'block_loop.thisRepN'
p7928
I2
sg6382
g6383
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7929
I2
sg6385
g6375
sg55
g11
sS'block_loop.thisTrial'
p7930
Nsg69
Vn
sS'block_loop.thisTrialN'
p7931
I0
sg39
F0.80018976111114171
sg34
g752
(S'\x07\xdf\n\x10\x0b0\x12\x03\xd4x'
tRp7932
sa(dp7933
S'trial_loop.thisTrialN'
p7934
I111
sg6370
g7094
sS'block_loop.thisIndex'
p7935
g6364
sg38
S'left'
p7936
sg58
g62
sS'trial_loop.thisN'
p7937
I111
sg33
g7098
sg63
g64
sS'trial_loop.thisIndex'
p7938
g59
(g98
S'o\x00\x00\x00'
tRp7939
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7940
I0
sg6379
g7102
sS'block_loop.thisRepN'
p7941
I2
sg6382
g7098
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7942
I2
sg6385
g7105
sg55
g11
sS'block_loop.thisTrial'
p7943
Nsg69
Vn
sS'block_loop.thisTrialN'
p7944
I0
sg39
F1.0001014948247757
sg34
g752
(S'\x07\xdf\n\x10\x0b0\x18\x01L\x08'
tRp7945
sa(dp7946
S'trial_loop.thisTrialN'
p7947
I112
sg6370
g7446
sS'block_loop.thisIndex'
p7948
g6364
sg38
S'right'
p7949
sg58
g62
sS'trial_loop.thisN'
p7950
I112
sg33
g6429
sg63
g64
sS'trial_loop.thisIndex'
p7951
g59
(g98
S'p\x00\x00\x00'
tRp7952
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7953
I0
sg6379
g7453
sS'block_loop.thisRepN'
p7954
I2
sg6382
g6429
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7955
I2
sg6385
g6436
sg55
g11
sS'block_loop.thisTrial'
p7956
Nsg69
Vn
sS'block_loop.thisTrialN'
p7957
I0
sg39
F2.0501258991980649
sg34
g752
(S'\x07\xdf\n\x10\x0b0\x1e\x01\xdc\x90'
tRp7958
sa(dp7959
S'trial_loop.thisTrialN'
p7960
I113
sg6370
g6868
sS'block_loop.thisIndex'
p7961
g6364
sg38
S'left'
p7962
sg58
g62
sS'trial_loop.thisN'
p7963
I113
sg33
g6872
sg63
g64
sS'trial_loop.thisIndex'
p7964
g59
(g98
S'q\x00\x00\x00'
tRp7965
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7966
I0
sg6379
g6876
sS'block_loop.thisRepN'
p7967
I2
sg6382
g6872
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7968
I2
sg6385
g6879
sg55
g11
sS'block_loop.thisTrial'
p7969
Nsg69
Vn
sS'block_loop.thisTrialN'
p7970
I0
sg39
F1.4168381054914789
sg34
g752
(S'\x07\xdf\n\x10\x0b0%\x03 \xc8'
tRp7971
sa(dp7972
S'trial_loop.thisTrialN'
p7973
I114
sg6370
g7513
sS'block_loop.thisIndex'
p7974
g6364
sg38
S'left'
p7975
sg58
g62
sS'trial_loop.thisN'
p7976
I114
sg33
g7087
sg63
g64
sS'trial_loop.thisIndex'
p7977
g59
(g98
S'r\x00\x00\x00'
tRp7978
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7979
I0
sg6379
g7520
sS'block_loop.thisRepN'
p7980
I2
sg6382
g7087
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7981
I2
sg6385
g7081
sg55
g11
sS'block_loop.thisTrial'
p7982
Nsg69
Vn
sS'block_loop.thisTrialN'
p7983
I0
sg39
F3.5167189916210191
sg34
g752
(S'\x07\xdf\n\x10\x0b0+\n\x1d\xd8'
tRp7984
sa(dp7985
S'trial_loop.thisTrialN'
p7986
I115
sg6370
g6425
sS'block_loop.thisIndex'
p7987
g6364
sg38
S'left'
p7988
sg58
g62
sS'trial_loop.thisN'
p7989
I115
sg33
g6429
sg63
g64
sS'trial_loop.thisIndex'
p7990
g59
(g98
S's\x00\x00\x00'
tRp7991
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p7992
I0
sg6379
g6433
sS'block_loop.thisRepN'
p7993
I2
sg6382
g6429
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p7994
I2
sg6385
g6436
sg55
g11
sS'block_loop.thisTrial'
p7995
Nsg69
Vn
sS'block_loop.thisTrialN'
p7996
I0
sg39
F1.3501522992564787
sg34
g752
(S'\x07\xdf\n\x10\x0b04\x03< '
tRp7997
sa(dp7998
S'trial_loop.thisTrialN'
p7999
I116
sg6370
g6692
sS'block_loop.thisIndex'
p8000
g6364
sg38
S'left'
p8001
sg58
g62
sS'trial_loop.thisN'
p8002
I116
sg33
g6412
sg63
g64
sS'trial_loop.thisIndex'
p8003
g59
(g98
S't\x00\x00\x00'
tRp8004
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8005
I0
sg6379
g6699
sS'block_loop.thisRepN'
p8006
I2
sg6382
g6412
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8007
I2
sg6385
g6419
sg55
g11
sS'block_loop.thisTrial'
p8008
Nsg69
Vn
sS'block_loop.thisTrialN'
p8009
I0
sg39
F1.2335022442894115
sg34
g752
(S'\x07\xdf\n\x10\x0b0:\t\x08\x80'
tRp8010
sa(dp8011
S'trial_loop.thisTrialN'
p8012
I117
sg6370
g7094
sS'block_loop.thisIndex'
p8013
g6364
sg38
S'left'
p8014
sg58
g62
sS'trial_loop.thisN'
p8015
I117
sg33
g7098
sg63
g64
sS'trial_loop.thisIndex'
p8016
g59
(g98
S'u\x00\x00\x00'
tRp8017
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8018
I0
sg6379
g7102
sS'block_loop.thisRepN'
p8019
I2
sg6382
g7098
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8020
I2
sg6385
g7105
sg55
g11
sS'block_loop.thisTrial'
p8021
Nsg69
Vn
sS'block_loop.thisTrialN'
p8022
I0
sg39
F0.96685652281030343
sg34
g752
(S'\x07\xdf\n\x10\x0b1\x04\r/\x00'
tRp8023
sa(dp8024
S'trial_loop.thisTrialN'
p8025
I118
sg6370
g7606
sS'block_loop.thisIndex'
p8026
g6364
sg38
S'right'
p8027
sg58
g62
sS'trial_loop.thisN'
p8028
I118
sg33
g6756
sg63
g64
sS'trial_loop.thisIndex'
p8029
g59
(g98
S'v\x00\x00\x00'
tRp8030
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8031
I0
sg6379
g7613
sS'block_loop.thisRepN'
p8032
I2
sg6382
g6756
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8033
I2
sg6385
g6763
sg55
g11
sS'block_loop.thisTrial'
p8034
Nsg69
Vn
sS'block_loop.thisTrialN'
p8035
I0
sg39
F1.1672526377251415
sg34
g752
(S'\x07\xdf\n\x10\x0b1\n\r\x07\xf0'
tRp8036
sa(dp8037
S'trial_loop.thisTrialN'
p8038
I119
sg6370
g6982
sS'block_loop.thisIndex'
p8039
g6364
sg38
S'left'
p8040
sg58
g62
sS'trial_loop.thisN'
p8041
I119
sg33
g6383
sg63
g64
sS'trial_loop.thisIndex'
p8042
g59
(g98
S'w\x00\x00\x00'
tRp8043
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8044
I0
sg6379
g6989
sS'block_loop.thisRepN'
p8045
I2
sg6382
g6383
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8046
I2
sg6385
g6375
sg55
g11
sS'block_loop.thisTrial'
p8047
Nsg69
Vn
sS'block_loop.thisTrialN'
p8048
I0
sg39
F1.016807657042591
sg34
g752
(S'\x07\xdf\n\x10\x0b1\x11\x00\xf6\x18'
tRp8049
sa(dp8050
S'trial_loop.thisTrialN'
p8051
I120
sg6370
S'1-treacle_cookies.png'
p8052
sS'block_loop.thisIndex'
p8053
g6364
sg38
S'right'
p8054
sg58
g62
sS'trial_loop.thisN'
p8055
I120
sg33
g6666
sg63
g64
sS'trial_loop.thisIndex'
p8056
g59
(g98
S'x\x00\x00\x00'
tRp8057
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8058
I0
sg6379
S'21-nakd_banana_crunch.png'
p8059
sS'block_loop.thisRepN'
p8060
I2
sg6382
g6672
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8061
I2
sg6385
g6666
sg55
g11
sS'block_loop.thisTrial'
p8062
Nsg69
Vn
sS'block_loop.thisTrialN'
p8063
I0
sg39
F0.73340188985639543
sg34
g752
(S'\x07\xdf\n\x10\x0b1\x17\x01\x86\xa0'
tRp8064
sa(dp8065
S'trial_loop.thisTrialN'
p8066
I121
sg6370
g6506
sS'block_loop.thisIndex'
p8067
g6364
sg38
S'left'
p8068
sg58
g62
sS'trial_loop.thisN'
p8069
I121
sg33
g6510
sg63
g64
sS'trial_loop.thisIndex'
p8070
g59
(g98
S'y\x00\x00\x00'
tRp8071
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8072
I0
sg6379
g6514
sS'block_loop.thisRepN'
p8073
I2
sg6382
g6510
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8074
I2
sg6385
g6517
sg55
g11
sS'block_loop.thisTrial'
p8075
Nsg69
Vn
sS'block_loop.thisTrialN'
p8076
I0
sg39
F1.0001043458032655
sg34
g752
(S'\x07\xdf\n\x10\x0b1\x1c\rN@'
tRp8077
sa(dp8078
S'trial_loop.thisTrialN'
p8079
I122
sg6370
g6557
sS'block_loop.thisIndex'
p8080
g6364
sg38
S'left'
p8081
sg58
g62
sS'trial_loop.thisN'
p8082
I122
sg33
g6568
sg63
g64
sS'trial_loop.thisIndex'
p8083
g59
(g98
S'z\x00\x00\x00'
tRp8084
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8085
I0
sg6379
g6565
sS'block_loop.thisRepN'
p8086
I2
sg6382
g6561
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8087
I2
sg6385
g6568
sg55
g11
sS'block_loop.thisTrial'
p8088
Nsg69
Vn
sS'block_loop.thisTrialN'
p8089
I0
sg39
F1.4667567385722577
sg34
g752
(S'\x07\xdf\n\x10\x0b1"\r\xde\xc8'
tRp8090
sa(dp8091
S'trial_loop.thisTrialN'
p8092
I123
sg6370
g6371
sS'block_loop.thisIndex'
p8093
g6364
sg38
S'right'
p8094
sg58
g62
sS'trial_loop.thisN'
p8095
I123
sg33
g6383
sg63
g64
sS'trial_loop.thisIndex'
p8096
g59
(g98
S'{\x00\x00\x00'
tRp8097
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8098
I0
sg6379
g6380
sS'block_loop.thisRepN'
p8099
I2
sg6382
g6383
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8100
I2
sg6385
g6375
sg55
g11
sS'block_loop.thisTrial'
p8101
Nsg69
Vn
sS'block_loop.thisTrialN'
p8102
I0
sg39
F1.1838937976399393
sg34
g752
(S'\x07\xdf\n\x10\x0b1)\x06\x16\x98'
tRp8103
sa(dp8104
S'trial_loop.thisTrialN'
p8105
I124
sg6370
g6391
sS'block_loop.thisIndex'
p8106
g6364
sg38
S'left'
p8107
sg58
g62
sS'trial_loop.thisN'
p8108
I124
sg33
g6395
sg63
g64
sS'trial_loop.thisIndex'
p8109
g59
(g98
S'|\x00\x00\x00'
tRp8110
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8111
I0
sg6379
g6399
sS'block_loop.thisRepN'
p8112
I2
sg6382
g6395
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8113
I2
sg6385
g6402
sg55
g11
sS'block_loop.thisTrial'
p8114
Nsg69
Vn
sS'block_loop.thisTrialN'
p8115
I0
sg39
F0.76659212308913993
sg34
g752
(S'\x07\xdf\n\x10\x0b1/\t\x81\x98'
tRp8116
sa(dp8117
S'trial_loop.thisTrialN'
p8118
I125
sg6370
g6506
sS'block_loop.thisIndex'
p8119
g6364
sg38
S'left'
p8120
sg58
g62
sS'trial_loop.thisN'
p8121
I125
sg33
g6517
sg63
g64
sS'trial_loop.thisIndex'
p8122
g59
(g98
S'}\x00\x00\x00'
tRp8123
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8124
I0
sg6379
g6514
sS'block_loop.thisRepN'
p8125
I2
sg6382
g6510
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8126
I2
sg6385
g6517
sg55
g11
sS'block_loop.thisTrial'
p8127
Nsg69
Vn
sS'block_loop.thisTrialN'
p8128
I0
sg39
F0.81686883903603302
sg34
g752
(S'\x07\xdf\n\x10\x0b15\x06\x80\x10'
tRp8129
sa(dp8130
S'trial_loop.thisTrialN'
p8131
I126
sg6370
g7353
sS'block_loop.thisIndex'
p8132
g6364
sg38
S'right'
p8133
sg58
g62
sS'trial_loop.thisN'
p8134
I126
sg33
g7098
sg63
g64
sS'trial_loop.thisIndex'
p8135
g59
(g98
S'~\x00\x00\x00'
tRp8136
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8137
I0
sg6379
g7360
sS'block_loop.thisRepN'
p8138
I2
sg6382
g7098
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8139
I2
sg6385
g7105
sg55
g11
sS'block_loop.thisTrial'
p8140
Nsg69
Vn
sS'block_loop.thisTrialN'
p8141
I0
sg39
F0.80009140236234089
sg34
g752
(S'\x07\xdf\n\x10\x0b1;\x046 '
tRp8142
sa(dp8143
S'trial_loop.thisTrialN'
p8144
I127
sg6370
g6506
sS'block_loop.thisIndex'
p8145
g6364
sg38
S'left'
p8146
sg58
g62
sS'trial_loop.thisN'
p8147
I127
sg33
g6510
sg63
g64
sS'trial_loop.thisIndex'
p8148
g59
(g98
S'\x7f\x00\x00\x00'
tRp8149
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8150
I0
sg6379
g6514
sS'block_loop.thisRepN'
p8151
I2
sg6382
g6510
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8152
I2
sg6385
g6517
sg55
g11
sS'block_loop.thisTrial'
p8153
Nsg69
Vn
sS'block_loop.thisTrialN'
p8154
I0
sg39
F0.86686102735620807
sg34
g752
(S'\x07\xdf\n\x10\x0b2\x05\x01\xb1\x98'
tRp8155
sa(dp8156
S'trial_loop.thisTrialN'
p8157
I128
sg6370
g6982
sS'block_loop.thisIndex'
p8158
g6364
sg38
S'left'
p8159
sg58
g62
sS'trial_loop.thisN'
p8160
I128
sg33
g6383
sg63
g64
sS'trial_loop.thisIndex'
p8161
g59
(g98
S'\x80\x00\x00\x00'
tRp8162
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8163
I0
sg6379
g6989
sS'block_loop.thisRepN'
p8164
I2
sg6382
g6383
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8165
I2
sg6385
g6375
sg55
g11
sS'block_loop.thisTrial'
p8166
Nsg69
Vn
sS'block_loop.thisTrialN'
p8167
I0
sg39
F0.83364656080721034
sg34
g752
(S'\x07\xdf\n\x10\x0b2\x0b\x00\x1f@'
tRp8168
sa(dp8169
S'trial_loop.thisTrialN'
p8170
I129
sg6370
g6634
sS'block_loop.thisIndex'
p8171
g6364
sg38
S'left'
p8172
sg58
g62
sS'trial_loop.thisN'
p8173
I129
sg33
g6463
sg63
g64
sS'trial_loop.thisIndex'
p8174
g59
(g98
S'\x81\x00\x00\x00'
tRp8175
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8176
I0
sg6379
g6641
sS'block_loop.thisRepN'
p8177
I2
sg6382
g6463
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8178
I2
sg6385
g6470
sg55
g11
sS'block_loop.thisTrial'
p8179
Nsg69
Vn
sS'block_loop.thisTrialN'
p8180
I0
sg39
F2.1002244290057206
sg34
g752
(S'\x07\xdf\n\x10\x0b2\x10\rR('
tRp8181
sa(dp8182
S'trial_loop.thisTrialN'
p8183
I130
sg6370
g7446
sS'block_loop.thisIndex'
p8184
g6364
sg38
S'right'
p8185
sg58
g62
sS'trial_loop.thisN'
p8186
I130
sg33
g6429
sg63
g64
sS'trial_loop.thisIndex'
p8187
g59
(g98
S'\x82\x00\x00\x00'
tRp8188
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8189
I0
sg6379
g7453
sS'block_loop.thisRepN'
p8190
I2
sg6382
g6429
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8191
I2
sg6385
g6436
sg55
g11
sS'block_loop.thisTrial'
p8192
Nsg69
Vn
sS'block_loop.thisTrialN'
p8193
I0
sg39
F1.183526591644295
sg34
g752
(S'\x07\xdf\n\x10\x0b2\x18\x00\x07\xd0'
tRp8194
sa(dp8195
S'trial_loop.thisTrialN'
p8196
I131
sg6370
g6408
sS'block_loop.thisIndex'
p8197
g6364
sg38
S'right'
p8198
sg58
g62
sS'trial_loop.thisN'
p8199
I131
sg33
g6412
sg63
g64
sS'trial_loop.thisIndex'
p8200
g59
(g98
S'\x83\x00\x00\x00'
tRp8201
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8202
I0
sg6379
g6416
sS'block_loop.thisRepN'
p8203
I2
sg6382
g6412
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8204
I2
sg6385
g6419
sg55
g11
sS'block_loop.thisTrial'
p8205
Nsg69
Vn
sS'block_loop.thisTrialN'
p8206
I0
sg39
F0.98346090510585782
sg34
g752
(S'\x07\xdf\n\x10\x0b2\x1e\x03v\xb8'
tRp8207
sa(dp8208
S'trial_loop.thisTrialN'
p8209
I132
sg6370
g7686
sS'block_loop.thisIndex'
p8210
g6364
sg38
S'left'
p8211
sg58
g62
sS'trial_loop.thisN'
p8212
I132
sg33
g7169
sg63
g64
sS'trial_loop.thisIndex'
p8213
g59
(g98
S'\x84\x00\x00\x00'
tRp8214
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8215
I0
sg6379
g7693
sS'block_loop.thisRepN'
p8216
I2
sg6382
g7169
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8217
I2
sg6385
g7176
sg55
g11
sS'block_loop.thisTrial'
p8218
Nsg69
Vn
sS'block_loop.thisTrialN'
p8219
I0
sg39
F1.3168155257435501
sg34
g752
(S'\x07\xdf\n\x10\x0b2$\x03\x8e('
tRp8220
sa(dp8221
S'trial_loop.thisTrialN'
p8222
I133
sg6370
g6707
sS'block_loop.thisIndex'
p8223
g6364
sg38
S'left'
p8224
sg58
g62
sS'trial_loop.thisN'
p8225
I133
sg33
g6578
sg63
g64
sS'trial_loop.thisIndex'
p8226
g59
(g98
S'\x85\x00\x00\x00'
tRp8227
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8228
I0
sg6379
g6714
sS'block_loop.thisRepN'
p8229
I2
sg6382
g6578
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8230
I2
sg6385
g6585
sg55
g11
sS'block_loop.thisTrial'
p8231
Nsg69
Vn
sS'block_loop.thisTrialN'
p8232
I0
sg39
F0.81684916728681856
sg34
g752
(S'\x07\xdf\n\x10\x0b2*\x08\xe1p'
tRp8233
sa(dp8234
S'trial_loop.thisTrialN'
p8235
I134
sg6370
g6692
sS'block_loop.thisIndex'
p8236
g6364
sg38
S'left'
p8237
sg58
g62
sS'trial_loop.thisN'
p8238
I134
sg33
g6412
sg63
g64
sS'trial_loop.thisIndex'
p8239
g59
(g98
S'\x86\x00\x00\x00'
tRp8240
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8241
I0
sg6379
g6699
sS'block_loop.thisRepN'
p8242
I2
sg6382
g6412
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8243
I2
sg6385
g6419
sg55
g11
sS'block_loop.thisTrial'
p8244
Nsg69
Vn
sS'block_loop.thisTrialN'
p8245
I0
sg39
F0.80058120042122027
sg34
g752
(S'\x07\xdf\n\x10\x0b20\x06\x97\x80'
tRp8246
sa(dp8247
S'trial_loop.thisTrialN'
p8248
I135
sg6370
g6752
sS'block_loop.thisIndex'
p8249
g6364
sg38
S'left'
p8250
sg58
g62
sS'trial_loop.thisN'
p8251
I135
sg33
g6763
sg63
g64
sS'trial_loop.thisIndex'
p8252
g59
(g98
S'\x87\x00\x00\x00'
tRp8253
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8254
I0
sg6379
g6760
sS'block_loop.thisRepN'
p8255
I2
sg6382
g6756
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8256
I2
sg6385
g6763
sg55
g11
sS'block_loop.thisTrial'
p8257
Nsg69
Vn
sS'block_loop.thisTrialN'
p8258
I0
sg39
F0.76683531153230433
sg34
g752
(S'\x07\xdf\n\x10\x0b26\x04\x12\xf8'
tRp8259
sa(dp8260
S'trial_loop.thisTrialN'
p8261
I136
sg6370
g7094
sS'block_loop.thisIndex'
p8262
g6364
sg38
S'left'
p8263
sg58
g62
sS'trial_loop.thisN'
p8264
I136
sg33
g7098
sg63
g64
sS'trial_loop.thisIndex'
p8265
g59
(g98
S'\x88\x00\x00\x00'
tRp8266
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8267
I0
sg6379
g7102
sS'block_loop.thisRepN'
p8268
I2
sg6382
g7098
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8269
I2
sg6385
g7105
sg55
g11
sS'block_loop.thisTrial'
p8270
Nsg69
Vn
sS'block_loop.thisTrialN'
p8271
I0
sg39
F0.81684831199254404
sg34
g752
(S'\x07\xdf\n\x10\x0b3\x00\x01\x11p'
tRp8272
sa(dp8273
S'trial_loop.thisTrialN'
p8274
I137
sg6370
g8052
sS'block_loop.thisIndex'
p8275
g6364
sg38
S'right'
p8276
sg58
g62
sS'trial_loop.thisN'
p8277
I137
sg33
g6672
sg63
g64
sS'trial_loop.thisIndex'
p8278
g59
(g98
S'\x89\x00\x00\x00'
tRp8279
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8280
I0
sg6379
g8059
sS'block_loop.thisRepN'
p8281
I2
sg6382
g6672
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8282
I2
sg6385
g6666
sg55
g11
sS'block_loop.thisTrial'
p8283
Nsg69
Vn
sS'block_loop.thisTrialN'
p8284
I0
sg39
F0.85020105098465137
sg34
g752
(S'\x07\xdf\n\x10\x0b3\x05\x0e\t\xc0'
tRp8285
sa(dp8286
S'trial_loop.thisTrialN'
p8287
I138
sg6370
g7077
sS'block_loop.thisIndex'
p8288
g6364
sg38
S'right'
p8289
sg58
g62
sS'trial_loop.thisN'
p8290
I138
sg33
g7087
sg63
g64
sS'trial_loop.thisIndex'
p8291
g59
(g98
S'\x8a\x00\x00\x00'
tRp8292
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8293
I0
sg6379
g7085
sS'block_loop.thisRepN'
p8294
I2
sg6382
g7087
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8295
I2
sg6385
g7081
sg55
g11
sS'block_loop.thisTrial'
p8296
Nsg69
Vn
sS'block_loop.thisTrialN'
p8297
I0
sg39
F0.78347019929515227
sg34
g752
(S'\x07\xdf\n\x10\x0b3\x0b\x0c8\xe8'
tRp8298
sa(dp8299
S'trial_loop.thisTrialN'
p8300
I139
sg6370
g7446
sS'block_loop.thisIndex'
p8301
g6364
sg38
S'right'
p8302
sg58
g62
sS'trial_loop.thisN'
p8303
I139
sg33
g6436
sg63
g64
sS'trial_loop.thisIndex'
p8304
g59
(g98
S'\x8b\x00\x00\x00'
tRp8305
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8306
I0
sg6379
g7453
sS'block_loop.thisRepN'
p8307
I2
sg6382
g6429
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8308
I2
sg6385
g6436
sg55
g11
sS'block_loop.thisTrial'
p8309
Nsg69
Vn
sS'block_loop.thisTrialN'
p8310
I0
sg39
F0.95019654643874674
sg34
g752
(S'\x07\xdf\n\x10\x0b3\x11\tu\xe0'
tRp8311
sa(dp8312
S'trial_loop.thisTrialN'
p8313
I140
sg6370
g7077
sS'block_loop.thisIndex'
p8314
g6364
sg38
S'right'
p8315
sg58
g62
sS'trial_loop.thisN'
p8316
I140
sg33
g7087
sg63
g64
sS'trial_loop.thisIndex'
p8317
g59
(g98
S'\x8c\x00\x00\x00'
tRp8318
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8319
I0
sg6379
g7085
sS'block_loop.thisRepN'
p8320
I2
sg6382
g7087
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8321
I2
sg6385
g7081
sg55
g11
sS'block_loop.thisTrial'
p8322
Nsg69
Vn
sS'block_loop.thisTrialN'
p8323
I0
sg39
F0.66723752754114685
sg34
g752
(S'\x07\xdf\n\x10\x0b3\x17\tN\xd0'
tRp8324
sa(dp8325
S'trial_loop.thisTrialN'
p8326
I141
sg6370
g7023
sS'block_loop.thisIndex'
p8327
g6364
sg38
S'right'
p8328
sg58
g62
sS'trial_loop.thisN'
p8329
I141
sg33
g6872
sg63
g64
sS'trial_loop.thisIndex'
p8330
g59
(g98
S'\x8d\x00\x00\x00'
tRp8331
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8332
I0
sg6379
g7030
sS'block_loop.thisRepN'
p8333
I2
sg6382
g6872
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8334
I2
sg6385
g6879
sg55
g11
sS'block_loop.thisTrial'
p8335
Nsg69
Vn
sS'block_loop.thisTrialN'
p8336
I0
sg39
F1.1501159777944849
sg34
g752
(S'\x07\xdf\n\x10\x0b3\x1d\x04\xa3\x80'
tRp8337
sa(dp8338
S'trial_loop.thisTrialN'
p8339
I142
sg6370
g7353
sS'block_loop.thisIndex'
p8340
g6364
sg38
S'right'
p8341
sg58
g62
sS'trial_loop.thisN'
p8342
I142
sg33
g7098
sg63
g64
sS'trial_loop.thisIndex'
p8343
g59
(g98
S'\x8e\x00\x00\x00'
tRp8344
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8345
I0
sg6379
g7360
sS'block_loop.thisRepN'
p8346
I2
sg6382
g7098
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8347
I2
sg6385
g7105
sg55
g11
sS'block_loop.thisTrial'
p8348
Nsg69
Vn
sS'block_loop.thisTrialN'
p8349
I0
sg39
F2.066685521135696
sg34
g752
(S'\x07\xdf\n\x10\x0b3#\x07Z\xd0'
tRp8350
sa(dp8351
S'trial_loop.thisTrialN'
p8352
I143
sg6370
g7077
sS'block_loop.thisIndex'
p8353
g6364
sg38
S'right'
p8354
sg58
g62
sS'trial_loop.thisN'
p8355
I143
sg33
g7087
sg63
g64
sS'trial_loop.thisIndex'
p8356
g59
(g98
S'\x8f\x00\x00\x00'
tRp8357
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8358
I0
sg6379
g7085
sS'block_loop.thisRepN'
p8359
I2
sg6382
g7087
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8360
I2
sg6385
g7081
sg55
g11
sS'block_loop.thisTrial'
p8361
Nsg69
Vn
sS'block_loop.thisTrialN'
p8362
I0
sg39
F0.66677253299167205
sg34
g752
(S'\x07\xdf\n\x10\x0b3*\t\x148'
tRp8363
sa(dp8364
S'trial_loop.thisTrialN'
p8365
I144
sg6370
g7273
sS'block_loop.thisIndex'
p8366
g6364
sg38
S'left'
p8367
sg58
g62
sS'trial_loop.thisN'
p8368
I144
sg33
g6544
sg63
g64
sS'trial_loop.thisIndex'
p8369
g59
(g98
S'\x90\x00\x00\x00'
tRp8370
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8371
I0
sg6379
g7280
sS'block_loop.thisRepN'
p8372
I2
sg6382
g6544
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8373
I2
sg6385
g6551
sg55
g11
sS'block_loop.thisTrial'
p8374
Nsg69
Vn
sS'block_loop.thisTrialN'
p8375
I0
sg39
F0.80019261208872194
sg34
g752
(S'\x07\xdf\n\x10\x0b30\x04h\xe8'
tRp8376
sa(dp8377
S'trial_loop.thisTrialN'
p8378
I145
sg6370
g8052
sS'block_loop.thisIndex'
p8379
g6364
sg38
S'right'
p8380
sg58
g62
sS'trial_loop.thisN'
p8381
I145
sg33
g6672
sg63
g64
sS'trial_loop.thisIndex'
p8382
g59
(g98
S'\x91\x00\x00\x00'
tRp8383
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8384
I0
sg6379
g8059
sS'block_loop.thisRepN'
p8385
I2
sg6382
g6672
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8386
I2
sg6385
g6666
sg55
g11
sS'block_loop.thisTrial'
p8387
Nsg69
Vn
sS'block_loop.thisTrialN'
p8388
I0
sg39
F0.66723781263863202
sg34
g752
(S'\x07\xdf\n\x10\x0b36\x01\xe4`'
tRp8389
sa(dp8390
S'trial_loop.thisTrialN'
p8391
I146
sg6370
g7111
sS'block_loop.thisIndex'
p8392
g6364
sg38
S'right'
p8393
sg58
g62
sS'trial_loop.thisN'
p8394
I146
sg33
g6969
sg63
g64
sS'trial_loop.thisIndex'
p8395
g59
(g98
S'\x92\x00\x00\x00'
tRp8396
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8397
I0
sg6379
g7118
sS'block_loop.thisRepN'
p8398
I2
sg6382
g6969
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8399
I2
sg6385
g6976
sg55
g11
sS'block_loop.thisTrial'
p8400
Nsg69
Vn
sS'block_loop.thisTrialN'
p8401
I0
sg39
F0.83343216724460945
sg34
g752
(S'\x07\xdf\n\x10\x0b3;\x0c{P'
tRp8402
sa(dp8403
S'trial_loop.thisTrialN'
p8404
I147
sg6370
g7446
sS'block_loop.thisIndex'
p8405
g6364
sg38
S'right'
p8406
sg58
g62
sS'trial_loop.thisN'
p8407
I147
sg33
g6429
sg63
g64
sS'trial_loop.thisIndex'
p8408
g59
(g98
S'\x93\x00\x00\x00'
tRp8409
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8410
I0
sg6379
g7453
sS'block_loop.thisRepN'
p8411
I2
sg6382
g6429
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8412
I2
sg6385
g6436
sg55
g11
sS'block_loop.thisTrial'
p8413
Nsg69
Vn
sS'block_loop.thisTrialN'
p8414
I0
sg39
F1.2835252231743652
sg34
g752
(S'\x07\xdf\n\x10\x0b4\x05\nk\xf8'
tRp8415
sa(dp8416
S'trial_loop.thisTrialN'
p8417
I148
sg6370
g7606
sS'block_loop.thisIndex'
p8418
g6364
sg38
S'right'
p8419
sg58
g62
sS'trial_loop.thisN'
p8420
I148
sg33
g6763
sg63
g64
sS'trial_loop.thisIndex'
p8421
g59
(g98
S'\x94\x00\x00\x00'
tRp8422
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8423
I0
sg6379
g7613
sS'block_loop.thisRepN'
p8424
I2
sg6382
g6756
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8425
I2
sg6385
g6763
sg55
g11
sS'block_loop.thisTrial'
p8426
Nsg69
Vn
sS'block_loop.thisTrialN'
p8427
I0
sg39
F1.91682841216425
sg34
g752
(S'\x07\xdf\n\x10\x0b4\x0c\x00\x03\xe8'
tRp8428
sa(dp8429
S'trial_loop.thisTrialN'
p8430
I149
sg6370
g6707
sS'block_loop.thisIndex'
p8431
g6364
sg38
S'left'
p8432
sg58
g62
sS'trial_loop.thisN'
p8433
I149
sg33
g6578
sg63
g64
sS'trial_loop.thisIndex'
p8434
g59
(g98
S'\x95\x00\x00\x00'
tRp8435
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8436
I0
sg6379
g6714
sS'block_loop.thisRepN'
p8437
I2
sg6382
g6578
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8438
I2
sg6385
g6585
sg55
g11
sS'block_loop.thisTrial'
p8439
Nsg69
Vn
sS'block_loop.thisTrialN'
p8440
I0
sg39
F0.78338609543698112
sg34
g752
(S'\x07\xdf\n\x10\x0b4\x12\x0e\xa2\x18'
tRp8441
sa(dp8442
S'trial_loop.thisTrialN'
p8443
I150
sg6370
g6692
sS'block_loop.thisIndex'
p8444
g6364
sg38
S'left'
p8445
sg58
g62
sS'trial_loop.thisN'
p8446
I150
sg33
g6412
sg63
g64
sS'trial_loop.thisIndex'
p8447
g59
(g98
S'\x96\x00\x00\x00'
tRp8448
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8449
I0
sg6379
g6699
sS'block_loop.thisRepN'
p8450
I2
sg6382
g6412
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8451
I2
sg6385
g6419
sg55
g11
sS'block_loop.thisTrial'
p8452
Nsg69
Vn
sS'block_loop.thisTrialN'
p8453
I0
sg39
F1.0005405454721767
sg34
g752
(S'\x07\xdf\n\x10\x0b4\x18\x0b\xdf\x10'
tRp8454
sa(dp8455
S'trial_loop.thisTrialN'
p8456
I151
sg6370
g6371
sS'block_loop.thisIndex'
p8457
g6364
sg38
S'right'
p8458
sg58
g62
sS'trial_loop.thisN'
p8459
I151
sg33
g6383
sg63
g64
sS'trial_loop.thisIndex'
p8460
g59
(g98
S'\x97\x00\x00\x00'
tRp8461
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8462
I0
sg6379
g6380
sS'block_loop.thisRepN'
p8463
I2
sg6382
g6383
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8464
I2
sg6385
g6375
sg55
g11
sS'block_loop.thisTrial'
p8465
Nsg69
Vn
sS'block_loop.thisTrialN'
p8466
I0
sg39
F0.76677287510847236
sg34
g752
(S'\x07\xdf\n\x10\x0b4\x1e\x0c1\x18'
tRp8467
sa(dp8468
S'trial_loop.thisTrialN'
p8469
I152
sg6370
g7273
sS'block_loop.thisIndex'
p8470
g6364
sg38
S'left'
p8471
sg58
g62
sS'trial_loop.thisN'
p8472
I152
sg33
g6544
sg63
g64
sS'trial_loop.thisIndex'
p8473
g59
(g98
S'\x98\x00\x00\x00'
tRp8474
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8475
I0
sg6379
g7280
sS'block_loop.thisRepN'
p8476
I2
sg6382
g6544
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8477
I2
sg6385
g6551
sg55
g11
sS'block_loop.thisTrial'
p8478
Nsg69
Vn
sS'block_loop.thisTrialN'
p8479
I0
sg39
F0.75014397440008906
sg34
g752
(S'\x07\xdf\n\x10\x0b4$\t3x'
tRp8480
sa(dp8481
S'trial_loop.thisTrialN'
p8482
I153
sg6370
g6459
sS'block_loop.thisIndex'
p8483
g6364
sg38
S'right'
p8484
sg58
g62
sS'trial_loop.thisN'
p8485
I153
sg33
g6463
sg63
g64
sS'trial_loop.thisIndex'
p8486
g59
(g98
S'\x99\x00\x00\x00'
tRp8487
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8488
I0
sg6379
g6467
sS'block_loop.thisRepN'
p8489
I2
sg6382
g6463
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8490
I2
sg6385
g6470
sg55
g11
sS'block_loop.thisTrial'
p8491
Nsg69
Vn
sS'block_loop.thisTrialN'
p8492
I0
sg39
F0.6835026434273459
sg34
g752
(S'\x07\xdf\n\x10\x0b4*\x05\xf3p'
tRp8493
sa(dp8494
S'trial_loop.thisTrialN'
p8495
I154
sg6370
g6662
sS'block_loop.thisIndex'
p8496
g6364
sg38
S'left'
p8497
sg58
g62
sS'trial_loop.thisN'
p8498
I154
sg33
g6666
sg63
g64
sS'trial_loop.thisIndex'
p8499
g59
(g98
S'\x9a\x00\x00\x00'
tRp8500
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8501
I0
sg6379
g6670
sS'block_loop.thisRepN'
p8502
I2
sg6382
g6672
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8503
I2
sg6385
g6666
sg55
g11
sS'block_loop.thisTrial'
p8504
Nsg69
Vn
sS'block_loop.thisTrialN'
p8505
I0
sg39
F0.85020390196314111
sg34
g752
(S'\x07\xdf\n\x10\x0b40\x01\x86\xa0'
tRp8506
sa(dp8507
S'trial_loop.thisTrialN'
p8508
I155
sg6370
g6391
sS'block_loop.thisIndex'
p8509
g6364
sg38
S'left'
p8510
sg58
g62
sS'trial_loop.thisN'
p8511
I155
sg33
g6395
sg63
g64
sS'trial_loop.thisIndex'
p8512
g59
(g98
S'\x9b\x00\x00\x00'
tRp8513
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8514
I0
sg6379
g6399
sS'block_loop.thisRepN'
p8515
I2
sg6382
g6395
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8516
I2
sg6385
g6402
sg55
g11
sS'block_loop.thisTrial'
p8517
Nsg69
Vn
sS'block_loop.thisTrialN'
p8518
I0
sg39
F0.99981126524107822
sg34
g752
(S'\x07\xdf\n\x10\x0b45\x0e\xf8\x08'
tRp8519
sa(dp8520
S'trial_loop.thisTrialN'
p8521
I156
sg6370
g7606
sS'block_loop.thisIndex'
p8522
g6364
sg38
S'right'
p8523
sg58
g62
sS'trial_loop.thisN'
p8524
I156
sg33
g6756
sg63
g64
sS'trial_loop.thisIndex'
p8525
g59
(g98
S'\x9c\x00\x00\x00'
tRp8526
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8527
I0
sg6379
g7613
sS'block_loop.thisRepN'
p8528
I2
sg6382
g6756
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8529
I2
sg6385
g6763
sg55
g11
sS'block_loop.thisTrial'
p8530
Nsg69
Vn
sS'block_loop.thisTrialN'
p8531
I0
sg39
F1.0335414737510291
sg34
g752
(S'\x07\xdf\n\x10\x0b5\x00\x00FP'
tRp8532
sa(dp8533
S'trial_loop.thisTrialN'
p8534
I157
sg6370
g6982
sS'block_loop.thisIndex'
p8535
g6364
sg38
S'left'
p8536
sg58
g62
sS'trial_loop.thisN'
p8537
I157
sg33
g6383
sg63
g64
sS'trial_loop.thisIndex'
p8538
g59
(g98
S'\x9d\x00\x00\x00'
tRp8539
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8540
I0
sg6379
g6989
sS'block_loop.thisRepN'
p8541
I2
sg6382
g6383
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8542
I2
sg6385
g6375
sg55
g11
sS'block_loop.thisTrial'
p8543
Nsg69
Vn
sS'block_loop.thisTrialN'
p8544
I0
sg39
F0.81684318023235392
sg34
g752
(S'\x07\xdf\n\x10\x0b5\x06\x01S\xd8'
tRp8545
sa(dp8546
S'trial_loop.thisTrialN'
p8547
I158
sg6370
g6523
sS'block_loop.thisIndex'
p8548
g6364
sg38
S'left'
p8549
sg58
g62
sS'trial_loop.thisN'
p8550
I158
sg33
g6527
sg63
g64
sS'trial_loop.thisIndex'
p8551
g59
(g98
S'\x9e\x00\x00\x00'
tRp8552
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8553
I0
sg6379
g6531
sS'block_loop.thisRepN'
p8554
I2
sg6382
g6527
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8555
I2
sg6385
g6534
sg55
g11
sS'block_loop.thisTrial'
p8556
Nsg69
Vn
sS'block_loop.thisTrialN'
p8557
I0
sg39
F1.1333887183373008
sg34
g752
(S'\x07\xdf\n\x10\x0b5\x0b\x0eL('
tRp8558
sa(dp8559
S'trial_loop.thisTrialN'
p8560
I159
sg6370
g7165
sS'block_loop.thisIndex'
p8561
g6364
sg38
S'right'
p8562
sg58
g62
sS'trial_loop.thisN'
p8563
I159
sg33
g7176
sg63
g64
sS'trial_loop.thisIndex'
p8564
g59
(g98
S'\x9f\x00\x00\x00'
tRp8565
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8566
I0
sg6379
g7173
sS'block_loop.thisRepN'
p8567
I2
sg6382
g7169
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8568
I2
sg6385
g7176
sg55
g11
sS'block_loop.thisTrial'
p8569
Nsg69
Vn
sS'block_loop.thisTrialN'
p8570
I0
sg39
F0.88353326293326973
sg34
g752
(S'\x07\xdf\n\x10\x0b5\x12\x01\x82\xb8'
tRp8571
sa(dp8572
S'trial_loop.thisTrialN'
p8573
I160
sg6370
g6491
sS'block_loop.thisIndex'
p8574
g6364
sg38
S'right'
p8575
sg58
g62
sS'trial_loop.thisN'
p8576
I160
sg33
g6446
sg63
g64
sS'trial_loop.thisIndex'
p8577
g59
(g98
S'\xa0\x00\x00\x00'
tRp8578
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8579
I0
sg6379
g6498
sS'block_loop.thisRepN'
p8580
I2
sg6382
g6446
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8581
I2
sg6385
g6453
sg55
g11
sS'block_loop.thisTrial'
p8582
Nsg69
Vn
sS'block_loop.thisTrialN'
p8583
I0
sg39
F0.83327564854062075
sg34
g752
(S'\x07\xdf\n\x10\x0b5\x18\x00ix'
tRp8584
sa(dp8585
S'trial_loop.thisTrialN'
p8586
I161
sg6370
g7111
sS'block_loop.thisIndex'
p8587
g6364
sg38
S'right'
p8588
sg58
g62
sS'trial_loop.thisN'
p8589
I161
sg33
g6969
sg63
g64
sS'trial_loop.thisIndex'
p8590
g59
(g98
S'\xa1\x00\x00\x00'
tRp8591
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8592
I0
sg6379
g7118
sS'block_loop.thisRepN'
p8593
I2
sg6382
g6969
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8594
I2
sg6385
g6976
sg55
g11
sS'block_loop.thisTrial'
p8595
Nsg69
Vn
sS'block_loop.thisTrialN'
p8596
I0
sg39
F0.91679448552349641
sg34
g752
(S'\x07\xdf\n\x10\x0b5\x1d\r\x9c`'
tRp8597
sa(dp8598
S'trial_loop.thisTrialN'
p8599
I162
sg6370
g6591
sS'block_loop.thisIndex'
p8600
g6364
sg38
S'right'
p8601
sg58
g62
sS'trial_loop.thisN'
p8602
I162
sg33
g6595
sg63
g64
sS'trial_loop.thisIndex'
p8603
g59
(g98
S'\xa2\x00\x00\x00'
tRp8604
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8605
I0
sg6379
g6599
sS'block_loop.thisRepN'
p8606
I2
sg6382
g6595
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8607
I2
sg6385
g6602
sg55
g11
sS'block_loop.thisTrial'
p8608
Nsg69
Vn
sS'block_loop.thisTrialN'
p8609
I0
sg39
F0.8335772820373677
sg34
g752
(S'\x07\xdf\n\x10\x0b5#\x0c\xc1\xa0'
tRp8610
sa(dp8611
S'trial_loop.thisTrialN'
p8612
I163
sg6370
g6662
sS'block_loop.thisIndex'
p8613
g6364
sg38
S'left'
p8614
sg58
g62
sS'trial_loop.thisN'
p8615
I163
sg33
g6672
sg63
g64
sS'trial_loop.thisIndex'
p8616
g59
(g98
S'\xa3\x00\x00\x00'
tRp8617
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8618
I0
sg6379
g6670
sS'block_loop.thisRepN'
p8619
I2
sg6382
g6672
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8620
I2
sg6385
g6666
sg55
g11
sS'block_loop.thisTrial'
p8621
Nsg69
Vn
sS'block_loop.thisTrialN'
p8622
I0
sg39
F0.8167448214835531
sg34
g752
(S'\x07\xdf\n\x10\x0b5)\n\xb60'
tRp8623
sa(dp8624
S'trial_loop.thisTrialN'
p8625
I164
sg6370
g6425
sS'block_loop.thisIndex'
p8626
g6364
sg38
S'left'
p8627
sg58
g62
sS'trial_loop.thisN'
p8628
I164
sg33
g6436
sg63
g64
sS'trial_loop.thisIndex'
p8629
g59
(g98
S'\xa4\x00\x00\x00'
tRp8630
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8631
I0
sg6379
g6433
sS'block_loop.thisRepN'
p8632
I2
sg6382
g6429
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8633
I2
sg6385
g6436
sg55
g11
sS'block_loop.thisTrial'
p8634
Nsg69
Vn
sS'block_loop.thisTrialN'
p8635
I0
sg39
F1.0834755021151068
sg34
g752
(S'\x07\xdf\n\x10\x0b5/\x08l@'
tRp8636
sa(dp8637
S'trial_loop.thisTrialN'
p8638
I165
sg6370
g6795
sS'block_loop.thisIndex'
p8639
g6364
sg38
S'right'
p8640
sg58
g62
sS'trial_loop.thisN'
p8641
I165
sg33
g6561
sg63
g64
sS'trial_loop.thisIndex'
p8642
g59
(g98
S'\xa5\x00\x00\x00'
tRp8643
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8644
I0
sg6379
g6802
sS'block_loop.thisRepN'
p8645
I2
sg6382
g6561
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8646
I2
sg6385
g6568
sg55
g11
sS'block_loop.thisTrial'
p8647
Nsg69
Vn
sS'block_loop.thisTrialN'
p8648
I0
sg39
F1.2168297236148646
sg34
g752
(S'\x07\xdf\n\x10\x0b55\n-x'
tRp8649
sa(dp8650
S'trial_loop.thisTrialN'
p8651
I166
sg6370
g6476
sS'block_loop.thisIndex'
p8652
g6364
sg38
S'right'
p8653
sg58
g62
sS'trial_loop.thisN'
p8654
I166
sg33
g6395
sg63
g64
sS'trial_loop.thisIndex'
p8655
g59
(g98
S'\xa6\x00\x00\x00'
tRp8656
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8657
I0
sg6379
g6483
sS'block_loop.thisRepN'
p8658
I2
sg6382
g6395
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8659
I2
sg6385
g6402
sg55
g11
sS'block_loop.thisTrial'
p8660
Nsg69
Vn
sS'block_loop.thisTrialN'
p8661
I0
sg39
F0.74993927416380757
sg34
g752
(S'\x07\xdf\n\x10\x0b5;\x0e\x11\x90'
tRp8662
sa(dp8663
S'trial_loop.thisTrialN'
p8664
I167
sg6370
g7273
sS'block_loop.thisIndex'
p8665
g6364
sg38
S'left'
p8666
sg58
g62
sS'trial_loop.thisN'
p8667
I167
sg33
g6544
sg63
g64
sS'trial_loop.thisIndex'
p8668
g59
(g98
S'\xa7\x00\x00\x00'
tRp8669
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8670
I0
sg6379
g7280
sS'block_loop.thisRepN'
p8671
I2
sg6382
g6544
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8672
I2
sg6385
g6551
sg55
g11
sS'block_loop.thisTrial'
p8673
Nsg69
Vn
sS'block_loop.thisTrialN'
p8674
I0
sg39
F0.8501021220408802
sg34
g752
(S'\x07\xdf\n\x10\x0b6\x05\n\xd5p'
tRp8675
sa(dp8676
S'trial_loop.thisTrialN'
p8677
I168
sg6370
g6557
sS'block_loop.thisIndex'
p8678
g6364
sg38
S'left'
p8679
sg58
g62
sS'trial_loop.thisN'
p8680
I168
sg33
g6568
sg63
g64
sS'trial_loop.thisIndex'
p8681
g59
(g98
S'\xa8\x00\x00\x00'
tRp8682
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8683
I0
sg6379
g6565
sS'block_loop.thisRepN'
p8684
I2
sg6382
g6561
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8685
I2
sg6385
g6568
sg55
g11
sS'block_loop.thisTrial'
p8686
Nsg69
Vn
sS'block_loop.thisTrialN'
p8687
I0
sg39
F1.6502234596728158
sg34
g752
(S'\x07\xdf\n\x10\x0b6\x0b\t\x04\x98'
tRp8688
sa(dp8689
S'trial_loop.thisTrialN'
p8690
I169
sg6370
g6825
sS'block_loop.thisIndex'
p8691
g6364
sg38
S'right'
p8692
sg58
g62
sS'trial_loop.thisN'
p8693
I169
sg33
g6510
sg63
g64
sS'trial_loop.thisIndex'
p8694
g59
(g98
S'\xa9\x00\x00\x00'
tRp8695
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8696
I0
sg6379
g6832
sS'block_loop.thisRepN'
p8697
I2
sg6382
g6510
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8698
I2
sg6385
g6517
sg55
g11
sS'block_loop.thisTrial'
p8699
Nsg69
Vn
sS'block_loop.thisTrialN'
p8700
I0
sg39
F0.75017134379140771
sg34
g752
(S'\x07\xdf\n\x10\x0b6\x12\x04\x16\xe0'
tRp8701
sa(dp8702
S'trial_loop.thisTrialN'
p8703
I170
sg6370
g7165
sS'block_loop.thisIndex'
p8704
g6364
sg38
S'right'
p8705
sg58
g62
sS'trial_loop.thisN'
p8706
I170
sg33
g7169
sg63
g64
sS'trial_loop.thisIndex'
p8707
g59
(g98
S'\xaa\x00\x00\x00'
tRp8708
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8709
I0
sg6379
g7173
sS'block_loop.thisRepN'
p8710
I2
sg6382
g7169
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8711
I2
sg6385
g7176
sg55
g11
sS'block_loop.thisTrial'
p8712
Nsg69
Vn
sS'block_loop.thisTrialN'
p8713
I0
sg39
F0.73353246465921984
sg34
g752
(S'\x07\xdf\n\x10\x0b6\x18\x00\xda\xc0'
tRp8714
sa(dp8715
S'trial_loop.thisTrialN'
p8716
I171
sg6370
g6810
sS'block_loop.thisIndex'
p8717
g6364
sg38
S'right'
p8718
sg58
g62
sS'trial_loop.thisN'
p8719
I171
sg33
g6527
sg63
g64
sS'trial_loop.thisIndex'
p8720
g59
(g98
S'\xab\x00\x00\x00'
tRp8721
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8722
I0
sg6379
g6817
sS'block_loop.thisRepN'
p8723
I2
sg6382
g6527
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8724
I2
sg6385
g6534
sg55
g11
sS'block_loop.thisTrial'
p8725
Nsg69
Vn
sS'block_loop.thisTrialN'
p8726
I0
sg39
F0.78333135665525333
sg34
g752
(S'\x07\xdf\n\x10\x0b6\x1d\x0cc\xe0'
tRp8727
sa(dp8728
S'trial_loop.thisTrialN'
p8729
I172
sg6370
g6476
sS'block_loop.thisIndex'
p8730
g6364
sg38
S'right'
p8731
sg58
g62
sS'trial_loop.thisN'
p8732
I172
sg33
g6395
sg63
g64
sS'trial_loop.thisIndex'
p8733
g59
(g98
S'\xac\x00\x00\x00'
tRp8734
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8735
I0
sg6379
g6483
sS'block_loop.thisRepN'
p8736
I2
sg6382
g6395
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8737
I2
sg6385
g6402
sg55
g11
sS'block_loop.thisTrial'
p8738
Nsg69
Vn
sS'block_loop.thisTrialN'
p8739
I0
sg39
F0.74987997381595051
sg34
g752
(S'\x07\xdf\n\x10\x0b6#\t\xa0\xd8'
tRp8740
sa(dp8741
S'trial_loop.thisTrialN'
p8742
I173
sg6370
g6662
sS'block_loop.thisIndex'
p8743
g6364
sg38
S'left'
p8744
sg58
g62
sS'trial_loop.thisN'
p8745
I173
sg33
g6672
sg63
g64
sS'trial_loop.thisIndex'
p8746
g59
(g98
S'\xad\x00\x00\x00'
tRp8747
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8748
I0
sg6379
g6670
sS'block_loop.thisRepN'
p8749
I2
sg6382
g6672
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8750
I2
sg6385
g6666
sg55
g11
sS'block_loop.thisTrial'
p8751
Nsg69
Vn
sS'block_loop.thisTrialN'
p8752
I0
sg39
F0.70020452917833609
sg34
g752
(S'\x07\xdf\n\x10\x0b6)\x06d\xb8'
tRp8753
sa(dp8754
S'trial_loop.thisTrialN'
p8755
I174
sg6370
g7686
sS'block_loop.thisIndex'
p8756
g6364
sg38
S'left'
p8757
sg58
g62
sS'trial_loop.thisN'
p8758
I174
sg33
g7169
sg63
g64
sS'trial_loop.thisIndex'
p8759
g59
(g98
S'\xae\x00\x00\x00'
tRp8760
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8761
I0
sg6379
g7693
sS'block_loop.thisRepN'
p8762
I2
sg6382
g7169
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8763
I2
sg6385
g7176
sg55
g11
sS'block_loop.thisTrial'
p8764
Nsg69
Vn
sS'block_loop.thisTrialN'
p8765
I0
sg39
F0.80022397284938052
sg34
g752
(S'\x07\xdf\n\x10\x0b6/\x02m\x18'
tRp8766
sa(dp8767
S'trial_loop.thisTrialN'
p8768
I175
sg6370
g6937
sS'block_loop.thisIndex'
p8769
g6364
sg38
S'left'
p8770
sg58
g62
sS'trial_loop.thisN'
p8771
I175
sg33
g6733
sg63
g64
sS'trial_loop.thisIndex'
p8772
g59
(g98
S'\xaf\x00\x00\x00'
tRp8773
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8774
I0
sg6379
g6944
sS'block_loop.thisRepN'
p8775
I2
sg6382
g6726
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8776
I2
sg6385
g6733
sg55
g11
sS'block_loop.thisTrial'
p8777
Nsg69
Vn
sS'block_loop.thisTrialN'
p8778
I0
sg39
F0.88356234291131841
sg34
g752
(S'\x07\xdf\n\x10\x0b64\x0f*\xd0'
tRp8779
sa(dp8780
S'trial_loop.thisTrialN'
p8781
I176
sg6370
g6707
sS'block_loop.thisIndex'
p8782
g6364
sg38
S'left'
p8783
sg58
g62
sS'trial_loop.thisN'
p8784
I176
sg33
g6585
sg63
g64
sS'trial_loop.thisIndex'
p8785
g59
(g98
S'\xb0\x00\x00\x00'
tRp8786
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8787
I0
sg6379
g6714
sS'block_loop.thisRepN'
p8788
I2
sg6382
g6578
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8789
I2
sg6385
g6585
sg55
g11
sS'block_loop.thisTrial'
p8790
Nsg69
Vn
sS'block_loop.thisTrialN'
p8791
I0
sg39
F0.73341757023717946
sg34
g752
(S'\x07\xdf\n\x10\x0b6:\r\xd3\x10'
tRp8792
sa(dp8793
S'trial_loop.thisTrialN'
p8794
I177
sg6370
g7077
sS'block_loop.thisIndex'
p8795
g6364
sg38
S'right'
p8796
sg58
g62
sS'trial_loop.thisN'
p8797
I177
sg33
g7087
sg63
g64
sS'trial_loop.thisIndex'
p8798
g59
(g98
S'\xb1\x00\x00\x00'
tRp8799
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8800
I0
sg6379
g7085
sS'block_loop.thisRepN'
p8801
I2
sg6382
g7087
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8802
I2
sg6385
g7081
sg55
g11
sS'block_loop.thisTrial'
p8803
Nsg69
Vn
sS'block_loop.thisTrialN'
p8804
I0
sg39
F0.81670861405928008
sg34
g752
(S'\x07\xdf\n\x10\x0b7\x04\n\x1d\xd8'
tRp8805
sa(dp8806
S'trial_loop.thisTrialN'
p8807
I178
sg6370
g6937
sS'block_loop.thisIndex'
p8808
g6364
sg38
S'left'
p8809
sg58
g62
sS'trial_loop.thisN'
p8810
I178
sg33
g6726
sg63
g64
sS'trial_loop.thisIndex'
p8811
g59
(g98
S'\xb2\x00\x00\x00'
tRp8812
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8813
I0
sg6379
g6944
sS'block_loop.thisRepN'
p8814
I2
sg6382
g6726
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8815
I2
sg6385
g6733
sg55
g11
sS'block_loop.thisTrial'
p8816
Nsg69
Vn
sS'block_loop.thisTrialN'
p8817
I0
sg39
F0.81687682177562237
sg34
g752
(S'\x07\xdf\n\x10\x0b7\n\x07\xd3\xe8'
tRp8818
sa(dp8819
S'trial_loop.thisTrialN'
p8820
I179
sg6370
g7513
sS'block_loop.thisIndex'
p8821
g6364
sg38
S'left'
p8822
sg58
g62
sS'trial_loop.thisN'
p8823
I179
sg33
g7087
sg63
g64
sS'trial_loop.thisIndex'
p8824
g59
(g98
S'\xb3\x00\x00\x00'
tRp8825
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8826
I0
sg6379
g7520
sS'block_loop.thisRepN'
p8827
I2
sg6382
g7087
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8828
I2
sg6385
g7081
sg55
g11
sS'block_loop.thisTrial'
p8829
Nsg69
Vn
sS'block_loop.thisTrialN'
p8830
I0
sg39
F0.91723011499743734
sg34
g752
(S'\x07\xdf\n\x10\x0b7\x10\x05\x89\xf8'
tRp8831
sa(dp8832
S'trial_loop.thisTrialN'
p8833
I180
sg6370
g6868
sS'block_loop.thisIndex'
p8834
g6364
sg38
S'left'
p8835
sg58
g62
sS'trial_loop.thisN'
p8836
I180
sg33
g6872
sg63
g64
sS'trial_loop.thisIndex'
p8837
g59
(g98
S'\xb4\x00\x00\x00'
tRp8838
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8839
I0
sg6379
g6876
sS'block_loop.thisRepN'
p8840
I2
sg6382
g6872
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8841
I2
sg6385
g6879
sg55
g11
sS'block_loop.thisTrial'
p8842
Nsg69
Vn
sS'block_loop.thisTrialN'
p8843
I0
sg39
F1.850114951442265
sg34
g752
(S'\x07\xdf\n\x10\x0b7\x16\x04\xe9\xd0'
tRp8844
sa(dp8845
S'trial_loop.thisTrialN'
p8846
I181
sg6370
g6752
sS'block_loop.thisIndex'
p8847
g6364
sg38
S'left'
p8848
sg58
g62
sS'trial_loop.thisN'
p8849
I181
sg33
g6756
sg63
g64
sS'trial_loop.thisIndex'
p8850
g59
(g98
S'\xb5\x00\x00\x00'
tRp8851
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8852
I0
sg6379
g6760
sS'block_loop.thisRepN'
p8853
I2
sg6382
g6756
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8854
I2
sg6385
g6763
sg55
g11
sS'block_loop.thisTrial'
p8855
Nsg69
Vn
sS'block_loop.thisTrialN'
p8856
I0
sg39
F0.8335182667879053
sg34
g752
(S'\x07\xdf\n\x10\x0b7\x1d\x03\x11('
tRp8857
sa(dp8858
S'trial_loop.thisTrialN'
p8859
I182
sg6370
g7273
sS'block_loop.thisIndex'
p8860
g6364
sg38
S'left'
p8861
sg58
g62
sS'trial_loop.thisN'
p8862
I182
sg33
g6551
sg63
g64
sS'trial_loop.thisIndex'
p8863
g59
(g98
S'\xb6\x00\x00\x00'
tRp8864
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8865
I0
sg6379
g7280
sS'block_loop.thisRepN'
p8866
I2
sg6382
g6544
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8867
I2
sg6385
g6551
sg55
g11
sS'block_loop.thisTrial'
p8868
Nsg69
Vn
sS'block_loop.thisTrialN'
p8869
I0
sg39
F0.78351552984804584
sg34
g752
(S'\x07\xdf\n\x10\x0b7#\x01\x05\xb8'
tRp8870
sa(dp8871
S'trial_loop.thisTrialN'
p8872
I183
sg6370
g7513
sS'block_loop.thisIndex'
p8873
g6364
sg38
S'left'
p8874
sg58
g62
sS'trial_loop.thisN'
p8875
I183
sg33
g7087
sg63
g64
sS'trial_loop.thisIndex'
p8876
g59
(g98
S'\xb7\x00\x00\x00'
tRp8877
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8878
I0
sg6379
g7520
sS'block_loop.thisRepN'
p8879
I2
sg6382
g7087
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8880
I2
sg6385
g7081
sg55
g11
sS'block_loop.thisTrial'
p8881
Nsg69
Vn
sS'block_loop.thisTrialN'
p8882
I0
sg39
F0.66687972977251775
sg34
g752
(S'\x07\xdf\n\x10\x0b7(\r\x84\xf0'
tRp8883
sa(dp8884
S'trial_loop.thisTrialN'
p8885
I184
sg6370
g6662
sS'block_loop.thisIndex'
p8886
g6364
sg38
S'left'
p8887
sg58
g62
sS'trial_loop.thisN'
p8888
I184
sg33
g6672
sg63
g64
sS'trial_loop.thisIndex'
p8889
g59
(g98
S'\xb8\x00\x00\x00'
tRp8890
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8891
I0
sg6379
g6670
sS'block_loop.thisRepN'
p8892
I2
sg6382
g6672
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8893
I2
sg6385
g6666
sg55
g11
sS'block_loop.thisTrial'
p8894
Nsg69
Vn
sS'block_loop.thisTrialN'
p8895
I0
sg39
F0.6168607422578134
sg34
g752
(S'\x07\xdf\n\x10\x0b7.\x08\xd9\xa0'
tRp8896
sa(dp8897
S'trial_loop.thisTrialN'
p8898
I185
sg6370
g6810
sS'block_loop.thisIndex'
p8899
g6364
sg38
S'right'
p8900
sg58
g62
sS'trial_loop.thisN'
p8901
I185
sg33
g6527
sg63
g64
sS'trial_loop.thisIndex'
p8902
g59
(g98
S'\xb9\x00\x00\x00'
tRp8903
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8904
I0
sg6379
g6817
sS'block_loop.thisRepN'
p8905
I2
sg6382
g6527
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8906
I2
sg6385
g6534
sg55
g11
sS'block_loop.thisTrial'
p8907
Nsg69
Vn
sS'block_loop.thisTrialN'
p8908
I0
sg39
F2.7333571294975627
sg34
g752
(S'\x07\xdf\n\x10\x0b74\x03\xb58'
tRp8909
sa(dp8910
S'trial_loop.thisTrialN'
p8911
I186
sg6370
g6937
sS'block_loop.thisIndex'
p8912
g6364
sg38
S'left'
p8913
sg58
g62
sS'trial_loop.thisN'
p8914
I186
sg33
g6733
sg63
g64
sS'trial_loop.thisIndex'
p8915
g59
(g98
S'\xba\x00\x00\x00'
tRp8916
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8917
I0
sg6379
g6944
sS'block_loop.thisRepN'
p8918
I2
sg6382
g6726
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8919
I2
sg6385
g6733
sg55
g11
sS'block_loop.thisTrial'
p8920
Nsg69
Vn
sS'block_loop.thisTrialN'
p8921
I0
sg39
F2.9167967663061063
sg34
g752
(S'\x07\xdf\n\x10\x0b7;\x0f2\xa0'
tRp8922
sa(dp8923
S'trial_loop.thisTrialN'
p8924
I187
sg6370
g7686
sS'block_loop.thisIndex'
p8925
g6364
sg38
S'left'
p8926
sg58
g62
sS'trial_loop.thisN'
p8927
I187
sg33
g7169
sg63
g64
sS'trial_loop.thisIndex'
p8928
g59
(g98
S'\xbb\x00\x00\x00'
tRp8929
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8930
I0
sg6379
g7693
sS'block_loop.thisRepN'
p8931
I2
sg6382
g7169
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8932
I2
sg6385
g7176
sg55
g11
sS'block_loop.thisTrial'
p8933
Nsg69
Vn
sS'block_loop.thisTrialN'
p8934
I0
sg39
F1.3667415713680384
sg34
g752
(S'\x07\xdf\n\x10\x0b8\x07\x0e\x86\xc0'
tRp8935
sa(dp8936
S'trial_loop.thisTrialN'
p8937
I188
sg6370
g8052
sS'block_loop.thisIndex'
p8938
g6364
sg38
S'right'
p8939
sg58
g62
sS'trial_loop.thisN'
p8940
I188
sg33
g6672
sg63
g64
sS'trial_loop.thisIndex'
p8941
g59
(g98
S'\xbc\x00\x00\x00'
tRp8942
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8943
I0
sg6379
g8059
sS'block_loop.thisRepN'
p8944
I2
sg6382
g6672
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8945
I2
sg6385
g6666
sg55
g11
sS'block_loop.thisTrial'
p8946
Nsg69
Vn
sS'block_loop.thisTrialN'
p8947
I0
sg39
F0.68357078180724784
sg34
g752
(S'\x07\xdf\n\x10\x0b8\x0e\x05O`'
tRp8948
sa(dp8949
S'trial_loop.thisTrialN'
p8950
I189
sg6370
g7513
sS'block_loop.thisIndex'
p8951
g6364
sg38
S'left'
p8952
sg58
g62
sS'trial_loop.thisN'
p8953
I189
sg33
g7087
sg63
g64
sS'trial_loop.thisIndex'
p8954
g59
(g98
S'\xbd\x00\x00\x00'
tRp8955
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8956
I0
sg6379
g7520
sS'block_loop.thisRepN'
p8957
I2
sg6382
g7087
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8958
I2
sg6385
g7081
sg55
g11
sS'block_loop.thisTrial'
p8959
Nsg69
Vn
sS'block_loop.thisTrialN'
p8960
I0
sg39
F0.81688680019851745
sg34
g752
(S'\x07\xdf\n\x10\x0b8\x14\x01\x1d('
tRp8961
sa(dp8962
S'trial_loop.thisTrialN'
p8963
I190
sg6370
g6408
sS'block_loop.thisIndex'
p8964
g6364
sg38
S'right'
p8965
sg58
g62
sS'trial_loop.thisN'
p8966
I190
sg33
g6412
sg63
g64
sS'trial_loop.thisIndex'
p8967
g59
(g98
S'\xbe\x00\x00\x00'
tRp8968
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8969
I0
sg6379
g6416
sS'block_loop.thisRepN'
p8970
I2
sg6382
g6412
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8971
I2
sg6385
g6419
sg55
g11
sS'block_loop.thisTrial'
p8972
Nsg69
Vn
sS'block_loop.thisTrialN'
p8973
I0
sg39
F0.95012299120026
sg34
g752
(S'\x07\xdf\n\x10\x0b8\x19\x0e\x15x'
tRp8974
sa(dp8975
S'trial_loop.thisTrialN'
p8976
I191
sg6370
g6574
sS'block_loop.thisIndex'
p8977
g6364
sg38
S'right'
p8978
sg58
g62
sS'trial_loop.thisN'
p8979
I191
sg33
g6578
sg63
g64
sS'trial_loop.thisIndex'
p8980
g59
(g98
S'\xbf\x00\x00\x00'
tRp8981
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8982
I0
sg6379
g6582
sS'block_loop.thisRepN'
p8983
I2
sg6382
g6578
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8984
I2
sg6385
g6585
sg55
g11
sS'block_loop.thisTrial'
p8985
Nsg69
Vn
sS'block_loop.thisTrialN'
p8986
I0
sg39
F0.7835309251313447
sg34
g752
(S'\x07\xdf\n\x10\x0b8\x1f\r\xb3\xd0'
tRp8987
sa(dp8988
S'trial_loop.thisTrialN'
p8989
I192
sg6370
g6840
sS'block_loop.thisIndex'
p8990
g6364
sg38
S'left'
p8991
sg58
g62
sS'trial_loop.thisN'
p8992
I192
sg33
g6595
sg63
g64
sS'trial_loop.thisIndex'
p8993
g59
(g98
S'\xc0\x00\x00\x00'
tRp8994
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p8995
I0
sg6379
g6847
sS'block_loop.thisRepN'
p8996
I2
sg6382
g6595
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p8997
I2
sg6385
g6602
sg55
g11
sS'block_loop.thisTrial'
p8998
Nsg69
Vn
sS'block_loop.thisTrialN'
p8999
I0
sg39
F0.78353149532631505
sg34
g752
(S'\x07\xdf\n\x10\x0b8%\n\xf0\xc8'
tRp9000
sa(dp9001
S'trial_loop.thisTrialN'
p9002
I193
sg6370
g6722
sS'block_loop.thisIndex'
p9003
g6364
sg38
S'right'
p9004
sg58
g62
sS'trial_loop.thisN'
p9005
I193
sg33
g6726
sg63
g64
sS'trial_loop.thisIndex'
p9006
g59
(g98
S'\xc1\x00\x00\x00'
tRp9007
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p9008
I0
sg6379
g6730
sS'block_loop.thisRepN'
p9009
I2
sg6382
g6726
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p9010
I2
sg6385
g6733
sg55
g11
sS'block_loop.thisTrial'
p9011
Nsg69
Vn
sS'block_loop.thisTrialN'
p9012
I0
sg39
F0.86679374426967115
sg34
g752
(S'\x07\xdf\n\x10\x0b8+\x08-\xc0'
tRp9013
sa(dp9014
S'trial_loop.thisTrialN'
p9015
I194
sg6370
g8052
sS'block_loop.thisIndex'
p9016
g6364
sg38
S'right'
p9017
sg58
g62
sS'trial_loop.thisN'
p9018
I194
sg33
g6666
sg63
g64
sS'trial_loop.thisIndex'
p9019
g59
(g98
S'\xc2\x00\x00\x00'
tRp9020
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p9021
I0
sg6379
g8059
sS'block_loop.thisRepN'
p9022
I2
sg6382
g6672
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p9023
I2
sg6385
g6666
sg55
g11
sS'block_loop.thisTrial'
p9024
Nsg69
Vn
sS'block_loop.thisTrialN'
p9025
I0
sg39
F0.7001936954611665
sg34
g752
(S'\x07\xdf\n\x10\x0b81\x06\x97\x80'
tRp9026
sa(dp9027
S'trial_loop.thisTrialN'
p9028
I195
sg6370
g6965
sS'block_loop.thisIndex'
p9029
g6364
sg38
S'left'
p9030
sg58
g62
sS'trial_loop.thisN'
p9031
I195
sg33
g6969
sg63
g64
sS'trial_loop.thisIndex'
p9032
g59
(g98
S'\xc3\x00\x00\x00'
tRp9033
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p9034
I0
sg6379
g6973
sS'block_loop.thisRepN'
p9035
I2
sg6382
g6969
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p9036
I2
sg6385
g6976
sg55
g11
sS'block_loop.thisTrial'
p9037
Nsg69
Vn
sS'block_loop.thisTrialN'
p9038
I0
sg39
F0.85057082286130026
sg34
g752
(S'\x07\xdf\n\x10\x0b87\x02\xa3\xc8'
tRp9039
sa(dp9040
S'trial_loop.thisTrialN'
p9041
I196
sg6370
g6868
sS'block_loop.thisIndex'
p9042
g6364
sg38
S'left'
p9043
sg58
g62
sS'trial_loop.thisN'
p9044
I196
sg33
g6872
sg63
g64
sS'trial_loop.thisIndex'
p9045
g59
(g98
S'\xc4\x00\x00\x00'
tRp9046
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p9047
I0
sg6379
g6876
sS'block_loop.thisRepN'
p9048
I2
sg6382
g6872
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p9049
I2
sg6385
g6879
sg55
g11
sS'block_loop.thisTrial'
p9050
Nsg69
Vn
sS'block_loop.thisTrialN'
p9051
I0
sg39
F0.81686513276417827
sg34
g752
(S'\x07\xdf\n\x10\x0b9\x01\x00\xd2\xf0'
tRp9052
sa(dp9053
S'trial_loop.thisTrialN'
p9054
I197
sg6370
g7111
sS'block_loop.thisIndex'
p9055
g6364
sg38
S'right'
p9056
sg58
g62
sS'trial_loop.thisN'
p9057
I197
sg33
g6969
sg63
g64
sS'trial_loop.thisIndex'
p9058
g59
(g98
S'\xc5\x00\x00\x00'
tRp9059
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p9060
I0
sg6379
g7118
sS'block_loop.thisRepN'
p9061
I2
sg6382
g6969
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p9062
I2
sg6385
g6976
sg55
g11
sS'block_loop.thisTrial'
p9063
Nsg69
Vn
sS'block_loop.thisTrialN'
p9064
I0
sg39
F0.70019483585292619
sg34
g752
(S'\x07\xdf\n\x10\x0b9\x06\r\xcb@'
tRp9065
sa(dp9066
S'trial_loop.thisTrialN'
p9067
I198
sg6370
g7686
sS'block_loop.thisIndex'
p9068
g6364
sg38
S'left'
p9069
sg58
g62
sS'trial_loop.thisN'
p9070
I198
sg33
g7169
sg63
g64
sS'trial_loop.thisIndex'
p9071
g59
(g98
S'\xc6\x00\x00\x00'
tRp9072
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p9073
I0
sg6379
g7693
sS'block_loop.thisRepN'
p9074
I2
sg6382
g7169
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p9075
I2
sg6385
g7176
sg55
g11
sS'block_loop.thisTrial'
p9076
Nsg69
Vn
sS'block_loop.thisTrialN'
p9077
I0
sg39
F0.83343359273385431
sg34
g752
(S'\x07\xdf\n\x10\x0b9\x0c\t\x9c\xf0'
tRp9078
sa(dp9079
S'trial_loop.thisTrialN'
p9080
I199
sg6370
g6459
sS'block_loop.thisIndex'
p9081
g6364
sg38
S'right'
p9082
sg58
g62
sS'trial_loop.thisN'
p9083
I199
sg33
g6463
sg63
g64
sS'trial_loop.thisIndex'
p9084
g59
(g98
S'\xc7\x00\x00\x00'
tRp9085
sg65
g66
sg67
g68
sS'trial_loop.thisRepN'
p9086
I0
sg6379
g6467
sS'block_loop.thisRepN'
p9087
I2
sg6382
g6463
sg56
Vr
sg57
Vy
sS'block_loop.thisN'
p9088
I2
sg6385
g6470
sg55
g11
sS'block_loop.thisTrial'
p9089
Nsg69
Vn
sS'block_loop.thisTrialN'
p9090
I0
sg39
F1.000177615944267
sg34
g752
(S'\x07\xdf\n\x10\x0b9\x12\x07\x8d\x98'
tRp9091
sa(dp9092
S'block_loop.thisRepN'
p9093
I2
sg56
Vr
sS'block_loop.thisIndex'
p9094
g6364
sg57
Vy
sg58
g62
sS'block_loop.thisN'
p9095
I2
sg55
g11
sg63
g64
sS'block_loop.thisTrial'
p9096
Nsg65
g66
sg67
g68
sS'block_loop.thisTrialN'
p9097
I0
sg69
Vn
sa(dp9098
g63
g64
sg43
I36
sg56
Vr
sg57
Vy
sg42
I564
sg58
g62
sg55
g11
sg65
g66
sg67
g68
sg69
Vn
sa(dp9099
g63
g64
sg43
I36
sg55
g11
sg56
Vr
sg45
F1.6000000000000001
sg42
I564
sg49
F0.01
sg57
Vy
sg58
g62
sg44
I00
sg48
I25
sg47
g444
sg51
F30.640000000000001
sg46
F0
sg65
g66
sg67
g68
sg50
I0
sg69
Vn
sasS'loops'
p9100
(lp9101
g1
(cpsychopy.data
TrialHandler
p9102
g3
NtRp9103
(dp9104
S'origin'
p9105
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a\u000a######################## CITATIONS ########################## \u000a##### Binary choice, BDM, auction routines, and instructions are modified from:\u000a##### \u000a##### De Martino, B., Fleming, S. M., Garrett, N., & Dolan, R. J. (2012). Confidence in value-based choice. Nature Neuroscience, 16(1), 105-110. \u000a#####\u000a##### Food item images are original.\u000a\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.80.01), July 16, 2014, at 03:20\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things bdm STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000afrom pyglet.window import key # to detect key state, whether key is held down, to move slider on key hold\u000aimport pandas as pd\u000aimport datetime\u000afrom psychopy.iohub import launchHubServer\u000aimport pylink\u000a\u000a# Initialize IOHub for eye tracker\u000a# io=launchHubServer(iohub_config_name='iohub_config.yaml')\u000a# tracker = io.devices.tracker\u000a\u000a# Store info about the experiment session\u000aexpName = 'infer_design1_no_eyetracking'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u'', u'eye': u'', u'glasses': u'', u'contacts': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Setup filename for saving\u000afilename = 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# set up variable to track current state of key press, to move slider when keys held down\u000akeyState=key.KeyStateHandler()\u000a\u000a# Setup the Window\u000ascreenwidth = 1920\u000ascreenheight = 1080\u000awin = visual.Window(size=(screenwidth, screenheight), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color='black', colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000awin.winHandle.push_handlers(keyState)\u000a\u000a\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a\u000a######################## COMPONENTS ##########################\u000a\u000a# Set up directory path for stimuli. This avoids us having to put the entire image path in the conditions spreadsheet.\u000adir_path = 'stimuli/itempics/modified/small/'\u000a\u000a# Initialize components for Routine "instr_main"\u000ainstr_mainClock = core.Clock()\u000ainstr_main_txt = visual.TextStim(win=win, ori=0, name='instr_main_txt',\u000a    text=u'Welcome!\u005cn\u005cnPlease read the instructions carefully and get the experimenter when you\u005c're finished. Take as much time as you need.',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "instr_bdm"\u000ainstr_bdmClock = core.Clock()\u000ainstr_bdm_txt = visual.TextStim(win=win, ori=0, name='instr_bdm_txt',\u000a    text=u'The bidding task is about to begin. Use the LEFT and RIGHT arrow keys to move the cursor along the slider, then press the DOWN arrow to enter your bid.\u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "fixation"\u000afixationClock = core.Clock()\u000afixation_text = visual.TextStim(win=win, ori=0, name='fixation_text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "bdm"\u000abdmClock = core.Clock()\u000abdm_pic = visual.ImageStim(win=win, name='bdm_pic',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=0.0)\u000abdm_bid = visual.RatingScale(win=win, name='bdm_bid', marker=u'triangle', markerColor=u'orange', leftKeys=None, rightKeys=None,\u000a    size=1.0, pos=[0.0, -0.6], low=0, high=3, precision=100, labels=[u'\u005cxa30', u'\u005cxa33'],\u000a    scale=u'', markerStart=u'1.5', tickHeight=u'1', showAccept=False, acceptKeys=[u'down', u'return'])\u000a\u000a# Initialize components for Routine "instr_choice"\u000ainstr_choiceClock = core.Clock()\u000ainstr_choice_txt = visual.TextStim(win=win, ori=0, name='instr_choice_txt',\u000a    text=u'The choice task is about to begin. Choose your preferred item by pressing the LEFT or RIGHT arrow keys, then use the slider to indicate how confident you are that you made the best choice.\u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "choice"\u000achoiceClock = core.Clock()\u000achoice_pic_left = visual.ImageStim(win=win, name='choice_pic_left',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[-0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=0.0)\u000achoice_pic_right = visual.ImageStim(win=win, name='choice_pic_right',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=-1.0)\u000a\u000a# Initialize components for Routine "choice_selection"\u000achoice_selectionClock = core.Clock()\u000astar_left_selection = visual.TextStim(win=win, ori=0, name='star_left_selection',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[-0.5, -0.8], height=0.5, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=-2.0)\u000astar_right_selection = visual.TextStim(win=win, ori=0, name='star_right_selection',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[0.5, -0.8], height=0.5, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=-3.0)\u000a\u000a# Initialize components for Routine "confidence"\u000aconfidenceClock = core.Clock()\u000aconfidence_rating = visual.RatingScale(win=win, name='confidence_rating', marker=u'triangle', markerColor=u'orange', leftKeys=None, rightKeys=None,\u000a    size=1.0, pos=[0.0, 0.0], low=1, high=6, precision=20,\u000a    scale=u'', markerStart=u'3.5', tickHeight=u'1', showAccept=False, acceptKeys=[u'down', u'return'])\u000a\u000a# Initialize components for Routine "instr_infer_intro"\u000ainstr_infer_introClock = core.Clock()\u000ainstr_infer_intro_txt = visual.TextStim(win=win, ori=0, name='instr_infer_intro_txt',\u000a    text=u'Thanks! Now please get the experimenter, who will give you the instructions for the second part of the experiment. \u005cn\u005cnPlease read these instructions carefully and get the experimenter again when you\u005c're finished. Take as much time as you need.',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=1.5,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "instr_infer_practice"\u000ainstr_infer_practiceClock = core.Clock()\u000ainstr_infer_practice_txt = visual.TextStim(win=win, ori=0, name='instr_infer_practice_txt',\u000a    text=u'First, you\u005c'll do some practice trials. These are just for you to get used to the task; your responses won\u005c't count. \u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=1.5,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "instr_infer"\u000ainstr_inferClock = core.Clock()\u000ainstr_infer_txt = visual.TextStim(win=win, ori=0, name='instr_infer_txt',\u000a    text=u'Great! Now that you\u005c've done some practice trials, we\u005c're ready to start the real trials. Please call the experimenter into the room.',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=1.5,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "get_ready"\u000aget_readyClock = core.Clock()\u000aget_ready_text = visual.TextStim(win=win, ori=0, name='get_ready_text',\u000a    text=u'Get ready!',    font=u'Arial',\u000a    pos=[0, 0], height=0.12, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000aimg_left_infer = visual.ImageStim(win=win, name='img_left_infer',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[-0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=0.0)\u000aimg_right_infer = visual.ImageStim(win=win, name='img_right_infer',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=-1.0)\u000a\u000a# Initialize components for Routine "trial_post_response"\u000atrial_post_responseClock = core.Clock()\u000aselection_arrow_left = visual.TextStim(win=win, ori=0, name='selection_arrow_left',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[-0.5, -0.09], height=0.5, wrapWidth=None,\u000a    color=u'red', colorSpace=u'rgb', opacity=1,\u000a    depth=-2.0)\u000aselection_arrow_right = visual.TextStim(win=win, ori=0, name='selection_arrow_right',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[0.5, -0.09], height=0.5, wrapWidth=None,\u000a    color=u'red', colorSpace=u'rgb', opacity=1,\u000a    depth=-3.0)\u000afeedback_box_left = visual.Rect(win=win, name='feedback_box_left',\u000a    width=[0.9, 0.9][0], height=[0.9, 0.9][1],\u000a    ori=0, pos=[-0.5, 0],\u000a    lineWidth=5, lineColor=u'yellow', lineColorSpace=u'rgb',\u000a    fillColor=None, fillColorSpace=u'rgb',\u000a    opacity=1, depth=-4.0, interpolate=True)\u000afeedback_box_right = visual.Rect(win=win, name='feedback_box_right',\u000a    width=[0.9, 0.9][0], height=[0.9, 0.9][1],\u000a    ori=0, pos=[0.5, 0],\u000a    lineWidth=5, lineColor=u'yellow', lineColorSpace=u'rgb',\u000a    fillColor=None, fillColorSpace=u'rgb',\u000a    opacity=1, depth=-5.0, interpolate=True)\u000a\u000a# Initialize components for Routine "rest_prompt"\u000arest_promptClock = core.Clock()\u000arest_prompt_txt = visual.TextStim(win=win, ori=0, name='rest_prompt_txt',\u000a    text=u'Great! Now take a rest and press the space bar when you\u005cu2019re ready to begin the next block.',    font=u'Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create counters for the number of correct and incorrect guesses made by subjects to determine extra payment.\u000acorrect_counter = 0\u000aincorrect_counter = 0\u000a\u000a# Create list of lists to store binary choice and BDM data to generate food reward at the end of the experiment\u000aprefs = [['left', 'right', 'choice', 'bid']]\u000abids = [['item', 'bid']] # For the bids collected during the first BDM routine, at the beginning of the experiment\u000a\u000a### CHOICE & INFERENCE RANDOMIZATION ###\u000a\u000a# Define two functions to generate constrained pseudorandom sequences of item pair presentations for the binary choice and inference\u000a# parts of the task. The constraint ensures that the same pair of items does not appear twice in a row (flipped or not).\u000a# In the conditions spreadsheet that the item pairs are drawn from, the flipped version of the same item pair is 20\u000a# rows apart.\u000a\u000a# Binary choice randomization\u000adef genseq_choice():\u000a    done = False\u000a    while done==False:\u000a        counter = 0\u000a        ans = np.random.choice(40, 40, replace=False) # Generate a pseudorandom sequence of 40 numbers\u000a        for x in range(1,40):\u000a            if (ans[x]-ans[x-1]) % 20 == 0: # Is the difference between any sequential numbers divisible by 20?\u000a                counter += 1\u000a        if counter==0: # If not, end the loop and return the array\u000a            done = True\u000a            return ans\u000a        else: # If so, continue the loop and try again\u000a            done = False\u000a\u000a# Inference practice block randomization\u000adef genseq_infer_practice():\u000a    done = False\u000a    while done==False:\u000a        counter = 0\u000a        ans = np.random.choice(14, 14, replace=False) # Generate a pseudorandom sequence of 200 numbers\u000a        for x in range(1,14):\u000a            if (ans[x]-ans[x-1]) % 7 == 0: # Is the difference between any sequential numbers divisible by 20?\u000a                counter += 1\u000a        if counter==0: # If not, end the loop and return the array\u000a            done = True\u000a            return ans\u000a        else: # If so, continue the loop and try again\u000a            done = False\u000a\u000a# Inference randomization\u000adef genseq_infer():\u000a    done = False\u000a    while done==False:\u000a        counter = 0\u000a        ans = np.random.choice(200, 200, replace=False) # Generate a pseudorandom sequence of 200 numbers\u000a        for x in range(1,200):\u000a            if (ans[x]-ans[x-1]) % 20 == 0: # Is the difference between any sequential numbers divisible by 20?\u000a                counter += 1\u000a        if counter==0: # If not, end the loop and return the array\u000a            done = True\u000a            return ans\u000a        else: # If so, continue the loop and try again\u000a            done = False\u000a\u000a\u000a# Set independent sequences for each of the two choice blocks, the inference practice block, and the three inference rest blocks. Each rest block contains 10 presentations of\u000a# each pair.\u000a\u000achoiceseq = genseq_choice()\u000apracticeseq = genseq_infer_practice()\u000ablock1seq = genseq_infer()\u000ablock2seq = genseq_infer()\u000ablock3seq = genseq_infer()\u000a\u000a\u000a# Choose a pilot participant whose choices will form the basis of the learning task\u000apartners = ['P1','P2','P3','P4','P5','P6','P8','P9','P10','P11','P12'] # List of pilot participants, P7 excluded for perfectly inconsistent choices\u000apartner = np.random.choice(partners,1) # Choose one at random\u000apartner_file = 'conditions/choices/infer_design1_value_pairs_' + partner[0] + '.csv' # Path to that participant's choice data\u000a\u000a# Create separate CSV files, one for each choice, practice, and rest block, with the item pairs in the pseudorandomly generated order.\u000a# These CSV files will be used as PsychoPy's conditions spreadsheets and run sequentially in the choice, practice, and inference loops below.\u000a\u000a\u000achoicecond_src = pd.read_csv('conditions/choice_design1_binary.csv', index_col=None, header=0)\u000achoicecond = choicecond_src.copy()\u000afor x in range(40):\u000a    seq = choiceseq[x]\u000a    choicecond.iloc[x] = choicecond_src.iloc[seq]\u000achoicecond.to_csv(path_or_buf=filename+'_choicecond.csv', index=False)\u000a\u000apracticecond_src = pd.read_csv('conditions/choices/infer_design1_value_pairs_practice.csv', index_col=None, header=0)\u000apracticecond = practicecond_src.copy()\u000afor x in range(14):\u000a    seq = practiceseq[x]\u000a    practicecond.iloc[x] = practicecond_src.iloc[seq]\u000apracticecond.to_csv(path_or_buf=filename+'_practicecond.csv', index=False)\u000a\u000ablock1cond_src = pd.read_csv(partner_file, index_col=None, header=0)\u000ablock1cond = block1cond_src.copy()\u000afor x in range(200):\u000a    seq = block1seq[x]\u000a    block1cond.iloc[x] = block1cond_src.iloc[seq]\u000ablock1cond.to_csv(path_or_buf=filename+'_block1cond.csv', index=False)\u000a\u000ablock2cond_src = pd.read_csv(partner_file, index_col=None, header=0)\u000ablock2cond = block2cond_src.copy()\u000afor x in range(200):\u000a    seq = block2seq[x]\u000a    block2cond.iloc[x] = block2cond_src.iloc[seq]\u000ablock2cond.to_csv(path_or_buf=filename+'_block2cond.csv', index=False)\u000a\u000ablock3cond_src = pd.read_csv(partner_file, index_col=None, header=0)\u000ablock3cond = block3cond_src.copy()\u000afor x in range(200):\u000a    seq = block3seq[x]\u000a    block3cond.iloc[x] = block3cond_src.iloc[seq]\u000ablock3cond.to_csv(path_or_buf=filename+'_block3cond.csv', index=False)\u000a\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instr_main"-------\u000at = 0\u000ainstr_mainClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_main_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_main_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_mainComponents = []\u000ainstr_mainComponents.append(instr_main_txt)\u000ainstr_mainComponents.append(instr_main_resp)\u000afor thisComponent in instr_mainComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_main"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_mainClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_main_txt* updates\u000a    if t >= 0.0 and instr_main_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_main_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_main_txt.frameNStart = frameN  # exact frame index\u000a        instr_main_txt.setAutoDraw(True)\u000a    \u000a    # *instr_main_resp* updates\u000a    if t >= 5.0 and instr_main_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_main_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_main_resp.frameNStart = frameN  # exact frame index\u000a        instr_main_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_main_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_main_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_main_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_main_resp.rt = instr_main_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_mainComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_main"-------\u000afor thisComponent in instr_mainComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_main_resp.keys in ['', [], None]:  # No response was made\u000a   instr_main_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_main_resp.keys',instr_main_resp.keys)\u000aif instr_main_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_main_resp.rt', instr_main_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a\u000a#------Prepare to start Routine "instr_bdm"-------\u000at = 0\u000ainstr_bdmClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_bdm_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_bdm_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_bdmComponents = []\u000ainstr_bdmComponents.append(instr_bdm_txt)\u000ainstr_bdmComponents.append(instr_bdm_resp)\u000afor thisComponent in instr_bdmComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_bdm"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_bdmClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_bdm_txt* updates\u000a    if t >= 0.0 and instr_bdm_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_bdm_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_bdm_txt.frameNStart = frameN  # exact frame index\u000a        instr_bdm_txt.setAutoDraw(True)\u000a    \u000a    # *instr_bdm_resp* updates\u000a    if t >= 2.0 and instr_bdm_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_bdm_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_bdm_resp.frameNStart = frameN  # exact frame index\u000a        instr_bdm_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_bdm_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_bdm_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space', 's'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_bdm_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_bdm_resp.rt = instr_bdm_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_bdmComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_bdm"-------\u000afor thisComponent in instr_bdmComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_bdm_resp.keys in ['', [], None]:  # No response was made\u000a   instr_bdm_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_bdm_resp.keys',instr_bdm_resp.keys)\u000athisExp.addData('partnered_pilot_participant', partner)\u000aif instr_bdm_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_bdm_resp.rt', instr_bdm_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## BDM LOOP 1 ##########################\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000abdm_loop1 = data.TrialHandler(nReps=1, method=u'random', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'conditions/choice_design1_bdm.xlsx'),\u000a    seed=None, name='bdm_loop1')\u000athisExp.addLoop(bdm_loop1)  # add the loop to the experiment\u000athisbdm_loop1 = bdm_loop1.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisbdm_loop1.rgb)\u000aif thisbdm_loop1 != None:\u000a    for paramName in thisbdm_loop1.keys():\u000a        exec(paramName + '= thisbdm_loop1.' + paramName)\u000a\u000a# Check if the 'skip' key was pressed in the instructions routine; if so, end the loop and move on to the inference task\u000aif instr_bdm_resp.keys=='s':\u000a    bdm_loop1.finished = True\u000a\u000afor thisbdm_loop1 in bdm_loop1:\u000a    currentLoop = bdm_loop1\u000a    # abbreviate parameter names if possible (e.g. rgb = thisbdm_loop1.rgb)\u000a    if thisbdm_loop1 != None:\u000a        for paramName in thisbdm_loop1.keys():\u000a            exec(paramName + '= thisbdm_loop1.' + paramName)\u000a    \u000a    #------Prepare to start Routine "bdm"-------\u000a    t = 0\u000a    bdmClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    bdm_pic.setImage(dir_path+bdm_img)\u000a    bdm_bid.reset()\u000a    # jitter the starting position of the BDM scale from a uniform distribution between 1 and 2, rounded to the nearest decimal place\u000a    bdm_marker_start = float(np.round(np.random.uniform(1, 2, 1)[0], 1))\u000a    bdm_bid.setMarkerPos(bdm_marker_start)\u000a    # keep track of which components have finished\u000a    bdmComponents = []\u000a    bdmComponents.append(fixation_text)\u000a    bdmComponents.append(bdm_pic)\u000a    bdmComponents.append(bdm_bid)\u000a    for thisComponent in bdmComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "bdm"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = bdmClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation_text* updates\u000a        if t >= 0 and fixation_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation_text.tStart = t  # underestimates by a little under one frame\u000a            fixation_text.frameNStart = frameN  # exact frame index\u000a            fixation_text.setAutoDraw(True)\u000a        elif fixation_text.status == STARTED and t>= (0 + (1.0-win.monitorFramePeriod*0.75)):\u000a            fixation_text.setAutoDraw(False)\u000a\u000a        # *bdm_pic* updates\u000a        if t >= 1.0 and bdm_pic.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bdm_pic.tStart = t  # underestimates by a little under one frame\u000a            bdm_pic.frameNStart = frameN  # exact frame index\u000a            bdm_pic.setAutoDraw(True)\u000a        # *bdm_bid* updates\u000a        if t >= 1.0:\u000a            bdm_bid.draw()\u000a            continueRoutine = bdm_bid.noResponse\u000a            if bdm_bid.noResponse == False:\u000a                bdm_bid.response = bdm_bid.getRating()\u000a                bdm_bid.rt = bdm_bid.getRT()\u000a            elif bdm_bid.noResponse==True:\u000a                if keyState[key.LEFT]==True and bdm_bid.markerPlacedAt >0.01:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt - 0.02\u000a                    bdm_bid.draw()\u000a                elif keyState[key.LEFT]==True and bdm_bid.markerPlacedAt==0.01:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt - 0.01\u000a                    bdm_bid.draw()\u000a                elif keyState[key.RIGHT]==True and bdm_bid.markerPlacedAt <2.99:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt + 0.02\u000a                    bdm_bid.draw()\u000a                elif keyState[key.RIGHT]==True and bdm_bid.markerPlacedAt==2.99:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt + 0.01\u000a                    bdm_bid.draw()\u000a                    \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in bdmComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "bdm"-------\u000a    for thisComponent in bdmComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # store data for bdm (TrialHandler)\u000a    bdm_loop1.addData('bdm_bid1.response', bdm_bid.getRating())\u000a    bdm_loop1.addData('bdm_bid1.rt', bdm_bid.getRT())\u000a    bdm_loop1.addData('bdm_marker_start', bdm_marker_start)\u000a\u000a    # Add the item and the subject's bid to the 'bids' list, which will be merged with the 'prefs' list later in order to run the auction\u000a    bids.append([bdm_img, bdm_bid.response])\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeat of 'bdm_loop1'\u000a\u000a\u000a#------Prepare to start Routine "instr_choice"-------\u000at = 0\u000ainstr_choiceClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_choice_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_choice_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_choiceComponents = []\u000ainstr_choiceComponents.append(instr_choice_txt)\u000ainstr_choiceComponents.append(instr_choice_resp)\u000afor thisComponent in instr_choiceComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_choice"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_choiceClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_choice_txt* updates\u000a    if t >= 0.0 and instr_choice_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_choice_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_choice_txt.frameNStart = frameN  # exact frame index\u000a        instr_choice_txt.setAutoDraw(True)\u000a    \u000a    # *instr_choice_resp* updates\u000a    if t >= 2.0 and instr_choice_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_choice_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_choice_resp.frameNStart = frameN  # exact frame index\u000a        instr_choice_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_choice_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_choice_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space', 's'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_choice_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_choice_resp.rt = instr_choice_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_choiceComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_choice"-------\u000afor thisComponent in instr_choiceComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_choice_resp.keys in ['', [], None]:  # No response was made\u000a   instr_choice_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_choice_resp.keys',instr_choice_resp.keys)\u000aif instr_choice_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_choice_resp.rt', instr_choice_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## BINARY LOOP ##########################\u000a\u000a# set up handler to look after randomisation of conditions etc\u000abinary = data.TrialHandler(nReps=1, method=u'sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(filename+'_choicecond.csv'),\u000a    seed=None, name='binary')\u000athisExp.addLoop(binary)  # add the loop to the experiment\u000athisBinary1 = binary.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBinary1.rgb)\u000aif thisBinary1 != None:\u000a    for paramName in thisBinary1.keys():\u000a        exec(paramName + '= thisBinary1.' + paramName)\u000a\u000a# Check if the 'skip' key was pressed in the instructions routine; if so, end the loop and move on to the BDM\u000aif instr_choice_resp.keys=='s':\u000a    binary.finished = True\u000a\u000afor thisBinary1 in binary:\u000a    currentLoop = binary\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBinary1.rgb)\u000a    if thisBinary1 != None:\u000a        for paramName in thisBinary1.keys():\u000a            exec(paramName + '= thisBinary1.' + paramName)\u000a    \u000a    #------Prepare to start Routine "choice"-------\u000a    t = 0\u000a    choiceClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    choice_pic_left.setImage(dir_path+choice_left)\u000a    choice_pic_right.setImage(dir_path+choice_right)\u000a    event.clearEvents(eventType='keyboard') # Clear keyboard event log to avoid last key press from prior loop being used\u000a    key_resp_choice = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_choice.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    choiceComponents = []\u000a    choiceComponents.append(fixation_text)\u000a    choiceComponents.append(choice_pic_left)\u000a    choiceComponents.append(choice_pic_right)\u000a    choiceComponents.append(key_resp_choice)\u000a    for thisComponent in choiceComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    \u000a    #-------Start Routine "choice"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = choiceClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation_text* updates\u000a        if t >= 0 and fixation_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation_text.tStart = t  # underestimates by a little under one frame\u000a            fixation_text.frameNStart = frameN  # exact frame index\u000a            fixation_text.setAutoDraw(True)\u000a        elif fixation_text.status == STARTED and t>= (0 + (1.0-win.monitorFramePeriod*0.75)):\u000a            fixation_text.setAutoDraw(False)\u000a\u000a        # *choice_pic_left* updates\u000a        if t >= 1.0 and choice_pic_left.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_left.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_left.frameNStart = frameN  # exact frame index\u000a            choice_pic_left.setAutoDraw(True)\u000a        \u000a        # *choice_pic_right* updates\u000a        if t >= 1.0 and choice_pic_right.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_right.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_right.frameNStart = frameN  # exact frame index\u000a            choice_pic_right.setAutoDraw(True)\u000a\u000a        # *key_resp_choice* updates\u000a        if t >= 1.0 and key_resp_choice.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_choice.tStart = t  # underestimates by a little under one frame\u000a            key_resp_choice.frameNStart = frameN  # exact frame index\u000a            key_resp_choice.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_choice.clock.reset()  # now t=0\u000a        if key_resp_choice.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_choice.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_choice.rt = key_resp_choice.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in choiceComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "choice"-------\u000a    for thisComponent in choiceComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_choice.keys in ['', [], None]:  # No response was made\u000a       key_resp_choice.keys=None\u000a    # store data for binary (TrialHandler)\u000a    binary.addData('key_resp_choice.keys',key_resp_choice.keys)\u000a    if key_resp_choice.keys != None:  # we had a response\u000a        binary.addData('key_resp_choice.rt', key_resp_choice.rt)\u000a\u000a    # define a function to append binary choices and the bid for the chosen item to the preference list\u000a    # lft is the left image displayed during that choice trial\u000a    # rt is the right image displayed\u000a    def rec_choice(lft, rt): \u000a        bd = False\u000a        if key_resp_choice.keys=='left':\u000a            chc = lft\u000a        elif key_resp_choice.keys=='right':\u000a            chc = rt\u000a        for x in range(len(bids)):\u000a            if bids[x][0]==chc:\u000a                bd = bids[x][1]\u000a        prefs.append([lft, rt, chc, bd])\u000a\u000a    # call the function\u000a    rec_choice(choice_left, choice_right)\u000a    \u000a\u000a    #------Prepare to start Routine "choice_selection"-------\u000a    t = 0\u000a    choice_selectionClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # keep track of which components have finished\u000a    choice_selectionComponents = []\u000a    choice_selectionComponents.append(choice_pic_left)\u000a    choice_selectionComponents.append(choice_pic_right)\u000a    choice_selectionComponents.append(star_left_selection)\u000a    choice_selectionComponents.append(star_right_selection)\u000a    for thisComponent in choice_selectionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "choice_selection"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = choice_selectionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *choice_pic_left* updates\u000a        if t >= 0.0 and choice_pic_left.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_left.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_left.frameNStart = frameN  # exact frame index\u000a            choice_pic_left.setAutoDraw(True)\u000a        elif choice_pic_left.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            choice_pic_left.setAutoDraw(False)\u000a        \u000a        # *choice_pic_right* updates\u000a        if t >= 0.0 and choice_pic_right.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_right.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_right.frameNStart = frameN  # exact frame index\u000a            choice_pic_right.setAutoDraw(True)\u000a        elif choice_pic_right.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            choice_pic_right.setAutoDraw(False)\u000a        \u000a        # *star_left_selection* updates\u000a        if key_resp_choice.keys=='left':\u000a            if t >= 0.0 and star_left_selection.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                star_left_selection.tStart = t  # underestimates by a little under one frame\u000a                star_left_selection.frameNStart = frameN  # exact frame index\u000a                star_left_selection.setAutoDraw(True)\u000a            elif star_left_selection.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                star_left_selection.setAutoDraw(False)\u000a        \u000a        # *star_right_selection* updates\u000a        if key_resp_choice.keys=='right':\u000a            if t >= 0.0 and star_right_selection.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                star_right_selection.tStart = t  # underestimates by a little under one frame\u000a                star_right_selection.frameNStart = frameN  # exact frame index\u000a                star_right_selection.setAutoDraw(True)\u000a            elif star_right_selection.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                star_right_selection.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in choice_selectionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "choice_selection"-------\u000a    for thisComponent in choice_selectionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    #thisExp.nextEntry()\u000a\u000a    #------Prepare to start Routine "confidence"-------\u000a    t = 0\u000a    confidenceClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    confidence_rating.reset()\u000a    # jitter the starting position of the confidence rating scale from a uniform distribution between 1.7 and 3.3 (the middle third of the scale), rounded to the nearest decimal place\u000a    confidence_marker_start = float(np.round(np.random.uniform(1.7, 3.3, 1)[0], 1))\u000a    confidence_rating.setMarkerPos(confidence_marker_start)\u000a    # keep track of which components have finished\u000a    confidenceComponents = []\u000a    confidenceComponents.append(confidence_rating)\u000a    for thisComponent in confidenceComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "confidence"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = confidenceClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *confidence_rating* updates\u000a        if t > 0.5:\u000a            confidence_rating.draw()\u000a            continueRoutine = confidence_rating.noResponse\u000a            if confidence_rating.noResponse == False:\u000a                confidence_rating.response = confidence_rating.getRating()\u000a                confidence_rating.rt = confidence_rating.getRT()\u000a            elif confidence_rating.noResponse==True:\u000a                if keyState[key.LEFT]==True and confidence_rating.markerPlacedAt >0:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt - 0.1\u000a                    confidence_rating.draw()\u000a                elif keyState[key.LEFT]==True and confidence_rating.markerPlacedAt==0.1:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt - 0.1\u000a                    confidence_rating.draw()\u000a                elif keyState[key.RIGHT]==True and confidence_rating.markerPlacedAt <4.9:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt + 0.1\u000a                    confidence_rating.draw()\u000a                elif keyState[key.RIGHT]==True and confidence_rating.markerPlacedAt==4.9:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt + 0.1\u000a                    confidence_rating.draw()\u000a                    \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in confidenceComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "confidence"-------\u000a    for thisComponent in confidenceComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # store data for confidence (TrialHandler)\u000a    binary.addData('confidence_rating1.response', confidence_rating.getRating())\u000a    binary.addData('confidence_rating1.rt', confidence_rating.getRT())\u000a    binary.addData('confidence_marker_start', confidence_marker_start+1) # Add 1 to convert from 0-5 to 1-6 scale\u000a\u000a    thisExp.nextEntry()\u000a\u000a\u000a# completed 1 repeat of 'binary'        \u000a\u000a#------Prepare to start Routine "instr_infer_intro"-------\u000at = 0\u000ainstr_infer_introClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_infer_intro_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_infer_intro_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_infer_introComponents = []\u000ainstr_infer_introComponents.append(instr_infer_intro_txt)\u000ainstr_infer_introComponents.append(instr_infer_intro_resp)\u000afor thisComponent in instr_infer_introComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_infer_intro"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_infer_introClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_infer_intro_txt* updates\u000a    if t >= 0.0 and instr_infer_intro_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_intro_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_intro_txt.frameNStart = frameN  # exact frame index\u000a        instr_infer_intro_txt.setAutoDraw(True)\u000a    \u000a    # *instr_infer_intro_resp* updates\u000a    if t >= 5.0 and instr_infer_intro_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_intro_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_intro_resp.frameNStart = frameN  # exact frame index\u000a        instr_infer_intro_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_infer_intro_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_infer_intro_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_infer_intro_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_infer_intro_resp.rt = instr_infer_intro_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_infer_introComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_infer_intro"-------\u000afor thisComponent in instr_infer_introComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_infer_intro_resp.keys in ['', [], None]:  # No response was made\u000a   instr_infer_intro_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_infer_intro_resp.keys',instr_infer_intro_resp.keys)\u000aif instr_infer_intro_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_infer_intro_resp.rt', instr_infer_intro_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a#------Prepare to start Routine "instr_infer_practice"-------\u000at = 0\u000ainstr_infer_practiceClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_infer_practice_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_infer_practice_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_infer_practiceComponents = []\u000ainstr_infer_practiceComponents.append(instr_infer_practice_txt)\u000ainstr_infer_practiceComponents.append(instr_infer_practice_resp)\u000afor thisComponent in instr_infer_practiceComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_infer_practice"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_infer_practiceClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_infer_practice_txt* updates\u000a    if t >= 0.0 and instr_infer_practice_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_practice_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_practice_txt.frameNStart = frameN  # exact frame index\u000a        instr_infer_practice_txt.setAutoDraw(True)\u000a    \u000a    # *instr_infer_practice_resp* updates\u000a    if t >= 5.0 and instr_infer_practice_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_practice_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_practice_resp.frameNStart = frameN  # exact frame index\u000a        instr_infer_practice_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_infer_practice_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_infer_practice_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_infer_practice_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_infer_practice_resp.rt = instr_infer_practice_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_infer_practiceComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_infer_practice"-------\u000afor thisComponent in instr_infer_practiceComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_infer_practice_resp.keys in ['', [], None]:  # No response was made\u000a   instr_infer_practice_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_infer_practice_resp.keys',instr_infer_practice_resp.keys)\u000aif instr_infer_practice_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_infer_practice_resp.rt', instr_infer_practice_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## PRACTICE LOOP ##########################\u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_loop = data.TrialHandler(nReps=1, method=u'sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(filename+'_practicecond.csv'),\u000a    seed=None, name='practice_loop')\u000athisExp.addLoop(practice_loop)  # add the loop to the experiment\u000athisPractice_loop = practice_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_loop.rgb)\u000aif thisPractice_loop != None:\u000a    for paramName in thisPractice_loop.keys():\u000a        exec(paramName + '= thisPractice_loop.' + paramName)\u000a\u000a  \u000afor thisPractice_loop in practice_loop:\u000a    currentLoop = practice_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_loop.rgb)\u000a    if thisPractice_loop != None:\u000a        for paramName in thisPractice_loop.keys():\u000a            exec(paramName + '= thisPractice_loop.' + paramName)    \u000a    \u000a        \u000a    # Define class for setting the feedback image\u000a    class set_feedback:\u000a        options = ['correct', 'wrong']\u000a        feedback = np.random.choice(options, replace=True, p=[0.8, 0.2])\u000a        if feedback=='correct':\u000a            feedback_img = img_correct\u000a        elif feedback=='wrong':\u000a            feedback_img = img_wrong\u000a\u000a        if feedback_img==img_left:\u000a            feedback_side = 'left'\u000a        elif feedback_img==img_right:\u000a            feedback_side = 'right'\u000a\u000a\u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialtime = datetime.datetime.now()\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    img_left_infer.setImage(dir_path+img_left)\u000a    img_right_infer.setImage(dir_path+img_right)\u000a    infer_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    infer_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(fixation_text)\u000a    trialComponents.append(img_left_infer)\u000a    trialComponents.append(img_right_infer)\u000a    trialComponents.append(infer_resp)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation_text* updates\u000a        if t >= 0 and fixation_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation_text.tStart = t  # underestimates by a little under one frame\u000a            fixation_text.frameNStart = frameN  # exact frame index\u000a            fixation_text.setAutoDraw(True)\u000a        elif fixation_text.status == STARTED and t>= (0 + (2.0-win.monitorFramePeriod*0.75)):\u000a            fixation_text.setAutoDraw(False)\u000a\u000a        # *img_left_infer* updates\u000a        if t >= 2.0 and img_left_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_left_infer.tStart = t  # underestimates by a little under one frame\u000a            img_left_infer.frameNStart = frameN  # exact frame index\u000a            img_left_infer.setAutoDraw(True)\u000a        \u000a        # *img_right_infer* updates\u000a        if t >= 2.0 and img_right_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_right_infer.tStart = t  # underestimates by a little under one frame\u000a            img_right_infer.frameNStart = frameN  # exact frame index\u000a            img_right_infer.setAutoDraw(True)\u000a                  \u000a        # *infer_resp* updates\u000a        if t >= 2.0 and infer_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            infer_resp.tStart = t  # underestimates by a little under one frame\u000a            infer_resp.frameNStart = frameN  # exact frame index\u000a            infer_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            infer_resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if infer_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                infer_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                infer_resp.rt = infer_resp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a\u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if infer_resp.keys in ['', [], None]:  # No response was made\u000a       infer_resp.keys=None\u000a    # # store data for practice_loop (TrialHandler)\u000a    # practice_loop.addData('infer_resp.keys',infer_resp.keys)\u000a    # if infer_resp.keys != None:  # we had a response\u000a    #     practice_loop.addData('infer_resp.rt', infer_resp.rt)\u000a    practice_loop.addData('set_feedback.feedback_img', set_feedback.feedback_img)\u000a    practice_loop.addData('trial_start_time', trialtime)\u000a    \u000a    # # Increase correct and incorrect response counters by 1 based on S's response\u000a    # if infer_resp.keys=='left' and img_correct==img_left:\u000a    #     correct_counter += 1\u000a    # elif infer_resp.keys=='left' and img_correct==img_right:\u000a    #     incorrect_counter += 1\u000a    # elif infer_resp.keys=='right' and img_correct==img_right:\u000a    #     correct_counter += 1\u000a    # elif infer_resp.keys=='right' and img_correct==img_left:\u000a    #     incorrect_counter += 1\u000a    \u000a\u000a    #------Prepare to start Routine "trial_post_response"-------\u000a    t = 0\u000a    trial_post_responseClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(3.000000)\u000a    # keep track of which components have finished\u000a    trial_post_responseComponents = []\u000a    trial_post_responseComponents.append(img_left_infer)\u000a    trial_post_responseComponents.append(img_right_infer)\u000a    trial_post_responseComponents.append(selection_arrow_left)\u000a    trial_post_responseComponents.append(selection_arrow_right)\u000a    trial_post_responseComponents.append(feedback_box_left)\u000a    trial_post_responseComponents.append(feedback_box_right)\u000a    for thisComponent in trial_post_responseComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial_post_response"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = trial_post_responseClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a\u000a        # *img_left_infer* updates\u000a        if t >= 0.0 and img_left_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_left_infer.tStart = t  # underestimates by a little under one frame\u000a            img_left_infer.frameNStart = frameN  # exact frame index\u000a            img_left_infer.setAutoDraw(True)\u000a        elif img_left_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            img_left_infer.setAutoDraw(False)\u000a        \u000a        # *img_right_infer* updates\u000a        if t >= 0.0 and img_right_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_right_infer.tStart = t  # underestimates by a little under one frame\u000a            img_right_infer.frameNStart = frameN  # exact frame index\u000a            img_right_infer.setAutoDraw(True)\u000a        elif img_right_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            img_right_infer.setAutoDraw(False)\u000a        \u000a        if infer_resp.keys == 'left':\u000a            # *selection_arrow_left* updates\u000a            if t >= 0.0 and selection_arrow_left.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                selection_arrow_left.tStart = t  # underestimates by a little under one frame\u000a                selection_arrow_left.frameNStart = frameN  # exact frame index\u000a                selection_arrow_left.setAutoDraw(True)\u000a            elif selection_arrow_left.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                selection_arrow_left.setAutoDraw(False)\u000a        \u000a        if infer_resp.keys == 'right':\u000a            # *selection_arrow_right* updates\u000a            if t >= 0.0 and selection_arrow_right.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                selection_arrow_right.tStart = t  # underestimates by a little under one frame\u000a                selection_arrow_right.frameNStart = frameN  # exact frame index\u000a                selection_arrow_right.setAutoDraw(True)\u000a            elif selection_arrow_right.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                selection_arrow_right.setAutoDraw(False)\u000a        \u000a        if set_feedback.feedback_side == 'left':\u000a            # *feedback_box_left* updates\u000a            if t >= 1.0 and feedback_box_left.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                feedback_box_left.tStart = t  # underestimates by a little under one frame\u000a                feedback_box_left.frameNStart = frameN  # exact frame index\u000a                feedback_box_left.setAutoDraw(True)\u000a            elif feedback_box_left.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                feedback_box_left.setAutoDraw(False)\u000a        \u000a        if set_feedback.feedback_side == 'right':\u000a            # *feedback_box_right* updates\u000a            if t >= 1.0 and feedback_box_right.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                feedback_box_right.tStart = t  # underestimates by a little under one frame\u000a                feedback_box_right.frameNStart = frameN  # exact frame index\u000a                feedback_box_right.setAutoDraw(True)\u000a            elif feedback_box_right.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period right\u000a                feedback_box_right.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trial_post_responseComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "trial_post_response"-------\u000a    for thisComponent in trial_post_responseComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000a    \u000a    thisExp.nextEntry()\u000a                        \u000a# completed 1 repeat of 'practice_loop'\u000a\u000a\u000a#------Prepare to start Routine "instr_infer"-------\u000at = 0\u000ainstr_inferClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_infer_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_infer_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_inferComponents = []\u000ainstr_inferComponents.append(instr_infer_txt)\u000ainstr_inferComponents.append(instr_infer_resp)\u000afor thisComponent in instr_inferComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_infer"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_inferClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_infer_txt* updates\u000a    if t >= 0.0 and instr_infer_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_txt.frameNStart = frameN  # exact frame index\u000a        instr_infer_txt.setAutoDraw(True)\u000a    \u000a    # *instr_infer_resp* updates\u000a    if t >= 5.0 and instr_infer_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_resp.frameNStart = frameN  # exact frame index\u000a        instr_infer_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_infer_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_infer_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_infer_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_infer_resp.rt = instr_infer_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_inferComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_infer"-------\u000afor thisComponent in instr_inferComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_infer_resp.keys in ['', [], None]:  # No response was made\u000a   instr_infer_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_infer_resp.keys',instr_infer_resp.keys)\u000aif instr_infer_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_infer_resp.rt', instr_infer_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## BLOCK LOOP ##########################\u000a\u000a# This loop runs a second nested loop that shows each item pair 10 times, followed by a rest break prompt.\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=3, method=u'sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=[None],\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000a# Set up counter to keep track of block loop cycle, so that the rest prompt is only shown twice\u000ablock_loop_counter = 0\u000a\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    # Increase loop counter by one\u000a    block_loop_counter += 1\u000a    \u000a    # Change the condition file for the feedback block based on which block loop we're on\u000a    condfilename = filename+u'_block'+str(block_loop_counter)+u'cond.csv'\u000a    \u000a    # # Minimize the psychopy window so the calibration window can be seen\u000a    # win.winHandle.minimize()\u000a    # #Do the eye tracker setup at the beginning of each block\u000a    # tracker.runSetupProcedure()\u000a    # # Re-display the psychopy window after setup is completed\u000a    # win.winHandle.maximize()\u000a    # win.winHandle.activate()\u000a    \u000a\u000a    \u000a    #------Prepare to start Routine "get_ready"-------\u000a    t = 0\u000a    get_readyClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(3.000000)\u000a    # update component parameters for each repeat\u000a    get_ready_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    get_ready_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    get_readyComponents = []\u000a    get_readyComponents.append(get_ready_text)\u000a    get_readyComponents.append(get_ready_resp)\u000a    for thisComponent in get_readyComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    \u000a    #-------Start Routine "get_ready"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = get_readyClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *get_ready_text* updates\u000a        if t >= 0.0 and get_ready_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            get_ready_text.tStart = t  # underestimates by a little under one frame\u000a            get_ready_text.frameNStart = frameN  # exact frame index\u000a            get_ready_text.setAutoDraw(True)\u000a        \u000a        # *get_ready_resp* updates\u000a        if t >= 0.0 and get_ready_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            get_ready_resp.tStart = t  # underestimates by a little under one frame\u000a            get_ready_resp.frameNStart = frameN  # exact frame index\u000a            get_ready_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            get_ready_resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if get_ready_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['p'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                get_ready_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                get_ready_resp.rt = get_ready_resp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in get_readyComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "get_ready"-------\u000a    for thisComponent in get_readyComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if get_ready_resp.keys in ['', [], None]:  # No response was made\u000a       get_ready_resp.keys=None\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('get_ready_resp.keys',get_ready_resp.keys)\u000a    if get_ready_resp.keys != None:  # we had a response\u000a        thisExp.addData('get_ready_resp.rt', get_ready_resp.rt)\u000a    thisExp.nextEntry()\u000a\u000a    ######################## TRIAL LOOP ##########################\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    trial_loop = data.TrialHandler(nReps=1, method=u'sequential', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(condfilename),\u000a        seed=None, name='trial_loop')\u000a    thisExp.addLoop(trial_loop)  # add the loop to the experiment\u000a    thisTrial_loop = trial_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_loop.rgb)\u000a    if thisTrial_loop != None:\u000a        for paramName in thisTrial_loop.keys():\u000a            exec(paramName + '= thisTrial_loop.' + paramName)\u000a    \u000a      \u000a    for thisTrial_loop in trial_loop:\u000a        currentLoop = trial_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_loop.rgb)\u000a        if thisTrial_loop != None:\u000a            for paramName in thisTrial_loop.keys():\u000a                exec(paramName + '= thisTrial_loop.' + paramName)    \u000a        \u000a            \u000a        # Define class for setting the feedback image\u000a        class set_feedback:\u000a            options = ['correct', 'wrong']\u000a            feedback = np.random.choice(options, replace=True, p=[0.8, 0.2])\u000a            if feedback=='correct':\u000a                feedback_img = img_correct\u000a            elif feedback=='wrong':\u000a                feedback_img = img_wrong\u000a\u000a            if feedback_img==img_left:\u000a                feedback_side = 'left'\u000a            elif feedback_img==img_right:\u000a                feedback_side = 'right'\u000a                        \u000a        # # Start getting data from the eye tracker\u000a        # tracker.enableEventReporting(True)\u000a        # # Send beginning-of-trial messages to eye tracker data file\u000a        # trial_number = (block_loop.thisN * 200) + trial_loop.thisTrialN # Trial number out of 599 (starts at 0)\u000a        # tracker.sendCommand("record_status_message 'INFERRING, Block %d/3, Trial %d/600 '" % (block_loop.thisN + 1, trial_number + 1))\u000a        # tracker.sendMessage("TRIALID %d" % trial_number)\u000a        # tracker.sendMessage("!V TRIAL_VAR_DATA %d" % trial_number)\u000a\u000a        \u000a        #------Prepare to start Routine "trial"-------\u000a        t = 0\u000a        trialtime = datetime.datetime.now()\u000a        trialClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        img_left_infer.setImage(dir_path+img_left)\u000a        img_right_infer.setImage(dir_path+img_right)\u000a        infer_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        infer_resp.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trialComponents = []\u000a        trialComponents.append(fixation_text)\u000a        trialComponents.append(img_left_infer)\u000a        trialComponents.append(img_right_infer)\u000a        trialComponents.append(infer_resp)\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        # Set indicator variable for whether eye tracker messages were sent during the first loop of the routine\u000a        eye_sync_messages_sent = 0\u000a        \u000a        #-------Start Routine "trial"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = trialClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *fixation_text* updates\u000a            if t >= 0 and fixation_text.status == NOT_STARTED:\u000a                if eye_sync_messages_sent==0:\u000a                    startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                # keep track of start time/frame for later\u000a                fixation_text.tStart = t  # underestimates by a little under one frame\u000a                fixation_text.frameNStart = frameN  # exact frame index\u000a                fixation_text.setAutoDraw(True)\u000a                if eye_sync_messages_sent==0:\u000a                    drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                    # tracker.sendMessage("%d DISPLAY ON" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                    # tracker.sendMessage("SYNCTIME %d" %drawTime)\u000a                    eye_sync_messages_sent = 1\u000a            elif fixation_text.status == STARTED and t>= (0 + (2.0-win.monitorFramePeriod*0.75)):\u000a                fixation_text.setAutoDraw(False)\u000a            \u000a            # *img_left_infer* updates\u000a            if t >= 2.0 and img_left_infer.status == NOT_STARTED:\u000a                if eye_sync_messages_sent==1:\u000a                    startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                # keep track of start time/frame for later\u000a                img_left_infer.tStart = t  # underestimates by a little under one frame\u000a                img_left_infer.frameNStart = frameN  # exact frame index\u000a                img_left_infer.setAutoDraw(True)\u000a            \u000a            # *img_right_infer* updates\u000a            if t >= 2.0 and img_right_infer.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                img_right_infer.tStart = t  # underestimates by a little under one frame\u000a                img_right_infer.frameNStart = frameN  # exact frame index\u000a                img_right_infer.setAutoDraw(True)\u000a                if eye_sync_messages_sent==1:\u000a                    drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                    # tracker.sendMessage("%d DISPLAY ON ITEMS" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                    eye_sync_messages_sent = 2\u000a                      \u000a            # *infer_resp* updates\u000a            if t >= 2.0 and infer_resp.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                infer_resp.tStart = t  # underestimates by a little under one frame\u000a                infer_resp.frameNStart = frameN  # exact frame index\u000a                infer_resp.status = STARTED\u000a                # keyboard checking is just starting\u000a                infer_resp.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            if infer_resp.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['left', 'right'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    infer_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                    infer_resp.rt = infer_resp.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trialComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                # tracker.enableEventReporting(False) # End eye tracker data recording\u000a                # tracker.sendMessage("EXPERIMENT ABORTED")\u000a                # io.quit() # Close iohub\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial"-------\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if infer_resp.keys in ['', [], None]:  # No response was made\u000a           infer_resp.keys=None\u000a        # store data for trial_loop (TrialHandler)\u000a        trial_loop.addData('infer_resp.keys',infer_resp.keys)\u000a        if infer_resp.keys != None:  # we had a response\u000a            trial_loop.addData('infer_resp.rt', infer_resp.rt)\u000a        trial_loop.addData('set_feedback.feedback_img', set_feedback.feedback_img)\u000a        trial_loop.addData('trial_start_time', trialtime)\u000a        \u000a        # Increase correct and incorrect response counters by 1 based on S's response\u000a        if infer_resp.keys=='left' and img_correct==img_left:\u000a            correct_counter += 1\u000a        elif infer_resp.keys=='left' and img_correct==img_right:\u000a            incorrect_counter += 1\u000a        elif infer_resp.keys=='right' and img_correct==img_right:\u000a            correct_counter += 1\u000a        elif infer_resp.keys=='right' and img_correct==img_left:\u000a            incorrect_counter += 1\u000a        \u000a\u000a        #------Prepare to start Routine "trial_post_response"-------\u000a        t = 0\u000a        trial_post_responseClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(3.000000)\u000a        # keep track of which components have finished\u000a        trial_post_responseComponents = []\u000a        trial_post_responseComponents.append(img_left_infer)\u000a        trial_post_responseComponents.append(img_right_infer)\u000a        trial_post_responseComponents.append(selection_arrow_left)\u000a        trial_post_responseComponents.append(selection_arrow_right)\u000a        trial_post_responseComponents.append(feedback_box_left)\u000a        trial_post_responseComponents.append(feedback_box_right)\u000a        for thisComponent in trial_post_responseComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        # Set indicator variable for whether eye tracker messages were sent during the first loop of the routine\u000a        eye_sync_messages_sent = 0\u000a\u000a        #-------Start Routine "trial_post_response"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = trial_post_responseClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a\u000a            # *img_left_infer* updates\u000a            if t >= 0.0 and img_left_infer.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                img_left_infer.tStart = t  # underestimates by a little under one frame\u000a                img_left_infer.frameNStart = frameN  # exact frame index\u000a                img_left_infer.setAutoDraw(True)\u000a            elif img_left_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                img_left_infer.setAutoDraw(False)\u000a            \u000a            # *img_right_infer* updates\u000a            if t >= 0.0 and img_right_infer.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                img_right_infer.tStart = t  # underestimates by a little under one frame\u000a                img_right_infer.frameNStart = frameN  # exact frame index\u000a                img_right_infer.setAutoDraw(True)\u000a            elif img_right_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                img_right_infer.setAutoDraw(False)\u000a            \u000a            if infer_resp.keys == 'left':\u000a                # *selection_arrow_left* updates\u000a                if t >= 0.0 and selection_arrow_left.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==0:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    selection_arrow_left.tStart = t  # underestimates by a little under one frame\u000a                    selection_arrow_left.frameNStart = frameN  # exact frame index\u000a                    selection_arrow_left.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==0:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        # tracker.sendMessage("%d DISPLAY ON SELECTION" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 1\u000a                elif selection_arrow_left.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    if eye_sync_messages_sent==1:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    selection_arrow_left.setAutoDraw(False)\u000a                    if eye_sync_messages_sent==1:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        # tracker.sendMessage("%d DISPLAY ON SELECTION OFF" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 2\u000a            \u000a            if infer_resp.keys == 'right':\u000a                # *selection_arrow_right* updates\u000a                if t >= 0.0 and selection_arrow_right.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==0:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    selection_arrow_right.tStart = t  # underestimates by a little under one frame\u000a                    selection_arrow_right.frameNStart = frameN  # exact frame index\u000a                    selection_arrow_right.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==0:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        # tracker.sendMessage("%d DISPLAY ON SELECTION" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 1\u000a                elif selection_arrow_right.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    if eye_sync_messages_sent==1:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    selection_arrow_right.setAutoDraw(False)\u000a                    if eye_sync_messages_sent==1:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        # tracker.sendMessage("%d DISPLAY ON SELECTION OFF" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 2\u000a            \u000a            if set_feedback.feedback_side == 'left':\u000a                # *feedback_box_left* updates\u000a                if t >= 1.0 and feedback_box_left.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==2:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    feedback_box_left.tStart = t  # underestimates by a little under one frame\u000a                    feedback_box_left.frameNStart = frameN  # exact frame index\u000a                    feedback_box_left.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==2:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        # tracker.sendMessage("%d DISPLAY ON FEEDBACK" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 3\u000a                elif feedback_box_left.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    feedback_box_left.setAutoDraw(False)\u000a            \u000a            if set_feedback.feedback_side == 'right':\u000a                # *feedback_box_right* updates\u000a                if t >= 1.0 and feedback_box_right.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==2:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    feedback_box_right.tStart = t  # underestimates by a little under one frame\u000a                    feedback_box_right.frameNStart = frameN  # exact frame index\u000a                    feedback_box_right.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==2:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        # tracker.sendMessage("%d DISPLAY ON FEEDBACK" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 3\u000a                elif feedback_box_right.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period right\u000a                    feedback_box_right.setAutoDraw(False)\u000a\u000a\u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial_post_responseComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                # tracker.enableEventReporting(False) # End eye tracker data recording\u000a                # tracker.sendMessage("EXPERIMENT ABORTED")\u000a                # io.quit() # Close iohub\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "trial_post_response"-------\u000a        for thisComponent in trial_post_responseComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a        thisExp.nextEntry()\u000a                            \u000a    # completed 5 repeats of 'trial_loop'\u000a    \u000a    if block_loop_counter <= 2: # If this is the first or second cycle of the loop, display the rest break prompt\u000a\u000a        #------Prepare to start Routine "rest_prompt"-------\u000a        t = 0\u000a        rest_promptClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        rest_prompt_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        rest_prompt_resp.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        rest_promptComponents = []\u000a        rest_promptComponents.append(rest_prompt_txt)\u000a        rest_promptComponents.append(rest_prompt_resp)\u000a        for thisComponent in rest_promptComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a\u000a        #-------Start Routine "rest_prompt"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = rest_promptClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *rest_prompt_txt* updates\u000a            if t >= 0.0 and rest_prompt_txt.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                rest_prompt_txt.tStart = t  # underestimates by a little under one frame\u000a                rest_prompt_txt.frameNStart = frameN  # exact frame index\u000a                rest_prompt_txt.setAutoDraw(True)\u000a            \u000a            # *rest_prompt_resp* updates\u000a            if t >= 2.0 and rest_prompt_resp.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                rest_prompt_resp.tStart = t  # underestimates by a little under one frame\u000a                rest_prompt_resp.frameNStart = frameN  # exact frame index\u000a                rest_prompt_resp.status = STARTED\u000a                # keyboard checking is just starting\u000a                rest_prompt_resp.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            if rest_prompt_resp.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    rest_prompt_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                    rest_prompt_resp.rt = rest_prompt_resp.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in rest_promptComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                # tracker.enableEventReporting(False) # End eye tracker data recording\u000a                # tracker.sendMessage("EXPERIMENT ABORTED")\u000a                # io.quit() # CLose iohub\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a\u000a        #-------Ending Routine "rest_prompt"-------\u000a        for thisComponent in rest_promptComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if rest_prompt_resp.keys in ['', [], None]:  # No response was made\u000a           rest_prompt_resp.keys=None\u000a        # store data for thisExp (ExperimentHandler)\u000a        thisExp.addData('rest_prompt_resp.keys',rest_prompt_resp.keys)\u000a        if rest_prompt_resp.keys != None:  # we had a response\u000a            thisExp.addData('rest_prompt_resp.rt', rest_prompt_resp.rt)\u000a\u000a\u000a    thisExp.nextEntry()\u000a    \u000a# completed 3 repeats of 'block_loop'\u000a\u000a\u000a# store data for total number of correct and incorrect responses    \u000athisExp.addData('correct_counter', correct_counter)\u000athisExp.addData('incorrect_counter', incorrect_counter)\u000athisExp.nextEntry()     \u000a\u000a# tracker.setConnectionState(False) # Close and transfer eye-tracking data, then close down eye tracker connection\u000a\u000a\u000a######################## AUCTION ##########################\u000a\u000aif len(prefs)==41 and len(bids)==41: # If S completed the entire binary choice and BDM routines, run the auction\u000a\u000a    # run the auction\u000a    class auction:\u000a        rand_itm = randint(1, (len(prefs))) # pick index for S's chosen item from a random choice\u000a        price = float((randint(1, 300)))/100 # assign a price to the item randomly from between 0.01 and 3 pounds\u000a        bid = prefs[rand_itm][3]\u000a        # check if S's bid for that item was above or below the price\u000a        if bid >= price:\u000a            win_item=True\u000a        elif bid < price:\u000a            win_item=False\u000a\u000a        # set text for the auction screen\u000a        if win_item==True:\u000a            auc_res_txt = u'Congratulations! You won the following item at auction. \u005cnThis was your preferred item out of a randomly selected pair from one of the choice tasks.'\u000a            auc_prc_txt = u'Your bid of \u005cxa3' + '{0:.2f}'.format(bid) + u' matched or exceeded the randomly generated price of \u005cxa3' + '{0:.2f}'.format(price) + '.\u005cn\u005cn[Press space bar to continue]'\u000a            cost = price\u000a        elif win_item==False:\u000a            auc_res_txt = u'Sorry, you did not win the following item at auction. \u005cnThis was your preferred item out of a randomly selected pair from one of the choice tasks.'\u000a            auc_prc_txt = u'Your bid of \u005cxa3' + '{0:.2f}'.format(bid) + u' was lower than the randomly generated price of \u005cxa3' + '{0:.2f}'.format(price) + '.\u005cn\u005cn[Press space bar to continue]'\u000a            cost = 0\u000a\u000a        # find the image path of the auction item\u000a        rand_itm_img = prefs[rand_itm][2]\u000a\u000a    # add up each component of S's payment\u000a    class score:\u000a        base = 25\u000a        rwrd = 0.01\u000a        loss = 0\u000a        rwrd_tot = rwrd * correct_counter\u000a        loss_tot = loss * incorrect_counter\u000a        pre_pymt = base + rwrd_tot - loss_tot\u000a        final_pymt = pre_pymt - auction.cost\u000a\u000a        pymt_expl_bdwn = u'\u005cxa3' + '{0:.2f}'.format(base) + u' base payment'+ u'\u005cn+ \u005cxa3' + '{0:.2f}'.format(rwrd_tot) + ' reward for ' + str(correct_counter) + u' correct responses (\u005cxa3' + '{0:.2f}'.format(rwrd) + u' each)' + u'\u005cn- \u005cxa3' + '{0:.2f}'.format(auction.cost) + ' cost of auction item' \u000a        pymt_expl_tot = u'Your total payment is: \u005cxa3' + '{0:.2f}'.format(final_pymt) + '\u005cn\u005cnThank you for participating!'\u000a\u000a\u000a    # Initialize components for Routine "auc_disp"\u000a    auc_dispClock = core.Clock()\u000a    pic_auc_itm = visual.ImageStim(win=win, name='pic_auc_itm',\u000a        image=dir_path+auction.rand_itm_img, mask=None,\u000a        ori=0, pos=[0, 0], size=None,\u000a        color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a        flipHoriz=False, flipVert=False,\u000a        texRes=128, interpolate=False, depth=0.0)\u000a    auc_txt1 = visual.TextStim(win=win, ori=0, name='auc_txt1',\u000a        text=auction.auc_res_txt, font=u'Arial',\u000a        pos=[0, 0.6], height=0.07, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    auc_txt2 = visual.TextStim(win=win, ori=0, name='auc_txt2',\u000a        text=auction.auc_prc_txt, font=u'Arial',\u000a        pos=[0, -0.6], height=0.07, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a\u000a    #------Prepare to start Routine "auc_disp"-------\u000a    t = 0\u000a    auc_dispClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    key_resp_auc_disp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_auc_disp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    auc_dispComponents = []\u000a    auc_dispComponents.append(pic_auc_itm)\u000a    auc_dispComponents.append(auc_txt1)\u000a    auc_dispComponents.append(auc_txt2)\u000a    for thisComponent in auc_dispComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "auc_disp"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = auc_dispClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *pic_auc_itm* updates\u000a        if t >= 0.2 and pic_auc_itm.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            pic_auc_itm.tStart = t  # underestimates by a little under one frame\u000a            pic_auc_itm.frameNStart = frameN  # exact frame index\u000a            pic_auc_itm.setAutoDraw(True)\u000a        \u000a        # *auc_txt1* updates\u000a        if t >= 0.2 and auc_txt1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            auc_txt1.tStart = t  # underestimates by a little under one frame\u000a            auc_txt1.frameNStart = frameN  # exact frame index\u000a            auc_txt1.setAutoDraw(True)\u000a\u000a        # *auc_txt2* updates\u000a        if t >= 0.2 and auc_txt2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            auc_txt2.tStart = t  # underestimates by a little under one frame\u000a            auc_txt2.frameNStart = frameN  # exact frame index\u000a            auc_txt2.setAutoDraw(True)\u000a        \u000a        # *key_resp_auc_disp* updates\u000a        if t >= 0.2 and key_resp_auc_disp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_auc_disp.tStart = t  # underestimates by a little under one frame\u000a            key_resp_auc_disp.frameNStart = frameN  # exact frame index\u000a            key_resp_auc_disp.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_auc_disp.clock.reset()  # now t=0\u000a        if key_resp_auc_disp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_auc_disp.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_auc_disp.rt = key_resp_auc_disp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in auc_dispComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "auc_disp"-------\u000a    for thisComponent in auc_dispComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_auc_disp.keys in ['', [], None]:  # No response was made\u000a       key_resp_auc_disp.keys=None\u000a    # store data for thisExp (TrialHandler)\u000a    thisExp.addData('auction.win_item', auction.win_item)\u000a    thisExp.addData('auction.price', auction.price)\u000a    thisExp.addData('auction.bid', auction.bid)\u000a    thisExp.addData('auction.rand_itm_img', auction.rand_itm_img)\u000a    thisExp.addData('score.base', score.base)\u000a    thisExp.addData('score.rwrd', score.rwrd)\u000a    thisExp.addData('score.loss', score.loss)\u000a    thisExp.addData('correct_counter', correct_counter)\u000a    thisExp.addData('incorrect_counter', incorrect_counter)\u000a    thisExp.addData('score.final_pymt', score.final_pymt)\u000a    thisExp.nextEntry()\u000a\u000a\u000a    # Initialize components for Routine "pymt_disp"\u000a    pymt_dispClock = core.Clock()\u000a    pymt_disp_txt1 = visual.TextStim(win=win, ori=0, name='pymt_disp_txt1',\u000a        text=score.pymt_expl_bdwn, font=u'Arial',\u000a        pos=[0, 0.6], height=0.07, wrapWidth=1.5,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    pymt_disp_txt2 = visual.TextStim(win=win, ori=0, name='pymt_disp_txt2',\u000a        text=score.pymt_expl_tot, font=u'Arial',\u000a        pos=[0, -0.65], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    #------Prepare to start Routine "pymt_disp"-------\u000a    t = 0\u000a    pymt_dispClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    key_resp_pymt_disp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_pymt_disp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    pymt_dispComponents = []\u000a    pymt_dispComponents.append(pic_auc_itm)\u000a    pymt_dispComponents.append(pymt_disp_txt1)\u000a    pymt_dispComponents.append(pymt_disp_txt2)\u000a    pymt_dispComponents.append(key_resp_pymt_disp)\u000a    for thisComponent in pymt_dispComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "pymt_disp"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = pymt_dispClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        if auction.win_item==True:\u000a            # *pic_auc_itm* updates\u000a            if t >= 0.0 and pic_auc_itm.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                pic_auc_itm.tStart = t  # underestimates by a little under one frame\u000a                pic_auc_itm.frameNStart = frameN  # exact frame index\u000a                pic_auc_itm.setAutoDraw(True)\u000a\u000a        # *pymt_disp_txt1* updates\u000a        if t >= 0.0 and pymt_disp_txt1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            pymt_disp_txt1.tStart = t  # underestimates by a little under one frame\u000a            pymt_disp_txt1.frameNStart = frameN  # exact frame index\u000a            pymt_disp_txt1.setAutoDraw(True)\u000a\u000a        # *pymt_disp_txt2* updates\u000a        if t >= 0.0 and pymt_disp_txt2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            pymt_disp_txt2.tStart = t  # underestimates by a little under one frame\u000a            pymt_disp_txt2.frameNStart = frameN  # exact frame index\u000a            pymt_disp_txt2.setAutoDraw(True)\u000a        \u000a        # *key_resp_pymt_disp* updates\u000a        if t >= 3.0 and key_resp_pymt_disp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_pymt_disp.tStart = t  # underestimates by a little under one frame\u000a            key_resp_pymt_disp.frameNStart = frameN  # exact frame index\u000a            key_resp_pymt_disp.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_pymt_disp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if key_resp_pymt_disp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_pymt_disp.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_pymt_disp.rt = key_resp_pymt_disp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in pymt_dispComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "pymt_disp"-------\u000a    for thisComponent in pymt_dispComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_pymt_disp.keys in ['', [], None]:  # No response was made\u000a       key_resp_pymt_disp.keys=None\u000a\u000aelse: # If S didn't complete the entire binary choice and BDM routines during this session, prompt a manual auction\u000a    # Initialize components for Routine "auc_manual"\u000a    auc_manualClock = core.Clock()\u000a    auc_manual_txt = visual.TextStim(win=win, ori=0, name='auc_manual_txt',\u000a        text=u'Thank you! This completes the experiment. The experimenter will now run the auction and calculate your final payment.\u005cn\u005cnCorrect: ' + str(correct_counter) + '\u005cnIncorrect: ' + str(incorrect_counter),    font=u'Arial',\u000a        pos=[0, 0], height=0.07, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    #------Prepare to start Routine "auc_manual"-------\u000a    t = 0\u000a    auc_manualClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    auc_manualComponents = []\u000a    auc_manualComponents.append(auc_manual_txt)\u000a    for thisComponent in auc_manualComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "auc_manual"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = auc_manualClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *auc_manual_txt* updates\u000a        if t >= 0.0 and auc_manual_txt.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            auc_manual_txt.tStart = t  # underestimates by a little under one frame\u000a            auc_manual_txt.frameNStart = frameN  # exact frame index\u000a            auc_manual_txt.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in auc_manualComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "auc_manual"-------\u000a    for thisComponent in auc_manualComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000athisExp.nextEntry()\u000a\u000a# io.quit() # Close iohub\u000a\u000a\u000awin.close()\u000acore.quit()\u000a
p9106
sS'thisTrial'
p9107
(lp9108
sS'_exp'
p9109
I85328720
sg10
S'bdm_loop1'
p9110
sg6
S'C:\\DATA\\bdm\\tor\\inferring_intentions_task\\task_code\\infer_design1_no_eyetracking.py'
p9111
sS'thisRepN'
p9112
I1
sg52
I01
sg53
g54
sS'data'
p9113
g1
(cpsychopy.data
DataHandler
p9114
c__builtin__
dict
p9115
(dp9116
S'ran'
p9117
cnumpy.ma.core
_mareconstruct
p9118
(cnumpy.ma.core
MaskedArray
p9119
g92
(I0
tp9120
S'b'
tRp9121
(I1
(I40
I1
tg60
(S'f4'
I0
I1
tRp9122
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
g9118
(g9119
g92
g9120
S'b'
tRp9123
(I1
(I40
I1
tg9122
I00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\n\xd7#>\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xcd\xcc\xcc=\x00\x00\x00\x00\xaeG\xe1>\n\xd7#=\x8f\xc2\xf5=\x8f\xc2u=\x00\x00\x00\x00\x00\x00\x00\x00\xcd\xccL>\x00\x00\x00\x00\x00\x00\xc0?\x00\x00\x00\x00\x00\x00\x00\x00\x8f\xc2\xf5=\x00\x00\x00\x00\xecQ\xb8>\x00\x00\x00\x00\x00\x00\x00\x00)\\\x0f>\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00)\\\x0f?\x00\x00\x00\x00\n\xd7\xa3=\x00\x00\x00\x00\xecQ8>'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg20
g9118
(g9119
g92
g9120
S'b'
tRp9124
(I1
(I40
I1
tg9122
I00
S"1\x08\xc8@\xee|'@\xee|7@B`5@\x87\x16\xb1@\xbaI\xcc@\x87\x16A@u\x93H@!\xb0\xba@\xfe\xd4\xdc@\xee|'@\xfc\xa9I@ff\xb8A\x10X\xdd@33#@1\x08\xe8@1\x08\xb0@\x98n\x8e@\xaa\xf1\x8e@!\xb0\x1a@\x96C#@D\x8b\xb0@T\xe3=@\x08\xac:A\xbaIt@\xfc\xa99@1\x08\xb0@\x04V6@w\xbe\x0fAm\xe7\x01A!\xb0j@\xd5x\x03A\xc9v6@u\x93H@!\xb0\n@\xaa\xf1\xe6@B`e@\xfe\xd4\xf4@\xbaI\x04@!\xb0\xaa@"
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbsS'order'
p9125
g9118
(g9119
g92
g9120
S'b'
tRp9126
(I1
(I40
I1
tg9122
I00
S'\x00\x00\xe0@\x00\x00\xa0@\x00\x00\x80@\x00\x00\xc0@\x00\x00\x88A\x00\x00\x00\x00\x00\x00\xe0A\x00\x00\xf8A\x00\x00\xa8A\x00\x00\xa0A\x00\x00\x08B\x00\x00\x90A\x00\x00@@\x00\x00\xb8A\x00\x00\xc8A\x00\x00\xf0A\x00\x00\x18B\x00\x00\x04B\x00\x00PA\x00\x00@A\x00\x00\x80A\x00\x00\x14B\x00\x00\x00@\x00\x00\xb0A\x00\x00\x10A\x00\x00\x80?\x00\x00\x1cB\x00\x00`A\x00\x00\xd0A\x00\x00pA\x00\x00\x00A\x00\x00\x00B\x00\x00\xd8A\x00\x000A\x00\x00\x0cB\x00\x00\xc0A\x00\x00 A\x00\x00\x98A\x00\x00\xe8A\x00\x00\x10B'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg21
g9118
(g9119
g92
g9120
S'b'
tRp9127
(I1
(I40
I1
tg9122
I00
S'ff\xa6?ff\xa6?\xcd\xcc\xcc?ff\xe6?33\xf3?\x00\x00\xc0?\x00\x00\x80?\x00\x00\x00@\xcd\xcc\xcc?\xcd\xcc\xcc?\xcd\xcc\xcc?\x00\x00\x00@ff\xe6?\x9a\x99\xd9?ff\xa6?\x00\x00\x80?\x00\x00\xc0?\xcd\xcc\xcc?\xcd\xcc\x8c?\xcd\xcc\x8c?33\xb3?ff\xe6?\x00\x00\x00@\x9a\x99\x99?\xcd\xcc\xcc?\x9a\x99\x99?\x00\x00\xc0?\xcd\xcc\xcc?\xcd\xcc\x8c?33\xb3?33\xf3?\x00\x00\x80?\x9a\x99\xd9?ff\xa6?ff\xa6?\x00\x00\xc0?\x9a\x99\xd9?\x00\x00\xc0?\x00\x00\x80?\x9a\x99\xd9?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp9128
(dp9129
S'isNumeric'
p9130
(dp9131
g9117
I01
sg19
I01
sg20
I01
sg9125
I01
sg21
I01
ssS'trials'
p9132
g9103
sS'dataTypes'
p9133
(lp9134
g9117
ag9125
ag19
ag20
ag21
asS'dataShape'
p9135
(lp9136
I40
aI1
asbsS'method'
p9137
Vrandom
p9138
sS'sequenceIndices'
p9139
g91
(g92
(I0
tS'b'
tRp9140
(I1
(I40
I1
tg98
I01
S'\x05\x00\x00\x00\x19\x00\x00\x00\x16\x00\x00\x00\x0c\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x1e\x00\x00\x00\x18\x00\x00\x00$\x00\x00\x00!\x00\x00\x00\x13\x00\x00\x00\x12\x00\x00\x00\x1b\x00\x00\x00\x1d\x00\x00\x00\x14\x00\x00\x00\x04\x00\x00\x00\x0b\x00\x00\x00%\x00\x00\x00\t\x00\x00\x00\x08\x00\x00\x00\x17\x00\x00\x00\r\x00\x00\x00#\x00\x00\x00\x0e\x00\x00\x00\x1c\x00\x00\x00 \x00\x00\x00\x06\x00\x00\x00&\x00\x00\x00\x0f\x00\x00\x00\x07\x00\x00\x00\x1f\x00\x00\x00\x11\x00\x00\x00\n\x00\x00\x00"\x00\x00\x00\'\x00\x00\x00\x15\x00\x00\x00\x10\x00\x00\x00\x1a\x00\x00\x00'
tbsS'finished'
p9141
I01
sS'nReps'
p9142
I1
sS'nRemaining'
p9143
I-1
sS'trialList'
p9144
(lp9145
g1
(cpsychopy.data
TrialType
p9146
g9115
(dp9147
g78
g151
stRp9148
ag1
(g9146
g9115
(dp9149
g78
g137
stRp9150
ag1
(g9146
g9115
(dp9151
g78
g130
stRp9152
ag1
(g9146
g9115
(dp9153
g78
g144
stRp9154
ag1
(g9146
g9115
(dp9155
g78
g221
stRp9156
ag1
(g9146
g9115
(dp9157
g78
g102
stRp9158
ag1
(g9146
g9115
(dp9159
g78
g298
stRp9160
ag1
(g9146
g9115
(dp9161
g78
g319
stRp9162
ag1
(g9146
g9115
(dp9163
g78
g249
stRp9164
ag1
(g9146
g9115
(dp9165
g78
g242
stRp9166
ag1
(g9146
g9115
(dp9167
g78
g340
stRp9168
ag1
(g9146
g9115
(dp9169
g78
g228
stRp9170
ag1
(g9146
g9115
(dp9171
g78
g123
stRp9172
ag1
(g9146
g9115
(dp9173
g78
g263
stRp9174
ag1
(g9146
g9115
(dp9175
g78
g277
stRp9176
ag1
(g9146
g9115
(dp9177
g78
g312
stRp9178
ag1
(g9146
g9115
(dp9179
g78
g368
stRp9180
ag1
(g9146
g9115
(dp9181
g78
g333
stRp9182
ag1
(g9146
g9115
(dp9183
g78
g193
stRp9184
ag1
(g9146
g9115
(dp9185
g78
g186
stRp9186
ag1
(g9146
g9115
(dp9187
g78
g214
stRp9188
ag1
(g9146
g9115
(dp9189
g78
g361
stRp9190
ag1
(g9146
g9115
(dp9191
g78
g116
stRp9192
ag1
(g9146
g9115
(dp9193
g78
g256
stRp9194
ag1
(g9146
g9115
(dp9195
g78
g165
stRp9196
ag1
(g9146
g9115
(dp9197
g78
g109
stRp9198
ag1
(g9146
g9115
(dp9199
g78
g375
stRp9200
ag1
(g9146
g9115
(dp9201
g78
g200
stRp9202
ag1
(g9146
g9115
(dp9203
g78
g284
stRp9204
ag1
(g9146
g9115
(dp9205
g78
g207
stRp9206
ag1
(g9146
g9115
(dp9207
g78
g158
stRp9208
ag1
(g9146
g9115
(dp9209
g78
g326
stRp9210
ag1
(g9146
g9115
(dp9211
g78
g291
stRp9212
ag1
(g9146
g9115
(dp9213
g78
g179
stRp9214
ag1
(g9146
g9115
(dp9215
g78
g347
stRp9216
ag1
(g9146
g9115
(dp9217
g78
g270
stRp9218
ag1
(g9146
g9115
(dp9219
g78
g172
stRp9220
ag1
(g9146
g9115
(dp9221
g78
g235
stRp9222
ag1
(g9146
g9115
(dp9223
g78
g305
stRp9224
ag1
(g9146
g9115
(dp9225
g78
g354
stRp9226
asS'seed'
p9227
NsS'thisIndex'
p9228
g372
sS'thisN'
p9229
I40
sS'thisTrialN'
p9230
I0
sS'nTotal'
p9231
I40
sS'_warnUseOfNext'
p9232
I01
sbag1
(g9102
g3
NtRp9233
(dp9234
g9105
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a\u000a######################## CITATIONS ########################## \u000a##### Binary choice, BDM, auction routines, and instructions are modified from:\u000a##### \u000a##### De Martino, B., Fleming, S. M., Garrett, N., & Dolan, R. J. (2012). Confidence in value-based choice. Nature Neuroscience, 16(1), 105-110. \u000a#####\u000a##### Food item images are original.\u000a\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.80.01), July 16, 2014, at 03:20\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things bdm STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000afrom pyglet.window import key # to detect key state, whether key is held down, to move slider on key hold\u000aimport pandas as pd\u000aimport datetime\u000afrom psychopy.iohub import launchHubServer\u000aimport pylink\u000a\u000a# Initialize IOHub for eye tracker\u000a# io=launchHubServer(iohub_config_name='iohub_config.yaml')\u000a# tracker = io.devices.tracker\u000a\u000a# Store info about the experiment session\u000aexpName = 'infer_design1_no_eyetracking'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u'', u'eye': u'', u'glasses': u'', u'contacts': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Setup filename for saving\u000afilename = 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# set up variable to track current state of key press, to move slider when keys held down\u000akeyState=key.KeyStateHandler()\u000a\u000a# Setup the Window\u000ascreenwidth = 1920\u000ascreenheight = 1080\u000awin = visual.Window(size=(screenwidth, screenheight), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color='black', colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000awin.winHandle.push_handlers(keyState)\u000a\u000a\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a\u000a######################## COMPONENTS ##########################\u000a\u000a# Set up directory path for stimuli. This avoids us having to put the entire image path in the conditions spreadsheet.\u000adir_path = 'stimuli/itempics/modified/small/'\u000a\u000a# Initialize components for Routine "instr_main"\u000ainstr_mainClock = core.Clock()\u000ainstr_main_txt = visual.TextStim(win=win, ori=0, name='instr_main_txt',\u000a    text=u'Welcome!\u005cn\u005cnPlease read the instructions carefully and get the experimenter when you\u005c're finished. Take as much time as you need.',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "instr_bdm"\u000ainstr_bdmClock = core.Clock()\u000ainstr_bdm_txt = visual.TextStim(win=win, ori=0, name='instr_bdm_txt',\u000a    text=u'The bidding task is about to begin. Use the LEFT and RIGHT arrow keys to move the cursor along the slider, then press the DOWN arrow to enter your bid.\u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "fixation"\u000afixationClock = core.Clock()\u000afixation_text = visual.TextStim(win=win, ori=0, name='fixation_text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "bdm"\u000abdmClock = core.Clock()\u000abdm_pic = visual.ImageStim(win=win, name='bdm_pic',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=0.0)\u000abdm_bid = visual.RatingScale(win=win, name='bdm_bid', marker=u'triangle', markerColor=u'orange', leftKeys=None, rightKeys=None,\u000a    size=1.0, pos=[0.0, -0.6], low=0, high=3, precision=100, labels=[u'\u005cxa30', u'\u005cxa33'],\u000a    scale=u'', markerStart=u'1.5', tickHeight=u'1', showAccept=False, acceptKeys=[u'down', u'return'])\u000a\u000a# Initialize components for Routine "instr_choice"\u000ainstr_choiceClock = core.Clock()\u000ainstr_choice_txt = visual.TextStim(win=win, ori=0, name='instr_choice_txt',\u000a    text=u'The choice task is about to begin. Choose your preferred item by pressing the LEFT or RIGHT arrow keys, then use the slider to indicate how confident you are that you made the best choice.\u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "choice"\u000achoiceClock = core.Clock()\u000achoice_pic_left = visual.ImageStim(win=win, name='choice_pic_left',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[-0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=0.0)\u000achoice_pic_right = visual.ImageStim(win=win, name='choice_pic_right',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=-1.0)\u000a\u000a# Initialize components for Routine "choice_selection"\u000achoice_selectionClock = core.Clock()\u000astar_left_selection = visual.TextStim(win=win, ori=0, name='star_left_selection',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[-0.5, -0.8], height=0.5, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=-2.0)\u000astar_right_selection = visual.TextStim(win=win, ori=0, name='star_right_selection',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[0.5, -0.8], height=0.5, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=-3.0)\u000a\u000a# Initialize components for Routine "confidence"\u000aconfidenceClock = core.Clock()\u000aconfidence_rating = visual.RatingScale(win=win, name='confidence_rating', marker=u'triangle', markerColor=u'orange', leftKeys=None, rightKeys=None,\u000a    size=1.0, pos=[0.0, 0.0], low=1, high=6, precision=20,\u000a    scale=u'', markerStart=u'3.5', tickHeight=u'1', showAccept=False, acceptKeys=[u'down', u'return'])\u000a\u000a# Initialize components for Routine "instr_infer_intro"\u000ainstr_infer_introClock = core.Clock()\u000ainstr_infer_intro_txt = visual.TextStim(win=win, ori=0, name='instr_infer_intro_txt',\u000a    text=u'Thanks! Now please get the experimenter, who will give you the instructions for the second part of the experiment. \u005cn\u005cnPlease read these instructions carefully and get the experimenter again when you\u005c're finished. Take as much time as you need.',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=1.5,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "instr_infer_practice"\u000ainstr_infer_practiceClock = core.Clock()\u000ainstr_infer_practice_txt = visual.TextStim(win=win, ori=0, name='instr_infer_practice_txt',\u000a    text=u'First, you\u005c'll do some practice trials. These are just for you to get used to the task; your responses won\u005c't count. \u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=1.5,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "instr_infer"\u000ainstr_inferClock = core.Clock()\u000ainstr_infer_txt = visual.TextStim(win=win, ori=0, name='instr_infer_txt',\u000a    text=u'Great! Now that you\u005c've done some practice trials, we\u005c're ready to start the real trials. Please call the experimenter into the room.',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=1.5,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "get_ready"\u000aget_readyClock = core.Clock()\u000aget_ready_text = visual.TextStim(win=win, ori=0, name='get_ready_text',\u000a    text=u'Get ready!',    font=u'Arial',\u000a    pos=[0, 0], height=0.12, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000aimg_left_infer = visual.ImageStim(win=win, name='img_left_infer',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[-0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=0.0)\u000aimg_right_infer = visual.ImageStim(win=win, name='img_right_infer',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=-1.0)\u000a\u000a# Initialize components for Routine "trial_post_response"\u000atrial_post_responseClock = core.Clock()\u000aselection_arrow_left = visual.TextStim(win=win, ori=0, name='selection_arrow_left',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[-0.5, -0.09], height=0.5, wrapWidth=None,\u000a    color=u'red', colorSpace=u'rgb', opacity=1,\u000a    depth=-2.0)\u000aselection_arrow_right = visual.TextStim(win=win, ori=0, name='selection_arrow_right',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[0.5, -0.09], height=0.5, wrapWidth=None,\u000a    color=u'red', colorSpace=u'rgb', opacity=1,\u000a    depth=-3.0)\u000afeedback_box_left = visual.Rect(win=win, name='feedback_box_left',\u000a    width=[0.9, 0.9][0], height=[0.9, 0.9][1],\u000a    ori=0, pos=[-0.5, 0],\u000a    lineWidth=5, lineColor=u'yellow', lineColorSpace=u'rgb',\u000a    fillColor=None, fillColorSpace=u'rgb',\u000a    opacity=1, depth=-4.0, interpolate=True)\u000afeedback_box_right = visual.Rect(win=win, name='feedback_box_right',\u000a    width=[0.9, 0.9][0], height=[0.9, 0.9][1],\u000a    ori=0, pos=[0.5, 0],\u000a    lineWidth=5, lineColor=u'yellow', lineColorSpace=u'rgb',\u000a    fillColor=None, fillColorSpace=u'rgb',\u000a    opacity=1, depth=-5.0, interpolate=True)\u000a\u000a# Initialize components for Routine "rest_prompt"\u000arest_promptClock = core.Clock()\u000arest_prompt_txt = visual.TextStim(win=win, ori=0, name='rest_prompt_txt',\u000a    text=u'Great! Now take a rest and press the space bar when you\u005cu2019re ready to begin the next block.',    font=u'Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create counters for the number of correct and incorrect guesses made by subjects to determine extra payment.\u000acorrect_counter = 0\u000aincorrect_counter = 0\u000a\u000a# Create list of lists to store binary choice and BDM data to generate food reward at the end of the experiment\u000aprefs = [['left', 'right', 'choice', 'bid']]\u000abids = [['item', 'bid']] # For the bids collected during the first BDM routine, at the beginning of the experiment\u000a\u000a### CHOICE & INFERENCE RANDOMIZATION ###\u000a\u000a# Define two functions to generate constrained pseudorandom sequences of item pair presentations for the binary choice and inference\u000a# parts of the task. The constraint ensures that the same pair of items does not appear twice in a row (flipped or not).\u000a# In the conditions spreadsheet that the item pairs are drawn from, the flipped version of the same item pair is 20\u000a# rows apart.\u000a\u000a# Binary choice randomization\u000adef genseq_choice():\u000a    done = False\u000a    while done==False:\u000a        counter = 0\u000a        ans = np.random.choice(40, 40, replace=False) # Generate a pseudorandom sequence of 40 numbers\u000a        for x in range(1,40):\u000a            if (ans[x]-ans[x-1]) % 20 == 0: # Is the difference between any sequential numbers divisible by 20?\u000a                counter += 1\u000a        if counter==0: # If not, end the loop and return the array\u000a            done = True\u000a            return ans\u000a        else: # If so, continue the loop and try again\u000a            done = False\u000a\u000a# Inference practice block randomization\u000adef genseq_infer_practice():\u000a    done = False\u000a    while done==False:\u000a        counter = 0\u000a        ans = np.random.choice(14, 14, replace=False) # Generate a pseudorandom sequence of 200 numbers\u000a        for x in range(1,14):\u000a            if (ans[x]-ans[x-1]) % 7 == 0: # Is the difference between any sequential numbers divisible by 20?\u000a                counter += 1\u000a        if counter==0: # If not, end the loop and return the array\u000a            done = True\u000a            return ans\u000a        else: # If so, continue the loop and try again\u000a            done = False\u000a\u000a# Inference randomization\u000adef genseq_infer():\u000a    done = False\u000a    while done==False:\u000a        counter = 0\u000a        ans = np.random.choice(200, 200, replace=False) # Generate a pseudorandom sequence of 200 numbers\u000a        for x in range(1,200):\u000a            if (ans[x]-ans[x-1]) % 20 == 0: # Is the difference between any sequential numbers divisible by 20?\u000a                counter += 1\u000a        if counter==0: # If not, end the loop and return the array\u000a            done = True\u000a            return ans\u000a        else: # If so, continue the loop and try again\u000a            done = False\u000a\u000a\u000a# Set independent sequences for each of the two choice blocks, the inference practice block, and the three inference rest blocks. Each rest block contains 10 presentations of\u000a# each pair.\u000a\u000achoiceseq = genseq_choice()\u000apracticeseq = genseq_infer_practice()\u000ablock1seq = genseq_infer()\u000ablock2seq = genseq_infer()\u000ablock3seq = genseq_infer()\u000a\u000a\u000a# Choose a pilot participant whose choices will form the basis of the learning task\u000apartners = ['P1','P2','P3','P4','P5','P6','P8','P9','P10','P11','P12'] # List of pilot participants, P7 excluded for perfectly inconsistent choices\u000apartner = np.random.choice(partners,1) # Choose one at random\u000apartner_file = 'conditions/choices/infer_design1_value_pairs_' + partner[0] + '.csv' # Path to that participant's choice data\u000a\u000a# Create separate CSV files, one for each choice, practice, and rest block, with the item pairs in the pseudorandomly generated order.\u000a# These CSV files will be used as PsychoPy's conditions spreadsheets and run sequentially in the choice, practice, and inference loops below.\u000a\u000a\u000achoicecond_src = pd.read_csv('conditions/choice_design1_binary.csv', index_col=None, header=0)\u000achoicecond = choicecond_src.copy()\u000afor x in range(40):\u000a    seq = choiceseq[x]\u000a    choicecond.iloc[x] = choicecond_src.iloc[seq]\u000achoicecond.to_csv(path_or_buf=filename+'_choicecond.csv', index=False)\u000a\u000apracticecond_src = pd.read_csv('conditions/choices/infer_design1_value_pairs_practice.csv', index_col=None, header=0)\u000apracticecond = practicecond_src.copy()\u000afor x in range(14):\u000a    seq = practiceseq[x]\u000a    practicecond.iloc[x] = practicecond_src.iloc[seq]\u000apracticecond.to_csv(path_or_buf=filename+'_practicecond.csv', index=False)\u000a\u000ablock1cond_src = pd.read_csv(partner_file, index_col=None, header=0)\u000ablock1cond = block1cond_src.copy()\u000afor x in range(200):\u000a    seq = block1seq[x]\u000a    block1cond.iloc[x] = block1cond_src.iloc[seq]\u000ablock1cond.to_csv(path_or_buf=filename+'_block1cond.csv', index=False)\u000a\u000ablock2cond_src = pd.read_csv(partner_file, index_col=None, header=0)\u000ablock2cond = block2cond_src.copy()\u000afor x in range(200):\u000a    seq = block2seq[x]\u000a    block2cond.iloc[x] = block2cond_src.iloc[seq]\u000ablock2cond.to_csv(path_or_buf=filename+'_block2cond.csv', index=False)\u000a\u000ablock3cond_src = pd.read_csv(partner_file, index_col=None, header=0)\u000ablock3cond = block3cond_src.copy()\u000afor x in range(200):\u000a    seq = block3seq[x]\u000a    block3cond.iloc[x] = block3cond_src.iloc[seq]\u000ablock3cond.to_csv(path_or_buf=filename+'_block3cond.csv', index=False)\u000a\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instr_main"-------\u000at = 0\u000ainstr_mainClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_main_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_main_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_mainComponents = []\u000ainstr_mainComponents.append(instr_main_txt)\u000ainstr_mainComponents.append(instr_main_resp)\u000afor thisComponent in instr_mainComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_main"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_mainClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_main_txt* updates\u000a    if t >= 0.0 and instr_main_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_main_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_main_txt.frameNStart = frameN  # exact frame index\u000a        instr_main_txt.setAutoDraw(True)\u000a    \u000a    # *instr_main_resp* updates\u000a    if t >= 5.0 and instr_main_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_main_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_main_resp.frameNStart = frameN  # exact frame index\u000a        instr_main_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_main_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_main_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_main_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_main_resp.rt = instr_main_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_mainComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_main"-------\u000afor thisComponent in instr_mainComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_main_resp.keys in ['', [], None]:  # No response was made\u000a   instr_main_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_main_resp.keys',instr_main_resp.keys)\u000aif instr_main_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_main_resp.rt', instr_main_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a\u000a#------Prepare to start Routine "instr_bdm"-------\u000at = 0\u000ainstr_bdmClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_bdm_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_bdm_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_bdmComponents = []\u000ainstr_bdmComponents.append(instr_bdm_txt)\u000ainstr_bdmComponents.append(instr_bdm_resp)\u000afor thisComponent in instr_bdmComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_bdm"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_bdmClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_bdm_txt* updates\u000a    if t >= 0.0 and instr_bdm_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_bdm_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_bdm_txt.frameNStart = frameN  # exact frame index\u000a        instr_bdm_txt.setAutoDraw(True)\u000a    \u000a    # *instr_bdm_resp* updates\u000a    if t >= 2.0 and instr_bdm_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_bdm_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_bdm_resp.frameNStart = frameN  # exact frame index\u000a        instr_bdm_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_bdm_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_bdm_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space', 's'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_bdm_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_bdm_resp.rt = instr_bdm_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_bdmComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_bdm"-------\u000afor thisComponent in instr_bdmComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_bdm_resp.keys in ['', [], None]:  # No response was made\u000a   instr_bdm_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_bdm_resp.keys',instr_bdm_resp.keys)\u000athisExp.addData('partnered_pilot_participant', partner)\u000aif instr_bdm_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_bdm_resp.rt', instr_bdm_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## BDM LOOP 1 ##########################\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000abdm_loop1 = data.TrialHandler(nReps=1, method=u'random', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'conditions/choice_design1_bdm.xlsx'),\u000a    seed=None, name='bdm_loop1')\u000athisExp.addLoop(bdm_loop1)  # add the loop to the experiment\u000athisbdm_loop1 = bdm_loop1.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisbdm_loop1.rgb)\u000aif thisbdm_loop1 != None:\u000a    for paramName in thisbdm_loop1.keys():\u000a        exec(paramName + '= thisbdm_loop1.' + paramName)\u000a\u000a# Check if the 'skip' key was pressed in the instructions routine; if so, end the loop and move on to the inference task\u000aif instr_bdm_resp.keys=='s':\u000a    bdm_loop1.finished = True\u000a\u000afor thisbdm_loop1 in bdm_loop1:\u000a    currentLoop = bdm_loop1\u000a    # abbreviate parameter names if possible (e.g. rgb = thisbdm_loop1.rgb)\u000a    if thisbdm_loop1 != None:\u000a        for paramName in thisbdm_loop1.keys():\u000a            exec(paramName + '= thisbdm_loop1.' + paramName)\u000a    \u000a    #------Prepare to start Routine "bdm"-------\u000a    t = 0\u000a    bdmClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    bdm_pic.setImage(dir_path+bdm_img)\u000a    bdm_bid.reset()\u000a    # jitter the starting position of the BDM scale from a uniform distribution between 1 and 2, rounded to the nearest decimal place\u000a    bdm_marker_start = float(np.round(np.random.uniform(1, 2, 1)[0], 1))\u000a    bdm_bid.setMarkerPos(bdm_marker_start)\u000a    # keep track of which components have finished\u000a    bdmComponents = []\u000a    bdmComponents.append(fixation_text)\u000a    bdmComponents.append(bdm_pic)\u000a    bdmComponents.append(bdm_bid)\u000a    for thisComponent in bdmComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "bdm"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = bdmClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation_text* updates\u000a        if t >= 0 and fixation_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation_text.tStart = t  # underestimates by a little under one frame\u000a            fixation_text.frameNStart = frameN  # exact frame index\u000a            fixation_text.setAutoDraw(True)\u000a        elif fixation_text.status == STARTED and t>= (0 + (1.0-win.monitorFramePeriod*0.75)):\u000a            fixation_text.setAutoDraw(False)\u000a\u000a        # *bdm_pic* updates\u000a        if t >= 1.0 and bdm_pic.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bdm_pic.tStart = t  # underestimates by a little under one frame\u000a            bdm_pic.frameNStart = frameN  # exact frame index\u000a            bdm_pic.setAutoDraw(True)\u000a        # *bdm_bid* updates\u000a        if t >= 1.0:\u000a            bdm_bid.draw()\u000a            continueRoutine = bdm_bid.noResponse\u000a            if bdm_bid.noResponse == False:\u000a                bdm_bid.response = bdm_bid.getRating()\u000a                bdm_bid.rt = bdm_bid.getRT()\u000a            elif bdm_bid.noResponse==True:\u000a                if keyState[key.LEFT]==True and bdm_bid.markerPlacedAt >0.01:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt - 0.02\u000a                    bdm_bid.draw()\u000a                elif keyState[key.LEFT]==True and bdm_bid.markerPlacedAt==0.01:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt - 0.01\u000a                    bdm_bid.draw()\u000a                elif keyState[key.RIGHT]==True and bdm_bid.markerPlacedAt <2.99:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt + 0.02\u000a                    bdm_bid.draw()\u000a                elif keyState[key.RIGHT]==True and bdm_bid.markerPlacedAt==2.99:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt + 0.01\u000a                    bdm_bid.draw()\u000a                    \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in bdmComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "bdm"-------\u000a    for thisComponent in bdmComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # store data for bdm (TrialHandler)\u000a    bdm_loop1.addData('bdm_bid1.response', bdm_bid.getRating())\u000a    bdm_loop1.addData('bdm_bid1.rt', bdm_bid.getRT())\u000a    bdm_loop1.addData('bdm_marker_start', bdm_marker_start)\u000a\u000a    # Add the item and the subject's bid to the 'bids' list, which will be merged with the 'prefs' list later in order to run the auction\u000a    bids.append([bdm_img, bdm_bid.response])\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeat of 'bdm_loop1'\u000a\u000a\u000a#------Prepare to start Routine "instr_choice"-------\u000at = 0\u000ainstr_choiceClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_choice_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_choice_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_choiceComponents = []\u000ainstr_choiceComponents.append(instr_choice_txt)\u000ainstr_choiceComponents.append(instr_choice_resp)\u000afor thisComponent in instr_choiceComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_choice"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_choiceClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_choice_txt* updates\u000a    if t >= 0.0 and instr_choice_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_choice_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_choice_txt.frameNStart = frameN  # exact frame index\u000a        instr_choice_txt.setAutoDraw(True)\u000a    \u000a    # *instr_choice_resp* updates\u000a    if t >= 2.0 and instr_choice_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_choice_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_choice_resp.frameNStart = frameN  # exact frame index\u000a        instr_choice_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_choice_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_choice_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space', 's'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_choice_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_choice_resp.rt = instr_choice_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_choiceComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_choice"-------\u000afor thisComponent in instr_choiceComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_choice_resp.keys in ['', [], None]:  # No response was made\u000a   instr_choice_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_choice_resp.keys',instr_choice_resp.keys)\u000aif instr_choice_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_choice_resp.rt', instr_choice_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## BINARY LOOP ##########################\u000a\u000a# set up handler to look after randomisation of conditions etc\u000abinary = data.TrialHandler(nReps=1, method=u'sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(filename+'_choicecond.csv'),\u000a    seed=None, name='binary')\u000athisExp.addLoop(binary)  # add the loop to the experiment\u000athisBinary1 = binary.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBinary1.rgb)\u000aif thisBinary1 != None:\u000a    for paramName in thisBinary1.keys():\u000a        exec(paramName + '= thisBinary1.' + paramName)\u000a\u000a# Check if the 'skip' key was pressed in the instructions routine; if so, end the loop and move on to the BDM\u000aif instr_choice_resp.keys=='s':\u000a    binary.finished = True\u000a\u000afor thisBinary1 in binary:\u000a    currentLoop = binary\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBinary1.rgb)\u000a    if thisBinary1 != None:\u000a        for paramName in thisBinary1.keys():\u000a            exec(paramName + '= thisBinary1.' + paramName)\u000a    \u000a    #------Prepare to start Routine "choice"-------\u000a    t = 0\u000a    choiceClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    choice_pic_left.setImage(dir_path+choice_left)\u000a    choice_pic_right.setImage(dir_path+choice_right)\u000a    event.clearEvents(eventType='keyboard') # Clear keyboard event log to avoid last key press from prior loop being used\u000a    key_resp_choice = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_choice.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    choiceComponents = []\u000a    choiceComponents.append(fixation_text)\u000a    choiceComponents.append(choice_pic_left)\u000a    choiceComponents.append(choice_pic_right)\u000a    choiceComponents.append(key_resp_choice)\u000a    for thisComponent in choiceComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    \u000a    #-------Start Routine "choice"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = choiceClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation_text* updates\u000a        if t >= 0 and fixation_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation_text.tStart = t  # underestimates by a little under one frame\u000a            fixation_text.frameNStart = frameN  # exact frame index\u000a            fixation_text.setAutoDraw(True)\u000a        elif fixation_text.status == STARTED and t>= (0 + (1.0-win.monitorFramePeriod*0.75)):\u000a            fixation_text.setAutoDraw(False)\u000a\u000a        # *choice_pic_left* updates\u000a        if t >= 1.0 and choice_pic_left.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_left.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_left.frameNStart = frameN  # exact frame index\u000a            choice_pic_left.setAutoDraw(True)\u000a        \u000a        # *choice_pic_right* updates\u000a        if t >= 1.0 and choice_pic_right.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_right.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_right.frameNStart = frameN  # exact frame index\u000a            choice_pic_right.setAutoDraw(True)\u000a\u000a        # *key_resp_choice* updates\u000a        if t >= 1.0 and key_resp_choice.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_choice.tStart = t  # underestimates by a little under one frame\u000a            key_resp_choice.frameNStart = frameN  # exact frame index\u000a            key_resp_choice.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_choice.clock.reset()  # now t=0\u000a        if key_resp_choice.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_choice.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_choice.rt = key_resp_choice.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in choiceComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "choice"-------\u000a    for thisComponent in choiceComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_choice.keys in ['', [], None]:  # No response was made\u000a       key_resp_choice.keys=None\u000a    # store data for binary (TrialHandler)\u000a    binary.addData('key_resp_choice.keys',key_resp_choice.keys)\u000a    if key_resp_choice.keys != None:  # we had a response\u000a        binary.addData('key_resp_choice.rt', key_resp_choice.rt)\u000a\u000a    # define a function to append binary choices and the bid for the chosen item to the preference list\u000a    # lft is the left image displayed during that choice trial\u000a    # rt is the right image displayed\u000a    def rec_choice(lft, rt): \u000a        bd = False\u000a        if key_resp_choice.keys=='left':\u000a            chc = lft\u000a        elif key_resp_choice.keys=='right':\u000a            chc = rt\u000a        for x in range(len(bids)):\u000a            if bids[x][0]==chc:\u000a                bd = bids[x][1]\u000a        prefs.append([lft, rt, chc, bd])\u000a\u000a    # call the function\u000a    rec_choice(choice_left, choice_right)\u000a    \u000a\u000a    #------Prepare to start Routine "choice_selection"-------\u000a    t = 0\u000a    choice_selectionClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # keep track of which components have finished\u000a    choice_selectionComponents = []\u000a    choice_selectionComponents.append(choice_pic_left)\u000a    choice_selectionComponents.append(choice_pic_right)\u000a    choice_selectionComponents.append(star_left_selection)\u000a    choice_selectionComponents.append(star_right_selection)\u000a    for thisComponent in choice_selectionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "choice_selection"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = choice_selectionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *choice_pic_left* updates\u000a        if t >= 0.0 and choice_pic_left.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_left.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_left.frameNStart = frameN  # exact frame index\u000a            choice_pic_left.setAutoDraw(True)\u000a        elif choice_pic_left.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            choice_pic_left.setAutoDraw(False)\u000a        \u000a        # *choice_pic_right* updates\u000a        if t >= 0.0 and choice_pic_right.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_right.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_right.frameNStart = frameN  # exact frame index\u000a            choice_pic_right.setAutoDraw(True)\u000a        elif choice_pic_right.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            choice_pic_right.setAutoDraw(False)\u000a        \u000a        # *star_left_selection* updates\u000a        if key_resp_choice.keys=='left':\u000a            if t >= 0.0 and star_left_selection.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                star_left_selection.tStart = t  # underestimates by a little under one frame\u000a                star_left_selection.frameNStart = frameN  # exact frame index\u000a                star_left_selection.setAutoDraw(True)\u000a            elif star_left_selection.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                star_left_selection.setAutoDraw(False)\u000a        \u000a        # *star_right_selection* updates\u000a        if key_resp_choice.keys=='right':\u000a            if t >= 0.0 and star_right_selection.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                star_right_selection.tStart = t  # underestimates by a little under one frame\u000a                star_right_selection.frameNStart = frameN  # exact frame index\u000a                star_right_selection.setAutoDraw(True)\u000a            elif star_right_selection.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                star_right_selection.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in choice_selectionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "choice_selection"-------\u000a    for thisComponent in choice_selectionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    #thisExp.nextEntry()\u000a\u000a    #------Prepare to start Routine "confidence"-------\u000a    t = 0\u000a    confidenceClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    confidence_rating.reset()\u000a    # jitter the starting position of the confidence rating scale from a uniform distribution between 1.7 and 3.3 (the middle third of the scale), rounded to the nearest decimal place\u000a    confidence_marker_start = float(np.round(np.random.uniform(1.7, 3.3, 1)[0], 1))\u000a    confidence_rating.setMarkerPos(confidence_marker_start)\u000a    # keep track of which components have finished\u000a    confidenceComponents = []\u000a    confidenceComponents.append(confidence_rating)\u000a    for thisComponent in confidenceComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "confidence"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = confidenceClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *confidence_rating* updates\u000a        if t > 0.5:\u000a            confidence_rating.draw()\u000a            continueRoutine = confidence_rating.noResponse\u000a            if confidence_rating.noResponse == False:\u000a                confidence_rating.response = confidence_rating.getRating()\u000a                confidence_rating.rt = confidence_rating.getRT()\u000a            elif confidence_rating.noResponse==True:\u000a                if keyState[key.LEFT]==True and confidence_rating.markerPlacedAt >0:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt - 0.1\u000a                    confidence_rating.draw()\u000a                elif keyState[key.LEFT]==True and confidence_rating.markerPlacedAt==0.1:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt - 0.1\u000a                    confidence_rating.draw()\u000a                elif keyState[key.RIGHT]==True and confidence_rating.markerPlacedAt <4.9:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt + 0.1\u000a                    confidence_rating.draw()\u000a                elif keyState[key.RIGHT]==True and confidence_rating.markerPlacedAt==4.9:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt + 0.1\u000a                    confidence_rating.draw()\u000a                    \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in confidenceComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "confidence"-------\u000a    for thisComponent in confidenceComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # store data for confidence (TrialHandler)\u000a    binary.addData('confidence_rating1.response', confidence_rating.getRating())\u000a    binary.addData('confidence_rating1.rt', confidence_rating.getRT())\u000a    binary.addData('confidence_marker_start', confidence_marker_start+1) # Add 1 to convert from 0-5 to 1-6 scale\u000a\u000a    thisExp.nextEntry()\u000a\u000a\u000a# completed 1 repeat of 'binary'        \u000a\u000a#------Prepare to start Routine "instr_infer_intro"-------\u000at = 0\u000ainstr_infer_introClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_infer_intro_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_infer_intro_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_infer_introComponents = []\u000ainstr_infer_introComponents.append(instr_infer_intro_txt)\u000ainstr_infer_introComponents.append(instr_infer_intro_resp)\u000afor thisComponent in instr_infer_introComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_infer_intro"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_infer_introClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_infer_intro_txt* updates\u000a    if t >= 0.0 and instr_infer_intro_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_intro_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_intro_txt.frameNStart = frameN  # exact frame index\u000a        instr_infer_intro_txt.setAutoDraw(True)\u000a    \u000a    # *instr_infer_intro_resp* updates\u000a    if t >= 5.0 and instr_infer_intro_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_intro_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_intro_resp.frameNStart = frameN  # exact frame index\u000a        instr_infer_intro_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_infer_intro_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_infer_intro_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_infer_intro_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_infer_intro_resp.rt = instr_infer_intro_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_infer_introComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_infer_intro"-------\u000afor thisComponent in instr_infer_introComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_infer_intro_resp.keys in ['', [], None]:  # No response was made\u000a   instr_infer_intro_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_infer_intro_resp.keys',instr_infer_intro_resp.keys)\u000aif instr_infer_intro_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_infer_intro_resp.rt', instr_infer_intro_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a#------Prepare to start Routine "instr_infer_practice"-------\u000at = 0\u000ainstr_infer_practiceClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_infer_practice_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_infer_practice_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_infer_practiceComponents = []\u000ainstr_infer_practiceComponents.append(instr_infer_practice_txt)\u000ainstr_infer_practiceComponents.append(instr_infer_practice_resp)\u000afor thisComponent in instr_infer_practiceComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_infer_practice"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_infer_practiceClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_infer_practice_txt* updates\u000a    if t >= 0.0 and instr_infer_practice_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_practice_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_practice_txt.frameNStart = frameN  # exact frame index\u000a        instr_infer_practice_txt.setAutoDraw(True)\u000a    \u000a    # *instr_infer_practice_resp* updates\u000a    if t >= 5.0 and instr_infer_practice_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_practice_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_practice_resp.frameNStart = frameN  # exact frame index\u000a        instr_infer_practice_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_infer_practice_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_infer_practice_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_infer_practice_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_infer_practice_resp.rt = instr_infer_practice_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_infer_practiceComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_infer_practice"-------\u000afor thisComponent in instr_infer_practiceComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_infer_practice_resp.keys in ['', [], None]:  # No response was made\u000a   instr_infer_practice_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_infer_practice_resp.keys',instr_infer_practice_resp.keys)\u000aif instr_infer_practice_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_infer_practice_resp.rt', instr_infer_practice_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## PRACTICE LOOP ##########################\u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_loop = data.TrialHandler(nReps=1, method=u'sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(filename+'_practicecond.csv'),\u000a    seed=None, name='practice_loop')\u000athisExp.addLoop(practice_loop)  # add the loop to the experiment\u000athisPractice_loop = practice_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_loop.rgb)\u000aif thisPractice_loop != None:\u000a    for paramName in thisPractice_loop.keys():\u000a        exec(paramName + '= thisPractice_loop.' + paramName)\u000a\u000a  \u000afor thisPractice_loop in practice_loop:\u000a    currentLoop = practice_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_loop.rgb)\u000a    if thisPractice_loop != None:\u000a        for paramName in thisPractice_loop.keys():\u000a            exec(paramName + '= thisPractice_loop.' + paramName)    \u000a    \u000a        \u000a    # Define class for setting the feedback image\u000a    class set_feedback:\u000a        options = ['correct', 'wrong']\u000a        feedback = np.random.choice(options, replace=True, p=[0.8, 0.2])\u000a        if feedback=='correct':\u000a            feedback_img = img_correct\u000a        elif feedback=='wrong':\u000a            feedback_img = img_wrong\u000a\u000a        if feedback_img==img_left:\u000a            feedback_side = 'left'\u000a        elif feedback_img==img_right:\u000a            feedback_side = 'right'\u000a\u000a\u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialtime = datetime.datetime.now()\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    img_left_infer.setImage(dir_path+img_left)\u000a    img_right_infer.setImage(dir_path+img_right)\u000a    infer_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    infer_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(fixation_text)\u000a    trialComponents.append(img_left_infer)\u000a    trialComponents.append(img_right_infer)\u000a    trialComponents.append(infer_resp)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation_text* updates\u000a        if t >= 0 and fixation_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation_text.tStart = t  # underestimates by a little under one frame\u000a            fixation_text.frameNStart = frameN  # exact frame index\u000a            fixation_text.setAutoDraw(True)\u000a        elif fixation_text.status == STARTED and t>= (0 + (2.0-win.monitorFramePeriod*0.75)):\u000a            fixation_text.setAutoDraw(False)\u000a\u000a        # *img_left_infer* updates\u000a        if t >= 2.0 and img_left_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_left_infer.tStart = t  # underestimates by a little under one frame\u000a            img_left_infer.frameNStart = frameN  # exact frame index\u000a            img_left_infer.setAutoDraw(True)\u000a        \u000a        # *img_right_infer* updates\u000a        if t >= 2.0 and img_right_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_right_infer.tStart = t  # underestimates by a little under one frame\u000a            img_right_infer.frameNStart = frameN  # exact frame index\u000a            img_right_infer.setAutoDraw(True)\u000a                  \u000a        # *infer_resp* updates\u000a        if t >= 2.0 and infer_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            infer_resp.tStart = t  # underestimates by a little under one frame\u000a            infer_resp.frameNStart = frameN  # exact frame index\u000a            infer_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            infer_resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if infer_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                infer_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                infer_resp.rt = infer_resp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a\u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if infer_resp.keys in ['', [], None]:  # No response was made\u000a       infer_resp.keys=None\u000a    # # store data for practice_loop (TrialHandler)\u000a    # practice_loop.addData('infer_resp.keys',infer_resp.keys)\u000a    # if infer_resp.keys != None:  # we had a response\u000a    #     practice_loop.addData('infer_resp.rt', infer_resp.rt)\u000a    practice_loop.addData('set_feedback.feedback_img', set_feedback.feedback_img)\u000a    practice_loop.addData('trial_start_time', trialtime)\u000a    \u000a    # # Increase correct and incorrect response counters by 1 based on S's response\u000a    # if infer_resp.keys=='left' and img_correct==img_left:\u000a    #     correct_counter += 1\u000a    # elif infer_resp.keys=='left' and img_correct==img_right:\u000a    #     incorrect_counter += 1\u000a    # elif infer_resp.keys=='right' and img_correct==img_right:\u000a    #     correct_counter += 1\u000a    # elif infer_resp.keys=='right' and img_correct==img_left:\u000a    #     incorrect_counter += 1\u000a    \u000a\u000a    #------Prepare to start Routine "trial_post_response"-------\u000a    t = 0\u000a    trial_post_responseClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(3.000000)\u000a    # keep track of which components have finished\u000a    trial_post_responseComponents = []\u000a    trial_post_responseComponents.append(img_left_infer)\u000a    trial_post_responseComponents.append(img_right_infer)\u000a    trial_post_responseComponents.append(selection_arrow_left)\u000a    trial_post_responseComponents.append(selection_arrow_right)\u000a    trial_post_responseComponents.append(feedback_box_left)\u000a    trial_post_responseComponents.append(feedback_box_right)\u000a    for thisComponent in trial_post_responseComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial_post_response"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = trial_post_responseClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a\u000a        # *img_left_infer* updates\u000a        if t >= 0.0 and img_left_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_left_infer.tStart = t  # underestimates by a little under one frame\u000a            img_left_infer.frameNStart = frameN  # exact frame index\u000a            img_left_infer.setAutoDraw(True)\u000a        elif img_left_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            img_left_infer.setAutoDraw(False)\u000a        \u000a        # *img_right_infer* updates\u000a        if t >= 0.0 and img_right_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_right_infer.tStart = t  # underestimates by a little under one frame\u000a            img_right_infer.frameNStart = frameN  # exact frame index\u000a            img_right_infer.setAutoDraw(True)\u000a        elif img_right_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            img_right_infer.setAutoDraw(False)\u000a        \u000a        if infer_resp.keys == 'left':\u000a            # *selection_arrow_left* updates\u000a            if t >= 0.0 and selection_arrow_left.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                selection_arrow_left.tStart = t  # underestimates by a little under one frame\u000a                selection_arrow_left.frameNStart = frameN  # exact frame index\u000a                selection_arrow_left.setAutoDraw(True)\u000a            elif selection_arrow_left.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                selection_arrow_left.setAutoDraw(False)\u000a        \u000a        if infer_resp.keys == 'right':\u000a            # *selection_arrow_right* updates\u000a            if t >= 0.0 and selection_arrow_right.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                selection_arrow_right.tStart = t  # underestimates by a little under one frame\u000a                selection_arrow_right.frameNStart = frameN  # exact frame index\u000a                selection_arrow_right.setAutoDraw(True)\u000a            elif selection_arrow_right.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                selection_arrow_right.setAutoDraw(False)\u000a        \u000a        if set_feedback.feedback_side == 'left':\u000a            # *feedback_box_left* updates\u000a            if t >= 1.0 and feedback_box_left.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                feedback_box_left.tStart = t  # underestimates by a little under one frame\u000a                feedback_box_left.frameNStart = frameN  # exact frame index\u000a                feedback_box_left.setAutoDraw(True)\u000a            elif feedback_box_left.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                feedback_box_left.setAutoDraw(False)\u000a        \u000a        if set_feedback.feedback_side == 'right':\u000a            # *feedback_box_right* updates\u000a            if t >= 1.0 and feedback_box_right.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                feedback_box_right.tStart = t  # underestimates by a little under one frame\u000a                feedback_box_right.frameNStart = frameN  # exact frame index\u000a                feedback_box_right.setAutoDraw(True)\u000a            elif feedback_box_right.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period right\u000a                feedback_box_right.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trial_post_responseComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "trial_post_response"-------\u000a    for thisComponent in trial_post_responseComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000a    \u000a    thisExp.nextEntry()\u000a                        \u000a# completed 1 repeat of 'practice_loop'\u000a\u000a\u000a#------Prepare to start Routine "instr_infer"-------\u000at = 0\u000ainstr_inferClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_infer_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_infer_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_inferComponents = []\u000ainstr_inferComponents.append(instr_infer_txt)\u000ainstr_inferComponents.append(instr_infer_resp)\u000afor thisComponent in instr_inferComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_infer"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_inferClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_infer_txt* updates\u000a    if t >= 0.0 and instr_infer_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_txt.frameNStart = frameN  # exact frame index\u000a        instr_infer_txt.setAutoDraw(True)\u000a    \u000a    # *instr_infer_resp* updates\u000a    if t >= 5.0 and instr_infer_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_resp.frameNStart = frameN  # exact frame index\u000a        instr_infer_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_infer_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_infer_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_infer_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_infer_resp.rt = instr_infer_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_inferComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_infer"-------\u000afor thisComponent in instr_inferComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_infer_resp.keys in ['', [], None]:  # No response was made\u000a   instr_infer_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_infer_resp.keys',instr_infer_resp.keys)\u000aif instr_infer_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_infer_resp.rt', instr_infer_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## BLOCK LOOP ##########################\u000a\u000a# This loop runs a second nested loop that shows each item pair 10 times, followed by a rest break prompt.\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=3, method=u'sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=[None],\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000a# Set up counter to keep track of block loop cycle, so that the rest prompt is only shown twice\u000ablock_loop_counter = 0\u000a\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    # Increase loop counter by one\u000a    block_loop_counter += 1\u000a    \u000a    # Change the condition file for the feedback block based on which block loop we're on\u000a    condfilename = filename+u'_block'+str(block_loop_counter)+u'cond.csv'\u000a    \u000a    # # Minimize the psychopy window so the calibration window can be seen\u000a    # win.winHandle.minimize()\u000a    # #Do the eye tracker setup at the beginning of each block\u000a    # tracker.runSetupProcedure()\u000a    # # Re-display the psychopy window after setup is completed\u000a    # win.winHandle.maximize()\u000a    # win.winHandle.activate()\u000a    \u000a\u000a    \u000a    #------Prepare to start Routine "get_ready"-------\u000a    t = 0\u000a    get_readyClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(3.000000)\u000a    # update component parameters for each repeat\u000a    get_ready_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    get_ready_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    get_readyComponents = []\u000a    get_readyComponents.append(get_ready_text)\u000a    get_readyComponents.append(get_ready_resp)\u000a    for thisComponent in get_readyComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    \u000a    #-------Start Routine "get_ready"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = get_readyClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *get_ready_text* updates\u000a        if t >= 0.0 and get_ready_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            get_ready_text.tStart = t  # underestimates by a little under one frame\u000a            get_ready_text.frameNStart = frameN  # exact frame index\u000a            get_ready_text.setAutoDraw(True)\u000a        \u000a        # *get_ready_resp* updates\u000a        if t >= 0.0 and get_ready_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            get_ready_resp.tStart = t  # underestimates by a little under one frame\u000a            get_ready_resp.frameNStart = frameN  # exact frame index\u000a            get_ready_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            get_ready_resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if get_ready_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['p'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                get_ready_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                get_ready_resp.rt = get_ready_resp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in get_readyComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "get_ready"-------\u000a    for thisComponent in get_readyComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if get_ready_resp.keys in ['', [], None]:  # No response was made\u000a       get_ready_resp.keys=None\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('get_ready_resp.keys',get_ready_resp.keys)\u000a    if get_ready_resp.keys != None:  # we had a response\u000a        thisExp.addData('get_ready_resp.rt', get_ready_resp.rt)\u000a    thisExp.nextEntry()\u000a\u000a    ######################## TRIAL LOOP ##########################\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    trial_loop = data.TrialHandler(nReps=1, method=u'sequential', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(condfilename),\u000a        seed=None, name='trial_loop')\u000a    thisExp.addLoop(trial_loop)  # add the loop to the experiment\u000a    thisTrial_loop = trial_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_loop.rgb)\u000a    if thisTrial_loop != None:\u000a        for paramName in thisTrial_loop.keys():\u000a            exec(paramName + '= thisTrial_loop.' + paramName)\u000a    \u000a      \u000a    for thisTrial_loop in trial_loop:\u000a        currentLoop = trial_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_loop.rgb)\u000a        if thisTrial_loop != None:\u000a            for paramName in thisTrial_loop.keys():\u000a                exec(paramName + '= thisTrial_loop.' + paramName)    \u000a        \u000a            \u000a        # Define class for setting the feedback image\u000a        class set_feedback:\u000a            options = ['correct', 'wrong']\u000a            feedback = np.random.choice(options, replace=True, p=[0.8, 0.2])\u000a            if feedback=='correct':\u000a                feedback_img = img_correct\u000a            elif feedback=='wrong':\u000a                feedback_img = img_wrong\u000a\u000a            if feedback_img==img_left:\u000a                feedback_side = 'left'\u000a            elif feedback_img==img_right:\u000a                feedback_side = 'right'\u000a                        \u000a        # # Start getting data from the eye tracker\u000a        # tracker.enableEventReporting(True)\u000a        # # Send beginning-of-trial messages to eye tracker data file\u000a        # trial_number = (block_loop.thisN * 200) + trial_loop.thisTrialN # Trial number out of 599 (starts at 0)\u000a        # tracker.sendCommand("record_status_message 'INFERRING, Block %d/3, Trial %d/600 '" % (block_loop.thisN + 1, trial_number + 1))\u000a        # tracker.sendMessage("TRIALID %d" % trial_number)\u000a        # tracker.sendMessage("!V TRIAL_VAR_DATA %d" % trial_number)\u000a\u000a        \u000a        #------Prepare to start Routine "trial"-------\u000a        t = 0\u000a        trialtime = datetime.datetime.now()\u000a        trialClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        img_left_infer.setImage(dir_path+img_left)\u000a        img_right_infer.setImage(dir_path+img_right)\u000a        infer_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        infer_resp.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trialComponents = []\u000a        trialComponents.append(fixation_text)\u000a        trialComponents.append(img_left_infer)\u000a        trialComponents.append(img_right_infer)\u000a        trialComponents.append(infer_resp)\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        # Set indicator variable for whether eye tracker messages were sent during the first loop of the routine\u000a        eye_sync_messages_sent = 0\u000a        \u000a        #-------Start Routine "trial"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = trialClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *fixation_text* updates\u000a            if t >= 0 and fixation_text.status == NOT_STARTED:\u000a                if eye_sync_messages_sent==0:\u000a                    startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                # keep track of start time/frame for later\u000a                fixation_text.tStart = t  # underestimates by a little under one frame\u000a                fixation_text.frameNStart = frameN  # exact frame index\u000a                fixation_text.setAutoDraw(True)\u000a                if eye_sync_messages_sent==0:\u000a                    drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                    # tracker.sendMessage("%d DISPLAY ON" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                    # tracker.sendMessage("SYNCTIME %d" %drawTime)\u000a                    eye_sync_messages_sent = 1\u000a            elif fixation_text.status == STARTED and t>= (0 + (2.0-win.monitorFramePeriod*0.75)):\u000a                fixation_text.setAutoDraw(False)\u000a            \u000a            # *img_left_infer* updates\u000a            if t >= 2.0 and img_left_infer.status == NOT_STARTED:\u000a                if eye_sync_messages_sent==1:\u000a                    startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                # keep track of start time/frame for later\u000a                img_left_infer.tStart = t  # underestimates by a little under one frame\u000a                img_left_infer.frameNStart = frameN  # exact frame index\u000a                img_left_infer.setAutoDraw(True)\u000a            \u000a            # *img_right_infer* updates\u000a            if t >= 2.0 and img_right_infer.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                img_right_infer.tStart = t  # underestimates by a little under one frame\u000a                img_right_infer.frameNStart = frameN  # exact frame index\u000a                img_right_infer.setAutoDraw(True)\u000a                if eye_sync_messages_sent==1:\u000a                    drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                    # tracker.sendMessage("%d DISPLAY ON ITEMS" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                    eye_sync_messages_sent = 2\u000a                      \u000a            # *infer_resp* updates\u000a            if t >= 2.0 and infer_resp.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                infer_resp.tStart = t  # underestimates by a little under one frame\u000a                infer_resp.frameNStart = frameN  # exact frame index\u000a                infer_resp.status = STARTED\u000a                # keyboard checking is just starting\u000a                infer_resp.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            if infer_resp.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['left', 'right'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    infer_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                    infer_resp.rt = infer_resp.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trialComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                # tracker.enableEventReporting(False) # End eye tracker data recording\u000a                # tracker.sendMessage("EXPERIMENT ABORTED")\u000a                # io.quit() # Close iohub\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial"-------\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if infer_resp.keys in ['', [], None]:  # No response was made\u000a           infer_resp.keys=None\u000a        # store data for trial_loop (TrialHandler)\u000a        trial_loop.addData('infer_resp.keys',infer_resp.keys)\u000a        if infer_resp.keys != None:  # we had a response\u000a            trial_loop.addData('infer_resp.rt', infer_resp.rt)\u000a        trial_loop.addData('set_feedback.feedback_img', set_feedback.feedback_img)\u000a        trial_loop.addData('trial_start_time', trialtime)\u000a        \u000a        # Increase correct and incorrect response counters by 1 based on S's response\u000a        if infer_resp.keys=='left' and img_correct==img_left:\u000a            correct_counter += 1\u000a        elif infer_resp.keys=='left' and img_correct==img_right:\u000a            incorrect_counter += 1\u000a        elif infer_resp.keys=='right' and img_correct==img_right:\u000a            correct_counter += 1\u000a        elif infer_resp.keys=='right' and img_correct==img_left:\u000a            incorrect_counter += 1\u000a        \u000a\u000a        #------Prepare to start Routine "trial_post_response"-------\u000a        t = 0\u000a        trial_post_responseClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(3.000000)\u000a        # keep track of which components have finished\u000a        trial_post_responseComponents = []\u000a        trial_post_responseComponents.append(img_left_infer)\u000a        trial_post_responseComponents.append(img_right_infer)\u000a        trial_post_responseComponents.append(selection_arrow_left)\u000a        trial_post_responseComponents.append(selection_arrow_right)\u000a        trial_post_responseComponents.append(feedback_box_left)\u000a        trial_post_responseComponents.append(feedback_box_right)\u000a        for thisComponent in trial_post_responseComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        # Set indicator variable for whether eye tracker messages were sent during the first loop of the routine\u000a        eye_sync_messages_sent = 0\u000a\u000a        #-------Start Routine "trial_post_response"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = trial_post_responseClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a\u000a            # *img_left_infer* updates\u000a            if t >= 0.0 and img_left_infer.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                img_left_infer.tStart = t  # underestimates by a little under one frame\u000a                img_left_infer.frameNStart = frameN  # exact frame index\u000a                img_left_infer.setAutoDraw(True)\u000a            elif img_left_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                img_left_infer.setAutoDraw(False)\u000a            \u000a            # *img_right_infer* updates\u000a            if t >= 0.0 and img_right_infer.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                img_right_infer.tStart = t  # underestimates by a little under one frame\u000a                img_right_infer.frameNStart = frameN  # exact frame index\u000a                img_right_infer.setAutoDraw(True)\u000a            elif img_right_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                img_right_infer.setAutoDraw(False)\u000a            \u000a            if infer_resp.keys == 'left':\u000a                # *selection_arrow_left* updates\u000a                if t >= 0.0 and selection_arrow_left.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==0:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    selection_arrow_left.tStart = t  # underestimates by a little under one frame\u000a                    selection_arrow_left.frameNStart = frameN  # exact frame index\u000a                    selection_arrow_left.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==0:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        # tracker.sendMessage("%d DISPLAY ON SELECTION" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 1\u000a                elif selection_arrow_left.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    if eye_sync_messages_sent==1:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    selection_arrow_left.setAutoDraw(False)\u000a                    if eye_sync_messages_sent==1:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        # tracker.sendMessage("%d DISPLAY ON SELECTION OFF" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 2\u000a            \u000a            if infer_resp.keys == 'right':\u000a                # *selection_arrow_right* updates\u000a                if t >= 0.0 and selection_arrow_right.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==0:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    selection_arrow_right.tStart = t  # underestimates by a little under one frame\u000a                    selection_arrow_right.frameNStart = frameN  # exact frame index\u000a                    selection_arrow_right.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==0:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        # tracker.sendMessage("%d DISPLAY ON SELECTION" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 1\u000a                elif selection_arrow_right.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    if eye_sync_messages_sent==1:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    selection_arrow_right.setAutoDraw(False)\u000a                    if eye_sync_messages_sent==1:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        # tracker.sendMessage("%d DISPLAY ON SELECTION OFF" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 2\u000a            \u000a            if set_feedback.feedback_side == 'left':\u000a                # *feedback_box_left* updates\u000a                if t >= 1.0 and feedback_box_left.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==2:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    feedback_box_left.tStart = t  # underestimates by a little under one frame\u000a                    feedback_box_left.frameNStart = frameN  # exact frame index\u000a                    feedback_box_left.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==2:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        # tracker.sendMessage("%d DISPLAY ON FEEDBACK" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 3\u000a                elif feedback_box_left.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    feedback_box_left.setAutoDraw(False)\u000a            \u000a            if set_feedback.feedback_side == 'right':\u000a                # *feedback_box_right* updates\u000a                if t >= 1.0 and feedback_box_right.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==2:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    feedback_box_right.tStart = t  # underestimates by a little under one frame\u000a                    feedback_box_right.frameNStart = frameN  # exact frame index\u000a                    feedback_box_right.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==2:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        # tracker.sendMessage("%d DISPLAY ON FEEDBACK" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 3\u000a                elif feedback_box_right.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period right\u000a                    feedback_box_right.setAutoDraw(False)\u000a\u000a\u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial_post_responseComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                # tracker.enableEventReporting(False) # End eye tracker data recording\u000a                # tracker.sendMessage("EXPERIMENT ABORTED")\u000a                # io.quit() # Close iohub\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "trial_post_response"-------\u000a        for thisComponent in trial_post_responseComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a        thisExp.nextEntry()\u000a                            \u000a    # completed 5 repeats of 'trial_loop'\u000a    \u000a    if block_loop_counter <= 2: # If this is the first or second cycle of the loop, display the rest break prompt\u000a\u000a        #------Prepare to start Routine "rest_prompt"-------\u000a        t = 0\u000a        rest_promptClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        rest_prompt_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        rest_prompt_resp.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        rest_promptComponents = []\u000a        rest_promptComponents.append(rest_prompt_txt)\u000a        rest_promptComponents.append(rest_prompt_resp)\u000a        for thisComponent in rest_promptComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a\u000a        #-------Start Routine "rest_prompt"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = rest_promptClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *rest_prompt_txt* updates\u000a            if t >= 0.0 and rest_prompt_txt.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                rest_prompt_txt.tStart = t  # underestimates by a little under one frame\u000a                rest_prompt_txt.frameNStart = frameN  # exact frame index\u000a                rest_prompt_txt.setAutoDraw(True)\u000a            \u000a            # *rest_prompt_resp* updates\u000a            if t >= 2.0 and rest_prompt_resp.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                rest_prompt_resp.tStart = t  # underestimates by a little under one frame\u000a                rest_prompt_resp.frameNStart = frameN  # exact frame index\u000a                rest_prompt_resp.status = STARTED\u000a                # keyboard checking is just starting\u000a                rest_prompt_resp.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            if rest_prompt_resp.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    rest_prompt_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                    rest_prompt_resp.rt = rest_prompt_resp.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in rest_promptComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                # tracker.enableEventReporting(False) # End eye tracker data recording\u000a                # tracker.sendMessage("EXPERIMENT ABORTED")\u000a                # io.quit() # CLose iohub\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a\u000a        #-------Ending Routine "rest_prompt"-------\u000a        for thisComponent in rest_promptComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if rest_prompt_resp.keys in ['', [], None]:  # No response was made\u000a           rest_prompt_resp.keys=None\u000a        # store data for thisExp (ExperimentHandler)\u000a        thisExp.addData('rest_prompt_resp.keys',rest_prompt_resp.keys)\u000a        if rest_prompt_resp.keys != None:  # we had a response\u000a            thisExp.addData('rest_prompt_resp.rt', rest_prompt_resp.rt)\u000a\u000a\u000a    thisExp.nextEntry()\u000a    \u000a# completed 3 repeats of 'block_loop'\u000a\u000a\u000a# store data for total number of correct and incorrect responses    \u000athisExp.addData('correct_counter', correct_counter)\u000athisExp.addData('incorrect_counter', incorrect_counter)\u000athisExp.nextEntry()     \u000a\u000a# tracker.setConnectionState(False) # Close and transfer eye-tracking data, then close down eye tracker connection\u000a\u000a\u000a######################## AUCTION ##########################\u000a\u000aif len(prefs)==41 and len(bids)==41: # If S completed the entire binary choice and BDM routines, run the auction\u000a\u000a    # run the auction\u000a    class auction:\u000a        rand_itm = randint(1, (len(prefs))) # pick index for S's chosen item from a random choice\u000a        price = float((randint(1, 300)))/100 # assign a price to the item randomly from between 0.01 and 3 pounds\u000a        bid = prefs[rand_itm][3]\u000a        # check if S's bid for that item was above or below the price\u000a        if bid >= price:\u000a            win_item=True\u000a        elif bid < price:\u000a            win_item=False\u000a\u000a        # set text for the auction screen\u000a        if win_item==True:\u000a            auc_res_txt = u'Congratulations! You won the following item at auction. \u005cnThis was your preferred item out of a randomly selected pair from one of the choice tasks.'\u000a            auc_prc_txt = u'Your bid of \u005cxa3' + '{0:.2f}'.format(bid) + u' matched or exceeded the randomly generated price of \u005cxa3' + '{0:.2f}'.format(price) + '.\u005cn\u005cn[Press space bar to continue]'\u000a            cost = price\u000a        elif win_item==False:\u000a            auc_res_txt = u'Sorry, you did not win the following item at auction. \u005cnThis was your preferred item out of a randomly selected pair from one of the choice tasks.'\u000a            auc_prc_txt = u'Your bid of \u005cxa3' + '{0:.2f}'.format(bid) + u' was lower than the randomly generated price of \u005cxa3' + '{0:.2f}'.format(price) + '.\u005cn\u005cn[Press space bar to continue]'\u000a            cost = 0\u000a\u000a        # find the image path of the auction item\u000a        rand_itm_img = prefs[rand_itm][2]\u000a\u000a    # add up each component of S's payment\u000a    class score:\u000a        base = 25\u000a        rwrd = 0.01\u000a        loss = 0\u000a        rwrd_tot = rwrd * correct_counter\u000a        loss_tot = loss * incorrect_counter\u000a        pre_pymt = base + rwrd_tot - loss_tot\u000a        final_pymt = pre_pymt - auction.cost\u000a\u000a        pymt_expl_bdwn = u'\u005cxa3' + '{0:.2f}'.format(base) + u' base payment'+ u'\u005cn+ \u005cxa3' + '{0:.2f}'.format(rwrd_tot) + ' reward for ' + str(correct_counter) + u' correct responses (\u005cxa3' + '{0:.2f}'.format(rwrd) + u' each)' + u'\u005cn- \u005cxa3' + '{0:.2f}'.format(auction.cost) + ' cost of auction item' \u000a        pymt_expl_tot = u'Your total payment is: \u005cxa3' + '{0:.2f}'.format(final_pymt) + '\u005cn\u005cnThank you for participating!'\u000a\u000a\u000a    # Initialize components for Routine "auc_disp"\u000a    auc_dispClock = core.Clock()\u000a    pic_auc_itm = visual.ImageStim(win=win, name='pic_auc_itm',\u000a        image=dir_path+auction.rand_itm_img, mask=None,\u000a        ori=0, pos=[0, 0], size=None,\u000a        color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a        flipHoriz=False, flipVert=False,\u000a        texRes=128, interpolate=False, depth=0.0)\u000a    auc_txt1 = visual.TextStim(win=win, ori=0, name='auc_txt1',\u000a        text=auction.auc_res_txt, font=u'Arial',\u000a        pos=[0, 0.6], height=0.07, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    auc_txt2 = visual.TextStim(win=win, ori=0, name='auc_txt2',\u000a        text=auction.auc_prc_txt, font=u'Arial',\u000a        pos=[0, -0.6], height=0.07, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a\u000a    #------Prepare to start Routine "auc_disp"-------\u000a    t = 0\u000a    auc_dispClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    key_resp_auc_disp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_auc_disp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    auc_dispComponents = []\u000a    auc_dispComponents.append(pic_auc_itm)\u000a    auc_dispComponents.append(auc_txt1)\u000a    auc_dispComponents.append(auc_txt2)\u000a    for thisComponent in auc_dispComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "auc_disp"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = auc_dispClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *pic_auc_itm* updates\u000a        if t >= 0.2 and pic_auc_itm.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            pic_auc_itm.tStart = t  # underestimates by a little under one frame\u000a            pic_auc_itm.frameNStart = frameN  # exact frame index\u000a            pic_auc_itm.setAutoDraw(True)\u000a        \u000a        # *auc_txt1* updates\u000a        if t >= 0.2 and auc_txt1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            auc_txt1.tStart = t  # underestimates by a little under one frame\u000a            auc_txt1.frameNStart = frameN  # exact frame index\u000a            auc_txt1.setAutoDraw(True)\u000a\u000a        # *auc_txt2* updates\u000a        if t >= 0.2 and auc_txt2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            auc_txt2.tStart = t  # underestimates by a little under one frame\u000a            auc_txt2.frameNStart = frameN  # exact frame index\u000a            auc_txt2.setAutoDraw(True)\u000a        \u000a        # *key_resp_auc_disp* updates\u000a        if t >= 0.2 and key_resp_auc_disp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_auc_disp.tStart = t  # underestimates by a little under one frame\u000a            key_resp_auc_disp.frameNStart = frameN  # exact frame index\u000a            key_resp_auc_disp.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_auc_disp.clock.reset()  # now t=0\u000a        if key_resp_auc_disp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_auc_disp.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_auc_disp.rt = key_resp_auc_disp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in auc_dispComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "auc_disp"-------\u000a    for thisComponent in auc_dispComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_auc_disp.keys in ['', [], None]:  # No response was made\u000a       key_resp_auc_disp.keys=None\u000a    # store data for thisExp (TrialHandler)\u000a    thisExp.addData('auction.win_item', auction.win_item)\u000a    thisExp.addData('auction.price', auction.price)\u000a    thisExp.addData('auction.bid', auction.bid)\u000a    thisExp.addData('auction.rand_itm_img', auction.rand_itm_img)\u000a    thisExp.addData('score.base', score.base)\u000a    thisExp.addData('score.rwrd', score.rwrd)\u000a    thisExp.addData('score.loss', score.loss)\u000a    thisExp.addData('correct_counter', correct_counter)\u000a    thisExp.addData('incorrect_counter', incorrect_counter)\u000a    thisExp.addData('score.final_pymt', score.final_pymt)\u000a    thisExp.nextEntry()\u000a\u000a\u000a    # Initialize components for Routine "pymt_disp"\u000a    pymt_dispClock = core.Clock()\u000a    pymt_disp_txt1 = visual.TextStim(win=win, ori=0, name='pymt_disp_txt1',\u000a        text=score.pymt_expl_bdwn, font=u'Arial',\u000a        pos=[0, 0.6], height=0.07, wrapWidth=1.5,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    pymt_disp_txt2 = visual.TextStim(win=win, ori=0, name='pymt_disp_txt2',\u000a        text=score.pymt_expl_tot, font=u'Arial',\u000a        pos=[0, -0.65], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    #------Prepare to start Routine "pymt_disp"-------\u000a    t = 0\u000a    pymt_dispClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    key_resp_pymt_disp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_pymt_disp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    pymt_dispComponents = []\u000a    pymt_dispComponents.append(pic_auc_itm)\u000a    pymt_dispComponents.append(pymt_disp_txt1)\u000a    pymt_dispComponents.append(pymt_disp_txt2)\u000a    pymt_dispComponents.append(key_resp_pymt_disp)\u000a    for thisComponent in pymt_dispComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "pymt_disp"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = pymt_dispClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        if auction.win_item==True:\u000a            # *pic_auc_itm* updates\u000a            if t >= 0.0 and pic_auc_itm.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                pic_auc_itm.tStart = t  # underestimates by a little under one frame\u000a                pic_auc_itm.frameNStart = frameN  # exact frame index\u000a                pic_auc_itm.setAutoDraw(True)\u000a\u000a        # *pymt_disp_txt1* updates\u000a        if t >= 0.0 and pymt_disp_txt1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            pymt_disp_txt1.tStart = t  # underestimates by a little under one frame\u000a            pymt_disp_txt1.frameNStart = frameN  # exact frame index\u000a            pymt_disp_txt1.setAutoDraw(True)\u000a\u000a        # *pymt_disp_txt2* updates\u000a        if t >= 0.0 and pymt_disp_txt2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            pymt_disp_txt2.tStart = t  # underestimates by a little under one frame\u000a            pymt_disp_txt2.frameNStart = frameN  # exact frame index\u000a            pymt_disp_txt2.setAutoDraw(True)\u000a        \u000a        # *key_resp_pymt_disp* updates\u000a        if t >= 3.0 and key_resp_pymt_disp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_pymt_disp.tStart = t  # underestimates by a little under one frame\u000a            key_resp_pymt_disp.frameNStart = frameN  # exact frame index\u000a            key_resp_pymt_disp.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_pymt_disp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if key_resp_pymt_disp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_pymt_disp.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_pymt_disp.rt = key_resp_pymt_disp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in pymt_dispComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "pymt_disp"-------\u000a    for thisComponent in pymt_dispComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_pymt_disp.keys in ['', [], None]:  # No response was made\u000a       key_resp_pymt_disp.keys=None\u000a\u000aelse: # If S didn't complete the entire binary choice and BDM routines during this session, prompt a manual auction\u000a    # Initialize components for Routine "auc_manual"\u000a    auc_manualClock = core.Clock()\u000a    auc_manual_txt = visual.TextStim(win=win, ori=0, name='auc_manual_txt',\u000a        text=u'Thank you! This completes the experiment. The experimenter will now run the auction and calculate your final payment.\u005cn\u005cnCorrect: ' + str(correct_counter) + '\u005cnIncorrect: ' + str(incorrect_counter),    font=u'Arial',\u000a        pos=[0, 0], height=0.07, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    #------Prepare to start Routine "auc_manual"-------\u000a    t = 0\u000a    auc_manualClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    auc_manualComponents = []\u000a    auc_manualComponents.append(auc_manual_txt)\u000a    for thisComponent in auc_manualComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "auc_manual"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = auc_manualClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *auc_manual_txt* updates\u000a        if t >= 0.0 and auc_manual_txt.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            auc_manual_txt.tStart = t  # underestimates by a little under one frame\u000a            auc_manual_txt.frameNStart = frameN  # exact frame index\u000a            auc_manual_txt.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in auc_manualComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "auc_manual"-------\u000a    for thisComponent in auc_manualComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000athisExp.nextEntry()\u000a\u000a# io.quit() # Close iohub\u000a\u000a\u000awin.close()\u000acore.quit()\u000a
p9235
sg9107
(lp9236
sg9109
I85328720
sg10
S'binary'
p9237
sg6
g9111
sg9112
I1
sg52
I01
sg53
g54
sg9113
g1
(g9114
g9115
(dp9238
g26
g9118
(g9119
g92
g9120
S'b'
tRp9239
(I1
(I40
I1
tg9122
I00
S'\xcd\xcc\xcc?\x00\x00\x90@\x00\x00\xc0@\x00\x00\xc0@\x00\x00\xc0@\x00\x00\xc0@\x00\x00\xb0@\x00\x00\xa0@ff\x96@\xcd\xccl@\xcd\xcc\x9c@\x00\x00\xc0@\x00\x00\xc0@ff\xe6?\x00\x00\x00@\x00\x00\xc0@\x00\x00\xa0@\x00\x00\xc0@\x00\x00\xc0@\x9a\x99\xa9@\x00\x00\xc0@\x00\x00\xc0@\x9a\x99\xa9@\x00\x00@@\x00\x00\x80?\x00\x00\xc0@\x00\x00\xc0@ff\x06@\x00\x00 @\x00\x00\xc0@\x00\x00\x80?ff&@33\x93@\x00\x00\xc0@\xcd\xcc,@ff\xe6?33\xf3?\xcd\xcc\xbc@\x00\x00\xc0@\x9a\x99\x19@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg9117
g9118
(g9119
g92
g9120
S'b'
tRp9240
(I1
(I40
I1
tg9122
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg25
g9118
(g9119
g92
g9120
S'b'
tRp9241
(I1
(I40
I1
tg9122
I00
S'm\x99\xd1@h"R@g\xab\xaa?\xbcE\xc4?\xa0\x88\x18@\xd9\xd2\xac?\xc0\xbb\x9b?\x86Et@\xb4\xcd\x0c@\x8d\xbc\xc3@d\xd0\xec?r\xb5\x9b?\xb56\xb3@\xb6\xff\xbf@\x08\x11\x05A\xb6\x1b\xc2?\xacU\xd5@\xd8\xcd\x0c@\xa1\x9d\xf9?\x03\x91\x08@\x87\xbe{?\x9d\xf0\x8e?:\xdf\xbd?cz\xef@\xf7\x989@\xae\x9a\x99?\x82\x11\xb1?\xd1G\x94@:gv@d\xcb\xcc?\xbe\x9a\x99?\xdbx\xb7?\xb6\xab\xca?\xf1f\x06@\xda3S@t\xbb+@eF\x04@\xd8\x13\x91?cK\xc4?\xb3[\xf5?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg28
g9118
(g9119
g92
g9120
S'b'
tRp9242
(I1
(I40
I1
tg9122
I00
S'333@\xcd\xccl@\x9a\x999@\x00\x00@@33S@\x9a\x999@\x9a\x99\x89@333@33\x83@\x9a\x99Y@33\x83@fff@\xcd\xcc,@\x00\x00@@\x9a\x99Y@\xcd\xccl@\xcd\xcc,@33S@\x00\x00\x80@\x9a\x99Y@\x00\x00@@33s@33\x83@33S@\x9a\x99Y@333@\x9a\x99y@\x9a\x999@fff@ffF@33S@\xcd\xccL@\x9a\x999@ffF@fff@\x00\x00@@\x00\x00@@33s@333@333@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg24
g9118
(g9119
g92
g9120
S'b'
tRp9243
(I1
(I40
I1
tg60
(S'O4'
I0
I1
tRp9244
(I3
S'|'
NNNI-1
I-1
I63
tbI00
S' i\x89\x04\xa0e\xb0\x0c\xc0c\xb0\x0c\xc0f\xb0\x0c\x80\xc0\x81\x0c@\x8f\xae\x0c\xa0\xfa\x83\x0c\xc0\xc0\x81\x0c`\x8f\xae\x0c\xe0\xdc\x88\x04\xa0\x8c\xae\x0c g\xb0\x0c\x80\x8f\xae\x0c\x00f\xb0\x0c\x80b\xb0\x0c\x80`\xb0\x0c\x00\xf5\x83\x0c\xc0e\xb0\x0c@\xdc\x88\x04\xc0\xd9\x88\x04\xc0\xdd\x88\x04\x00\xdb\x88\x04\x00\xdc\x88\x04\x00\xd2\x88\x04\xc0\xdf\x88\x04@\xdb\x88\x04\xc0\xde\x88\x04\xc0\xdb\x88\x04@\xde\x88\x04\x80Q\x82\x0c\x80\xdd\x88\x04\x00\xdd\x88\x04\x80\xdc\x88\x04@\xda\x88\x04@\xdf\x88\x04@\xdd\x88\x04\x80\xde\x88\x04\xc0\xdc\x88\x04\x80\xdf\x88\x04\x80\xdb\x88\x04'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg27
g9118
(g9119
g92
g9120
S'b'
tRp9245
(I1
(I40
I1
tg9122
I00
S"\xaa\xf1\x0eA\xfe\xd4\xec@\xee|\xbf@P\x8d\xd7?\x83\xc0\xea?\xe9&\xb1?\xc9vv@T\xe3\x1d@/\xddL@d;\xeb@\xd5x\x17A\xa8\xc6\x0b@\xc9v\x06@\xbaIt@\xee|\x8f@\x87\x16\x11@P\x8d\xd7?u\x93\xc8?\x1dZ\xc4?d;\x93@B`\xb5?\xc9vv@u\x938@\xdb\xf9^@\xc5 \xc0?T\xe3]@u\x93\x18@\x87\x16\xa1@u\x93(@w\xbe\xc3@\xfc\xa9)@w\xbe\xb3@P\x8d\xf7?b\x10\x00@d;\x83@\xee|'@B`\xf5?B`5@\xa8\xc6\x9b?\xfc\xa9y@"
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg9125
g9118
(g9119
g92
g9120
S'b'
tRp9246
(I1
(I40
I1
tg9122
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00@\x00\x00@@\x00\x00\x80@\x00\x00\xa0@\x00\x00\xc0@\x00\x00\xe0@\x00\x00\x00A\x00\x00\x10A\x00\x00 A\x00\x000A\x00\x00@A\x00\x00PA\x00\x00`A\x00\x00pA\x00\x00\x80A\x00\x00\x88A\x00\x00\x90A\x00\x00\x98A\x00\x00\xa0A\x00\x00\xa8A\x00\x00\xb0A\x00\x00\xb8A\x00\x00\xc0A\x00\x00\xc8A\x00\x00\xd0A\x00\x00\xd8A\x00\x00\xe0A\x00\x00\xe8A\x00\x00\xf0A\x00\x00\xf8A\x00\x00\x00B\x00\x00\x04B\x00\x00\x08B\x00\x00\x0cB\x00\x00\x10B\x00\x00\x14B\x00\x00\x18B\x00\x00\x1cB'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp9247
(dp9248
g9130
(dp9249
g26
I01
sg9117
I01
sg28
I01
sg25
I01
sg24
I00
sg9125
I01
sg27
I01
ssg9132
g9233
sg9133
(lp9250
g9117
ag9125
ag24
ag25
ag26
ag27
ag28
asg9135
(lp9251
I40
aI1
asbsg9137
Vsequential
p9252
sg9139
g91
(g92
(I0
tS'b'
tRp9253
(I1
(I40
I1
tg98
I00
S'\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00\x04\x00\x00\x00\x05\x00\x00\x00\x06\x00\x00\x00\x07\x00\x00\x00\x08\x00\x00\x00\t\x00\x00\x00\n\x00\x00\x00\x0b\x00\x00\x00\x0c\x00\x00\x00\r\x00\x00\x00\x0e\x00\x00\x00\x0f\x00\x00\x00\x10\x00\x00\x00\x11\x00\x00\x00\x12\x00\x00\x00\x13\x00\x00\x00\x14\x00\x00\x00\x15\x00\x00\x00\x16\x00\x00\x00\x17\x00\x00\x00\x18\x00\x00\x00\x19\x00\x00\x00\x1a\x00\x00\x00\x1b\x00\x00\x00\x1c\x00\x00\x00\x1d\x00\x00\x00\x1e\x00\x00\x00\x1f\x00\x00\x00 \x00\x00\x00!\x00\x00\x00"\x00\x00\x00#\x00\x00\x00$\x00\x00\x00%\x00\x00\x00&\x00\x00\x00\'\x00\x00\x00'
tbsg9141
I01
sg9142
I1
sg9143
I-1
sg9144
(lp9254
g1
(g9146
g9115
(dp9255
g79
g380
sg80
g381
stRp9256
ag1
(g9146
g9115
(dp9257
g79
g389
sg80
g390
stRp9258
ag1
(g9146
g9115
(dp9259
g79
g398
sg80
g399
stRp9260
ag1
(g9146
g9115
(dp9261
g79
g407
sg80
g408
stRp9262
ag1
(g9146
g9115
(dp9263
g79
g416
sg80
g417
stRp9264
ag1
(g9146
g9115
(dp9265
g79
g425
sg80
g426
stRp9266
ag1
(g9146
g9115
(dp9267
g79
g434
sg80
g435
stRp9268
ag1
(g9146
g9115
(dp9269
g79
g443
sg80
g444
stRp9270
ag1
(g9146
g9115
(dp9271
g79
g452
sg80
g453
stRp9272
ag1
(g9146
g9115
(dp9273
g79
g461
sg80
g462
stRp9274
ag1
(g9146
g9115
(dp9275
g79
g470
sg80
g471
stRp9276
ag1
(g9146
g9115
(dp9277
g79
g479
sg80
g480
stRp9278
ag1
(g9146
g9115
(dp9279
g79
g488
sg80
g489
stRp9280
ag1
(g9146
g9115
(dp9281
g79
g497
sg80
g498
stRp9282
ag1
(g9146
g9115
(dp9283
g79
g506
sg80
g507
stRp9284
ag1
(g9146
g9115
(dp9285
g79
g515
sg80
g516
stRp9286
ag1
(g9146
g9115
(dp9287
g79
g524
sg80
g525
stRp9288
ag1
(g9146
g9115
(dp9289
g79
g533
sg80
g534
stRp9290
ag1
(g9146
g9115
(dp9291
g79
g542
sg80
g543
stRp9292
ag1
(g9146
g9115
(dp9293
g79
g551
sg80
g552
stRp9294
ag1
(g9146
g9115
(dp9295
g79
g560
sg80
g561
stRp9296
ag1
(g9146
g9115
(dp9297
g79
g569
sg80
g570
stRp9298
ag1
(g9146
g9115
(dp9299
g79
g578
sg80
g579
stRp9300
ag1
(g9146
g9115
(dp9301
g79
g587
sg80
g588
stRp9302
ag1
(g9146
g9115
(dp9303
g79
g596
sg80
g597
stRp9304
ag1
(g9146
g9115
(dp9305
g79
g605
sg80
g606
stRp9306
ag1
(g9146
g9115
(dp9307
g79
g614
sg80
g615
stRp9308
ag1
(g9146
g9115
(dp9309
g79
g623
sg80
g624
stRp9310
ag1
(g9146
g9115
(dp9311
g79
g632
sg80
g633
stRp9312
ag1
(g9146
g9115
(dp9313
g79
g641
sg80
g642
stRp9314
ag1
(g9146
g9115
(dp9315
g79
g650
sg80
g651
stRp9316
ag1
(g9146
g9115
(dp9317
g79
g659
sg80
g660
stRp9318
ag1
(g9146
g9115
(dp9319
g79
g668
sg80
g669
stRp9320
ag1
(g9146
g9115
(dp9321
g79
g677
sg80
g678
stRp9322
ag1
(g9146
g9115
(dp9323
g79
g686
sg80
g687
stRp9324
ag1
(g9146
g9115
(dp9325
g79
g695
sg80
g696
stRp9326
ag1
(g9146
g9115
(dp9327
g79
g704
sg80
g705
stRp9328
ag1
(g9146
g9115
(dp9329
g79
g713
sg80
g714
stRp9330
ag1
(g9146
g9115
(dp9331
g79
g722
sg80
g723
stRp9332
ag1
(g9146
g9115
(dp9333
g79
g731
sg80
g732
stRp9334
asg9227
Nsg9228
g735
sg9229
I40
sg9230
I0
sg9231
I40
sg9232
I01
sbag1
(g9102
g3
NtRp9335
(dp9336
g9105
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a\u000a######################## CITATIONS ########################## \u000a##### Binary choice, BDM, auction routines, and instructions are modified from:\u000a##### \u000a##### De Martino, B., Fleming, S. M., Garrett, N., & Dolan, R. J. (2012). Confidence in value-based choice. Nature Neuroscience, 16(1), 105-110. \u000a#####\u000a##### Food item images are original.\u000a\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.80.01), July 16, 2014, at 03:20\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things bdm STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000afrom pyglet.window import key # to detect key state, whether key is held down, to move slider on key hold\u000aimport pandas as pd\u000aimport datetime\u000afrom psychopy.iohub import launchHubServer\u000aimport pylink\u000a\u000a# Initialize IOHub for eye tracker\u000a# io=launchHubServer(iohub_config_name='iohub_config.yaml')\u000a# tracker = io.devices.tracker\u000a\u000a# Store info about the experiment session\u000aexpName = 'infer_design1_no_eyetracking'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u'', u'eye': u'', u'glasses': u'', u'contacts': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Setup filename for saving\u000afilename = 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# set up variable to track current state of key press, to move slider when keys held down\u000akeyState=key.KeyStateHandler()\u000a\u000a# Setup the Window\u000ascreenwidth = 1920\u000ascreenheight = 1080\u000awin = visual.Window(size=(screenwidth, screenheight), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color='black', colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000awin.winHandle.push_handlers(keyState)\u000a\u000a\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a\u000a######################## COMPONENTS ##########################\u000a\u000a# Set up directory path for stimuli. This avoids us having to put the entire image path in the conditions spreadsheet.\u000adir_path = 'stimuli/itempics/modified/small/'\u000a\u000a# Initialize components for Routine "instr_main"\u000ainstr_mainClock = core.Clock()\u000ainstr_main_txt = visual.TextStim(win=win, ori=0, name='instr_main_txt',\u000a    text=u'Welcome!\u005cn\u005cnPlease read the instructions carefully and get the experimenter when you\u005c're finished. Take as much time as you need.',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "instr_bdm"\u000ainstr_bdmClock = core.Clock()\u000ainstr_bdm_txt = visual.TextStim(win=win, ori=0, name='instr_bdm_txt',\u000a    text=u'The bidding task is about to begin. Use the LEFT and RIGHT arrow keys to move the cursor along the slider, then press the DOWN arrow to enter your bid.\u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "fixation"\u000afixationClock = core.Clock()\u000afixation_text = visual.TextStim(win=win, ori=0, name='fixation_text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "bdm"\u000abdmClock = core.Clock()\u000abdm_pic = visual.ImageStim(win=win, name='bdm_pic',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=0.0)\u000abdm_bid = visual.RatingScale(win=win, name='bdm_bid', marker=u'triangle', markerColor=u'orange', leftKeys=None, rightKeys=None,\u000a    size=1.0, pos=[0.0, -0.6], low=0, high=3, precision=100, labels=[u'\u005cxa30', u'\u005cxa33'],\u000a    scale=u'', markerStart=u'1.5', tickHeight=u'1', showAccept=False, acceptKeys=[u'down', u'return'])\u000a\u000a# Initialize components for Routine "instr_choice"\u000ainstr_choiceClock = core.Clock()\u000ainstr_choice_txt = visual.TextStim(win=win, ori=0, name='instr_choice_txt',\u000a    text=u'The choice task is about to begin. Choose your preferred item by pressing the LEFT or RIGHT arrow keys, then use the slider to indicate how confident you are that you made the best choice.\u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "choice"\u000achoiceClock = core.Clock()\u000achoice_pic_left = visual.ImageStim(win=win, name='choice_pic_left',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[-0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=0.0)\u000achoice_pic_right = visual.ImageStim(win=win, name='choice_pic_right',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=-1.0)\u000a\u000a# Initialize components for Routine "choice_selection"\u000achoice_selectionClock = core.Clock()\u000astar_left_selection = visual.TextStim(win=win, ori=0, name='star_left_selection',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[-0.5, -0.8], height=0.5, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=-2.0)\u000astar_right_selection = visual.TextStim(win=win, ori=0, name='star_right_selection',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[0.5, -0.8], height=0.5, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=-3.0)\u000a\u000a# Initialize components for Routine "confidence"\u000aconfidenceClock = core.Clock()\u000aconfidence_rating = visual.RatingScale(win=win, name='confidence_rating', marker=u'triangle', markerColor=u'orange', leftKeys=None, rightKeys=None,\u000a    size=1.0, pos=[0.0, 0.0], low=1, high=6, precision=20,\u000a    scale=u'', markerStart=u'3.5', tickHeight=u'1', showAccept=False, acceptKeys=[u'down', u'return'])\u000a\u000a# Initialize components for Routine "instr_infer_intro"\u000ainstr_infer_introClock = core.Clock()\u000ainstr_infer_intro_txt = visual.TextStim(win=win, ori=0, name='instr_infer_intro_txt',\u000a    text=u'Thanks! Now please get the experimenter, who will give you the instructions for the second part of the experiment. \u005cn\u005cnPlease read these instructions carefully and get the experimenter again when you\u005c're finished. Take as much time as you need.',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=1.5,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "instr_infer_practice"\u000ainstr_infer_practiceClock = core.Clock()\u000ainstr_infer_practice_txt = visual.TextStim(win=win, ori=0, name='instr_infer_practice_txt',\u000a    text=u'First, you\u005c'll do some practice trials. These are just for you to get used to the task; your responses won\u005c't count. \u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=1.5,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "instr_infer"\u000ainstr_inferClock = core.Clock()\u000ainstr_infer_txt = visual.TextStim(win=win, ori=0, name='instr_infer_txt',\u000a    text=u'Great! Now that you\u005c've done some practice trials, we\u005c're ready to start the real trials. Please call the experimenter into the room.',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=1.5,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "get_ready"\u000aget_readyClock = core.Clock()\u000aget_ready_text = visual.TextStim(win=win, ori=0, name='get_ready_text',\u000a    text=u'Get ready!',    font=u'Arial',\u000a    pos=[0, 0], height=0.12, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000aimg_left_infer = visual.ImageStim(win=win, name='img_left_infer',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[-0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=0.0)\u000aimg_right_infer = visual.ImageStim(win=win, name='img_right_infer',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=-1.0)\u000a\u000a# Initialize components for Routine "trial_post_response"\u000atrial_post_responseClock = core.Clock()\u000aselection_arrow_left = visual.TextStim(win=win, ori=0, name='selection_arrow_left',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[-0.5, -0.09], height=0.5, wrapWidth=None,\u000a    color=u'red', colorSpace=u'rgb', opacity=1,\u000a    depth=-2.0)\u000aselection_arrow_right = visual.TextStim(win=win, ori=0, name='selection_arrow_right',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[0.5, -0.09], height=0.5, wrapWidth=None,\u000a    color=u'red', colorSpace=u'rgb', opacity=1,\u000a    depth=-3.0)\u000afeedback_box_left = visual.Rect(win=win, name='feedback_box_left',\u000a    width=[0.9, 0.9][0], height=[0.9, 0.9][1],\u000a    ori=0, pos=[-0.5, 0],\u000a    lineWidth=5, lineColor=u'yellow', lineColorSpace=u'rgb',\u000a    fillColor=None, fillColorSpace=u'rgb',\u000a    opacity=1, depth=-4.0, interpolate=True)\u000afeedback_box_right = visual.Rect(win=win, name='feedback_box_right',\u000a    width=[0.9, 0.9][0], height=[0.9, 0.9][1],\u000a    ori=0, pos=[0.5, 0],\u000a    lineWidth=5, lineColor=u'yellow', lineColorSpace=u'rgb',\u000a    fillColor=None, fillColorSpace=u'rgb',\u000a    opacity=1, depth=-5.0, interpolate=True)\u000a\u000a# Initialize components for Routine "rest_prompt"\u000arest_promptClock = core.Clock()\u000arest_prompt_txt = visual.TextStim(win=win, ori=0, name='rest_prompt_txt',\u000a    text=u'Great! Now take a rest and press the space bar when you\u005cu2019re ready to begin the next block.',    font=u'Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create counters for the number of correct and incorrect guesses made by subjects to determine extra payment.\u000acorrect_counter = 0\u000aincorrect_counter = 0\u000a\u000a# Create list of lists to store binary choice and BDM data to generate food reward at the end of the experiment\u000aprefs = [['left', 'right', 'choice', 'bid']]\u000abids = [['item', 'bid']] # For the bids collected during the first BDM routine, at the beginning of the experiment\u000a\u000a### CHOICE & INFERENCE RANDOMIZATION ###\u000a\u000a# Define two functions to generate constrained pseudorandom sequences of item pair presentations for the binary choice and inference\u000a# parts of the task. The constraint ensures that the same pair of items does not appear twice in a row (flipped or not).\u000a# In the conditions spreadsheet that the item pairs are drawn from, the flipped version of the same item pair is 20\u000a# rows apart.\u000a\u000a# Binary choice randomization\u000adef genseq_choice():\u000a    done = False\u000a    while done==False:\u000a        counter = 0\u000a        ans = np.random.choice(40, 40, replace=False) # Generate a pseudorandom sequence of 40 numbers\u000a        for x in range(1,40):\u000a            if (ans[x]-ans[x-1]) % 20 == 0: # Is the difference between any sequential numbers divisible by 20?\u000a                counter += 1\u000a        if counter==0: # If not, end the loop and return the array\u000a            done = True\u000a            return ans\u000a        else: # If so, continue the loop and try again\u000a            done = False\u000a\u000a# Inference practice block randomization\u000adef genseq_infer_practice():\u000a    done = False\u000a    while done==False:\u000a        counter = 0\u000a        ans = np.random.choice(14, 14, replace=False) # Generate a pseudorandom sequence of 200 numbers\u000a        for x in range(1,14):\u000a            if (ans[x]-ans[x-1]) % 7 == 0: # Is the difference between any sequential numbers divisible by 20?\u000a                counter += 1\u000a        if counter==0: # If not, end the loop and return the array\u000a            done = True\u000a            return ans\u000a        else: # If so, continue the loop and try again\u000a            done = False\u000a\u000a# Inference randomization\u000adef genseq_infer():\u000a    done = False\u000a    while done==False:\u000a        counter = 0\u000a        ans = np.random.choice(200, 200, replace=False) # Generate a pseudorandom sequence of 200 numbers\u000a        for x in range(1,200):\u000a            if (ans[x]-ans[x-1]) % 20 == 0: # Is the difference between any sequential numbers divisible by 20?\u000a                counter += 1\u000a        if counter==0: # If not, end the loop and return the array\u000a            done = True\u000a            return ans\u000a        else: # If so, continue the loop and try again\u000a            done = False\u000a\u000a\u000a# Set independent sequences for each of the two choice blocks, the inference practice block, and the three inference rest blocks. Each rest block contains 10 presentations of\u000a# each pair.\u000a\u000achoiceseq = genseq_choice()\u000apracticeseq = genseq_infer_practice()\u000ablock1seq = genseq_infer()\u000ablock2seq = genseq_infer()\u000ablock3seq = genseq_infer()\u000a\u000a\u000a# Choose a pilot participant whose choices will form the basis of the learning task\u000apartners = ['P1','P2','P3','P4','P5','P6','P8','P9','P10','P11','P12'] # List of pilot participants, P7 excluded for perfectly inconsistent choices\u000apartner = np.random.choice(partners,1) # Choose one at random\u000apartner_file = 'conditions/choices/infer_design1_value_pairs_' + partner[0] + '.csv' # Path to that participant's choice data\u000a\u000a# Create separate CSV files, one for each choice, practice, and rest block, with the item pairs in the pseudorandomly generated order.\u000a# These CSV files will be used as PsychoPy's conditions spreadsheets and run sequentially in the choice, practice, and inference loops below.\u000a\u000a\u000achoicecond_src = pd.read_csv('conditions/choice_design1_binary.csv', index_col=None, header=0)\u000achoicecond = choicecond_src.copy()\u000afor x in range(40):\u000a    seq = choiceseq[x]\u000a    choicecond.iloc[x] = choicecond_src.iloc[seq]\u000achoicecond.to_csv(path_or_buf=filename+'_choicecond.csv', index=False)\u000a\u000apracticecond_src = pd.read_csv('conditions/choices/infer_design1_value_pairs_practice.csv', index_col=None, header=0)\u000apracticecond = practicecond_src.copy()\u000afor x in range(14):\u000a    seq = practiceseq[x]\u000a    practicecond.iloc[x] = practicecond_src.iloc[seq]\u000apracticecond.to_csv(path_or_buf=filename+'_practicecond.csv', index=False)\u000a\u000ablock1cond_src = pd.read_csv(partner_file, index_col=None, header=0)\u000ablock1cond = block1cond_src.copy()\u000afor x in range(200):\u000a    seq = block1seq[x]\u000a    block1cond.iloc[x] = block1cond_src.iloc[seq]\u000ablock1cond.to_csv(path_or_buf=filename+'_block1cond.csv', index=False)\u000a\u000ablock2cond_src = pd.read_csv(partner_file, index_col=None, header=0)\u000ablock2cond = block2cond_src.copy()\u000afor x in range(200):\u000a    seq = block2seq[x]\u000a    block2cond.iloc[x] = block2cond_src.iloc[seq]\u000ablock2cond.to_csv(path_or_buf=filename+'_block2cond.csv', index=False)\u000a\u000ablock3cond_src = pd.read_csv(partner_file, index_col=None, header=0)\u000ablock3cond = block3cond_src.copy()\u000afor x in range(200):\u000a    seq = block3seq[x]\u000a    block3cond.iloc[x] = block3cond_src.iloc[seq]\u000ablock3cond.to_csv(path_or_buf=filename+'_block3cond.csv', index=False)\u000a\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instr_main"-------\u000at = 0\u000ainstr_mainClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_main_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_main_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_mainComponents = []\u000ainstr_mainComponents.append(instr_main_txt)\u000ainstr_mainComponents.append(instr_main_resp)\u000afor thisComponent in instr_mainComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_main"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_mainClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_main_txt* updates\u000a    if t >= 0.0 and instr_main_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_main_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_main_txt.frameNStart = frameN  # exact frame index\u000a        instr_main_txt.setAutoDraw(True)\u000a    \u000a    # *instr_main_resp* updates\u000a    if t >= 5.0 and instr_main_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_main_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_main_resp.frameNStart = frameN  # exact frame index\u000a        instr_main_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_main_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_main_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_main_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_main_resp.rt = instr_main_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_mainComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_main"-------\u000afor thisComponent in instr_mainComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_main_resp.keys in ['', [], None]:  # No response was made\u000a   instr_main_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_main_resp.keys',instr_main_resp.keys)\u000aif instr_main_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_main_resp.rt', instr_main_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a\u000a#------Prepare to start Routine "instr_bdm"-------\u000at = 0\u000ainstr_bdmClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_bdm_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_bdm_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_bdmComponents = []\u000ainstr_bdmComponents.append(instr_bdm_txt)\u000ainstr_bdmComponents.append(instr_bdm_resp)\u000afor thisComponent in instr_bdmComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_bdm"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_bdmClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_bdm_txt* updates\u000a    if t >= 0.0 and instr_bdm_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_bdm_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_bdm_txt.frameNStart = frameN  # exact frame index\u000a        instr_bdm_txt.setAutoDraw(True)\u000a    \u000a    # *instr_bdm_resp* updates\u000a    if t >= 2.0 and instr_bdm_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_bdm_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_bdm_resp.frameNStart = frameN  # exact frame index\u000a        instr_bdm_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_bdm_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_bdm_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space', 's'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_bdm_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_bdm_resp.rt = instr_bdm_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_bdmComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_bdm"-------\u000afor thisComponent in instr_bdmComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_bdm_resp.keys in ['', [], None]:  # No response was made\u000a   instr_bdm_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_bdm_resp.keys',instr_bdm_resp.keys)\u000athisExp.addData('partnered_pilot_participant', partner)\u000aif instr_bdm_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_bdm_resp.rt', instr_bdm_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## BDM LOOP 1 ##########################\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000abdm_loop1 = data.TrialHandler(nReps=1, method=u'random', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'conditions/choice_design1_bdm.xlsx'),\u000a    seed=None, name='bdm_loop1')\u000athisExp.addLoop(bdm_loop1)  # add the loop to the experiment\u000athisbdm_loop1 = bdm_loop1.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisbdm_loop1.rgb)\u000aif thisbdm_loop1 != None:\u000a    for paramName in thisbdm_loop1.keys():\u000a        exec(paramName + '= thisbdm_loop1.' + paramName)\u000a\u000a# Check if the 'skip' key was pressed in the instructions routine; if so, end the loop and move on to the inference task\u000aif instr_bdm_resp.keys=='s':\u000a    bdm_loop1.finished = True\u000a\u000afor thisbdm_loop1 in bdm_loop1:\u000a    currentLoop = bdm_loop1\u000a    # abbreviate parameter names if possible (e.g. rgb = thisbdm_loop1.rgb)\u000a    if thisbdm_loop1 != None:\u000a        for paramName in thisbdm_loop1.keys():\u000a            exec(paramName + '= thisbdm_loop1.' + paramName)\u000a    \u000a    #------Prepare to start Routine "bdm"-------\u000a    t = 0\u000a    bdmClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    bdm_pic.setImage(dir_path+bdm_img)\u000a    bdm_bid.reset()\u000a    # jitter the starting position of the BDM scale from a uniform distribution between 1 and 2, rounded to the nearest decimal place\u000a    bdm_marker_start = float(np.round(np.random.uniform(1, 2, 1)[0], 1))\u000a    bdm_bid.setMarkerPos(bdm_marker_start)\u000a    # keep track of which components have finished\u000a    bdmComponents = []\u000a    bdmComponents.append(fixation_text)\u000a    bdmComponents.append(bdm_pic)\u000a    bdmComponents.append(bdm_bid)\u000a    for thisComponent in bdmComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "bdm"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = bdmClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation_text* updates\u000a        if t >= 0 and fixation_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation_text.tStart = t  # underestimates by a little under one frame\u000a            fixation_text.frameNStart = frameN  # exact frame index\u000a            fixation_text.setAutoDraw(True)\u000a        elif fixation_text.status == STARTED and t>= (0 + (1.0-win.monitorFramePeriod*0.75)):\u000a            fixation_text.setAutoDraw(False)\u000a\u000a        # *bdm_pic* updates\u000a        if t >= 1.0 and bdm_pic.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bdm_pic.tStart = t  # underestimates by a little under one frame\u000a            bdm_pic.frameNStart = frameN  # exact frame index\u000a            bdm_pic.setAutoDraw(True)\u000a        # *bdm_bid* updates\u000a        if t >= 1.0:\u000a            bdm_bid.draw()\u000a            continueRoutine = bdm_bid.noResponse\u000a            if bdm_bid.noResponse == False:\u000a                bdm_bid.response = bdm_bid.getRating()\u000a                bdm_bid.rt = bdm_bid.getRT()\u000a            elif bdm_bid.noResponse==True:\u000a                if keyState[key.LEFT]==True and bdm_bid.markerPlacedAt >0.01:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt - 0.02\u000a                    bdm_bid.draw()\u000a                elif keyState[key.LEFT]==True and bdm_bid.markerPlacedAt==0.01:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt - 0.01\u000a                    bdm_bid.draw()\u000a                elif keyState[key.RIGHT]==True and bdm_bid.markerPlacedAt <2.99:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt + 0.02\u000a                    bdm_bid.draw()\u000a                elif keyState[key.RIGHT]==True and bdm_bid.markerPlacedAt==2.99:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt + 0.01\u000a                    bdm_bid.draw()\u000a                    \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in bdmComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "bdm"-------\u000a    for thisComponent in bdmComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # store data for bdm (TrialHandler)\u000a    bdm_loop1.addData('bdm_bid1.response', bdm_bid.getRating())\u000a    bdm_loop1.addData('bdm_bid1.rt', bdm_bid.getRT())\u000a    bdm_loop1.addData('bdm_marker_start', bdm_marker_start)\u000a\u000a    # Add the item and the subject's bid to the 'bids' list, which will be merged with the 'prefs' list later in order to run the auction\u000a    bids.append([bdm_img, bdm_bid.response])\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeat of 'bdm_loop1'\u000a\u000a\u000a#------Prepare to start Routine "instr_choice"-------\u000at = 0\u000ainstr_choiceClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_choice_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_choice_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_choiceComponents = []\u000ainstr_choiceComponents.append(instr_choice_txt)\u000ainstr_choiceComponents.append(instr_choice_resp)\u000afor thisComponent in instr_choiceComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_choice"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_choiceClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_choice_txt* updates\u000a    if t >= 0.0 and instr_choice_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_choice_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_choice_txt.frameNStart = frameN  # exact frame index\u000a        instr_choice_txt.setAutoDraw(True)\u000a    \u000a    # *instr_choice_resp* updates\u000a    if t >= 2.0 and instr_choice_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_choice_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_choice_resp.frameNStart = frameN  # exact frame index\u000a        instr_choice_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_choice_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_choice_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space', 's'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_choice_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_choice_resp.rt = instr_choice_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_choiceComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_choice"-------\u000afor thisComponent in instr_choiceComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_choice_resp.keys in ['', [], None]:  # No response was made\u000a   instr_choice_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_choice_resp.keys',instr_choice_resp.keys)\u000aif instr_choice_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_choice_resp.rt', instr_choice_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## BINARY LOOP ##########################\u000a\u000a# set up handler to look after randomisation of conditions etc\u000abinary = data.TrialHandler(nReps=1, method=u'sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(filename+'_choicecond.csv'),\u000a    seed=None, name='binary')\u000athisExp.addLoop(binary)  # add the loop to the experiment\u000athisBinary1 = binary.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBinary1.rgb)\u000aif thisBinary1 != None:\u000a    for paramName in thisBinary1.keys():\u000a        exec(paramName + '= thisBinary1.' + paramName)\u000a\u000a# Check if the 'skip' key was pressed in the instructions routine; if so, end the loop and move on to the BDM\u000aif instr_choice_resp.keys=='s':\u000a    binary.finished = True\u000a\u000afor thisBinary1 in binary:\u000a    currentLoop = binary\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBinary1.rgb)\u000a    if thisBinary1 != None:\u000a        for paramName in thisBinary1.keys():\u000a            exec(paramName + '= thisBinary1.' + paramName)\u000a    \u000a    #------Prepare to start Routine "choice"-------\u000a    t = 0\u000a    choiceClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    choice_pic_left.setImage(dir_path+choice_left)\u000a    choice_pic_right.setImage(dir_path+choice_right)\u000a    event.clearEvents(eventType='keyboard') # Clear keyboard event log to avoid last key press from prior loop being used\u000a    key_resp_choice = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_choice.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    choiceComponents = []\u000a    choiceComponents.append(fixation_text)\u000a    choiceComponents.append(choice_pic_left)\u000a    choiceComponents.append(choice_pic_right)\u000a    choiceComponents.append(key_resp_choice)\u000a    for thisComponent in choiceComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    \u000a    #-------Start Routine "choice"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = choiceClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation_text* updates\u000a        if t >= 0 and fixation_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation_text.tStart = t  # underestimates by a little under one frame\u000a            fixation_text.frameNStart = frameN  # exact frame index\u000a            fixation_text.setAutoDraw(True)\u000a        elif fixation_text.status == STARTED and t>= (0 + (1.0-win.monitorFramePeriod*0.75)):\u000a            fixation_text.setAutoDraw(False)\u000a\u000a        # *choice_pic_left* updates\u000a        if t >= 1.0 and choice_pic_left.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_left.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_left.frameNStart = frameN  # exact frame index\u000a            choice_pic_left.setAutoDraw(True)\u000a        \u000a        # *choice_pic_right* updates\u000a        if t >= 1.0 and choice_pic_right.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_right.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_right.frameNStart = frameN  # exact frame index\u000a            choice_pic_right.setAutoDraw(True)\u000a\u000a        # *key_resp_choice* updates\u000a        if t >= 1.0 and key_resp_choice.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_choice.tStart = t  # underestimates by a little under one frame\u000a            key_resp_choice.frameNStart = frameN  # exact frame index\u000a            key_resp_choice.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_choice.clock.reset()  # now t=0\u000a        if key_resp_choice.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_choice.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_choice.rt = key_resp_choice.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in choiceComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "choice"-------\u000a    for thisComponent in choiceComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_choice.keys in ['', [], None]:  # No response was made\u000a       key_resp_choice.keys=None\u000a    # store data for binary (TrialHandler)\u000a    binary.addData('key_resp_choice.keys',key_resp_choice.keys)\u000a    if key_resp_choice.keys != None:  # we had a response\u000a        binary.addData('key_resp_choice.rt', key_resp_choice.rt)\u000a\u000a    # define a function to append binary choices and the bid for the chosen item to the preference list\u000a    # lft is the left image displayed during that choice trial\u000a    # rt is the right image displayed\u000a    def rec_choice(lft, rt): \u000a        bd = False\u000a        if key_resp_choice.keys=='left':\u000a            chc = lft\u000a        elif key_resp_choice.keys=='right':\u000a            chc = rt\u000a        for x in range(len(bids)):\u000a            if bids[x][0]==chc:\u000a                bd = bids[x][1]\u000a        prefs.append([lft, rt, chc, bd])\u000a\u000a    # call the function\u000a    rec_choice(choice_left, choice_right)\u000a    \u000a\u000a    #------Prepare to start Routine "choice_selection"-------\u000a    t = 0\u000a    choice_selectionClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # keep track of which components have finished\u000a    choice_selectionComponents = []\u000a    choice_selectionComponents.append(choice_pic_left)\u000a    choice_selectionComponents.append(choice_pic_right)\u000a    choice_selectionComponents.append(star_left_selection)\u000a    choice_selectionComponents.append(star_right_selection)\u000a    for thisComponent in choice_selectionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "choice_selection"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = choice_selectionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *choice_pic_left* updates\u000a        if t >= 0.0 and choice_pic_left.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_left.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_left.frameNStart = frameN  # exact frame index\u000a            choice_pic_left.setAutoDraw(True)\u000a        elif choice_pic_left.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            choice_pic_left.setAutoDraw(False)\u000a        \u000a        # *choice_pic_right* updates\u000a        if t >= 0.0 and choice_pic_right.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_right.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_right.frameNStart = frameN  # exact frame index\u000a            choice_pic_right.setAutoDraw(True)\u000a        elif choice_pic_right.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            choice_pic_right.setAutoDraw(False)\u000a        \u000a        # *star_left_selection* updates\u000a        if key_resp_choice.keys=='left':\u000a            if t >= 0.0 and star_left_selection.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                star_left_selection.tStart = t  # underestimates by a little under one frame\u000a                star_left_selection.frameNStart = frameN  # exact frame index\u000a                star_left_selection.setAutoDraw(True)\u000a            elif star_left_selection.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                star_left_selection.setAutoDraw(False)\u000a        \u000a        # *star_right_selection* updates\u000a        if key_resp_choice.keys=='right':\u000a            if t >= 0.0 and star_right_selection.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                star_right_selection.tStart = t  # underestimates by a little under one frame\u000a                star_right_selection.frameNStart = frameN  # exact frame index\u000a                star_right_selection.setAutoDraw(True)\u000a            elif star_right_selection.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                star_right_selection.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in choice_selectionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "choice_selection"-------\u000a    for thisComponent in choice_selectionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    #thisExp.nextEntry()\u000a\u000a    #------Prepare to start Routine "confidence"-------\u000a    t = 0\u000a    confidenceClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    confidence_rating.reset()\u000a    # jitter the starting position of the confidence rating scale from a uniform distribution between 1.7 and 3.3 (the middle third of the scale), rounded to the nearest decimal place\u000a    confidence_marker_start = float(np.round(np.random.uniform(1.7, 3.3, 1)[0], 1))\u000a    confidence_rating.setMarkerPos(confidence_marker_start)\u000a    # keep track of which components have finished\u000a    confidenceComponents = []\u000a    confidenceComponents.append(confidence_rating)\u000a    for thisComponent in confidenceComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "confidence"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = confidenceClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *confidence_rating* updates\u000a        if t > 0.5:\u000a            confidence_rating.draw()\u000a            continueRoutine = confidence_rating.noResponse\u000a            if confidence_rating.noResponse == False:\u000a                confidence_rating.response = confidence_rating.getRating()\u000a                confidence_rating.rt = confidence_rating.getRT()\u000a            elif confidence_rating.noResponse==True:\u000a                if keyState[key.LEFT]==True and confidence_rating.markerPlacedAt >0:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt - 0.1\u000a                    confidence_rating.draw()\u000a                elif keyState[key.LEFT]==True and confidence_rating.markerPlacedAt==0.1:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt - 0.1\u000a                    confidence_rating.draw()\u000a                elif keyState[key.RIGHT]==True and confidence_rating.markerPlacedAt <4.9:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt + 0.1\u000a                    confidence_rating.draw()\u000a                elif keyState[key.RIGHT]==True and confidence_rating.markerPlacedAt==4.9:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt + 0.1\u000a                    confidence_rating.draw()\u000a                    \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in confidenceComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "confidence"-------\u000a    for thisComponent in confidenceComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # store data for confidence (TrialHandler)\u000a    binary.addData('confidence_rating1.response', confidence_rating.getRating())\u000a    binary.addData('confidence_rating1.rt', confidence_rating.getRT())\u000a    binary.addData('confidence_marker_start', confidence_marker_start+1) # Add 1 to convert from 0-5 to 1-6 scale\u000a\u000a    thisExp.nextEntry()\u000a\u000a\u000a# completed 1 repeat of 'binary'        \u000a\u000a#------Prepare to start Routine "instr_infer_intro"-------\u000at = 0\u000ainstr_infer_introClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_infer_intro_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_infer_intro_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_infer_introComponents = []\u000ainstr_infer_introComponents.append(instr_infer_intro_txt)\u000ainstr_infer_introComponents.append(instr_infer_intro_resp)\u000afor thisComponent in instr_infer_introComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_infer_intro"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_infer_introClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_infer_intro_txt* updates\u000a    if t >= 0.0 and instr_infer_intro_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_intro_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_intro_txt.frameNStart = frameN  # exact frame index\u000a        instr_infer_intro_txt.setAutoDraw(True)\u000a    \u000a    # *instr_infer_intro_resp* updates\u000a    if t >= 5.0 and instr_infer_intro_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_intro_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_intro_resp.frameNStart = frameN  # exact frame index\u000a        instr_infer_intro_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_infer_intro_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_infer_intro_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_infer_intro_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_infer_intro_resp.rt = instr_infer_intro_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_infer_introComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_infer_intro"-------\u000afor thisComponent in instr_infer_introComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_infer_intro_resp.keys in ['', [], None]:  # No response was made\u000a   instr_infer_intro_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_infer_intro_resp.keys',instr_infer_intro_resp.keys)\u000aif instr_infer_intro_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_infer_intro_resp.rt', instr_infer_intro_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a#------Prepare to start Routine "instr_infer_practice"-------\u000at = 0\u000ainstr_infer_practiceClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_infer_practice_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_infer_practice_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_infer_practiceComponents = []\u000ainstr_infer_practiceComponents.append(instr_infer_practice_txt)\u000ainstr_infer_practiceComponents.append(instr_infer_practice_resp)\u000afor thisComponent in instr_infer_practiceComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_infer_practice"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_infer_practiceClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_infer_practice_txt* updates\u000a    if t >= 0.0 and instr_infer_practice_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_practice_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_practice_txt.frameNStart = frameN  # exact frame index\u000a        instr_infer_practice_txt.setAutoDraw(True)\u000a    \u000a    # *instr_infer_practice_resp* updates\u000a    if t >= 5.0 and instr_infer_practice_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_practice_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_practice_resp.frameNStart = frameN  # exact frame index\u000a        instr_infer_practice_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_infer_practice_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_infer_practice_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_infer_practice_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_infer_practice_resp.rt = instr_infer_practice_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_infer_practiceComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_infer_practice"-------\u000afor thisComponent in instr_infer_practiceComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_infer_practice_resp.keys in ['', [], None]:  # No response was made\u000a   instr_infer_practice_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_infer_practice_resp.keys',instr_infer_practice_resp.keys)\u000aif instr_infer_practice_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_infer_practice_resp.rt', instr_infer_practice_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## PRACTICE LOOP ##########################\u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_loop = data.TrialHandler(nReps=1, method=u'sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(filename+'_practicecond.csv'),\u000a    seed=None, name='practice_loop')\u000athisExp.addLoop(practice_loop)  # add the loop to the experiment\u000athisPractice_loop = practice_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_loop.rgb)\u000aif thisPractice_loop != None:\u000a    for paramName in thisPractice_loop.keys():\u000a        exec(paramName + '= thisPractice_loop.' + paramName)\u000a\u000a  \u000afor thisPractice_loop in practice_loop:\u000a    currentLoop = practice_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_loop.rgb)\u000a    if thisPractice_loop != None:\u000a        for paramName in thisPractice_loop.keys():\u000a            exec(paramName + '= thisPractice_loop.' + paramName)    \u000a    \u000a        \u000a    # Define class for setting the feedback image\u000a    class set_feedback:\u000a        options = ['correct', 'wrong']\u000a        feedback = np.random.choice(options, replace=True, p=[0.8, 0.2])\u000a        if feedback=='correct':\u000a            feedback_img = img_correct\u000a        elif feedback=='wrong':\u000a            feedback_img = img_wrong\u000a\u000a        if feedback_img==img_left:\u000a            feedback_side = 'left'\u000a        elif feedback_img==img_right:\u000a            feedback_side = 'right'\u000a\u000a\u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialtime = datetime.datetime.now()\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    img_left_infer.setImage(dir_path+img_left)\u000a    img_right_infer.setImage(dir_path+img_right)\u000a    infer_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    infer_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(fixation_text)\u000a    trialComponents.append(img_left_infer)\u000a    trialComponents.append(img_right_infer)\u000a    trialComponents.append(infer_resp)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation_text* updates\u000a        if t >= 0 and fixation_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation_text.tStart = t  # underestimates by a little under one frame\u000a            fixation_text.frameNStart = frameN  # exact frame index\u000a            fixation_text.setAutoDraw(True)\u000a        elif fixation_text.status == STARTED and t>= (0 + (2.0-win.monitorFramePeriod*0.75)):\u000a            fixation_text.setAutoDraw(False)\u000a\u000a        # *img_left_infer* updates\u000a        if t >= 2.0 and img_left_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_left_infer.tStart = t  # underestimates by a little under one frame\u000a            img_left_infer.frameNStart = frameN  # exact frame index\u000a            img_left_infer.setAutoDraw(True)\u000a        \u000a        # *img_right_infer* updates\u000a        if t >= 2.0 and img_right_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_right_infer.tStart = t  # underestimates by a little under one frame\u000a            img_right_infer.frameNStart = frameN  # exact frame index\u000a            img_right_infer.setAutoDraw(True)\u000a                  \u000a        # *infer_resp* updates\u000a        if t >= 2.0 and infer_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            infer_resp.tStart = t  # underestimates by a little under one frame\u000a            infer_resp.frameNStart = frameN  # exact frame index\u000a            infer_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            infer_resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if infer_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                infer_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                infer_resp.rt = infer_resp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a\u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if infer_resp.keys in ['', [], None]:  # No response was made\u000a       infer_resp.keys=None\u000a    # # store data for practice_loop (TrialHandler)\u000a    # practice_loop.addData('infer_resp.keys',infer_resp.keys)\u000a    # if infer_resp.keys != None:  # we had a response\u000a    #     practice_loop.addData('infer_resp.rt', infer_resp.rt)\u000a    practice_loop.addData('set_feedback.feedback_img', set_feedback.feedback_img)\u000a    practice_loop.addData('trial_start_time', trialtime)\u000a    \u000a    # # Increase correct and incorrect response counters by 1 based on S's response\u000a    # if infer_resp.keys=='left' and img_correct==img_left:\u000a    #     correct_counter += 1\u000a    # elif infer_resp.keys=='left' and img_correct==img_right:\u000a    #     incorrect_counter += 1\u000a    # elif infer_resp.keys=='right' and img_correct==img_right:\u000a    #     correct_counter += 1\u000a    # elif infer_resp.keys=='right' and img_correct==img_left:\u000a    #     incorrect_counter += 1\u000a    \u000a\u000a    #------Prepare to start Routine "trial_post_response"-------\u000a    t = 0\u000a    trial_post_responseClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(3.000000)\u000a    # keep track of which components have finished\u000a    trial_post_responseComponents = []\u000a    trial_post_responseComponents.append(img_left_infer)\u000a    trial_post_responseComponents.append(img_right_infer)\u000a    trial_post_responseComponents.append(selection_arrow_left)\u000a    trial_post_responseComponents.append(selection_arrow_right)\u000a    trial_post_responseComponents.append(feedback_box_left)\u000a    trial_post_responseComponents.append(feedback_box_right)\u000a    for thisComponent in trial_post_responseComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial_post_response"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = trial_post_responseClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a\u000a        # *img_left_infer* updates\u000a        if t >= 0.0 and img_left_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_left_infer.tStart = t  # underestimates by a little under one frame\u000a            img_left_infer.frameNStart = frameN  # exact frame index\u000a            img_left_infer.setAutoDraw(True)\u000a        elif img_left_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            img_left_infer.setAutoDraw(False)\u000a        \u000a        # *img_right_infer* updates\u000a        if t >= 0.0 and img_right_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_right_infer.tStart = t  # underestimates by a little under one frame\u000a            img_right_infer.frameNStart = frameN  # exact frame index\u000a            img_right_infer.setAutoDraw(True)\u000a        elif img_right_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            img_right_infer.setAutoDraw(False)\u000a        \u000a        if infer_resp.keys == 'left':\u000a            # *selection_arrow_left* updates\u000a            if t >= 0.0 and selection_arrow_left.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                selection_arrow_left.tStart = t  # underestimates by a little under one frame\u000a                selection_arrow_left.frameNStart = frameN  # exact frame index\u000a                selection_arrow_left.setAutoDraw(True)\u000a            elif selection_arrow_left.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                selection_arrow_left.setAutoDraw(False)\u000a        \u000a        if infer_resp.keys == 'right':\u000a            # *selection_arrow_right* updates\u000a            if t >= 0.0 and selection_arrow_right.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                selection_arrow_right.tStart = t  # underestimates by a little under one frame\u000a                selection_arrow_right.frameNStart = frameN  # exact frame index\u000a                selection_arrow_right.setAutoDraw(True)\u000a            elif selection_arrow_right.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                selection_arrow_right.setAutoDraw(False)\u000a        \u000a        if set_feedback.feedback_side == 'left':\u000a            # *feedback_box_left* updates\u000a            if t >= 1.0 and feedback_box_left.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                feedback_box_left.tStart = t  # underestimates by a little under one frame\u000a                feedback_box_left.frameNStart = frameN  # exact frame index\u000a                feedback_box_left.setAutoDraw(True)\u000a            elif feedback_box_left.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                feedback_box_left.setAutoDraw(False)\u000a        \u000a        if set_feedback.feedback_side == 'right':\u000a            # *feedback_box_right* updates\u000a            if t >= 1.0 and feedback_box_right.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                feedback_box_right.tStart = t  # underestimates by a little under one frame\u000a                feedback_box_right.frameNStart = frameN  # exact frame index\u000a                feedback_box_right.setAutoDraw(True)\u000a            elif feedback_box_right.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period right\u000a                feedback_box_right.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trial_post_responseComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "trial_post_response"-------\u000a    for thisComponent in trial_post_responseComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000a    \u000a    thisExp.nextEntry()\u000a                        \u000a# completed 1 repeat of 'practice_loop'\u000a\u000a\u000a#------Prepare to start Routine "instr_infer"-------\u000at = 0\u000ainstr_inferClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_infer_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_infer_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_inferComponents = []\u000ainstr_inferComponents.append(instr_infer_txt)\u000ainstr_inferComponents.append(instr_infer_resp)\u000afor thisComponent in instr_inferComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_infer"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_inferClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_infer_txt* updates\u000a    if t >= 0.0 and instr_infer_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_txt.frameNStart = frameN  # exact frame index\u000a        instr_infer_txt.setAutoDraw(True)\u000a    \u000a    # *instr_infer_resp* updates\u000a    if t >= 5.0 and instr_infer_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_resp.frameNStart = frameN  # exact frame index\u000a        instr_infer_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_infer_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_infer_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_infer_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_infer_resp.rt = instr_infer_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_inferComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_infer"-------\u000afor thisComponent in instr_inferComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_infer_resp.keys in ['', [], None]:  # No response was made\u000a   instr_infer_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_infer_resp.keys',instr_infer_resp.keys)\u000aif instr_infer_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_infer_resp.rt', instr_infer_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## BLOCK LOOP ##########################\u000a\u000a# This loop runs a second nested loop that shows each item pair 10 times, followed by a rest break prompt.\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=3, method=u'sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=[None],\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000a# Set up counter to keep track of block loop cycle, so that the rest prompt is only shown twice\u000ablock_loop_counter = 0\u000a\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    # Increase loop counter by one\u000a    block_loop_counter += 1\u000a    \u000a    # Change the condition file for the feedback block based on which block loop we're on\u000a    condfilename = filename+u'_block'+str(block_loop_counter)+u'cond.csv'\u000a    \u000a    # # Minimize the psychopy window so the calibration window can be seen\u000a    # win.winHandle.minimize()\u000a    # #Do the eye tracker setup at the beginning of each block\u000a    # tracker.runSetupProcedure()\u000a    # # Re-display the psychopy window after setup is completed\u000a    # win.winHandle.maximize()\u000a    # win.winHandle.activate()\u000a    \u000a\u000a    \u000a    #------Prepare to start Routine "get_ready"-------\u000a    t = 0\u000a    get_readyClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(3.000000)\u000a    # update component parameters for each repeat\u000a    get_ready_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    get_ready_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    get_readyComponents = []\u000a    get_readyComponents.append(get_ready_text)\u000a    get_readyComponents.append(get_ready_resp)\u000a    for thisComponent in get_readyComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    \u000a    #-------Start Routine "get_ready"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = get_readyClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *get_ready_text* updates\u000a        if t >= 0.0 and get_ready_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            get_ready_text.tStart = t  # underestimates by a little under one frame\u000a            get_ready_text.frameNStart = frameN  # exact frame index\u000a            get_ready_text.setAutoDraw(True)\u000a        \u000a        # *get_ready_resp* updates\u000a        if t >= 0.0 and get_ready_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            get_ready_resp.tStart = t  # underestimates by a little under one frame\u000a            get_ready_resp.frameNStart = frameN  # exact frame index\u000a            get_ready_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            get_ready_resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if get_ready_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['p'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                get_ready_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                get_ready_resp.rt = get_ready_resp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in get_readyComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "get_ready"-------\u000a    for thisComponent in get_readyComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if get_ready_resp.keys in ['', [], None]:  # No response was made\u000a       get_ready_resp.keys=None\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('get_ready_resp.keys',get_ready_resp.keys)\u000a    if get_ready_resp.keys != None:  # we had a response\u000a        thisExp.addData('get_ready_resp.rt', get_ready_resp.rt)\u000a    thisExp.nextEntry()\u000a\u000a    ######################## TRIAL LOOP ##########################\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    trial_loop = data.TrialHandler(nReps=1, method=u'sequential', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(condfilename),\u000a        seed=None, name='trial_loop')\u000a    thisExp.addLoop(trial_loop)  # add the loop to the experiment\u000a    thisTrial_loop = trial_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_loop.rgb)\u000a    if thisTrial_loop != None:\u000a        for paramName in thisTrial_loop.keys():\u000a            exec(paramName + '= thisTrial_loop.' + paramName)\u000a    \u000a      \u000a    for thisTrial_loop in trial_loop:\u000a        currentLoop = trial_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_loop.rgb)\u000a        if thisTrial_loop != None:\u000a            for paramName in thisTrial_loop.keys():\u000a                exec(paramName + '= thisTrial_loop.' + paramName)    \u000a        \u000a            \u000a        # Define class for setting the feedback image\u000a        class set_feedback:\u000a            options = ['correct', 'wrong']\u000a            feedback = np.random.choice(options, replace=True, p=[0.8, 0.2])\u000a            if feedback=='correct':\u000a                feedback_img = img_correct\u000a            elif feedback=='wrong':\u000a                feedback_img = img_wrong\u000a\u000a            if feedback_img==img_left:\u000a                feedback_side = 'left'\u000a            elif feedback_img==img_right:\u000a                feedback_side = 'right'\u000a                        \u000a        # # Start getting data from the eye tracker\u000a        # tracker.enableEventReporting(True)\u000a        # # Send beginning-of-trial messages to eye tracker data file\u000a        # trial_number = (block_loop.thisN * 200) + trial_loop.thisTrialN # Trial number out of 599 (starts at 0)\u000a        # tracker.sendCommand("record_status_message 'INFERRING, Block %d/3, Trial %d/600 '" % (block_loop.thisN + 1, trial_number + 1))\u000a        # tracker.sendMessage("TRIALID %d" % trial_number)\u000a        # tracker.sendMessage("!V TRIAL_VAR_DATA %d" % trial_number)\u000a\u000a        \u000a        #------Prepare to start Routine "trial"-------\u000a        t = 0\u000a        trialtime = datetime.datetime.now()\u000a        trialClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        img_left_infer.setImage(dir_path+img_left)\u000a        img_right_infer.setImage(dir_path+img_right)\u000a        infer_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        infer_resp.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trialComponents = []\u000a        trialComponents.append(fixation_text)\u000a        trialComponents.append(img_left_infer)\u000a        trialComponents.append(img_right_infer)\u000a        trialComponents.append(infer_resp)\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        # Set indicator variable for whether eye tracker messages were sent during the first loop of the routine\u000a        eye_sync_messages_sent = 0\u000a        \u000a        #-------Start Routine "trial"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = trialClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *fixation_text* updates\u000a            if t >= 0 and fixation_text.status == NOT_STARTED:\u000a                if eye_sync_messages_sent==0:\u000a                    startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                # keep track of start time/frame for later\u000a                fixation_text.tStart = t  # underestimates by a little under one frame\u000a                fixation_text.frameNStart = frameN  # exact frame index\u000a                fixation_text.setAutoDraw(True)\u000a                if eye_sync_messages_sent==0:\u000a                    drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                    # tracker.sendMessage("%d DISPLAY ON" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                    # tracker.sendMessage("SYNCTIME %d" %drawTime)\u000a                    eye_sync_messages_sent = 1\u000a            elif fixation_text.status == STARTED and t>= (0 + (2.0-win.monitorFramePeriod*0.75)):\u000a                fixation_text.setAutoDraw(False)\u000a            \u000a            # *img_left_infer* updates\u000a            if t >= 2.0 and img_left_infer.status == NOT_STARTED:\u000a                if eye_sync_messages_sent==1:\u000a                    startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                # keep track of start time/frame for later\u000a                img_left_infer.tStart = t  # underestimates by a little under one frame\u000a                img_left_infer.frameNStart = frameN  # exact frame index\u000a                img_left_infer.setAutoDraw(True)\u000a            \u000a            # *img_right_infer* updates\u000a            if t >= 2.0 and img_right_infer.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                img_right_infer.tStart = t  # underestimates by a little under one frame\u000a                img_right_infer.frameNStart = frameN  # exact frame index\u000a                img_right_infer.setAutoDraw(True)\u000a                if eye_sync_messages_sent==1:\u000a                    drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                    # tracker.sendMessage("%d DISPLAY ON ITEMS" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                    eye_sync_messages_sent = 2\u000a                      \u000a            # *infer_resp* updates\u000a            if t >= 2.0 and infer_resp.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                infer_resp.tStart = t  # underestimates by a little under one frame\u000a                infer_resp.frameNStart = frameN  # exact frame index\u000a                infer_resp.status = STARTED\u000a                # keyboard checking is just starting\u000a                infer_resp.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            if infer_resp.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['left', 'right'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    infer_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                    infer_resp.rt = infer_resp.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trialComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                # tracker.enableEventReporting(False) # End eye tracker data recording\u000a                # tracker.sendMessage("EXPERIMENT ABORTED")\u000a                # io.quit() # Close iohub\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial"-------\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if infer_resp.keys in ['', [], None]:  # No response was made\u000a           infer_resp.keys=None\u000a        # store data for trial_loop (TrialHandler)\u000a        trial_loop.addData('infer_resp.keys',infer_resp.keys)\u000a        if infer_resp.keys != None:  # we had a response\u000a            trial_loop.addData('infer_resp.rt', infer_resp.rt)\u000a        trial_loop.addData('set_feedback.feedback_img', set_feedback.feedback_img)\u000a        trial_loop.addData('trial_start_time', trialtime)\u000a        \u000a        # Increase correct and incorrect response counters by 1 based on S's response\u000a        if infer_resp.keys=='left' and img_correct==img_left:\u000a            correct_counter += 1\u000a        elif infer_resp.keys=='left' and img_correct==img_right:\u000a            incorrect_counter += 1\u000a        elif infer_resp.keys=='right' and img_correct==img_right:\u000a            correct_counter += 1\u000a        elif infer_resp.keys=='right' and img_correct==img_left:\u000a            incorrect_counter += 1\u000a        \u000a\u000a        #------Prepare to start Routine "trial_post_response"-------\u000a        t = 0\u000a        trial_post_responseClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(3.000000)\u000a        # keep track of which components have finished\u000a        trial_post_responseComponents = []\u000a        trial_post_responseComponents.append(img_left_infer)\u000a        trial_post_responseComponents.append(img_right_infer)\u000a        trial_post_responseComponents.append(selection_arrow_left)\u000a        trial_post_responseComponents.append(selection_arrow_right)\u000a        trial_post_responseComponents.append(feedback_box_left)\u000a        trial_post_responseComponents.append(feedback_box_right)\u000a        for thisComponent in trial_post_responseComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        # Set indicator variable for whether eye tracker messages were sent during the first loop of the routine\u000a        eye_sync_messages_sent = 0\u000a\u000a        #-------Start Routine "trial_post_response"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = trial_post_responseClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a\u000a            # *img_left_infer* updates\u000a            if t >= 0.0 and img_left_infer.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                img_left_infer.tStart = t  # underestimates by a little under one frame\u000a                img_left_infer.frameNStart = frameN  # exact frame index\u000a                img_left_infer.setAutoDraw(True)\u000a            elif img_left_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                img_left_infer.setAutoDraw(False)\u000a            \u000a            # *img_right_infer* updates\u000a            if t >= 0.0 and img_right_infer.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                img_right_infer.tStart = t  # underestimates by a little under one frame\u000a                img_right_infer.frameNStart = frameN  # exact frame index\u000a                img_right_infer.setAutoDraw(True)\u000a            elif img_right_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                img_right_infer.setAutoDraw(False)\u000a            \u000a            if infer_resp.keys == 'left':\u000a                # *selection_arrow_left* updates\u000a                if t >= 0.0 and selection_arrow_left.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==0:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    selection_arrow_left.tStart = t  # underestimates by a little under one frame\u000a                    selection_arrow_left.frameNStart = frameN  # exact frame index\u000a                    selection_arrow_left.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==0:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        # tracker.sendMessage("%d DISPLAY ON SELECTION" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 1\u000a                elif selection_arrow_left.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    if eye_sync_messages_sent==1:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    selection_arrow_left.setAutoDraw(False)\u000a                    if eye_sync_messages_sent==1:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        # tracker.sendMessage("%d DISPLAY ON SELECTION OFF" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 2\u000a            \u000a            if infer_resp.keys == 'right':\u000a                # *selection_arrow_right* updates\u000a                if t >= 0.0 and selection_arrow_right.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==0:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    selection_arrow_right.tStart = t  # underestimates by a little under one frame\u000a                    selection_arrow_right.frameNStart = frameN  # exact frame index\u000a                    selection_arrow_right.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==0:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        # tracker.sendMessage("%d DISPLAY ON SELECTION" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 1\u000a                elif selection_arrow_right.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    if eye_sync_messages_sent==1:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    selection_arrow_right.setAutoDraw(False)\u000a                    if eye_sync_messages_sent==1:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        # tracker.sendMessage("%d DISPLAY ON SELECTION OFF" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 2\u000a            \u000a            if set_feedback.feedback_side == 'left':\u000a                # *feedback_box_left* updates\u000a                if t >= 1.0 and feedback_box_left.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==2:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    feedback_box_left.tStart = t  # underestimates by a little under one frame\u000a                    feedback_box_left.frameNStart = frameN  # exact frame index\u000a                    feedback_box_left.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==2:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        # tracker.sendMessage("%d DISPLAY ON FEEDBACK" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 3\u000a                elif feedback_box_left.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    feedback_box_left.setAutoDraw(False)\u000a            \u000a            if set_feedback.feedback_side == 'right':\u000a                # *feedback_box_right* updates\u000a                if t >= 1.0 and feedback_box_right.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==2:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    feedback_box_right.tStart = t  # underestimates by a little under one frame\u000a                    feedback_box_right.frameNStart = frameN  # exact frame index\u000a                    feedback_box_right.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==2:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        # tracker.sendMessage("%d DISPLAY ON FEEDBACK" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 3\u000a                elif feedback_box_right.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period right\u000a                    feedback_box_right.setAutoDraw(False)\u000a\u000a\u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial_post_responseComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                # tracker.enableEventReporting(False) # End eye tracker data recording\u000a                # tracker.sendMessage("EXPERIMENT ABORTED")\u000a                # io.quit() # Close iohub\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "trial_post_response"-------\u000a        for thisComponent in trial_post_responseComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a        thisExp.nextEntry()\u000a                            \u000a    # completed 5 repeats of 'trial_loop'\u000a    \u000a    if block_loop_counter <= 2: # If this is the first or second cycle of the loop, display the rest break prompt\u000a\u000a        #------Prepare to start Routine "rest_prompt"-------\u000a        t = 0\u000a        rest_promptClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        rest_prompt_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        rest_prompt_resp.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        rest_promptComponents = []\u000a        rest_promptComponents.append(rest_prompt_txt)\u000a        rest_promptComponents.append(rest_prompt_resp)\u000a        for thisComponent in rest_promptComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a\u000a        #-------Start Routine "rest_prompt"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = rest_promptClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *rest_prompt_txt* updates\u000a            if t >= 0.0 and rest_prompt_txt.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                rest_prompt_txt.tStart = t  # underestimates by a little under one frame\u000a                rest_prompt_txt.frameNStart = frameN  # exact frame index\u000a                rest_prompt_txt.setAutoDraw(True)\u000a            \u000a            # *rest_prompt_resp* updates\u000a            if t >= 2.0 and rest_prompt_resp.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                rest_prompt_resp.tStart = t  # underestimates by a little under one frame\u000a                rest_prompt_resp.frameNStart = frameN  # exact frame index\u000a                rest_prompt_resp.status = STARTED\u000a                # keyboard checking is just starting\u000a                rest_prompt_resp.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            if rest_prompt_resp.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    rest_prompt_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                    rest_prompt_resp.rt = rest_prompt_resp.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in rest_promptComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                # tracker.enableEventReporting(False) # End eye tracker data recording\u000a                # tracker.sendMessage("EXPERIMENT ABORTED")\u000a                # io.quit() # CLose iohub\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a\u000a        #-------Ending Routine "rest_prompt"-------\u000a        for thisComponent in rest_promptComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if rest_prompt_resp.keys in ['', [], None]:  # No response was made\u000a           rest_prompt_resp.keys=None\u000a        # store data for thisExp (ExperimentHandler)\u000a        thisExp.addData('rest_prompt_resp.keys',rest_prompt_resp.keys)\u000a        if rest_prompt_resp.keys != None:  # we had a response\u000a            thisExp.addData('rest_prompt_resp.rt', rest_prompt_resp.rt)\u000a\u000a\u000a    thisExp.nextEntry()\u000a    \u000a# completed 3 repeats of 'block_loop'\u000a\u000a\u000a# store data for total number of correct and incorrect responses    \u000athisExp.addData('correct_counter', correct_counter)\u000athisExp.addData('incorrect_counter', incorrect_counter)\u000athisExp.nextEntry()     \u000a\u000a# tracker.setConnectionState(False) # Close and transfer eye-tracking data, then close down eye tracker connection\u000a\u000a\u000a######################## AUCTION ##########################\u000a\u000aif len(prefs)==41 and len(bids)==41: # If S completed the entire binary choice and BDM routines, run the auction\u000a\u000a    # run the auction\u000a    class auction:\u000a        rand_itm = randint(1, (len(prefs))) # pick index for S's chosen item from a random choice\u000a        price = float((randint(1, 300)))/100 # assign a price to the item randomly from between 0.01 and 3 pounds\u000a        bid = prefs[rand_itm][3]\u000a        # check if S's bid for that item was above or below the price\u000a        if bid >= price:\u000a            win_item=True\u000a        elif bid < price:\u000a            win_item=False\u000a\u000a        # set text for the auction screen\u000a        if win_item==True:\u000a            auc_res_txt = u'Congratulations! You won the following item at auction. \u005cnThis was your preferred item out of a randomly selected pair from one of the choice tasks.'\u000a            auc_prc_txt = u'Your bid of \u005cxa3' + '{0:.2f}'.format(bid) + u' matched or exceeded the randomly generated price of \u005cxa3' + '{0:.2f}'.format(price) + '.\u005cn\u005cn[Press space bar to continue]'\u000a            cost = price\u000a        elif win_item==False:\u000a            auc_res_txt = u'Sorry, you did not win the following item at auction. \u005cnThis was your preferred item out of a randomly selected pair from one of the choice tasks.'\u000a            auc_prc_txt = u'Your bid of \u005cxa3' + '{0:.2f}'.format(bid) + u' was lower than the randomly generated price of \u005cxa3' + '{0:.2f}'.format(price) + '.\u005cn\u005cn[Press space bar to continue]'\u000a            cost = 0\u000a\u000a        # find the image path of the auction item\u000a        rand_itm_img = prefs[rand_itm][2]\u000a\u000a    # add up each component of S's payment\u000a    class score:\u000a        base = 25\u000a        rwrd = 0.01\u000a        loss = 0\u000a        rwrd_tot = rwrd * correct_counter\u000a        loss_tot = loss * incorrect_counter\u000a        pre_pymt = base + rwrd_tot - loss_tot\u000a        final_pymt = pre_pymt - auction.cost\u000a\u000a        pymt_expl_bdwn = u'\u005cxa3' + '{0:.2f}'.format(base) + u' base payment'+ u'\u005cn+ \u005cxa3' + '{0:.2f}'.format(rwrd_tot) + ' reward for ' + str(correct_counter) + u' correct responses (\u005cxa3' + '{0:.2f}'.format(rwrd) + u' each)' + u'\u005cn- \u005cxa3' + '{0:.2f}'.format(auction.cost) + ' cost of auction item' \u000a        pymt_expl_tot = u'Your total payment is: \u005cxa3' + '{0:.2f}'.format(final_pymt) + '\u005cn\u005cnThank you for participating!'\u000a\u000a\u000a    # Initialize components for Routine "auc_disp"\u000a    auc_dispClock = core.Clock()\u000a    pic_auc_itm = visual.ImageStim(win=win, name='pic_auc_itm',\u000a        image=dir_path+auction.rand_itm_img, mask=None,\u000a        ori=0, pos=[0, 0], size=None,\u000a        color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a        flipHoriz=False, flipVert=False,\u000a        texRes=128, interpolate=False, depth=0.0)\u000a    auc_txt1 = visual.TextStim(win=win, ori=0, name='auc_txt1',\u000a        text=auction.auc_res_txt, font=u'Arial',\u000a        pos=[0, 0.6], height=0.07, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    auc_txt2 = visual.TextStim(win=win, ori=0, name='auc_txt2',\u000a        text=auction.auc_prc_txt, font=u'Arial',\u000a        pos=[0, -0.6], height=0.07, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a\u000a    #------Prepare to start Routine "auc_disp"-------\u000a    t = 0\u000a    auc_dispClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    key_resp_auc_disp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_auc_disp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    auc_dispComponents = []\u000a    auc_dispComponents.append(pic_auc_itm)\u000a    auc_dispComponents.append(auc_txt1)\u000a    auc_dispComponents.append(auc_txt2)\u000a    for thisComponent in auc_dispComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "auc_disp"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = auc_dispClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *pic_auc_itm* updates\u000a        if t >= 0.2 and pic_auc_itm.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            pic_auc_itm.tStart = t  # underestimates by a little under one frame\u000a            pic_auc_itm.frameNStart = frameN  # exact frame index\u000a            pic_auc_itm.setAutoDraw(True)\u000a        \u000a        # *auc_txt1* updates\u000a        if t >= 0.2 and auc_txt1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            auc_txt1.tStart = t  # underestimates by a little under one frame\u000a            auc_txt1.frameNStart = frameN  # exact frame index\u000a            auc_txt1.setAutoDraw(True)\u000a\u000a        # *auc_txt2* updates\u000a        if t >= 0.2 and auc_txt2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            auc_txt2.tStart = t  # underestimates by a little under one frame\u000a            auc_txt2.frameNStart = frameN  # exact frame index\u000a            auc_txt2.setAutoDraw(True)\u000a        \u000a        # *key_resp_auc_disp* updates\u000a        if t >= 0.2 and key_resp_auc_disp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_auc_disp.tStart = t  # underestimates by a little under one frame\u000a            key_resp_auc_disp.frameNStart = frameN  # exact frame index\u000a            key_resp_auc_disp.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_auc_disp.clock.reset()  # now t=0\u000a        if key_resp_auc_disp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_auc_disp.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_auc_disp.rt = key_resp_auc_disp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in auc_dispComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "auc_disp"-------\u000a    for thisComponent in auc_dispComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_auc_disp.keys in ['', [], None]:  # No response was made\u000a       key_resp_auc_disp.keys=None\u000a    # store data for thisExp (TrialHandler)\u000a    thisExp.addData('auction.win_item', auction.win_item)\u000a    thisExp.addData('auction.price', auction.price)\u000a    thisExp.addData('auction.bid', auction.bid)\u000a    thisExp.addData('auction.rand_itm_img', auction.rand_itm_img)\u000a    thisExp.addData('score.base', score.base)\u000a    thisExp.addData('score.rwrd', score.rwrd)\u000a    thisExp.addData('score.loss', score.loss)\u000a    thisExp.addData('correct_counter', correct_counter)\u000a    thisExp.addData('incorrect_counter', incorrect_counter)\u000a    thisExp.addData('score.final_pymt', score.final_pymt)\u000a    thisExp.nextEntry()\u000a\u000a\u000a    # Initialize components for Routine "pymt_disp"\u000a    pymt_dispClock = core.Clock()\u000a    pymt_disp_txt1 = visual.TextStim(win=win, ori=0, name='pymt_disp_txt1',\u000a        text=score.pymt_expl_bdwn, font=u'Arial',\u000a        pos=[0, 0.6], height=0.07, wrapWidth=1.5,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    pymt_disp_txt2 = visual.TextStim(win=win, ori=0, name='pymt_disp_txt2',\u000a        text=score.pymt_expl_tot, font=u'Arial',\u000a        pos=[0, -0.65], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    #------Prepare to start Routine "pymt_disp"-------\u000a    t = 0\u000a    pymt_dispClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    key_resp_pymt_disp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_pymt_disp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    pymt_dispComponents = []\u000a    pymt_dispComponents.append(pic_auc_itm)\u000a    pymt_dispComponents.append(pymt_disp_txt1)\u000a    pymt_dispComponents.append(pymt_disp_txt2)\u000a    pymt_dispComponents.append(key_resp_pymt_disp)\u000a    for thisComponent in pymt_dispComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "pymt_disp"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = pymt_dispClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        if auction.win_item==True:\u000a            # *pic_auc_itm* updates\u000a            if t >= 0.0 and pic_auc_itm.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                pic_auc_itm.tStart = t  # underestimates by a little under one frame\u000a                pic_auc_itm.frameNStart = frameN  # exact frame index\u000a                pic_auc_itm.setAutoDraw(True)\u000a\u000a        # *pymt_disp_txt1* updates\u000a        if t >= 0.0 and pymt_disp_txt1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            pymt_disp_txt1.tStart = t  # underestimates by a little under one frame\u000a            pymt_disp_txt1.frameNStart = frameN  # exact frame index\u000a            pymt_disp_txt1.setAutoDraw(True)\u000a\u000a        # *pymt_disp_txt2* updates\u000a        if t >= 0.0 and pymt_disp_txt2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            pymt_disp_txt2.tStart = t  # underestimates by a little under one frame\u000a            pymt_disp_txt2.frameNStart = frameN  # exact frame index\u000a            pymt_disp_txt2.setAutoDraw(True)\u000a        \u000a        # *key_resp_pymt_disp* updates\u000a        if t >= 3.0 and key_resp_pymt_disp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_pymt_disp.tStart = t  # underestimates by a little under one frame\u000a            key_resp_pymt_disp.frameNStart = frameN  # exact frame index\u000a            key_resp_pymt_disp.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_pymt_disp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if key_resp_pymt_disp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_pymt_disp.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_pymt_disp.rt = key_resp_pymt_disp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in pymt_dispComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "pymt_disp"-------\u000a    for thisComponent in pymt_dispComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_pymt_disp.keys in ['', [], None]:  # No response was made\u000a       key_resp_pymt_disp.keys=None\u000a\u000aelse: # If S didn't complete the entire binary choice and BDM routines during this session, prompt a manual auction\u000a    # Initialize components for Routine "auc_manual"\u000a    auc_manualClock = core.Clock()\u000a    auc_manual_txt = visual.TextStim(win=win, ori=0, name='auc_manual_txt',\u000a        text=u'Thank you! This completes the experiment. The experimenter will now run the auction and calculate your final payment.\u005cn\u005cnCorrect: ' + str(correct_counter) + '\u005cnIncorrect: ' + str(incorrect_counter),    font=u'Arial',\u000a        pos=[0, 0], height=0.07, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    #------Prepare to start Routine "auc_manual"-------\u000a    t = 0\u000a    auc_manualClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    auc_manualComponents = []\u000a    auc_manualComponents.append(auc_manual_txt)\u000a    for thisComponent in auc_manualComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "auc_manual"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = auc_manualClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *auc_manual_txt* updates\u000a        if t >= 0.0 and auc_manual_txt.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            auc_manual_txt.tStart = t  # underestimates by a little under one frame\u000a            auc_manual_txt.frameNStart = frameN  # exact frame index\u000a            auc_manual_txt.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in auc_manualComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "auc_manual"-------\u000a    for thisComponent in auc_manualComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000athisExp.nextEntry()\u000a\u000a# io.quit() # Close iohub\u000a\u000a\u000awin.close()\u000acore.quit()\u000a
p9337
sg9107
(lp9338
sg9109
I85328720
sg10
S'practice_loop'
p9339
sg6
g9111
sg9112
I1
sg52
I01
sg53
g54
sg9113
g1
(g9114
g9115
(dp9340
g9117
g9118
(g9119
g92
g9120
S'b'
tRp9341
(I1
(I14
I1
tg9122
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg33
g9118
(g9119
g92
g9120
S'b'
tRp9342
(I1
(I14
I1
tg9244
I00
S'\xc0_\xed\x0c\x10\xa1\xed\x0c\x80\xe6\x89\x048\xa1\xed\x0cP\xe6\x89\x048\xa1\xed\x0c\xf0\xe5\x89\x04\xc0_\xed\x0c\x10\xa1\xed\x0cp\xa0\xed\x0c\x98\xa0\xed\x0cP\xe6\x89\x04\x80\xe6\x89\x04\xc0\xe5\x89\x04'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg9125
g9118
(g9119
g92
g9120
S'b'
tRp9343
(I1
(I14
I1
tg9122
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00@\x00\x00@@\x00\x00\x80@\x00\x00\xa0@\x00\x00\xc0@\x00\x00\xe0@\x00\x00\x00A\x00\x00\x10A\x00\x00 A\x00\x000A\x00\x00@A\x00\x00PA'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg34
g9118
(g9119
g92
g9120
S'b'
tRp9344
(I1
(I14
I1
tg9244
I00
S'\xb87\xb8\x04h\xc9]\x02\xa8kW\x04X\xba\xb7\x04\xb8\xb7\xb7\x048\xbf\xb7\x04X\xb1\xb7\x04\xd8\xb2\xb7\x04P\xb9\xb7\x04\xc8\xb6\xb7\x04\xc8\xbc\xb7\x04\xb8\xb1\xb7\x04\xe0\xb3\xb7\x04\xe8\xbd\xb7\x04'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp9345
(dp9346
g9130
(dp9347
g9117
I01
sg33
I00
sg9125
I01
sg34
I00
ssg9132
g9335
sg9133
(lp9348
g9117
ag9125
ag33
ag34
asg9135
(lp9349
I14
aI1
asbsg9137
g9252
sg9139
g91
(g92
(I0
tS'b'
tRp9350
(I1
(I14
I1
tg98
I00
S'\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00\x04\x00\x00\x00\x05\x00\x00\x00\x06\x00\x00\x00\x07\x00\x00\x00\x08\x00\x00\x00\t\x00\x00\x00\n\x00\x00\x00\x0b\x00\x00\x00\x0c\x00\x00\x00\r\x00\x00\x00'
tbsg9141
I01
sg9142
I1
sg9143
I-1
sg9144
(lp9351
g1
(g9146
g9115
(dp9352
g81
g743
sg82
g744
sg83
g748
sg84
g749
stRp9353
ag1
(g9146
g9115
(dp9354
g81
g755
sg82
g756
sg83
g760
sg84
g761
stRp9355
ag1
(g9146
g9115
(dp9356
g81
g766
sg82
g767
sg83
g771
sg84
g772
stRp9357
ag1
(g9146
g9115
(dp9358
g81
g777
sg82
g778
sg83
g782
sg84
g783
stRp9359
ag1
(g9146
g9115
(dp9360
g81
g788
sg82
g789
sg83
g793
sg84
g794
stRp9361
ag1
(g9146
g9115
(dp9362
g81
g777
sg82
g799
sg83
g782
sg84
g803
stRp9363
ag1
(g9146
g9115
(dp9364
g81
g808
sg82
g809
sg83
g813
sg84
g814
stRp9365
ag1
(g9146
g9115
(dp9366
g81
g743
sg82
g819
sg83
g748
sg84
g823
stRp9367
ag1
(g9146
g9115
(dp9368
g81
g755
sg82
g828
sg83
g760
sg84
g832
stRp9369
ag1
(g9146
g9115
(dp9370
g81
g808
sg82
g837
sg83
g813
sg84
g841
stRp9371
ag1
(g9146
g9115
(dp9372
g81
g846
sg82
g847
sg83
g851
sg84
g852
stRp9373
ag1
(g9146
g9115
(dp9374
g81
g788
sg82
g857
sg83
g793
sg84
g861
stRp9375
ag1
(g9146
g9115
(dp9376
g81
g766
sg82
g866
sg83
g771
sg84
g870
stRp9377
ag1
(g9146
g9115
(dp9378
g81
g846
sg82
g875
sg83
g851
sg84
g879
stRp9379
asg9227
Nsg9228
g881
sg9229
I14
sg9230
I0
sg9231
I14
sg9232
I01
sbag1
(g9102
g3
NtRp9380
(dp9381
g9105
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a\u000a######################## CITATIONS ########################## \u000a##### Binary choice, BDM, auction routines, and instructions are modified from:\u000a##### \u000a##### De Martino, B., Fleming, S. M., Garrett, N., & Dolan, R. J. (2012). Confidence in value-based choice. Nature Neuroscience, 16(1), 105-110. \u000a#####\u000a##### Food item images are original.\u000a\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.80.01), July 16, 2014, at 03:20\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things bdm STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000afrom pyglet.window import key # to detect key state, whether key is held down, to move slider on key hold\u000aimport pandas as pd\u000aimport datetime\u000afrom psychopy.iohub import launchHubServer\u000aimport pylink\u000a\u000a# Initialize IOHub for eye tracker\u000a# io=launchHubServer(iohub_config_name='iohub_config.yaml')\u000a# tracker = io.devices.tracker\u000a\u000a# Store info about the experiment session\u000aexpName = 'infer_design1_no_eyetracking'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u'', u'eye': u'', u'glasses': u'', u'contacts': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Setup filename for saving\u000afilename = 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# set up variable to track current state of key press, to move slider when keys held down\u000akeyState=key.KeyStateHandler()\u000a\u000a# Setup the Window\u000ascreenwidth = 1920\u000ascreenheight = 1080\u000awin = visual.Window(size=(screenwidth, screenheight), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color='black', colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000awin.winHandle.push_handlers(keyState)\u000a\u000a\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a\u000a######################## COMPONENTS ##########################\u000a\u000a# Set up directory path for stimuli. This avoids us having to put the entire image path in the conditions spreadsheet.\u000adir_path = 'stimuli/itempics/modified/small/'\u000a\u000a# Initialize components for Routine "instr_main"\u000ainstr_mainClock = core.Clock()\u000ainstr_main_txt = visual.TextStim(win=win, ori=0, name='instr_main_txt',\u000a    text=u'Welcome!\u005cn\u005cnPlease read the instructions carefully and get the experimenter when you\u005c're finished. Take as much time as you need.',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "instr_bdm"\u000ainstr_bdmClock = core.Clock()\u000ainstr_bdm_txt = visual.TextStim(win=win, ori=0, name='instr_bdm_txt',\u000a    text=u'The bidding task is about to begin. Use the LEFT and RIGHT arrow keys to move the cursor along the slider, then press the DOWN arrow to enter your bid.\u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "fixation"\u000afixationClock = core.Clock()\u000afixation_text = visual.TextStim(win=win, ori=0, name='fixation_text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "bdm"\u000abdmClock = core.Clock()\u000abdm_pic = visual.ImageStim(win=win, name='bdm_pic',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=0.0)\u000abdm_bid = visual.RatingScale(win=win, name='bdm_bid', marker=u'triangle', markerColor=u'orange', leftKeys=None, rightKeys=None,\u000a    size=1.0, pos=[0.0, -0.6], low=0, high=3, precision=100, labels=[u'\u005cxa30', u'\u005cxa33'],\u000a    scale=u'', markerStart=u'1.5', tickHeight=u'1', showAccept=False, acceptKeys=[u'down', u'return'])\u000a\u000a# Initialize components for Routine "instr_choice"\u000ainstr_choiceClock = core.Clock()\u000ainstr_choice_txt = visual.TextStim(win=win, ori=0, name='instr_choice_txt',\u000a    text=u'The choice task is about to begin. Choose your preferred item by pressing the LEFT or RIGHT arrow keys, then use the slider to indicate how confident you are that you made the best choice.\u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "choice"\u000achoiceClock = core.Clock()\u000achoice_pic_left = visual.ImageStim(win=win, name='choice_pic_left',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[-0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=0.0)\u000achoice_pic_right = visual.ImageStim(win=win, name='choice_pic_right',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=-1.0)\u000a\u000a# Initialize components for Routine "choice_selection"\u000achoice_selectionClock = core.Clock()\u000astar_left_selection = visual.TextStim(win=win, ori=0, name='star_left_selection',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[-0.5, -0.8], height=0.5, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=-2.0)\u000astar_right_selection = visual.TextStim(win=win, ori=0, name='star_right_selection',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[0.5, -0.8], height=0.5, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=-3.0)\u000a\u000a# Initialize components for Routine "confidence"\u000aconfidenceClock = core.Clock()\u000aconfidence_rating = visual.RatingScale(win=win, name='confidence_rating', marker=u'triangle', markerColor=u'orange', leftKeys=None, rightKeys=None,\u000a    size=1.0, pos=[0.0, 0.0], low=1, high=6, precision=20,\u000a    scale=u'', markerStart=u'3.5', tickHeight=u'1', showAccept=False, acceptKeys=[u'down', u'return'])\u000a\u000a# Initialize components for Routine "instr_infer_intro"\u000ainstr_infer_introClock = core.Clock()\u000ainstr_infer_intro_txt = visual.TextStim(win=win, ori=0, name='instr_infer_intro_txt',\u000a    text=u'Thanks! Now please get the experimenter, who will give you the instructions for the second part of the experiment. \u005cn\u005cnPlease read these instructions carefully and get the experimenter again when you\u005c're finished. Take as much time as you need.',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=1.5,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "instr_infer_practice"\u000ainstr_infer_practiceClock = core.Clock()\u000ainstr_infer_practice_txt = visual.TextStim(win=win, ori=0, name='instr_infer_practice_txt',\u000a    text=u'First, you\u005c'll do some practice trials. These are just for you to get used to the task; your responses won\u005c't count. \u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=1.5,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "instr_infer"\u000ainstr_inferClock = core.Clock()\u000ainstr_infer_txt = visual.TextStim(win=win, ori=0, name='instr_infer_txt',\u000a    text=u'Great! Now that you\u005c've done some practice trials, we\u005c're ready to start the real trials. Please call the experimenter into the room.',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=1.5,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "get_ready"\u000aget_readyClock = core.Clock()\u000aget_ready_text = visual.TextStim(win=win, ori=0, name='get_ready_text',\u000a    text=u'Get ready!',    font=u'Arial',\u000a    pos=[0, 0], height=0.12, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000aimg_left_infer = visual.ImageStim(win=win, name='img_left_infer',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[-0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=0.0)\u000aimg_right_infer = visual.ImageStim(win=win, name='img_right_infer',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=-1.0)\u000a\u000a# Initialize components for Routine "trial_post_response"\u000atrial_post_responseClock = core.Clock()\u000aselection_arrow_left = visual.TextStim(win=win, ori=0, name='selection_arrow_left',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[-0.5, -0.09], height=0.5, wrapWidth=None,\u000a    color=u'red', colorSpace=u'rgb', opacity=1,\u000a    depth=-2.0)\u000aselection_arrow_right = visual.TextStim(win=win, ori=0, name='selection_arrow_right',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[0.5, -0.09], height=0.5, wrapWidth=None,\u000a    color=u'red', colorSpace=u'rgb', opacity=1,\u000a    depth=-3.0)\u000afeedback_box_left = visual.Rect(win=win, name='feedback_box_left',\u000a    width=[0.9, 0.9][0], height=[0.9, 0.9][1],\u000a    ori=0, pos=[-0.5, 0],\u000a    lineWidth=5, lineColor=u'yellow', lineColorSpace=u'rgb',\u000a    fillColor=None, fillColorSpace=u'rgb',\u000a    opacity=1, depth=-4.0, interpolate=True)\u000afeedback_box_right = visual.Rect(win=win, name='feedback_box_right',\u000a    width=[0.9, 0.9][0], height=[0.9, 0.9][1],\u000a    ori=0, pos=[0.5, 0],\u000a    lineWidth=5, lineColor=u'yellow', lineColorSpace=u'rgb',\u000a    fillColor=None, fillColorSpace=u'rgb',\u000a    opacity=1, depth=-5.0, interpolate=True)\u000a\u000a# Initialize components for Routine "rest_prompt"\u000arest_promptClock = core.Clock()\u000arest_prompt_txt = visual.TextStim(win=win, ori=0, name='rest_prompt_txt',\u000a    text=u'Great! Now take a rest and press the space bar when you\u005cu2019re ready to begin the next block.',    font=u'Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create counters for the number of correct and incorrect guesses made by subjects to determine extra payment.\u000acorrect_counter = 0\u000aincorrect_counter = 0\u000a\u000a# Create list of lists to store binary choice and BDM data to generate food reward at the end of the experiment\u000aprefs = [['left', 'right', 'choice', 'bid']]\u000abids = [['item', 'bid']] # For the bids collected during the first BDM routine, at the beginning of the experiment\u000a\u000a### CHOICE & INFERENCE RANDOMIZATION ###\u000a\u000a# Define two functions to generate constrained pseudorandom sequences of item pair presentations for the binary choice and inference\u000a# parts of the task. The constraint ensures that the same pair of items does not appear twice in a row (flipped or not).\u000a# In the conditions spreadsheet that the item pairs are drawn from, the flipped version of the same item pair is 20\u000a# rows apart.\u000a\u000a# Binary choice randomization\u000adef genseq_choice():\u000a    done = False\u000a    while done==False:\u000a        counter = 0\u000a        ans = np.random.choice(40, 40, replace=False) # Generate a pseudorandom sequence of 40 numbers\u000a        for x in range(1,40):\u000a            if (ans[x]-ans[x-1]) % 20 == 0: # Is the difference between any sequential numbers divisible by 20?\u000a                counter += 1\u000a        if counter==0: # If not, end the loop and return the array\u000a            done = True\u000a            return ans\u000a        else: # If so, continue the loop and try again\u000a            done = False\u000a\u000a# Inference practice block randomization\u000adef genseq_infer_practice():\u000a    done = False\u000a    while done==False:\u000a        counter = 0\u000a        ans = np.random.choice(14, 14, replace=False) # Generate a pseudorandom sequence of 200 numbers\u000a        for x in range(1,14):\u000a            if (ans[x]-ans[x-1]) % 7 == 0: # Is the difference between any sequential numbers divisible by 20?\u000a                counter += 1\u000a        if counter==0: # If not, end the loop and return the array\u000a            done = True\u000a            return ans\u000a        else: # If so, continue the loop and try again\u000a            done = False\u000a\u000a# Inference randomization\u000adef genseq_infer():\u000a    done = False\u000a    while done==False:\u000a        counter = 0\u000a        ans = np.random.choice(200, 200, replace=False) # Generate a pseudorandom sequence of 200 numbers\u000a        for x in range(1,200):\u000a            if (ans[x]-ans[x-1]) % 20 == 0: # Is the difference between any sequential numbers divisible by 20?\u000a                counter += 1\u000a        if counter==0: # If not, end the loop and return the array\u000a            done = True\u000a            return ans\u000a        else: # If so, continue the loop and try again\u000a            done = False\u000a\u000a\u000a# Set independent sequences for each of the two choice blocks, the inference practice block, and the three inference rest blocks. Each rest block contains 10 presentations of\u000a# each pair.\u000a\u000achoiceseq = genseq_choice()\u000apracticeseq = genseq_infer_practice()\u000ablock1seq = genseq_infer()\u000ablock2seq = genseq_infer()\u000ablock3seq = genseq_infer()\u000a\u000a\u000a# Choose a pilot participant whose choices will form the basis of the learning task\u000apartners = ['P1','P2','P3','P4','P5','P6','P8','P9','P10','P11','P12'] # List of pilot participants, P7 excluded for perfectly inconsistent choices\u000apartner = np.random.choice(partners,1) # Choose one at random\u000apartner_file = 'conditions/choices/infer_design1_value_pairs_' + partner[0] + '.csv' # Path to that participant's choice data\u000a\u000a# Create separate CSV files, one for each choice, practice, and rest block, with the item pairs in the pseudorandomly generated order.\u000a# These CSV files will be used as PsychoPy's conditions spreadsheets and run sequentially in the choice, practice, and inference loops below.\u000a\u000a\u000achoicecond_src = pd.read_csv('conditions/choice_design1_binary.csv', index_col=None, header=0)\u000achoicecond = choicecond_src.copy()\u000afor x in range(40):\u000a    seq = choiceseq[x]\u000a    choicecond.iloc[x] = choicecond_src.iloc[seq]\u000achoicecond.to_csv(path_or_buf=filename+'_choicecond.csv', index=False)\u000a\u000apracticecond_src = pd.read_csv('conditions/choices/infer_design1_value_pairs_practice.csv', index_col=None, header=0)\u000apracticecond = practicecond_src.copy()\u000afor x in range(14):\u000a    seq = practiceseq[x]\u000a    practicecond.iloc[x] = practicecond_src.iloc[seq]\u000apracticecond.to_csv(path_or_buf=filename+'_practicecond.csv', index=False)\u000a\u000ablock1cond_src = pd.read_csv(partner_file, index_col=None, header=0)\u000ablock1cond = block1cond_src.copy()\u000afor x in range(200):\u000a    seq = block1seq[x]\u000a    block1cond.iloc[x] = block1cond_src.iloc[seq]\u000ablock1cond.to_csv(path_or_buf=filename+'_block1cond.csv', index=False)\u000a\u000ablock2cond_src = pd.read_csv(partner_file, index_col=None, header=0)\u000ablock2cond = block2cond_src.copy()\u000afor x in range(200):\u000a    seq = block2seq[x]\u000a    block2cond.iloc[x] = block2cond_src.iloc[seq]\u000ablock2cond.to_csv(path_or_buf=filename+'_block2cond.csv', index=False)\u000a\u000ablock3cond_src = pd.read_csv(partner_file, index_col=None, header=0)\u000ablock3cond = block3cond_src.copy()\u000afor x in range(200):\u000a    seq = block3seq[x]\u000a    block3cond.iloc[x] = block3cond_src.iloc[seq]\u000ablock3cond.to_csv(path_or_buf=filename+'_block3cond.csv', index=False)\u000a\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instr_main"-------\u000at = 0\u000ainstr_mainClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_main_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_main_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_mainComponents = []\u000ainstr_mainComponents.append(instr_main_txt)\u000ainstr_mainComponents.append(instr_main_resp)\u000afor thisComponent in instr_mainComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_main"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_mainClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_main_txt* updates\u000a    if t >= 0.0 and instr_main_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_main_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_main_txt.frameNStart = frameN  # exact frame index\u000a        instr_main_txt.setAutoDraw(True)\u000a    \u000a    # *instr_main_resp* updates\u000a    if t >= 5.0 and instr_main_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_main_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_main_resp.frameNStart = frameN  # exact frame index\u000a        instr_main_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_main_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_main_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_main_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_main_resp.rt = instr_main_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_mainComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_main"-------\u000afor thisComponent in instr_mainComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_main_resp.keys in ['', [], None]:  # No response was made\u000a   instr_main_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_main_resp.keys',instr_main_resp.keys)\u000aif instr_main_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_main_resp.rt', instr_main_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a\u000a#------Prepare to start Routine "instr_bdm"-------\u000at = 0\u000ainstr_bdmClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_bdm_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_bdm_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_bdmComponents = []\u000ainstr_bdmComponents.append(instr_bdm_txt)\u000ainstr_bdmComponents.append(instr_bdm_resp)\u000afor thisComponent in instr_bdmComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_bdm"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_bdmClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_bdm_txt* updates\u000a    if t >= 0.0 and instr_bdm_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_bdm_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_bdm_txt.frameNStart = frameN  # exact frame index\u000a        instr_bdm_txt.setAutoDraw(True)\u000a    \u000a    # *instr_bdm_resp* updates\u000a    if t >= 2.0 and instr_bdm_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_bdm_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_bdm_resp.frameNStart = frameN  # exact frame index\u000a        instr_bdm_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_bdm_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_bdm_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space', 's'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_bdm_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_bdm_resp.rt = instr_bdm_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_bdmComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_bdm"-------\u000afor thisComponent in instr_bdmComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_bdm_resp.keys in ['', [], None]:  # No response was made\u000a   instr_bdm_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_bdm_resp.keys',instr_bdm_resp.keys)\u000athisExp.addData('partnered_pilot_participant', partner)\u000aif instr_bdm_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_bdm_resp.rt', instr_bdm_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## BDM LOOP 1 ##########################\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000abdm_loop1 = data.TrialHandler(nReps=1, method=u'random', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'conditions/choice_design1_bdm.xlsx'),\u000a    seed=None, name='bdm_loop1')\u000athisExp.addLoop(bdm_loop1)  # add the loop to the experiment\u000athisbdm_loop1 = bdm_loop1.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisbdm_loop1.rgb)\u000aif thisbdm_loop1 != None:\u000a    for paramName in thisbdm_loop1.keys():\u000a        exec(paramName + '= thisbdm_loop1.' + paramName)\u000a\u000a# Check if the 'skip' key was pressed in the instructions routine; if so, end the loop and move on to the inference task\u000aif instr_bdm_resp.keys=='s':\u000a    bdm_loop1.finished = True\u000a\u000afor thisbdm_loop1 in bdm_loop1:\u000a    currentLoop = bdm_loop1\u000a    # abbreviate parameter names if possible (e.g. rgb = thisbdm_loop1.rgb)\u000a    if thisbdm_loop1 != None:\u000a        for paramName in thisbdm_loop1.keys():\u000a            exec(paramName + '= thisbdm_loop1.' + paramName)\u000a    \u000a    #------Prepare to start Routine "bdm"-------\u000a    t = 0\u000a    bdmClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    bdm_pic.setImage(dir_path+bdm_img)\u000a    bdm_bid.reset()\u000a    # jitter the starting position of the BDM scale from a uniform distribution between 1 and 2, rounded to the nearest decimal place\u000a    bdm_marker_start = float(np.round(np.random.uniform(1, 2, 1)[0], 1))\u000a    bdm_bid.setMarkerPos(bdm_marker_start)\u000a    # keep track of which components have finished\u000a    bdmComponents = []\u000a    bdmComponents.append(fixation_text)\u000a    bdmComponents.append(bdm_pic)\u000a    bdmComponents.append(bdm_bid)\u000a    for thisComponent in bdmComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "bdm"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = bdmClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation_text* updates\u000a        if t >= 0 and fixation_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation_text.tStart = t  # underestimates by a little under one frame\u000a            fixation_text.frameNStart = frameN  # exact frame index\u000a            fixation_text.setAutoDraw(True)\u000a        elif fixation_text.status == STARTED and t>= (0 + (1.0-win.monitorFramePeriod*0.75)):\u000a            fixation_text.setAutoDraw(False)\u000a\u000a        # *bdm_pic* updates\u000a        if t >= 1.0 and bdm_pic.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bdm_pic.tStart = t  # underestimates by a little under one frame\u000a            bdm_pic.frameNStart = frameN  # exact frame index\u000a            bdm_pic.setAutoDraw(True)\u000a        # *bdm_bid* updates\u000a        if t >= 1.0:\u000a            bdm_bid.draw()\u000a            continueRoutine = bdm_bid.noResponse\u000a            if bdm_bid.noResponse == False:\u000a                bdm_bid.response = bdm_bid.getRating()\u000a                bdm_bid.rt = bdm_bid.getRT()\u000a            elif bdm_bid.noResponse==True:\u000a                if keyState[key.LEFT]==True and bdm_bid.markerPlacedAt >0.01:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt - 0.02\u000a                    bdm_bid.draw()\u000a                elif keyState[key.LEFT]==True and bdm_bid.markerPlacedAt==0.01:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt - 0.01\u000a                    bdm_bid.draw()\u000a                elif keyState[key.RIGHT]==True and bdm_bid.markerPlacedAt <2.99:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt + 0.02\u000a                    bdm_bid.draw()\u000a                elif keyState[key.RIGHT]==True and bdm_bid.markerPlacedAt==2.99:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt + 0.01\u000a                    bdm_bid.draw()\u000a                    \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in bdmComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "bdm"-------\u000a    for thisComponent in bdmComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # store data for bdm (TrialHandler)\u000a    bdm_loop1.addData('bdm_bid1.response', bdm_bid.getRating())\u000a    bdm_loop1.addData('bdm_bid1.rt', bdm_bid.getRT())\u000a    bdm_loop1.addData('bdm_marker_start', bdm_marker_start)\u000a\u000a    # Add the item and the subject's bid to the 'bids' list, which will be merged with the 'prefs' list later in order to run the auction\u000a    bids.append([bdm_img, bdm_bid.response])\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeat of 'bdm_loop1'\u000a\u000a\u000a#------Prepare to start Routine "instr_choice"-------\u000at = 0\u000ainstr_choiceClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_choice_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_choice_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_choiceComponents = []\u000ainstr_choiceComponents.append(instr_choice_txt)\u000ainstr_choiceComponents.append(instr_choice_resp)\u000afor thisComponent in instr_choiceComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_choice"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_choiceClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_choice_txt* updates\u000a    if t >= 0.0 and instr_choice_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_choice_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_choice_txt.frameNStart = frameN  # exact frame index\u000a        instr_choice_txt.setAutoDraw(True)\u000a    \u000a    # *instr_choice_resp* updates\u000a    if t >= 2.0 and instr_choice_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_choice_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_choice_resp.frameNStart = frameN  # exact frame index\u000a        instr_choice_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_choice_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_choice_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space', 's'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_choice_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_choice_resp.rt = instr_choice_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_choiceComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_choice"-------\u000afor thisComponent in instr_choiceComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_choice_resp.keys in ['', [], None]:  # No response was made\u000a   instr_choice_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_choice_resp.keys',instr_choice_resp.keys)\u000aif instr_choice_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_choice_resp.rt', instr_choice_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## BINARY LOOP ##########################\u000a\u000a# set up handler to look after randomisation of conditions etc\u000abinary = data.TrialHandler(nReps=1, method=u'sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(filename+'_choicecond.csv'),\u000a    seed=None, name='binary')\u000athisExp.addLoop(binary)  # add the loop to the experiment\u000athisBinary1 = binary.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBinary1.rgb)\u000aif thisBinary1 != None:\u000a    for paramName in thisBinary1.keys():\u000a        exec(paramName + '= thisBinary1.' + paramName)\u000a\u000a# Check if the 'skip' key was pressed in the instructions routine; if so, end the loop and move on to the BDM\u000aif instr_choice_resp.keys=='s':\u000a    binary.finished = True\u000a\u000afor thisBinary1 in binary:\u000a    currentLoop = binary\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBinary1.rgb)\u000a    if thisBinary1 != None:\u000a        for paramName in thisBinary1.keys():\u000a            exec(paramName + '= thisBinary1.' + paramName)\u000a    \u000a    #------Prepare to start Routine "choice"-------\u000a    t = 0\u000a    choiceClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    choice_pic_left.setImage(dir_path+choice_left)\u000a    choice_pic_right.setImage(dir_path+choice_right)\u000a    event.clearEvents(eventType='keyboard') # Clear keyboard event log to avoid last key press from prior loop being used\u000a    key_resp_choice = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_choice.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    choiceComponents = []\u000a    choiceComponents.append(fixation_text)\u000a    choiceComponents.append(choice_pic_left)\u000a    choiceComponents.append(choice_pic_right)\u000a    choiceComponents.append(key_resp_choice)\u000a    for thisComponent in choiceComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    \u000a    #-------Start Routine "choice"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = choiceClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation_text* updates\u000a        if t >= 0 and fixation_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation_text.tStart = t  # underestimates by a little under one frame\u000a            fixation_text.frameNStart = frameN  # exact frame index\u000a            fixation_text.setAutoDraw(True)\u000a        elif fixation_text.status == STARTED and t>= (0 + (1.0-win.monitorFramePeriod*0.75)):\u000a            fixation_text.setAutoDraw(False)\u000a\u000a        # *choice_pic_left* updates\u000a        if t >= 1.0 and choice_pic_left.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_left.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_left.frameNStart = frameN  # exact frame index\u000a            choice_pic_left.setAutoDraw(True)\u000a        \u000a        # *choice_pic_right* updates\u000a        if t >= 1.0 and choice_pic_right.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_right.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_right.frameNStart = frameN  # exact frame index\u000a            choice_pic_right.setAutoDraw(True)\u000a\u000a        # *key_resp_choice* updates\u000a        if t >= 1.0 and key_resp_choice.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_choice.tStart = t  # underestimates by a little under one frame\u000a            key_resp_choice.frameNStart = frameN  # exact frame index\u000a            key_resp_choice.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_choice.clock.reset()  # now t=0\u000a        if key_resp_choice.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_choice.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_choice.rt = key_resp_choice.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in choiceComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "choice"-------\u000a    for thisComponent in choiceComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_choice.keys in ['', [], None]:  # No response was made\u000a       key_resp_choice.keys=None\u000a    # store data for binary (TrialHandler)\u000a    binary.addData('key_resp_choice.keys',key_resp_choice.keys)\u000a    if key_resp_choice.keys != None:  # we had a response\u000a        binary.addData('key_resp_choice.rt', key_resp_choice.rt)\u000a\u000a    # define a function to append binary choices and the bid for the chosen item to the preference list\u000a    # lft is the left image displayed during that choice trial\u000a    # rt is the right image displayed\u000a    def rec_choice(lft, rt): \u000a        bd = False\u000a        if key_resp_choice.keys=='left':\u000a            chc = lft\u000a        elif key_resp_choice.keys=='right':\u000a            chc = rt\u000a        for x in range(len(bids)):\u000a            if bids[x][0]==chc:\u000a                bd = bids[x][1]\u000a        prefs.append([lft, rt, chc, bd])\u000a\u000a    # call the function\u000a    rec_choice(choice_left, choice_right)\u000a    \u000a\u000a    #------Prepare to start Routine "choice_selection"-------\u000a    t = 0\u000a    choice_selectionClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # keep track of which components have finished\u000a    choice_selectionComponents = []\u000a    choice_selectionComponents.append(choice_pic_left)\u000a    choice_selectionComponents.append(choice_pic_right)\u000a    choice_selectionComponents.append(star_left_selection)\u000a    choice_selectionComponents.append(star_right_selection)\u000a    for thisComponent in choice_selectionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "choice_selection"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = choice_selectionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *choice_pic_left* updates\u000a        if t >= 0.0 and choice_pic_left.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_left.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_left.frameNStart = frameN  # exact frame index\u000a            choice_pic_left.setAutoDraw(True)\u000a        elif choice_pic_left.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            choice_pic_left.setAutoDraw(False)\u000a        \u000a        # *choice_pic_right* updates\u000a        if t >= 0.0 and choice_pic_right.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_right.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_right.frameNStart = frameN  # exact frame index\u000a            choice_pic_right.setAutoDraw(True)\u000a        elif choice_pic_right.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            choice_pic_right.setAutoDraw(False)\u000a        \u000a        # *star_left_selection* updates\u000a        if key_resp_choice.keys=='left':\u000a            if t >= 0.0 and star_left_selection.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                star_left_selection.tStart = t  # underestimates by a little under one frame\u000a                star_left_selection.frameNStart = frameN  # exact frame index\u000a                star_left_selection.setAutoDraw(True)\u000a            elif star_left_selection.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                star_left_selection.setAutoDraw(False)\u000a        \u000a        # *star_right_selection* updates\u000a        if key_resp_choice.keys=='right':\u000a            if t >= 0.0 and star_right_selection.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                star_right_selection.tStart = t  # underestimates by a little under one frame\u000a                star_right_selection.frameNStart = frameN  # exact frame index\u000a                star_right_selection.setAutoDraw(True)\u000a            elif star_right_selection.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                star_right_selection.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in choice_selectionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "choice_selection"-------\u000a    for thisComponent in choice_selectionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    #thisExp.nextEntry()\u000a\u000a    #------Prepare to start Routine "confidence"-------\u000a    t = 0\u000a    confidenceClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    confidence_rating.reset()\u000a    # jitter the starting position of the confidence rating scale from a uniform distribution between 1.7 and 3.3 (the middle third of the scale), rounded to the nearest decimal place\u000a    confidence_marker_start = float(np.round(np.random.uniform(1.7, 3.3, 1)[0], 1))\u000a    confidence_rating.setMarkerPos(confidence_marker_start)\u000a    # keep track of which components have finished\u000a    confidenceComponents = []\u000a    confidenceComponents.append(confidence_rating)\u000a    for thisComponent in confidenceComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "confidence"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = confidenceClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *confidence_rating* updates\u000a        if t > 0.5:\u000a            confidence_rating.draw()\u000a            continueRoutine = confidence_rating.noResponse\u000a            if confidence_rating.noResponse == False:\u000a                confidence_rating.response = confidence_rating.getRating()\u000a                confidence_rating.rt = confidence_rating.getRT()\u000a            elif confidence_rating.noResponse==True:\u000a                if keyState[key.LEFT]==True and confidence_rating.markerPlacedAt >0:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt - 0.1\u000a                    confidence_rating.draw()\u000a                elif keyState[key.LEFT]==True and confidence_rating.markerPlacedAt==0.1:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt - 0.1\u000a                    confidence_rating.draw()\u000a                elif keyState[key.RIGHT]==True and confidence_rating.markerPlacedAt <4.9:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt + 0.1\u000a                    confidence_rating.draw()\u000a                elif keyState[key.RIGHT]==True and confidence_rating.markerPlacedAt==4.9:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt + 0.1\u000a                    confidence_rating.draw()\u000a                    \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in confidenceComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "confidence"-------\u000a    for thisComponent in confidenceComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # store data for confidence (TrialHandler)\u000a    binary.addData('confidence_rating1.response', confidence_rating.getRating())\u000a    binary.addData('confidence_rating1.rt', confidence_rating.getRT())\u000a    binary.addData('confidence_marker_start', confidence_marker_start+1) # Add 1 to convert from 0-5 to 1-6 scale\u000a\u000a    thisExp.nextEntry()\u000a\u000a\u000a# completed 1 repeat of 'binary'        \u000a\u000a#------Prepare to start Routine "instr_infer_intro"-------\u000at = 0\u000ainstr_infer_introClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_infer_intro_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_infer_intro_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_infer_introComponents = []\u000ainstr_infer_introComponents.append(instr_infer_intro_txt)\u000ainstr_infer_introComponents.append(instr_infer_intro_resp)\u000afor thisComponent in instr_infer_introComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_infer_intro"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_infer_introClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_infer_intro_txt* updates\u000a    if t >= 0.0 and instr_infer_intro_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_intro_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_intro_txt.frameNStart = frameN  # exact frame index\u000a        instr_infer_intro_txt.setAutoDraw(True)\u000a    \u000a    # *instr_infer_intro_resp* updates\u000a    if t >= 5.0 and instr_infer_intro_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_intro_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_intro_resp.frameNStart = frameN  # exact frame index\u000a        instr_infer_intro_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_infer_intro_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_infer_intro_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_infer_intro_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_infer_intro_resp.rt = instr_infer_intro_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_infer_introComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_infer_intro"-------\u000afor thisComponent in instr_infer_introComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_infer_intro_resp.keys in ['', [], None]:  # No response was made\u000a   instr_infer_intro_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_infer_intro_resp.keys',instr_infer_intro_resp.keys)\u000aif instr_infer_intro_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_infer_intro_resp.rt', instr_infer_intro_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a#------Prepare to start Routine "instr_infer_practice"-------\u000at = 0\u000ainstr_infer_practiceClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_infer_practice_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_infer_practice_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_infer_practiceComponents = []\u000ainstr_infer_practiceComponents.append(instr_infer_practice_txt)\u000ainstr_infer_practiceComponents.append(instr_infer_practice_resp)\u000afor thisComponent in instr_infer_practiceComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_infer_practice"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_infer_practiceClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_infer_practice_txt* updates\u000a    if t >= 0.0 and instr_infer_practice_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_practice_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_practice_txt.frameNStart = frameN  # exact frame index\u000a        instr_infer_practice_txt.setAutoDraw(True)\u000a    \u000a    # *instr_infer_practice_resp* updates\u000a    if t >= 5.0 and instr_infer_practice_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_practice_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_practice_resp.frameNStart = frameN  # exact frame index\u000a        instr_infer_practice_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_infer_practice_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_infer_practice_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_infer_practice_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_infer_practice_resp.rt = instr_infer_practice_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_infer_practiceComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_infer_practice"-------\u000afor thisComponent in instr_infer_practiceComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_infer_practice_resp.keys in ['', [], None]:  # No response was made\u000a   instr_infer_practice_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_infer_practice_resp.keys',instr_infer_practice_resp.keys)\u000aif instr_infer_practice_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_infer_practice_resp.rt', instr_infer_practice_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## PRACTICE LOOP ##########################\u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_loop = data.TrialHandler(nReps=1, method=u'sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(filename+'_practicecond.csv'),\u000a    seed=None, name='practice_loop')\u000athisExp.addLoop(practice_loop)  # add the loop to the experiment\u000athisPractice_loop = practice_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_loop.rgb)\u000aif thisPractice_loop != None:\u000a    for paramName in thisPractice_loop.keys():\u000a        exec(paramName + '= thisPractice_loop.' + paramName)\u000a\u000a  \u000afor thisPractice_loop in practice_loop:\u000a    currentLoop = practice_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_loop.rgb)\u000a    if thisPractice_loop != None:\u000a        for paramName in thisPractice_loop.keys():\u000a            exec(paramName + '= thisPractice_loop.' + paramName)    \u000a    \u000a        \u000a    # Define class for setting the feedback image\u000a    class set_feedback:\u000a        options = ['correct', 'wrong']\u000a        feedback = np.random.choice(options, replace=True, p=[0.8, 0.2])\u000a        if feedback=='correct':\u000a            feedback_img = img_correct\u000a        elif feedback=='wrong':\u000a            feedback_img = img_wrong\u000a\u000a        if feedback_img==img_left:\u000a            feedback_side = 'left'\u000a        elif feedback_img==img_right:\u000a            feedback_side = 'right'\u000a\u000a\u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialtime = datetime.datetime.now()\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    img_left_infer.setImage(dir_path+img_left)\u000a    img_right_infer.setImage(dir_path+img_right)\u000a    infer_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    infer_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(fixation_text)\u000a    trialComponents.append(img_left_infer)\u000a    trialComponents.append(img_right_infer)\u000a    trialComponents.append(infer_resp)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation_text* updates\u000a        if t >= 0 and fixation_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation_text.tStart = t  # underestimates by a little under one frame\u000a            fixation_text.frameNStart = frameN  # exact frame index\u000a            fixation_text.setAutoDraw(True)\u000a        elif fixation_text.status == STARTED and t>= (0 + (2.0-win.monitorFramePeriod*0.75)):\u000a            fixation_text.setAutoDraw(False)\u000a\u000a        # *img_left_infer* updates\u000a        if t >= 2.0 and img_left_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_left_infer.tStart = t  # underestimates by a little under one frame\u000a            img_left_infer.frameNStart = frameN  # exact frame index\u000a            img_left_infer.setAutoDraw(True)\u000a        \u000a        # *img_right_infer* updates\u000a        if t >= 2.0 and img_right_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_right_infer.tStart = t  # underestimates by a little under one frame\u000a            img_right_infer.frameNStart = frameN  # exact frame index\u000a            img_right_infer.setAutoDraw(True)\u000a                  \u000a        # *infer_resp* updates\u000a        if t >= 2.0 and infer_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            infer_resp.tStart = t  # underestimates by a little under one frame\u000a            infer_resp.frameNStart = frameN  # exact frame index\u000a            infer_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            infer_resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if infer_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                infer_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                infer_resp.rt = infer_resp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a\u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if infer_resp.keys in ['', [], None]:  # No response was made\u000a       infer_resp.keys=None\u000a    # # store data for practice_loop (TrialHandler)\u000a    # practice_loop.addData('infer_resp.keys',infer_resp.keys)\u000a    # if infer_resp.keys != None:  # we had a response\u000a    #     practice_loop.addData('infer_resp.rt', infer_resp.rt)\u000a    practice_loop.addData('set_feedback.feedback_img', set_feedback.feedback_img)\u000a    practice_loop.addData('trial_start_time', trialtime)\u000a    \u000a    # # Increase correct and incorrect response counters by 1 based on S's response\u000a    # if infer_resp.keys=='left' and img_correct==img_left:\u000a    #     correct_counter += 1\u000a    # elif infer_resp.keys=='left' and img_correct==img_right:\u000a    #     incorrect_counter += 1\u000a    # elif infer_resp.keys=='right' and img_correct==img_right:\u000a    #     correct_counter += 1\u000a    # elif infer_resp.keys=='right' and img_correct==img_left:\u000a    #     incorrect_counter += 1\u000a    \u000a\u000a    #------Prepare to start Routine "trial_post_response"-------\u000a    t = 0\u000a    trial_post_responseClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(3.000000)\u000a    # keep track of which components have finished\u000a    trial_post_responseComponents = []\u000a    trial_post_responseComponents.append(img_left_infer)\u000a    trial_post_responseComponents.append(img_right_infer)\u000a    trial_post_responseComponents.append(selection_arrow_left)\u000a    trial_post_responseComponents.append(selection_arrow_right)\u000a    trial_post_responseComponents.append(feedback_box_left)\u000a    trial_post_responseComponents.append(feedback_box_right)\u000a    for thisComponent in trial_post_responseComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial_post_response"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = trial_post_responseClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a\u000a        # *img_left_infer* updates\u000a        if t >= 0.0 and img_left_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_left_infer.tStart = t  # underestimates by a little under one frame\u000a            img_left_infer.frameNStart = frameN  # exact frame index\u000a            img_left_infer.setAutoDraw(True)\u000a        elif img_left_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            img_left_infer.setAutoDraw(False)\u000a        \u000a        # *img_right_infer* updates\u000a        if t >= 0.0 and img_right_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_right_infer.tStart = t  # underestimates by a little under one frame\u000a            img_right_infer.frameNStart = frameN  # exact frame index\u000a            img_right_infer.setAutoDraw(True)\u000a        elif img_right_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            img_right_infer.setAutoDraw(False)\u000a        \u000a        if infer_resp.keys == 'left':\u000a            # *selection_arrow_left* updates\u000a            if t >= 0.0 and selection_arrow_left.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                selection_arrow_left.tStart = t  # underestimates by a little under one frame\u000a                selection_arrow_left.frameNStart = frameN  # exact frame index\u000a                selection_arrow_left.setAutoDraw(True)\u000a            elif selection_arrow_left.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                selection_arrow_left.setAutoDraw(False)\u000a        \u000a        if infer_resp.keys == 'right':\u000a            # *selection_arrow_right* updates\u000a            if t >= 0.0 and selection_arrow_right.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                selection_arrow_right.tStart = t  # underestimates by a little under one frame\u000a                selection_arrow_right.frameNStart = frameN  # exact frame index\u000a                selection_arrow_right.setAutoDraw(True)\u000a            elif selection_arrow_right.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                selection_arrow_right.setAutoDraw(False)\u000a        \u000a        if set_feedback.feedback_side == 'left':\u000a            # *feedback_box_left* updates\u000a            if t >= 1.0 and feedback_box_left.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                feedback_box_left.tStart = t  # underestimates by a little under one frame\u000a                feedback_box_left.frameNStart = frameN  # exact frame index\u000a                feedback_box_left.setAutoDraw(True)\u000a            elif feedback_box_left.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                feedback_box_left.setAutoDraw(False)\u000a        \u000a        if set_feedback.feedback_side == 'right':\u000a            # *feedback_box_right* updates\u000a            if t >= 1.0 and feedback_box_right.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                feedback_box_right.tStart = t  # underestimates by a little under one frame\u000a                feedback_box_right.frameNStart = frameN  # exact frame index\u000a                feedback_box_right.setAutoDraw(True)\u000a            elif feedback_box_right.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period right\u000a                feedback_box_right.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trial_post_responseComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "trial_post_response"-------\u000a    for thisComponent in trial_post_responseComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000a    \u000a    thisExp.nextEntry()\u000a                        \u000a# completed 1 repeat of 'practice_loop'\u000a\u000a\u000a#------Prepare to start Routine "instr_infer"-------\u000at = 0\u000ainstr_inferClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_infer_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_infer_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_inferComponents = []\u000ainstr_inferComponents.append(instr_infer_txt)\u000ainstr_inferComponents.append(instr_infer_resp)\u000afor thisComponent in instr_inferComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_infer"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_inferClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_infer_txt* updates\u000a    if t >= 0.0 and instr_infer_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_txt.frameNStart = frameN  # exact frame index\u000a        instr_infer_txt.setAutoDraw(True)\u000a    \u000a    # *instr_infer_resp* updates\u000a    if t >= 5.0 and instr_infer_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_resp.frameNStart = frameN  # exact frame index\u000a        instr_infer_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_infer_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_infer_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_infer_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_infer_resp.rt = instr_infer_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_inferComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_infer"-------\u000afor thisComponent in instr_inferComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_infer_resp.keys in ['', [], None]:  # No response was made\u000a   instr_infer_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_infer_resp.keys',instr_infer_resp.keys)\u000aif instr_infer_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_infer_resp.rt', instr_infer_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## BLOCK LOOP ##########################\u000a\u000a# This loop runs a second nested loop that shows each item pair 10 times, followed by a rest break prompt.\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=3, method=u'sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=[None],\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000a# Set up counter to keep track of block loop cycle, so that the rest prompt is only shown twice\u000ablock_loop_counter = 0\u000a\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    # Increase loop counter by one\u000a    block_loop_counter += 1\u000a    \u000a    # Change the condition file for the feedback block based on which block loop we're on\u000a    condfilename = filename+u'_block'+str(block_loop_counter)+u'cond.csv'\u000a    \u000a    # # Minimize the psychopy window so the calibration window can be seen\u000a    # win.winHandle.minimize()\u000a    # #Do the eye tracker setup at the beginning of each block\u000a    # tracker.runSetupProcedure()\u000a    # # Re-display the psychopy window after setup is completed\u000a    # win.winHandle.maximize()\u000a    # win.winHandle.activate()\u000a    \u000a\u000a    \u000a    #------Prepare to start Routine "get_ready"-------\u000a    t = 0\u000a    get_readyClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(3.000000)\u000a    # update component parameters for each repeat\u000a    get_ready_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    get_ready_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    get_readyComponents = []\u000a    get_readyComponents.append(get_ready_text)\u000a    get_readyComponents.append(get_ready_resp)\u000a    for thisComponent in get_readyComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    \u000a    #-------Start Routine "get_ready"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = get_readyClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *get_ready_text* updates\u000a        if t >= 0.0 and get_ready_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            get_ready_text.tStart = t  # underestimates by a little under one frame\u000a            get_ready_text.frameNStart = frameN  # exact frame index\u000a            get_ready_text.setAutoDraw(True)\u000a        \u000a        # *get_ready_resp* updates\u000a        if t >= 0.0 and get_ready_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            get_ready_resp.tStart = t  # underestimates by a little under one frame\u000a            get_ready_resp.frameNStart = frameN  # exact frame index\u000a            get_ready_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            get_ready_resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if get_ready_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['p'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                get_ready_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                get_ready_resp.rt = get_ready_resp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in get_readyComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "get_ready"-------\u000a    for thisComponent in get_readyComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if get_ready_resp.keys in ['', [], None]:  # No response was made\u000a       get_ready_resp.keys=None\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('get_ready_resp.keys',get_ready_resp.keys)\u000a    if get_ready_resp.keys != None:  # we had a response\u000a        thisExp.addData('get_ready_resp.rt', get_ready_resp.rt)\u000a    thisExp.nextEntry()\u000a\u000a    ######################## TRIAL LOOP ##########################\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    trial_loop = data.TrialHandler(nReps=1, method=u'sequential', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(condfilename),\u000a        seed=None, name='trial_loop')\u000a    thisExp.addLoop(trial_loop)  # add the loop to the experiment\u000a    thisTrial_loop = trial_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_loop.rgb)\u000a    if thisTrial_loop != None:\u000a        for paramName in thisTrial_loop.keys():\u000a            exec(paramName + '= thisTrial_loop.' + paramName)\u000a    \u000a      \u000a    for thisTrial_loop in trial_loop:\u000a        currentLoop = trial_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_loop.rgb)\u000a        if thisTrial_loop != None:\u000a            for paramName in thisTrial_loop.keys():\u000a                exec(paramName + '= thisTrial_loop.' + paramName)    \u000a        \u000a            \u000a        # Define class for setting the feedback image\u000a        class set_feedback:\u000a            options = ['correct', 'wrong']\u000a            feedback = np.random.choice(options, replace=True, p=[0.8, 0.2])\u000a            if feedback=='correct':\u000a                feedback_img = img_correct\u000a            elif feedback=='wrong':\u000a                feedback_img = img_wrong\u000a\u000a            if feedback_img==img_left:\u000a                feedback_side = 'left'\u000a            elif feedback_img==img_right:\u000a                feedback_side = 'right'\u000a                        \u000a        # # Start getting data from the eye tracker\u000a        # tracker.enableEventReporting(True)\u000a        # # Send beginning-of-trial messages to eye tracker data file\u000a        # trial_number = (block_loop.thisN * 200) + trial_loop.thisTrialN # Trial number out of 599 (starts at 0)\u000a        # tracker.sendCommand("record_status_message 'INFERRING, Block %d/3, Trial %d/600 '" % (block_loop.thisN + 1, trial_number + 1))\u000a        # tracker.sendMessage("TRIALID %d" % trial_number)\u000a        # tracker.sendMessage("!V TRIAL_VAR_DATA %d" % trial_number)\u000a\u000a        \u000a        #------Prepare to start Routine "trial"-------\u000a        t = 0\u000a        trialtime = datetime.datetime.now()\u000a        trialClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        img_left_infer.setImage(dir_path+img_left)\u000a        img_right_infer.setImage(dir_path+img_right)\u000a        infer_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        infer_resp.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trialComponents = []\u000a        trialComponents.append(fixation_text)\u000a        trialComponents.append(img_left_infer)\u000a        trialComponents.append(img_right_infer)\u000a        trialComponents.append(infer_resp)\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        # Set indicator variable for whether eye tracker messages were sent during the first loop of the routine\u000a        eye_sync_messages_sent = 0\u000a        \u000a        #-------Start Routine "trial"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = trialClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *fixation_text* updates\u000a            if t >= 0 and fixation_text.status == NOT_STARTED:\u000a                if eye_sync_messages_sent==0:\u000a                    startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                # keep track of start time/frame for later\u000a                fixation_text.tStart = t  # underestimates by a little under one frame\u000a                fixation_text.frameNStart = frameN  # exact frame index\u000a                fixation_text.setAutoDraw(True)\u000a                if eye_sync_messages_sent==0:\u000a                    drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                    # tracker.sendMessage("%d DISPLAY ON" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                    # tracker.sendMessage("SYNCTIME %d" %drawTime)\u000a                    eye_sync_messages_sent = 1\u000a            elif fixation_text.status == STARTED and t>= (0 + (2.0-win.monitorFramePeriod*0.75)):\u000a                fixation_text.setAutoDraw(False)\u000a            \u000a            # *img_left_infer* updates\u000a            if t >= 2.0 and img_left_infer.status == NOT_STARTED:\u000a                if eye_sync_messages_sent==1:\u000a                    startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                # keep track of start time/frame for later\u000a                img_left_infer.tStart = t  # underestimates by a little under one frame\u000a                img_left_infer.frameNStart = frameN  # exact frame index\u000a                img_left_infer.setAutoDraw(True)\u000a            \u000a            # *img_right_infer* updates\u000a            if t >= 2.0 and img_right_infer.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                img_right_infer.tStart = t  # underestimates by a little under one frame\u000a                img_right_infer.frameNStart = frameN  # exact frame index\u000a                img_right_infer.setAutoDraw(True)\u000a                if eye_sync_messages_sent==1:\u000a                    drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                    # tracker.sendMessage("%d DISPLAY ON ITEMS" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                    eye_sync_messages_sent = 2\u000a                      \u000a            # *infer_resp* updates\u000a            if t >= 2.0 and infer_resp.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                infer_resp.tStart = t  # underestimates by a little under one frame\u000a                infer_resp.frameNStart = frameN  # exact frame index\u000a                infer_resp.status = STARTED\u000a                # keyboard checking is just starting\u000a                infer_resp.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            if infer_resp.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['left', 'right'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    infer_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                    infer_resp.rt = infer_resp.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trialComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                # tracker.enableEventReporting(False) # End eye tracker data recording\u000a                # tracker.sendMessage("EXPERIMENT ABORTED")\u000a                # io.quit() # Close iohub\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial"-------\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if infer_resp.keys in ['', [], None]:  # No response was made\u000a           infer_resp.keys=None\u000a        # store data for trial_loop (TrialHandler)\u000a        trial_loop.addData('infer_resp.keys',infer_resp.keys)\u000a        if infer_resp.keys != None:  # we had a response\u000a            trial_loop.addData('infer_resp.rt', infer_resp.rt)\u000a        trial_loop.addData('set_feedback.feedback_img', set_feedback.feedback_img)\u000a        trial_loop.addData('trial_start_time', trialtime)\u000a        \u000a        # Increase correct and incorrect response counters by 1 based on S's response\u000a        if infer_resp.keys=='left' and img_correct==img_left:\u000a            correct_counter += 1\u000a        elif infer_resp.keys=='left' and img_correct==img_right:\u000a            incorrect_counter += 1\u000a        elif infer_resp.keys=='right' and img_correct==img_right:\u000a            correct_counter += 1\u000a        elif infer_resp.keys=='right' and img_correct==img_left:\u000a            incorrect_counter += 1\u000a        \u000a\u000a        #------Prepare to start Routine "trial_post_response"-------\u000a        t = 0\u000a        trial_post_responseClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(3.000000)\u000a        # keep track of which components have finished\u000a        trial_post_responseComponents = []\u000a        trial_post_responseComponents.append(img_left_infer)\u000a        trial_post_responseComponents.append(img_right_infer)\u000a        trial_post_responseComponents.append(selection_arrow_left)\u000a        trial_post_responseComponents.append(selection_arrow_right)\u000a        trial_post_responseComponents.append(feedback_box_left)\u000a        trial_post_responseComponents.append(feedback_box_right)\u000a        for thisComponent in trial_post_responseComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        # Set indicator variable for whether eye tracker messages were sent during the first loop of the routine\u000a        eye_sync_messages_sent = 0\u000a\u000a        #-------Start Routine "trial_post_response"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = trial_post_responseClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a\u000a            # *img_left_infer* updates\u000a            if t >= 0.0 and img_left_infer.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                img_left_infer.tStart = t  # underestimates by a little under one frame\u000a                img_left_infer.frameNStart = frameN  # exact frame index\u000a                img_left_infer.setAutoDraw(True)\u000a            elif img_left_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                img_left_infer.setAutoDraw(False)\u000a            \u000a            # *img_right_infer* updates\u000a            if t >= 0.0 and img_right_infer.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                img_right_infer.tStart = t  # underestimates by a little under one frame\u000a                img_right_infer.frameNStart = frameN  # exact frame index\u000a                img_right_infer.setAutoDraw(True)\u000a            elif img_right_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                img_right_infer.setAutoDraw(False)\u000a            \u000a            if infer_resp.keys == 'left':\u000a                # *selection_arrow_left* updates\u000a                if t >= 0.0 and selection_arrow_left.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==0:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    selection_arrow_left.tStart = t  # underestimates by a little under one frame\u000a                    selection_arrow_left.frameNStart = frameN  # exact frame index\u000a                    selection_arrow_left.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==0:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        # tracker.sendMessage("%d DISPLAY ON SELECTION" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 1\u000a                elif selection_arrow_left.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    if eye_sync_messages_sent==1:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    selection_arrow_left.setAutoDraw(False)\u000a                    if eye_sync_messages_sent==1:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        # tracker.sendMessage("%d DISPLAY ON SELECTION OFF" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 2\u000a            \u000a            if infer_resp.keys == 'right':\u000a                # *selection_arrow_right* updates\u000a                if t >= 0.0 and selection_arrow_right.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==0:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    selection_arrow_right.tStart = t  # underestimates by a little under one frame\u000a                    selection_arrow_right.frameNStart = frameN  # exact frame index\u000a                    selection_arrow_right.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==0:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        # tracker.sendMessage("%d DISPLAY ON SELECTION" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 1\u000a                elif selection_arrow_right.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    if eye_sync_messages_sent==1:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    selection_arrow_right.setAutoDraw(False)\u000a                    if eye_sync_messages_sent==1:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        # tracker.sendMessage("%d DISPLAY ON SELECTION OFF" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 2\u000a            \u000a            if set_feedback.feedback_side == 'left':\u000a                # *feedback_box_left* updates\u000a                if t >= 1.0 and feedback_box_left.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==2:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    feedback_box_left.tStart = t  # underestimates by a little under one frame\u000a                    feedback_box_left.frameNStart = frameN  # exact frame index\u000a                    feedback_box_left.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==2:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        # tracker.sendMessage("%d DISPLAY ON FEEDBACK" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 3\u000a                elif feedback_box_left.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    feedback_box_left.setAutoDraw(False)\u000a            \u000a            if set_feedback.feedback_side == 'right':\u000a                # *feedback_box_right* updates\u000a                if t >= 1.0 and feedback_box_right.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==2:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    feedback_box_right.tStart = t  # underestimates by a little under one frame\u000a                    feedback_box_right.frameNStart = frameN  # exact frame index\u000a                    feedback_box_right.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==2:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        # tracker.sendMessage("%d DISPLAY ON FEEDBACK" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 3\u000a                elif feedback_box_right.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period right\u000a                    feedback_box_right.setAutoDraw(False)\u000a\u000a\u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial_post_responseComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                # tracker.enableEventReporting(False) # End eye tracker data recording\u000a                # tracker.sendMessage("EXPERIMENT ABORTED")\u000a                # io.quit() # Close iohub\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "trial_post_response"-------\u000a        for thisComponent in trial_post_responseComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a        thisExp.nextEntry()\u000a                            \u000a    # completed 5 repeats of 'trial_loop'\u000a    \u000a    if block_loop_counter <= 2: # If this is the first or second cycle of the loop, display the rest break prompt\u000a\u000a        #------Prepare to start Routine "rest_prompt"-------\u000a        t = 0\u000a        rest_promptClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        rest_prompt_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        rest_prompt_resp.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        rest_promptComponents = []\u000a        rest_promptComponents.append(rest_prompt_txt)\u000a        rest_promptComponents.append(rest_prompt_resp)\u000a        for thisComponent in rest_promptComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a\u000a        #-------Start Routine "rest_prompt"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = rest_promptClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *rest_prompt_txt* updates\u000a            if t >= 0.0 and rest_prompt_txt.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                rest_prompt_txt.tStart = t  # underestimates by a little under one frame\u000a                rest_prompt_txt.frameNStart = frameN  # exact frame index\u000a                rest_prompt_txt.setAutoDraw(True)\u000a            \u000a            # *rest_prompt_resp* updates\u000a            if t >= 2.0 and rest_prompt_resp.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                rest_prompt_resp.tStart = t  # underestimates by a little under one frame\u000a                rest_prompt_resp.frameNStart = frameN  # exact frame index\u000a                rest_prompt_resp.status = STARTED\u000a                # keyboard checking is just starting\u000a                rest_prompt_resp.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            if rest_prompt_resp.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    rest_prompt_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                    rest_prompt_resp.rt = rest_prompt_resp.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in rest_promptComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                # tracker.enableEventReporting(False) # End eye tracker data recording\u000a                # tracker.sendMessage("EXPERIMENT ABORTED")\u000a                # io.quit() # CLose iohub\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a\u000a        #-------Ending Routine "rest_prompt"-------\u000a        for thisComponent in rest_promptComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if rest_prompt_resp.keys in ['', [], None]:  # No response was made\u000a           rest_prompt_resp.keys=None\u000a        # store data for thisExp (ExperimentHandler)\u000a        thisExp.addData('rest_prompt_resp.keys',rest_prompt_resp.keys)\u000a        if rest_prompt_resp.keys != None:  # we had a response\u000a            thisExp.addData('rest_prompt_resp.rt', rest_prompt_resp.rt)\u000a\u000a\u000a    thisExp.nextEntry()\u000a    \u000a# completed 3 repeats of 'block_loop'\u000a\u000a\u000a# store data for total number of correct and incorrect responses    \u000athisExp.addData('correct_counter', correct_counter)\u000athisExp.addData('incorrect_counter', incorrect_counter)\u000athisExp.nextEntry()     \u000a\u000a# tracker.setConnectionState(False) # Close and transfer eye-tracking data, then close down eye tracker connection\u000a\u000a\u000a######################## AUCTION ##########################\u000a\u000aif len(prefs)==41 and len(bids)==41: # If S completed the entire binary choice and BDM routines, run the auction\u000a\u000a    # run the auction\u000a    class auction:\u000a        rand_itm = randint(1, (len(prefs))) # pick index for S's chosen item from a random choice\u000a        price = float((randint(1, 300)))/100 # assign a price to the item randomly from between 0.01 and 3 pounds\u000a        bid = prefs[rand_itm][3]\u000a        # check if S's bid for that item was above or below the price\u000a        if bid >= price:\u000a            win_item=True\u000a        elif bid < price:\u000a            win_item=False\u000a\u000a        # set text for the auction screen\u000a        if win_item==True:\u000a            auc_res_txt = u'Congratulations! You won the following item at auction. \u005cnThis was your preferred item out of a randomly selected pair from one of the choice tasks.'\u000a            auc_prc_txt = u'Your bid of \u005cxa3' + '{0:.2f}'.format(bid) + u' matched or exceeded the randomly generated price of \u005cxa3' + '{0:.2f}'.format(price) + '.\u005cn\u005cn[Press space bar to continue]'\u000a            cost = price\u000a        elif win_item==False:\u000a            auc_res_txt = u'Sorry, you did not win the following item at auction. \u005cnThis was your preferred item out of a randomly selected pair from one of the choice tasks.'\u000a            auc_prc_txt = u'Your bid of \u005cxa3' + '{0:.2f}'.format(bid) + u' was lower than the randomly generated price of \u005cxa3' + '{0:.2f}'.format(price) + '.\u005cn\u005cn[Press space bar to continue]'\u000a            cost = 0\u000a\u000a        # find the image path of the auction item\u000a        rand_itm_img = prefs[rand_itm][2]\u000a\u000a    # add up each component of S's payment\u000a    class score:\u000a        base = 25\u000a        rwrd = 0.01\u000a        loss = 0\u000a        rwrd_tot = rwrd * correct_counter\u000a        loss_tot = loss * incorrect_counter\u000a        pre_pymt = base + rwrd_tot - loss_tot\u000a        final_pymt = pre_pymt - auction.cost\u000a\u000a        pymt_expl_bdwn = u'\u005cxa3' + '{0:.2f}'.format(base) + u' base payment'+ u'\u005cn+ \u005cxa3' + '{0:.2f}'.format(rwrd_tot) + ' reward for ' + str(correct_counter) + u' correct responses (\u005cxa3' + '{0:.2f}'.format(rwrd) + u' each)' + u'\u005cn- \u005cxa3' + '{0:.2f}'.format(auction.cost) + ' cost of auction item' \u000a        pymt_expl_tot = u'Your total payment is: \u005cxa3' + '{0:.2f}'.format(final_pymt) + '\u005cn\u005cnThank you for participating!'\u000a\u000a\u000a    # Initialize components for Routine "auc_disp"\u000a    auc_dispClock = core.Clock()\u000a    pic_auc_itm = visual.ImageStim(win=win, name='pic_auc_itm',\u000a        image=dir_path+auction.rand_itm_img, mask=None,\u000a        ori=0, pos=[0, 0], size=None,\u000a        color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a        flipHoriz=False, flipVert=False,\u000a        texRes=128, interpolate=False, depth=0.0)\u000a    auc_txt1 = visual.TextStim(win=win, ori=0, name='auc_txt1',\u000a        text=auction.auc_res_txt, font=u'Arial',\u000a        pos=[0, 0.6], height=0.07, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    auc_txt2 = visual.TextStim(win=win, ori=0, name='auc_txt2',\u000a        text=auction.auc_prc_txt, font=u'Arial',\u000a        pos=[0, -0.6], height=0.07, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a\u000a    #------Prepare to start Routine "auc_disp"-------\u000a    t = 0\u000a    auc_dispClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    key_resp_auc_disp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_auc_disp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    auc_dispComponents = []\u000a    auc_dispComponents.append(pic_auc_itm)\u000a    auc_dispComponents.append(auc_txt1)\u000a    auc_dispComponents.append(auc_txt2)\u000a    for thisComponent in auc_dispComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "auc_disp"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = auc_dispClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *pic_auc_itm* updates\u000a        if t >= 0.2 and pic_auc_itm.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            pic_auc_itm.tStart = t  # underestimates by a little under one frame\u000a            pic_auc_itm.frameNStart = frameN  # exact frame index\u000a            pic_auc_itm.setAutoDraw(True)\u000a        \u000a        # *auc_txt1* updates\u000a        if t >= 0.2 and auc_txt1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            auc_txt1.tStart = t  # underestimates by a little under one frame\u000a            auc_txt1.frameNStart = frameN  # exact frame index\u000a            auc_txt1.setAutoDraw(True)\u000a\u000a        # *auc_txt2* updates\u000a        if t >= 0.2 and auc_txt2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            auc_txt2.tStart = t  # underestimates by a little under one frame\u000a            auc_txt2.frameNStart = frameN  # exact frame index\u000a            auc_txt2.setAutoDraw(True)\u000a        \u000a        # *key_resp_auc_disp* updates\u000a        if t >= 0.2 and key_resp_auc_disp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_auc_disp.tStart = t  # underestimates by a little under one frame\u000a            key_resp_auc_disp.frameNStart = frameN  # exact frame index\u000a            key_resp_auc_disp.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_auc_disp.clock.reset()  # now t=0\u000a        if key_resp_auc_disp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_auc_disp.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_auc_disp.rt = key_resp_auc_disp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in auc_dispComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "auc_disp"-------\u000a    for thisComponent in auc_dispComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_auc_disp.keys in ['', [], None]:  # No response was made\u000a       key_resp_auc_disp.keys=None\u000a    # store data for thisExp (TrialHandler)\u000a    thisExp.addData('auction.win_item', auction.win_item)\u000a    thisExp.addData('auction.price', auction.price)\u000a    thisExp.addData('auction.bid', auction.bid)\u000a    thisExp.addData('auction.rand_itm_img', auction.rand_itm_img)\u000a    thisExp.addData('score.base', score.base)\u000a    thisExp.addData('score.rwrd', score.rwrd)\u000a    thisExp.addData('score.loss', score.loss)\u000a    thisExp.addData('correct_counter', correct_counter)\u000a    thisExp.addData('incorrect_counter', incorrect_counter)\u000a    thisExp.addData('score.final_pymt', score.final_pymt)\u000a    thisExp.nextEntry()\u000a\u000a\u000a    # Initialize components for Routine "pymt_disp"\u000a    pymt_dispClock = core.Clock()\u000a    pymt_disp_txt1 = visual.TextStim(win=win, ori=0, name='pymt_disp_txt1',\u000a        text=score.pymt_expl_bdwn, font=u'Arial',\u000a        pos=[0, 0.6], height=0.07, wrapWidth=1.5,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    pymt_disp_txt2 = visual.TextStim(win=win, ori=0, name='pymt_disp_txt2',\u000a        text=score.pymt_expl_tot, font=u'Arial',\u000a        pos=[0, -0.65], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    #------Prepare to start Routine "pymt_disp"-------\u000a    t = 0\u000a    pymt_dispClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    key_resp_pymt_disp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_pymt_disp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    pymt_dispComponents = []\u000a    pymt_dispComponents.append(pic_auc_itm)\u000a    pymt_dispComponents.append(pymt_disp_txt1)\u000a    pymt_dispComponents.append(pymt_disp_txt2)\u000a    pymt_dispComponents.append(key_resp_pymt_disp)\u000a    for thisComponent in pymt_dispComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "pymt_disp"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = pymt_dispClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        if auction.win_item==True:\u000a            # *pic_auc_itm* updates\u000a            if t >= 0.0 and pic_auc_itm.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                pic_auc_itm.tStart = t  # underestimates by a little under one frame\u000a                pic_auc_itm.frameNStart = frameN  # exact frame index\u000a                pic_auc_itm.setAutoDraw(True)\u000a\u000a        # *pymt_disp_txt1* updates\u000a        if t >= 0.0 and pymt_disp_txt1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            pymt_disp_txt1.tStart = t  # underestimates by a little under one frame\u000a            pymt_disp_txt1.frameNStart = frameN  # exact frame index\u000a            pymt_disp_txt1.setAutoDraw(True)\u000a\u000a        # *pymt_disp_txt2* updates\u000a        if t >= 0.0 and pymt_disp_txt2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            pymt_disp_txt2.tStart = t  # underestimates by a little under one frame\u000a            pymt_disp_txt2.frameNStart = frameN  # exact frame index\u000a            pymt_disp_txt2.setAutoDraw(True)\u000a        \u000a        # *key_resp_pymt_disp* updates\u000a        if t >= 3.0 and key_resp_pymt_disp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_pymt_disp.tStart = t  # underestimates by a little under one frame\u000a            key_resp_pymt_disp.frameNStart = frameN  # exact frame index\u000a            key_resp_pymt_disp.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_pymt_disp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if key_resp_pymt_disp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_pymt_disp.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_pymt_disp.rt = key_resp_pymt_disp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in pymt_dispComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "pymt_disp"-------\u000a    for thisComponent in pymt_dispComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_pymt_disp.keys in ['', [], None]:  # No response was made\u000a       key_resp_pymt_disp.keys=None\u000a\u000aelse: # If S didn't complete the entire binary choice and BDM routines during this session, prompt a manual auction\u000a    # Initialize components for Routine "auc_manual"\u000a    auc_manualClock = core.Clock()\u000a    auc_manual_txt = visual.TextStim(win=win, ori=0, name='auc_manual_txt',\u000a        text=u'Thank you! This completes the experiment. The experimenter will now run the auction and calculate your final payment.\u005cn\u005cnCorrect: ' + str(correct_counter) + '\u005cnIncorrect: ' + str(incorrect_counter),    font=u'Arial',\u000a        pos=[0, 0], height=0.07, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    #------Prepare to start Routine "auc_manual"-------\u000a    t = 0\u000a    auc_manualClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    auc_manualComponents = []\u000a    auc_manualComponents.append(auc_manual_txt)\u000a    for thisComponent in auc_manualComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "auc_manual"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = auc_manualClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *auc_manual_txt* updates\u000a        if t >= 0.0 and auc_manual_txt.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            auc_manual_txt.tStart = t  # underestimates by a little under one frame\u000a            auc_manual_txt.frameNStart = frameN  # exact frame index\u000a            auc_manual_txt.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in auc_manualComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "auc_manual"-------\u000a    for thisComponent in auc_manualComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000athisExp.nextEntry()\u000a\u000a# io.quit() # Close iohub\u000a\u000a\u000awin.close()\u000acore.quit()\u000a
p9382
sg9107
(lp9383
sg9109
I85328720
sg10
S'block_loop'
p9384
sg6
g9111
sg9112
I3
sg52
I01
sg53
g54
sg9113
g1
(g9114
g9115
(dp9385
g9117
g9118
(g9119
g92
g9120
S'b'
tRp9386
(I1
(I1
I3
tg9122
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00'
Ntbsg9125
g9118
(g9119
g92
g9120
S'b'
tRp9387
(I1
(I1
I3
tg9122
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00@'
S'\x00\x00\x00'
NtbstRp9388
(dp9389
g9130
(dp9390
g9117
I01
sg9125
I01
ssg9132
g9380
sg9133
(lp9391
g9117
ag9125
asg9135
(lp9392
I1
aI3
asbsg9137
g9252
sg9139
g91
(g92
(I0
tS'b'
tRp9393
(I1
(I1
I3
tg98
I00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
tbsg9141
I01
sg9142
I3
sg9143
I-1
sg9144
(lp9394
Nasg9227
Nsg9228
g6364
sg9229
I3
sg9230
I0
sg9231
I3
sg9232
I01
sbag1
(g9102
g3
NtRp9395
(dp9396
g9105
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a\u000a######################## CITATIONS ########################## \u000a##### Binary choice, BDM, auction routines, and instructions are modified from:\u000a##### \u000a##### De Martino, B., Fleming, S. M., Garrett, N., & Dolan, R. J. (2012). Confidence in value-based choice. Nature Neuroscience, 16(1), 105-110. \u000a#####\u000a##### Food item images are original.\u000a\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.80.01), July 16, 2014, at 03:20\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things bdm STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000afrom pyglet.window import key # to detect key state, whether key is held down, to move slider on key hold\u000aimport pandas as pd\u000aimport datetime\u000afrom psychopy.iohub import launchHubServer\u000aimport pylink\u000a\u000a# Initialize IOHub for eye tracker\u000a# io=launchHubServer(iohub_config_name='iohub_config.yaml')\u000a# tracker = io.devices.tracker\u000a\u000a# Store info about the experiment session\u000aexpName = 'infer_design1_no_eyetracking'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u'', u'eye': u'', u'glasses': u'', u'contacts': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Setup filename for saving\u000afilename = 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# set up variable to track current state of key press, to move slider when keys held down\u000akeyState=key.KeyStateHandler()\u000a\u000a# Setup the Window\u000ascreenwidth = 1920\u000ascreenheight = 1080\u000awin = visual.Window(size=(screenwidth, screenheight), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color='black', colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000awin.winHandle.push_handlers(keyState)\u000a\u000a\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a\u000a######################## COMPONENTS ##########################\u000a\u000a# Set up directory path for stimuli. This avoids us having to put the entire image path in the conditions spreadsheet.\u000adir_path = 'stimuli/itempics/modified/small/'\u000a\u000a# Initialize components for Routine "instr_main"\u000ainstr_mainClock = core.Clock()\u000ainstr_main_txt = visual.TextStim(win=win, ori=0, name='instr_main_txt',\u000a    text=u'Welcome!\u005cn\u005cnPlease read the instructions carefully and get the experimenter when you\u005c're finished. Take as much time as you need.',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "instr_bdm"\u000ainstr_bdmClock = core.Clock()\u000ainstr_bdm_txt = visual.TextStim(win=win, ori=0, name='instr_bdm_txt',\u000a    text=u'The bidding task is about to begin. Use the LEFT and RIGHT arrow keys to move the cursor along the slider, then press the DOWN arrow to enter your bid.\u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "fixation"\u000afixationClock = core.Clock()\u000afixation_text = visual.TextStim(win=win, ori=0, name='fixation_text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "bdm"\u000abdmClock = core.Clock()\u000abdm_pic = visual.ImageStim(win=win, name='bdm_pic',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=0.0)\u000abdm_bid = visual.RatingScale(win=win, name='bdm_bid', marker=u'triangle', markerColor=u'orange', leftKeys=None, rightKeys=None,\u000a    size=1.0, pos=[0.0, -0.6], low=0, high=3, precision=100, labels=[u'\u005cxa30', u'\u005cxa33'],\u000a    scale=u'', markerStart=u'1.5', tickHeight=u'1', showAccept=False, acceptKeys=[u'down', u'return'])\u000a\u000a# Initialize components for Routine "instr_choice"\u000ainstr_choiceClock = core.Clock()\u000ainstr_choice_txt = visual.TextStim(win=win, ori=0, name='instr_choice_txt',\u000a    text=u'The choice task is about to begin. Choose your preferred item by pressing the LEFT or RIGHT arrow keys, then use the slider to indicate how confident you are that you made the best choice.\u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "choice"\u000achoiceClock = core.Clock()\u000achoice_pic_left = visual.ImageStim(win=win, name='choice_pic_left',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[-0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=0.0)\u000achoice_pic_right = visual.ImageStim(win=win, name='choice_pic_right',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=-1.0)\u000a\u000a# Initialize components for Routine "choice_selection"\u000achoice_selectionClock = core.Clock()\u000astar_left_selection = visual.TextStim(win=win, ori=0, name='star_left_selection',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[-0.5, -0.8], height=0.5, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=-2.0)\u000astar_right_selection = visual.TextStim(win=win, ori=0, name='star_right_selection',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[0.5, -0.8], height=0.5, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=-3.0)\u000a\u000a# Initialize components for Routine "confidence"\u000aconfidenceClock = core.Clock()\u000aconfidence_rating = visual.RatingScale(win=win, name='confidence_rating', marker=u'triangle', markerColor=u'orange', leftKeys=None, rightKeys=None,\u000a    size=1.0, pos=[0.0, 0.0], low=1, high=6, precision=20,\u000a    scale=u'', markerStart=u'3.5', tickHeight=u'1', showAccept=False, acceptKeys=[u'down', u'return'])\u000a\u000a# Initialize components for Routine "instr_infer_intro"\u000ainstr_infer_introClock = core.Clock()\u000ainstr_infer_intro_txt = visual.TextStim(win=win, ori=0, name='instr_infer_intro_txt',\u000a    text=u'Thanks! Now please get the experimenter, who will give you the instructions for the second part of the experiment. \u005cn\u005cnPlease read these instructions carefully and get the experimenter again when you\u005c're finished. Take as much time as you need.',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=1.5,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "instr_infer_practice"\u000ainstr_infer_practiceClock = core.Clock()\u000ainstr_infer_practice_txt = visual.TextStim(win=win, ori=0, name='instr_infer_practice_txt',\u000a    text=u'First, you\u005c'll do some practice trials. These are just for you to get used to the task; your responses won\u005c't count. \u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=1.5,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "instr_infer"\u000ainstr_inferClock = core.Clock()\u000ainstr_infer_txt = visual.TextStim(win=win, ori=0, name='instr_infer_txt',\u000a    text=u'Great! Now that you\u005c've done some practice trials, we\u005c're ready to start the real trials. Please call the experimenter into the room.',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=1.5,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "get_ready"\u000aget_readyClock = core.Clock()\u000aget_ready_text = visual.TextStim(win=win, ori=0, name='get_ready_text',\u000a    text=u'Get ready!',    font=u'Arial',\u000a    pos=[0, 0], height=0.12, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000aimg_left_infer = visual.ImageStim(win=win, name='img_left_infer',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[-0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=0.0)\u000aimg_right_infer = visual.ImageStim(win=win, name='img_right_infer',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=-1.0)\u000a\u000a# Initialize components for Routine "trial_post_response"\u000atrial_post_responseClock = core.Clock()\u000aselection_arrow_left = visual.TextStim(win=win, ori=0, name='selection_arrow_left',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[-0.5, -0.09], height=0.5, wrapWidth=None,\u000a    color=u'red', colorSpace=u'rgb', opacity=1,\u000a    depth=-2.0)\u000aselection_arrow_right = visual.TextStim(win=win, ori=0, name='selection_arrow_right',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[0.5, -0.09], height=0.5, wrapWidth=None,\u000a    color=u'red', colorSpace=u'rgb', opacity=1,\u000a    depth=-3.0)\u000afeedback_box_left = visual.Rect(win=win, name='feedback_box_left',\u000a    width=[0.9, 0.9][0], height=[0.9, 0.9][1],\u000a    ori=0, pos=[-0.5, 0],\u000a    lineWidth=5, lineColor=u'yellow', lineColorSpace=u'rgb',\u000a    fillColor=None, fillColorSpace=u'rgb',\u000a    opacity=1, depth=-4.0, interpolate=True)\u000afeedback_box_right = visual.Rect(win=win, name='feedback_box_right',\u000a    width=[0.9, 0.9][0], height=[0.9, 0.9][1],\u000a    ori=0, pos=[0.5, 0],\u000a    lineWidth=5, lineColor=u'yellow', lineColorSpace=u'rgb',\u000a    fillColor=None, fillColorSpace=u'rgb',\u000a    opacity=1, depth=-5.0, interpolate=True)\u000a\u000a# Initialize components for Routine "rest_prompt"\u000arest_promptClock = core.Clock()\u000arest_prompt_txt = visual.TextStim(win=win, ori=0, name='rest_prompt_txt',\u000a    text=u'Great! Now take a rest and press the space bar when you\u005cu2019re ready to begin the next block.',    font=u'Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create counters for the number of correct and incorrect guesses made by subjects to determine extra payment.\u000acorrect_counter = 0\u000aincorrect_counter = 0\u000a\u000a# Create list of lists to store binary choice and BDM data to generate food reward at the end of the experiment\u000aprefs = [['left', 'right', 'choice', 'bid']]\u000abids = [['item', 'bid']] # For the bids collected during the first BDM routine, at the beginning of the experiment\u000a\u000a### CHOICE & INFERENCE RANDOMIZATION ###\u000a\u000a# Define two functions to generate constrained pseudorandom sequences of item pair presentations for the binary choice and inference\u000a# parts of the task. The constraint ensures that the same pair of items does not appear twice in a row (flipped or not).\u000a# In the conditions spreadsheet that the item pairs are drawn from, the flipped version of the same item pair is 20\u000a# rows apart.\u000a\u000a# Binary choice randomization\u000adef genseq_choice():\u000a    done = False\u000a    while done==False:\u000a        counter = 0\u000a        ans = np.random.choice(40, 40, replace=False) # Generate a pseudorandom sequence of 40 numbers\u000a        for x in range(1,40):\u000a            if (ans[x]-ans[x-1]) % 20 == 0: # Is the difference between any sequential numbers divisible by 20?\u000a                counter += 1\u000a        if counter==0: # If not, end the loop and return the array\u000a            done = True\u000a            return ans\u000a        else: # If so, continue the loop and try again\u000a            done = False\u000a\u000a# Inference practice block randomization\u000adef genseq_infer_practice():\u000a    done = False\u000a    while done==False:\u000a        counter = 0\u000a        ans = np.random.choice(14, 14, replace=False) # Generate a pseudorandom sequence of 200 numbers\u000a        for x in range(1,14):\u000a            if (ans[x]-ans[x-1]) % 7 == 0: # Is the difference between any sequential numbers divisible by 20?\u000a                counter += 1\u000a        if counter==0: # If not, end the loop and return the array\u000a            done = True\u000a            return ans\u000a        else: # If so, continue the loop and try again\u000a            done = False\u000a\u000a# Inference randomization\u000adef genseq_infer():\u000a    done = False\u000a    while done==False:\u000a        counter = 0\u000a        ans = np.random.choice(200, 200, replace=False) # Generate a pseudorandom sequence of 200 numbers\u000a        for x in range(1,200):\u000a            if (ans[x]-ans[x-1]) % 20 == 0: # Is the difference between any sequential numbers divisible by 20?\u000a                counter += 1\u000a        if counter==0: # If not, end the loop and return the array\u000a            done = True\u000a            return ans\u000a        else: # If so, continue the loop and try again\u000a            done = False\u000a\u000a\u000a# Set independent sequences for each of the two choice blocks, the inference practice block, and the three inference rest blocks. Each rest block contains 10 presentations of\u000a# each pair.\u000a\u000achoiceseq = genseq_choice()\u000apracticeseq = genseq_infer_practice()\u000ablock1seq = genseq_infer()\u000ablock2seq = genseq_infer()\u000ablock3seq = genseq_infer()\u000a\u000a\u000a# Choose a pilot participant whose choices will form the basis of the learning task\u000apartners = ['P1','P2','P3','P4','P5','P6','P8','P9','P10','P11','P12'] # List of pilot participants, P7 excluded for perfectly inconsistent choices\u000apartner = np.random.choice(partners,1) # Choose one at random\u000apartner_file = 'conditions/choices/infer_design1_value_pairs_' + partner[0] + '.csv' # Path to that participant's choice data\u000a\u000a# Create separate CSV files, one for each choice, practice, and rest block, with the item pairs in the pseudorandomly generated order.\u000a# These CSV files will be used as PsychoPy's conditions spreadsheets and run sequentially in the choice, practice, and inference loops below.\u000a\u000a\u000achoicecond_src = pd.read_csv('conditions/choice_design1_binary.csv', index_col=None, header=0)\u000achoicecond = choicecond_src.copy()\u000afor x in range(40):\u000a    seq = choiceseq[x]\u000a    choicecond.iloc[x] = choicecond_src.iloc[seq]\u000achoicecond.to_csv(path_or_buf=filename+'_choicecond.csv', index=False)\u000a\u000apracticecond_src = pd.read_csv('conditions/choices/infer_design1_value_pairs_practice.csv', index_col=None, header=0)\u000apracticecond = practicecond_src.copy()\u000afor x in range(14):\u000a    seq = practiceseq[x]\u000a    practicecond.iloc[x] = practicecond_src.iloc[seq]\u000apracticecond.to_csv(path_or_buf=filename+'_practicecond.csv', index=False)\u000a\u000ablock1cond_src = pd.read_csv(partner_file, index_col=None, header=0)\u000ablock1cond = block1cond_src.copy()\u000afor x in range(200):\u000a    seq = block1seq[x]\u000a    block1cond.iloc[x] = block1cond_src.iloc[seq]\u000ablock1cond.to_csv(path_or_buf=filename+'_block1cond.csv', index=False)\u000a\u000ablock2cond_src = pd.read_csv(partner_file, index_col=None, header=0)\u000ablock2cond = block2cond_src.copy()\u000afor x in range(200):\u000a    seq = block2seq[x]\u000a    block2cond.iloc[x] = block2cond_src.iloc[seq]\u000ablock2cond.to_csv(path_or_buf=filename+'_block2cond.csv', index=False)\u000a\u000ablock3cond_src = pd.read_csv(partner_file, index_col=None, header=0)\u000ablock3cond = block3cond_src.copy()\u000afor x in range(200):\u000a    seq = block3seq[x]\u000a    block3cond.iloc[x] = block3cond_src.iloc[seq]\u000ablock3cond.to_csv(path_or_buf=filename+'_block3cond.csv', index=False)\u000a\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instr_main"-------\u000at = 0\u000ainstr_mainClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_main_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_main_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_mainComponents = []\u000ainstr_mainComponents.append(instr_main_txt)\u000ainstr_mainComponents.append(instr_main_resp)\u000afor thisComponent in instr_mainComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_main"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_mainClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_main_txt* updates\u000a    if t >= 0.0 and instr_main_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_main_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_main_txt.frameNStart = frameN  # exact frame index\u000a        instr_main_txt.setAutoDraw(True)\u000a    \u000a    # *instr_main_resp* updates\u000a    if t >= 5.0 and instr_main_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_main_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_main_resp.frameNStart = frameN  # exact frame index\u000a        instr_main_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_main_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_main_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_main_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_main_resp.rt = instr_main_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_mainComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_main"-------\u000afor thisComponent in instr_mainComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_main_resp.keys in ['', [], None]:  # No response was made\u000a   instr_main_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_main_resp.keys',instr_main_resp.keys)\u000aif instr_main_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_main_resp.rt', instr_main_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a\u000a#------Prepare to start Routine "instr_bdm"-------\u000at = 0\u000ainstr_bdmClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_bdm_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_bdm_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_bdmComponents = []\u000ainstr_bdmComponents.append(instr_bdm_txt)\u000ainstr_bdmComponents.append(instr_bdm_resp)\u000afor thisComponent in instr_bdmComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_bdm"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_bdmClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_bdm_txt* updates\u000a    if t >= 0.0 and instr_bdm_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_bdm_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_bdm_txt.frameNStart = frameN  # exact frame index\u000a        instr_bdm_txt.setAutoDraw(True)\u000a    \u000a    # *instr_bdm_resp* updates\u000a    if t >= 2.0 and instr_bdm_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_bdm_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_bdm_resp.frameNStart = frameN  # exact frame index\u000a        instr_bdm_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_bdm_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_bdm_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space', 's'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_bdm_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_bdm_resp.rt = instr_bdm_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_bdmComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_bdm"-------\u000afor thisComponent in instr_bdmComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_bdm_resp.keys in ['', [], None]:  # No response was made\u000a   instr_bdm_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_bdm_resp.keys',instr_bdm_resp.keys)\u000athisExp.addData('partnered_pilot_participant', partner)\u000aif instr_bdm_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_bdm_resp.rt', instr_bdm_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## BDM LOOP 1 ##########################\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000abdm_loop1 = data.TrialHandler(nReps=1, method=u'random', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'conditions/choice_design1_bdm.xlsx'),\u000a    seed=None, name='bdm_loop1')\u000athisExp.addLoop(bdm_loop1)  # add the loop to the experiment\u000athisbdm_loop1 = bdm_loop1.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisbdm_loop1.rgb)\u000aif thisbdm_loop1 != None:\u000a    for paramName in thisbdm_loop1.keys():\u000a        exec(paramName + '= thisbdm_loop1.' + paramName)\u000a\u000a# Check if the 'skip' key was pressed in the instructions routine; if so, end the loop and move on to the inference task\u000aif instr_bdm_resp.keys=='s':\u000a    bdm_loop1.finished = True\u000a\u000afor thisbdm_loop1 in bdm_loop1:\u000a    currentLoop = bdm_loop1\u000a    # abbreviate parameter names if possible (e.g. rgb = thisbdm_loop1.rgb)\u000a    if thisbdm_loop1 != None:\u000a        for paramName in thisbdm_loop1.keys():\u000a            exec(paramName + '= thisbdm_loop1.' + paramName)\u000a    \u000a    #------Prepare to start Routine "bdm"-------\u000a    t = 0\u000a    bdmClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    bdm_pic.setImage(dir_path+bdm_img)\u000a    bdm_bid.reset()\u000a    # jitter the starting position of the BDM scale from a uniform distribution between 1 and 2, rounded to the nearest decimal place\u000a    bdm_marker_start = float(np.round(np.random.uniform(1, 2, 1)[0], 1))\u000a    bdm_bid.setMarkerPos(bdm_marker_start)\u000a    # keep track of which components have finished\u000a    bdmComponents = []\u000a    bdmComponents.append(fixation_text)\u000a    bdmComponents.append(bdm_pic)\u000a    bdmComponents.append(bdm_bid)\u000a    for thisComponent in bdmComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "bdm"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = bdmClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation_text* updates\u000a        if t >= 0 and fixation_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation_text.tStart = t  # underestimates by a little under one frame\u000a            fixation_text.frameNStart = frameN  # exact frame index\u000a            fixation_text.setAutoDraw(True)\u000a        elif fixation_text.status == STARTED and t>= (0 + (1.0-win.monitorFramePeriod*0.75)):\u000a            fixation_text.setAutoDraw(False)\u000a\u000a        # *bdm_pic* updates\u000a        if t >= 1.0 and bdm_pic.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bdm_pic.tStart = t  # underestimates by a little under one frame\u000a            bdm_pic.frameNStart = frameN  # exact frame index\u000a            bdm_pic.setAutoDraw(True)\u000a        # *bdm_bid* updates\u000a        if t >= 1.0:\u000a            bdm_bid.draw()\u000a            continueRoutine = bdm_bid.noResponse\u000a            if bdm_bid.noResponse == False:\u000a                bdm_bid.response = bdm_bid.getRating()\u000a                bdm_bid.rt = bdm_bid.getRT()\u000a            elif bdm_bid.noResponse==True:\u000a                if keyState[key.LEFT]==True and bdm_bid.markerPlacedAt >0.01:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt - 0.02\u000a                    bdm_bid.draw()\u000a                elif keyState[key.LEFT]==True and bdm_bid.markerPlacedAt==0.01:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt - 0.01\u000a                    bdm_bid.draw()\u000a                elif keyState[key.RIGHT]==True and bdm_bid.markerPlacedAt <2.99:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt + 0.02\u000a                    bdm_bid.draw()\u000a                elif keyState[key.RIGHT]==True and bdm_bid.markerPlacedAt==2.99:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt + 0.01\u000a                    bdm_bid.draw()\u000a                    \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in bdmComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "bdm"-------\u000a    for thisComponent in bdmComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # store data for bdm (TrialHandler)\u000a    bdm_loop1.addData('bdm_bid1.response', bdm_bid.getRating())\u000a    bdm_loop1.addData('bdm_bid1.rt', bdm_bid.getRT())\u000a    bdm_loop1.addData('bdm_marker_start', bdm_marker_start)\u000a\u000a    # Add the item and the subject's bid to the 'bids' list, which will be merged with the 'prefs' list later in order to run the auction\u000a    bids.append([bdm_img, bdm_bid.response])\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeat of 'bdm_loop1'\u000a\u000a\u000a#------Prepare to start Routine "instr_choice"-------\u000at = 0\u000ainstr_choiceClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_choice_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_choice_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_choiceComponents = []\u000ainstr_choiceComponents.append(instr_choice_txt)\u000ainstr_choiceComponents.append(instr_choice_resp)\u000afor thisComponent in instr_choiceComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_choice"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_choiceClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_choice_txt* updates\u000a    if t >= 0.0 and instr_choice_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_choice_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_choice_txt.frameNStart = frameN  # exact frame index\u000a        instr_choice_txt.setAutoDraw(True)\u000a    \u000a    # *instr_choice_resp* updates\u000a    if t >= 2.0 and instr_choice_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_choice_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_choice_resp.frameNStart = frameN  # exact frame index\u000a        instr_choice_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_choice_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_choice_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space', 's'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_choice_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_choice_resp.rt = instr_choice_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_choiceComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_choice"-------\u000afor thisComponent in instr_choiceComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_choice_resp.keys in ['', [], None]:  # No response was made\u000a   instr_choice_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_choice_resp.keys',instr_choice_resp.keys)\u000aif instr_choice_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_choice_resp.rt', instr_choice_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## BINARY LOOP ##########################\u000a\u000a# set up handler to look after randomisation of conditions etc\u000abinary = data.TrialHandler(nReps=1, method=u'sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(filename+'_choicecond.csv'),\u000a    seed=None, name='binary')\u000athisExp.addLoop(binary)  # add the loop to the experiment\u000athisBinary1 = binary.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBinary1.rgb)\u000aif thisBinary1 != None:\u000a    for paramName in thisBinary1.keys():\u000a        exec(paramName + '= thisBinary1.' + paramName)\u000a\u000a# Check if the 'skip' key was pressed in the instructions routine; if so, end the loop and move on to the BDM\u000aif instr_choice_resp.keys=='s':\u000a    binary.finished = True\u000a\u000afor thisBinary1 in binary:\u000a    currentLoop = binary\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBinary1.rgb)\u000a    if thisBinary1 != None:\u000a        for paramName in thisBinary1.keys():\u000a            exec(paramName + '= thisBinary1.' + paramName)\u000a    \u000a    #------Prepare to start Routine "choice"-------\u000a    t = 0\u000a    choiceClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    choice_pic_left.setImage(dir_path+choice_left)\u000a    choice_pic_right.setImage(dir_path+choice_right)\u000a    event.clearEvents(eventType='keyboard') # Clear keyboard event log to avoid last key press from prior loop being used\u000a    key_resp_choice = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_choice.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    choiceComponents = []\u000a    choiceComponents.append(fixation_text)\u000a    choiceComponents.append(choice_pic_left)\u000a    choiceComponents.append(choice_pic_right)\u000a    choiceComponents.append(key_resp_choice)\u000a    for thisComponent in choiceComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    \u000a    #-------Start Routine "choice"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = choiceClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation_text* updates\u000a        if t >= 0 and fixation_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation_text.tStart = t  # underestimates by a little under one frame\u000a            fixation_text.frameNStart = frameN  # exact frame index\u000a            fixation_text.setAutoDraw(True)\u000a        elif fixation_text.status == STARTED and t>= (0 + (1.0-win.monitorFramePeriod*0.75)):\u000a            fixation_text.setAutoDraw(False)\u000a\u000a        # *choice_pic_left* updates\u000a        if t >= 1.0 and choice_pic_left.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_left.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_left.frameNStart = frameN  # exact frame index\u000a            choice_pic_left.setAutoDraw(True)\u000a        \u000a        # *choice_pic_right* updates\u000a        if t >= 1.0 and choice_pic_right.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_right.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_right.frameNStart = frameN  # exact frame index\u000a            choice_pic_right.setAutoDraw(True)\u000a\u000a        # *key_resp_choice* updates\u000a        if t >= 1.0 and key_resp_choice.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_choice.tStart = t  # underestimates by a little under one frame\u000a            key_resp_choice.frameNStart = frameN  # exact frame index\u000a            key_resp_choice.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_choice.clock.reset()  # now t=0\u000a        if key_resp_choice.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_choice.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_choice.rt = key_resp_choice.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in choiceComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "choice"-------\u000a    for thisComponent in choiceComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_choice.keys in ['', [], None]:  # No response was made\u000a       key_resp_choice.keys=None\u000a    # store data for binary (TrialHandler)\u000a    binary.addData('key_resp_choice.keys',key_resp_choice.keys)\u000a    if key_resp_choice.keys != None:  # we had a response\u000a        binary.addData('key_resp_choice.rt', key_resp_choice.rt)\u000a\u000a    # define a function to append binary choices and the bid for the chosen item to the preference list\u000a    # lft is the left image displayed during that choice trial\u000a    # rt is the right image displayed\u000a    def rec_choice(lft, rt): \u000a        bd = False\u000a        if key_resp_choice.keys=='left':\u000a            chc = lft\u000a        elif key_resp_choice.keys=='right':\u000a            chc = rt\u000a        for x in range(len(bids)):\u000a            if bids[x][0]==chc:\u000a                bd = bids[x][1]\u000a        prefs.append([lft, rt, chc, bd])\u000a\u000a    # call the function\u000a    rec_choice(choice_left, choice_right)\u000a    \u000a\u000a    #------Prepare to start Routine "choice_selection"-------\u000a    t = 0\u000a    choice_selectionClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # keep track of which components have finished\u000a    choice_selectionComponents = []\u000a    choice_selectionComponents.append(choice_pic_left)\u000a    choice_selectionComponents.append(choice_pic_right)\u000a    choice_selectionComponents.append(star_left_selection)\u000a    choice_selectionComponents.append(star_right_selection)\u000a    for thisComponent in choice_selectionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "choice_selection"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = choice_selectionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *choice_pic_left* updates\u000a        if t >= 0.0 and choice_pic_left.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_left.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_left.frameNStart = frameN  # exact frame index\u000a            choice_pic_left.setAutoDraw(True)\u000a        elif choice_pic_left.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            choice_pic_left.setAutoDraw(False)\u000a        \u000a        # *choice_pic_right* updates\u000a        if t >= 0.0 and choice_pic_right.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_right.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_right.frameNStart = frameN  # exact frame index\u000a            choice_pic_right.setAutoDraw(True)\u000a        elif choice_pic_right.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            choice_pic_right.setAutoDraw(False)\u000a        \u000a        # *star_left_selection* updates\u000a        if key_resp_choice.keys=='left':\u000a            if t >= 0.0 and star_left_selection.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                star_left_selection.tStart = t  # underestimates by a little under one frame\u000a                star_left_selection.frameNStart = frameN  # exact frame index\u000a                star_left_selection.setAutoDraw(True)\u000a            elif star_left_selection.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                star_left_selection.setAutoDraw(False)\u000a        \u000a        # *star_right_selection* updates\u000a        if key_resp_choice.keys=='right':\u000a            if t >= 0.0 and star_right_selection.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                star_right_selection.tStart = t  # underestimates by a little under one frame\u000a                star_right_selection.frameNStart = frameN  # exact frame index\u000a                star_right_selection.setAutoDraw(True)\u000a            elif star_right_selection.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                star_right_selection.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in choice_selectionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "choice_selection"-------\u000a    for thisComponent in choice_selectionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    #thisExp.nextEntry()\u000a\u000a    #------Prepare to start Routine "confidence"-------\u000a    t = 0\u000a    confidenceClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    confidence_rating.reset()\u000a    # jitter the starting position of the confidence rating scale from a uniform distribution between 1.7 and 3.3 (the middle third of the scale), rounded to the nearest decimal place\u000a    confidence_marker_start = float(np.round(np.random.uniform(1.7, 3.3, 1)[0], 1))\u000a    confidence_rating.setMarkerPos(confidence_marker_start)\u000a    # keep track of which components have finished\u000a    confidenceComponents = []\u000a    confidenceComponents.append(confidence_rating)\u000a    for thisComponent in confidenceComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "confidence"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = confidenceClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *confidence_rating* updates\u000a        if t > 0.5:\u000a            confidence_rating.draw()\u000a            continueRoutine = confidence_rating.noResponse\u000a            if confidence_rating.noResponse == False:\u000a                confidence_rating.response = confidence_rating.getRating()\u000a                confidence_rating.rt = confidence_rating.getRT()\u000a            elif confidence_rating.noResponse==True:\u000a                if keyState[key.LEFT]==True and confidence_rating.markerPlacedAt >0:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt - 0.1\u000a                    confidence_rating.draw()\u000a                elif keyState[key.LEFT]==True and confidence_rating.markerPlacedAt==0.1:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt - 0.1\u000a                    confidence_rating.draw()\u000a                elif keyState[key.RIGHT]==True and confidence_rating.markerPlacedAt <4.9:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt + 0.1\u000a                    confidence_rating.draw()\u000a                elif keyState[key.RIGHT]==True and confidence_rating.markerPlacedAt==4.9:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt + 0.1\u000a                    confidence_rating.draw()\u000a                    \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in confidenceComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "confidence"-------\u000a    for thisComponent in confidenceComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # store data for confidence (TrialHandler)\u000a    binary.addData('confidence_rating1.response', confidence_rating.getRating())\u000a    binary.addData('confidence_rating1.rt', confidence_rating.getRT())\u000a    binary.addData('confidence_marker_start', confidence_marker_start+1) # Add 1 to convert from 0-5 to 1-6 scale\u000a\u000a    thisExp.nextEntry()\u000a\u000a\u000a# completed 1 repeat of 'binary'        \u000a\u000a#------Prepare to start Routine "instr_infer_intro"-------\u000at = 0\u000ainstr_infer_introClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_infer_intro_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_infer_intro_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_infer_introComponents = []\u000ainstr_infer_introComponents.append(instr_infer_intro_txt)\u000ainstr_infer_introComponents.append(instr_infer_intro_resp)\u000afor thisComponent in instr_infer_introComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_infer_intro"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_infer_introClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_infer_intro_txt* updates\u000a    if t >= 0.0 and instr_infer_intro_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_intro_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_intro_txt.frameNStart = frameN  # exact frame index\u000a        instr_infer_intro_txt.setAutoDraw(True)\u000a    \u000a    # *instr_infer_intro_resp* updates\u000a    if t >= 5.0 and instr_infer_intro_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_intro_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_intro_resp.frameNStart = frameN  # exact frame index\u000a        instr_infer_intro_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_infer_intro_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_infer_intro_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_infer_intro_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_infer_intro_resp.rt = instr_infer_intro_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_infer_introComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_infer_intro"-------\u000afor thisComponent in instr_infer_introComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_infer_intro_resp.keys in ['', [], None]:  # No response was made\u000a   instr_infer_intro_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_infer_intro_resp.keys',instr_infer_intro_resp.keys)\u000aif instr_infer_intro_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_infer_intro_resp.rt', instr_infer_intro_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a#------Prepare to start Routine "instr_infer_practice"-------\u000at = 0\u000ainstr_infer_practiceClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_infer_practice_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_infer_practice_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_infer_practiceComponents = []\u000ainstr_infer_practiceComponents.append(instr_infer_practice_txt)\u000ainstr_infer_practiceComponents.append(instr_infer_practice_resp)\u000afor thisComponent in instr_infer_practiceComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_infer_practice"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_infer_practiceClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_infer_practice_txt* updates\u000a    if t >= 0.0 and instr_infer_practice_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_practice_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_practice_txt.frameNStart = frameN  # exact frame index\u000a        instr_infer_practice_txt.setAutoDraw(True)\u000a    \u000a    # *instr_infer_practice_resp* updates\u000a    if t >= 5.0 and instr_infer_practice_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_practice_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_practice_resp.frameNStart = frameN  # exact frame index\u000a        instr_infer_practice_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_infer_practice_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_infer_practice_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_infer_practice_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_infer_practice_resp.rt = instr_infer_practice_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_infer_practiceComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_infer_practice"-------\u000afor thisComponent in instr_infer_practiceComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_infer_practice_resp.keys in ['', [], None]:  # No response was made\u000a   instr_infer_practice_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_infer_practice_resp.keys',instr_infer_practice_resp.keys)\u000aif instr_infer_practice_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_infer_practice_resp.rt', instr_infer_practice_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## PRACTICE LOOP ##########################\u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_loop = data.TrialHandler(nReps=1, method=u'sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(filename+'_practicecond.csv'),\u000a    seed=None, name='practice_loop')\u000athisExp.addLoop(practice_loop)  # add the loop to the experiment\u000athisPractice_loop = practice_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_loop.rgb)\u000aif thisPractice_loop != None:\u000a    for paramName in thisPractice_loop.keys():\u000a        exec(paramName + '= thisPractice_loop.' + paramName)\u000a\u000a  \u000afor thisPractice_loop in practice_loop:\u000a    currentLoop = practice_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_loop.rgb)\u000a    if thisPractice_loop != None:\u000a        for paramName in thisPractice_loop.keys():\u000a            exec(paramName + '= thisPractice_loop.' + paramName)    \u000a    \u000a        \u000a    # Define class for setting the feedback image\u000a    class set_feedback:\u000a        options = ['correct', 'wrong']\u000a        feedback = np.random.choice(options, replace=True, p=[0.8, 0.2])\u000a        if feedback=='correct':\u000a            feedback_img = img_correct\u000a        elif feedback=='wrong':\u000a            feedback_img = img_wrong\u000a\u000a        if feedback_img==img_left:\u000a            feedback_side = 'left'\u000a        elif feedback_img==img_right:\u000a            feedback_side = 'right'\u000a\u000a\u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialtime = datetime.datetime.now()\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    img_left_infer.setImage(dir_path+img_left)\u000a    img_right_infer.setImage(dir_path+img_right)\u000a    infer_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    infer_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(fixation_text)\u000a    trialComponents.append(img_left_infer)\u000a    trialComponents.append(img_right_infer)\u000a    trialComponents.append(infer_resp)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation_text* updates\u000a        if t >= 0 and fixation_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation_text.tStart = t  # underestimates by a little under one frame\u000a            fixation_text.frameNStart = frameN  # exact frame index\u000a            fixation_text.setAutoDraw(True)\u000a        elif fixation_text.status == STARTED and t>= (0 + (2.0-win.monitorFramePeriod*0.75)):\u000a            fixation_text.setAutoDraw(False)\u000a\u000a        # *img_left_infer* updates\u000a        if t >= 2.0 and img_left_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_left_infer.tStart = t  # underestimates by a little under one frame\u000a            img_left_infer.frameNStart = frameN  # exact frame index\u000a            img_left_infer.setAutoDraw(True)\u000a        \u000a        # *img_right_infer* updates\u000a        if t >= 2.0 and img_right_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_right_infer.tStart = t  # underestimates by a little under one frame\u000a            img_right_infer.frameNStart = frameN  # exact frame index\u000a            img_right_infer.setAutoDraw(True)\u000a                  \u000a        # *infer_resp* updates\u000a        if t >= 2.0 and infer_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            infer_resp.tStart = t  # underestimates by a little under one frame\u000a            infer_resp.frameNStart = frameN  # exact frame index\u000a            infer_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            infer_resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if infer_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                infer_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                infer_resp.rt = infer_resp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a\u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if infer_resp.keys in ['', [], None]:  # No response was made\u000a       infer_resp.keys=None\u000a    # # store data for practice_loop (TrialHandler)\u000a    # practice_loop.addData('infer_resp.keys',infer_resp.keys)\u000a    # if infer_resp.keys != None:  # we had a response\u000a    #     practice_loop.addData('infer_resp.rt', infer_resp.rt)\u000a    practice_loop.addData('set_feedback.feedback_img', set_feedback.feedback_img)\u000a    practice_loop.addData('trial_start_time', trialtime)\u000a    \u000a    # # Increase correct and incorrect response counters by 1 based on S's response\u000a    # if infer_resp.keys=='left' and img_correct==img_left:\u000a    #     correct_counter += 1\u000a    # elif infer_resp.keys=='left' and img_correct==img_right:\u000a    #     incorrect_counter += 1\u000a    # elif infer_resp.keys=='right' and img_correct==img_right:\u000a    #     correct_counter += 1\u000a    # elif infer_resp.keys=='right' and img_correct==img_left:\u000a    #     incorrect_counter += 1\u000a    \u000a\u000a    #------Prepare to start Routine "trial_post_response"-------\u000a    t = 0\u000a    trial_post_responseClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(3.000000)\u000a    # keep track of which components have finished\u000a    trial_post_responseComponents = []\u000a    trial_post_responseComponents.append(img_left_infer)\u000a    trial_post_responseComponents.append(img_right_infer)\u000a    trial_post_responseComponents.append(selection_arrow_left)\u000a    trial_post_responseComponents.append(selection_arrow_right)\u000a    trial_post_responseComponents.append(feedback_box_left)\u000a    trial_post_responseComponents.append(feedback_box_right)\u000a    for thisComponent in trial_post_responseComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial_post_response"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = trial_post_responseClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a\u000a        # *img_left_infer* updates\u000a        if t >= 0.0 and img_left_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_left_infer.tStart = t  # underestimates by a little under one frame\u000a            img_left_infer.frameNStart = frameN  # exact frame index\u000a            img_left_infer.setAutoDraw(True)\u000a        elif img_left_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            img_left_infer.setAutoDraw(False)\u000a        \u000a        # *img_right_infer* updates\u000a        if t >= 0.0 and img_right_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_right_infer.tStart = t  # underestimates by a little under one frame\u000a            img_right_infer.frameNStart = frameN  # exact frame index\u000a            img_right_infer.setAutoDraw(True)\u000a        elif img_right_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            img_right_infer.setAutoDraw(False)\u000a        \u000a        if infer_resp.keys == 'left':\u000a            # *selection_arrow_left* updates\u000a            if t >= 0.0 and selection_arrow_left.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                selection_arrow_left.tStart = t  # underestimates by a little under one frame\u000a                selection_arrow_left.frameNStart = frameN  # exact frame index\u000a                selection_arrow_left.setAutoDraw(True)\u000a            elif selection_arrow_left.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                selection_arrow_left.setAutoDraw(False)\u000a        \u000a        if infer_resp.keys == 'right':\u000a            # *selection_arrow_right* updates\u000a            if t >= 0.0 and selection_arrow_right.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                selection_arrow_right.tStart = t  # underestimates by a little under one frame\u000a                selection_arrow_right.frameNStart = frameN  # exact frame index\u000a                selection_arrow_right.setAutoDraw(True)\u000a            elif selection_arrow_right.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                selection_arrow_right.setAutoDraw(False)\u000a        \u000a        if set_feedback.feedback_side == 'left':\u000a            # *feedback_box_left* updates\u000a            if t >= 1.0 and feedback_box_left.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                feedback_box_left.tStart = t  # underestimates by a little under one frame\u000a                feedback_box_left.frameNStart = frameN  # exact frame index\u000a                feedback_box_left.setAutoDraw(True)\u000a            elif feedback_box_left.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                feedback_box_left.setAutoDraw(False)\u000a        \u000a        if set_feedback.feedback_side == 'right':\u000a            # *feedback_box_right* updates\u000a            if t >= 1.0 and feedback_box_right.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                feedback_box_right.tStart = t  # underestimates by a little under one frame\u000a                feedback_box_right.frameNStart = frameN  # exact frame index\u000a                feedback_box_right.setAutoDraw(True)\u000a            elif feedback_box_right.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period right\u000a                feedback_box_right.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trial_post_responseComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "trial_post_response"-------\u000a    for thisComponent in trial_post_responseComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000a    \u000a    thisExp.nextEntry()\u000a                        \u000a# completed 1 repeat of 'practice_loop'\u000a\u000a\u000a#------Prepare to start Routine "instr_infer"-------\u000at = 0\u000ainstr_inferClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_infer_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_infer_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_inferComponents = []\u000ainstr_inferComponents.append(instr_infer_txt)\u000ainstr_inferComponents.append(instr_infer_resp)\u000afor thisComponent in instr_inferComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_infer"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_inferClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_infer_txt* updates\u000a    if t >= 0.0 and instr_infer_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_txt.frameNStart = frameN  # exact frame index\u000a        instr_infer_txt.setAutoDraw(True)\u000a    \u000a    # *instr_infer_resp* updates\u000a    if t >= 5.0 and instr_infer_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_resp.frameNStart = frameN  # exact frame index\u000a        instr_infer_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_infer_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_infer_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_infer_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_infer_resp.rt = instr_infer_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_inferComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_infer"-------\u000afor thisComponent in instr_inferComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_infer_resp.keys in ['', [], None]:  # No response was made\u000a   instr_infer_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_infer_resp.keys',instr_infer_resp.keys)\u000aif instr_infer_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_infer_resp.rt', instr_infer_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## BLOCK LOOP ##########################\u000a\u000a# This loop runs a second nested loop that shows each item pair 10 times, followed by a rest break prompt.\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=3, method=u'sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=[None],\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000a# Set up counter to keep track of block loop cycle, so that the rest prompt is only shown twice\u000ablock_loop_counter = 0\u000a\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    # Increase loop counter by one\u000a    block_loop_counter += 1\u000a    \u000a    # Change the condition file for the feedback block based on which block loop we're on\u000a    condfilename = filename+u'_block'+str(block_loop_counter)+u'cond.csv'\u000a    \u000a    # # Minimize the psychopy window so the calibration window can be seen\u000a    # win.winHandle.minimize()\u000a    # #Do the eye tracker setup at the beginning of each block\u000a    # tracker.runSetupProcedure()\u000a    # # Re-display the psychopy window after setup is completed\u000a    # win.winHandle.maximize()\u000a    # win.winHandle.activate()\u000a    \u000a\u000a    \u000a    #------Prepare to start Routine "get_ready"-------\u000a    t = 0\u000a    get_readyClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(3.000000)\u000a    # update component parameters for each repeat\u000a    get_ready_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    get_ready_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    get_readyComponents = []\u000a    get_readyComponents.append(get_ready_text)\u000a    get_readyComponents.append(get_ready_resp)\u000a    for thisComponent in get_readyComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    \u000a    #-------Start Routine "get_ready"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = get_readyClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *get_ready_text* updates\u000a        if t >= 0.0 and get_ready_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            get_ready_text.tStart = t  # underestimates by a little under one frame\u000a            get_ready_text.frameNStart = frameN  # exact frame index\u000a            get_ready_text.setAutoDraw(True)\u000a        \u000a        # *get_ready_resp* updates\u000a        if t >= 0.0 and get_ready_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            get_ready_resp.tStart = t  # underestimates by a little under one frame\u000a            get_ready_resp.frameNStart = frameN  # exact frame index\u000a            get_ready_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            get_ready_resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if get_ready_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['p'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                get_ready_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                get_ready_resp.rt = get_ready_resp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in get_readyComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "get_ready"-------\u000a    for thisComponent in get_readyComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if get_ready_resp.keys in ['', [], None]:  # No response was made\u000a       get_ready_resp.keys=None\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('get_ready_resp.keys',get_ready_resp.keys)\u000a    if get_ready_resp.keys != None:  # we had a response\u000a        thisExp.addData('get_ready_resp.rt', get_ready_resp.rt)\u000a    thisExp.nextEntry()\u000a\u000a    ######################## TRIAL LOOP ##########################\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    trial_loop = data.TrialHandler(nReps=1, method=u'sequential', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(condfilename),\u000a        seed=None, name='trial_loop')\u000a    thisExp.addLoop(trial_loop)  # add the loop to the experiment\u000a    thisTrial_loop = trial_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_loop.rgb)\u000a    if thisTrial_loop != None:\u000a        for paramName in thisTrial_loop.keys():\u000a            exec(paramName + '= thisTrial_loop.' + paramName)\u000a    \u000a      \u000a    for thisTrial_loop in trial_loop:\u000a        currentLoop = trial_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_loop.rgb)\u000a        if thisTrial_loop != None:\u000a            for paramName in thisTrial_loop.keys():\u000a                exec(paramName + '= thisTrial_loop.' + paramName)    \u000a        \u000a            \u000a        # Define class for setting the feedback image\u000a        class set_feedback:\u000a            options = ['correct', 'wrong']\u000a            feedback = np.random.choice(options, replace=True, p=[0.8, 0.2])\u000a            if feedback=='correct':\u000a                feedback_img = img_correct\u000a            elif feedback=='wrong':\u000a                feedback_img = img_wrong\u000a\u000a            if feedback_img==img_left:\u000a                feedback_side = 'left'\u000a            elif feedback_img==img_right:\u000a                feedback_side = 'right'\u000a                        \u000a        # # Start getting data from the eye tracker\u000a        # tracker.enableEventReporting(True)\u000a        # # Send beginning-of-trial messages to eye tracker data file\u000a        # trial_number = (block_loop.thisN * 200) + trial_loop.thisTrialN # Trial number out of 599 (starts at 0)\u000a        # tracker.sendCommand("record_status_message 'INFERRING, Block %d/3, Trial %d/600 '" % (block_loop.thisN + 1, trial_number + 1))\u000a        # tracker.sendMessage("TRIALID %d" % trial_number)\u000a        # tracker.sendMessage("!V TRIAL_VAR_DATA %d" % trial_number)\u000a\u000a        \u000a        #------Prepare to start Routine "trial"-------\u000a        t = 0\u000a        trialtime = datetime.datetime.now()\u000a        trialClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        img_left_infer.setImage(dir_path+img_left)\u000a        img_right_infer.setImage(dir_path+img_right)\u000a        infer_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        infer_resp.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trialComponents = []\u000a        trialComponents.append(fixation_text)\u000a        trialComponents.append(img_left_infer)\u000a        trialComponents.append(img_right_infer)\u000a        trialComponents.append(infer_resp)\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        # Set indicator variable for whether eye tracker messages were sent during the first loop of the routine\u000a        eye_sync_messages_sent = 0\u000a        \u000a        #-------Start Routine "trial"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = trialClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *fixation_text* updates\u000a            if t >= 0 and fixation_text.status == NOT_STARTED:\u000a                if eye_sync_messages_sent==0:\u000a                    startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                # keep track of start time/frame for later\u000a                fixation_text.tStart = t  # underestimates by a little under one frame\u000a                fixation_text.frameNStart = frameN  # exact frame index\u000a                fixation_text.setAutoDraw(True)\u000a                if eye_sync_messages_sent==0:\u000a                    drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                    # tracker.sendMessage("%d DISPLAY ON" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                    # tracker.sendMessage("SYNCTIME %d" %drawTime)\u000a                    eye_sync_messages_sent = 1\u000a            elif fixation_text.status == STARTED and t>= (0 + (2.0-win.monitorFramePeriod*0.75)):\u000a                fixation_text.setAutoDraw(False)\u000a            \u000a            # *img_left_infer* updates\u000a            if t >= 2.0 and img_left_infer.status == NOT_STARTED:\u000a                if eye_sync_messages_sent==1:\u000a                    startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                # keep track of start time/frame for later\u000a                img_left_infer.tStart = t  # underestimates by a little under one frame\u000a                img_left_infer.frameNStart = frameN  # exact frame index\u000a                img_left_infer.setAutoDraw(True)\u000a            \u000a            # *img_right_infer* updates\u000a            if t >= 2.0 and img_right_infer.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                img_right_infer.tStart = t  # underestimates by a little under one frame\u000a                img_right_infer.frameNStart = frameN  # exact frame index\u000a                img_right_infer.setAutoDraw(True)\u000a                if eye_sync_messages_sent==1:\u000a                    drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                    # tracker.sendMessage("%d DISPLAY ON ITEMS" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                    eye_sync_messages_sent = 2\u000a                      \u000a            # *infer_resp* updates\u000a            if t >= 2.0 and infer_resp.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                infer_resp.tStart = t  # underestimates by a little under one frame\u000a                infer_resp.frameNStart = frameN  # exact frame index\u000a                infer_resp.status = STARTED\u000a                # keyboard checking is just starting\u000a                infer_resp.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            if infer_resp.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['left', 'right'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    infer_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                    infer_resp.rt = infer_resp.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trialComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                # tracker.enableEventReporting(False) # End eye tracker data recording\u000a                # tracker.sendMessage("EXPERIMENT ABORTED")\u000a                # io.quit() # Close iohub\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial"-------\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if infer_resp.keys in ['', [], None]:  # No response was made\u000a           infer_resp.keys=None\u000a        # store data for trial_loop (TrialHandler)\u000a        trial_loop.addData('infer_resp.keys',infer_resp.keys)\u000a        if infer_resp.keys != None:  # we had a response\u000a            trial_loop.addData('infer_resp.rt', infer_resp.rt)\u000a        trial_loop.addData('set_feedback.feedback_img', set_feedback.feedback_img)\u000a        trial_loop.addData('trial_start_time', trialtime)\u000a        \u000a        # Increase correct and incorrect response counters by 1 based on S's response\u000a        if infer_resp.keys=='left' and img_correct==img_left:\u000a            correct_counter += 1\u000a        elif infer_resp.keys=='left' and img_correct==img_right:\u000a            incorrect_counter += 1\u000a        elif infer_resp.keys=='right' and img_correct==img_right:\u000a            correct_counter += 1\u000a        elif infer_resp.keys=='right' and img_correct==img_left:\u000a            incorrect_counter += 1\u000a        \u000a\u000a        #------Prepare to start Routine "trial_post_response"-------\u000a        t = 0\u000a        trial_post_responseClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(3.000000)\u000a        # keep track of which components have finished\u000a        trial_post_responseComponents = []\u000a        trial_post_responseComponents.append(img_left_infer)\u000a        trial_post_responseComponents.append(img_right_infer)\u000a        trial_post_responseComponents.append(selection_arrow_left)\u000a        trial_post_responseComponents.append(selection_arrow_right)\u000a        trial_post_responseComponents.append(feedback_box_left)\u000a        trial_post_responseComponents.append(feedback_box_right)\u000a        for thisComponent in trial_post_responseComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        # Set indicator variable for whether eye tracker messages were sent during the first loop of the routine\u000a        eye_sync_messages_sent = 0\u000a\u000a        #-------Start Routine "trial_post_response"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = trial_post_responseClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a\u000a            # *img_left_infer* updates\u000a            if t >= 0.0 and img_left_infer.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                img_left_infer.tStart = t  # underestimates by a little under one frame\u000a                img_left_infer.frameNStart = frameN  # exact frame index\u000a                img_left_infer.setAutoDraw(True)\u000a            elif img_left_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                img_left_infer.setAutoDraw(False)\u000a            \u000a            # *img_right_infer* updates\u000a            if t >= 0.0 and img_right_infer.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                img_right_infer.tStart = t  # underestimates by a little under one frame\u000a                img_right_infer.frameNStart = frameN  # exact frame index\u000a                img_right_infer.setAutoDraw(True)\u000a            elif img_right_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                img_right_infer.setAutoDraw(False)\u000a            \u000a            if infer_resp.keys == 'left':\u000a                # *selection_arrow_left* updates\u000a                if t >= 0.0 and selection_arrow_left.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==0:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    selection_arrow_left.tStart = t  # underestimates by a little under one frame\u000a                    selection_arrow_left.frameNStart = frameN  # exact frame index\u000a                    selection_arrow_left.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==0:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        # tracker.sendMessage("%d DISPLAY ON SELECTION" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 1\u000a                elif selection_arrow_left.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    if eye_sync_messages_sent==1:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    selection_arrow_left.setAutoDraw(False)\u000a                    if eye_sync_messages_sent==1:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        # tracker.sendMessage("%d DISPLAY ON SELECTION OFF" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 2\u000a            \u000a            if infer_resp.keys == 'right':\u000a                # *selection_arrow_right* updates\u000a                if t >= 0.0 and selection_arrow_right.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==0:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    selection_arrow_right.tStart = t  # underestimates by a little under one frame\u000a                    selection_arrow_right.frameNStart = frameN  # exact frame index\u000a                    selection_arrow_right.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==0:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        # tracker.sendMessage("%d DISPLAY ON SELECTION" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 1\u000a                elif selection_arrow_right.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    if eye_sync_messages_sent==1:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    selection_arrow_right.setAutoDraw(False)\u000a                    if eye_sync_messages_sent==1:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        # tracker.sendMessage("%d DISPLAY ON SELECTION OFF" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 2\u000a            \u000a            if set_feedback.feedback_side == 'left':\u000a                # *feedback_box_left* updates\u000a                if t >= 1.0 and feedback_box_left.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==2:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    feedback_box_left.tStart = t  # underestimates by a little under one frame\u000a                    feedback_box_left.frameNStart = frameN  # exact frame index\u000a                    feedback_box_left.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==2:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        # tracker.sendMessage("%d DISPLAY ON FEEDBACK" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 3\u000a                elif feedback_box_left.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    feedback_box_left.setAutoDraw(False)\u000a            \u000a            if set_feedback.feedback_side == 'right':\u000a                # *feedback_box_right* updates\u000a                if t >= 1.0 and feedback_box_right.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==2:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    feedback_box_right.tStart = t  # underestimates by a little under one frame\u000a                    feedback_box_right.frameNStart = frameN  # exact frame index\u000a                    feedback_box_right.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==2:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        # tracker.sendMessage("%d DISPLAY ON FEEDBACK" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 3\u000a                elif feedback_box_right.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period right\u000a                    feedback_box_right.setAutoDraw(False)\u000a\u000a\u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial_post_responseComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                # tracker.enableEventReporting(False) # End eye tracker data recording\u000a                # tracker.sendMessage("EXPERIMENT ABORTED")\u000a                # io.quit() # Close iohub\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "trial_post_response"-------\u000a        for thisComponent in trial_post_responseComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a        thisExp.nextEntry()\u000a                            \u000a    # completed 5 repeats of 'trial_loop'\u000a    \u000a    if block_loop_counter <= 2: # If this is the first or second cycle of the loop, display the rest break prompt\u000a\u000a        #------Prepare to start Routine "rest_prompt"-------\u000a        t = 0\u000a        rest_promptClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        rest_prompt_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        rest_prompt_resp.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        rest_promptComponents = []\u000a        rest_promptComponents.append(rest_prompt_txt)\u000a        rest_promptComponents.append(rest_prompt_resp)\u000a        for thisComponent in rest_promptComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a\u000a        #-------Start Routine "rest_prompt"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = rest_promptClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *rest_prompt_txt* updates\u000a            if t >= 0.0 and rest_prompt_txt.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                rest_prompt_txt.tStart = t  # underestimates by a little under one frame\u000a                rest_prompt_txt.frameNStart = frameN  # exact frame index\u000a                rest_prompt_txt.setAutoDraw(True)\u000a            \u000a            # *rest_prompt_resp* updates\u000a            if t >= 2.0 and rest_prompt_resp.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                rest_prompt_resp.tStart = t  # underestimates by a little under one frame\u000a                rest_prompt_resp.frameNStart = frameN  # exact frame index\u000a                rest_prompt_resp.status = STARTED\u000a                # keyboard checking is just starting\u000a                rest_prompt_resp.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            if rest_prompt_resp.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    rest_prompt_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                    rest_prompt_resp.rt = rest_prompt_resp.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in rest_promptComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                # tracker.enableEventReporting(False) # End eye tracker data recording\u000a                # tracker.sendMessage("EXPERIMENT ABORTED")\u000a                # io.quit() # CLose iohub\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a\u000a        #-------Ending Routine "rest_prompt"-------\u000a        for thisComponent in rest_promptComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if rest_prompt_resp.keys in ['', [], None]:  # No response was made\u000a           rest_prompt_resp.keys=None\u000a        # store data for thisExp (ExperimentHandler)\u000a        thisExp.addData('rest_prompt_resp.keys',rest_prompt_resp.keys)\u000a        if rest_prompt_resp.keys != None:  # we had a response\u000a            thisExp.addData('rest_prompt_resp.rt', rest_prompt_resp.rt)\u000a\u000a\u000a    thisExp.nextEntry()\u000a    \u000a# completed 3 repeats of 'block_loop'\u000a\u000a\u000a# store data for total number of correct and incorrect responses    \u000athisExp.addData('correct_counter', correct_counter)\u000athisExp.addData('incorrect_counter', incorrect_counter)\u000athisExp.nextEntry()     \u000a\u000a# tracker.setConnectionState(False) # Close and transfer eye-tracking data, then close down eye tracker connection\u000a\u000a\u000a######################## AUCTION ##########################\u000a\u000aif len(prefs)==41 and len(bids)==41: # If S completed the entire binary choice and BDM routines, run the auction\u000a\u000a    # run the auction\u000a    class auction:\u000a        rand_itm = randint(1, (len(prefs))) # pick index for S's chosen item from a random choice\u000a        price = float((randint(1, 300)))/100 # assign a price to the item randomly from between 0.01 and 3 pounds\u000a        bid = prefs[rand_itm][3]\u000a        # check if S's bid for that item was above or below the price\u000a        if bid >= price:\u000a            win_item=True\u000a        elif bid < price:\u000a            win_item=False\u000a\u000a        # set text for the auction screen\u000a        if win_item==True:\u000a            auc_res_txt = u'Congratulations! You won the following item at auction. \u005cnThis was your preferred item out of a randomly selected pair from one of the choice tasks.'\u000a            auc_prc_txt = u'Your bid of \u005cxa3' + '{0:.2f}'.format(bid) + u' matched or exceeded the randomly generated price of \u005cxa3' + '{0:.2f}'.format(price) + '.\u005cn\u005cn[Press space bar to continue]'\u000a            cost = price\u000a        elif win_item==False:\u000a            auc_res_txt = u'Sorry, you did not win the following item at auction. \u005cnThis was your preferred item out of a randomly selected pair from one of the choice tasks.'\u000a            auc_prc_txt = u'Your bid of \u005cxa3' + '{0:.2f}'.format(bid) + u' was lower than the randomly generated price of \u005cxa3' + '{0:.2f}'.format(price) + '.\u005cn\u005cn[Press space bar to continue]'\u000a            cost = 0\u000a\u000a        # find the image path of the auction item\u000a        rand_itm_img = prefs[rand_itm][2]\u000a\u000a    # add up each component of S's payment\u000a    class score:\u000a        base = 25\u000a        rwrd = 0.01\u000a        loss = 0\u000a        rwrd_tot = rwrd * correct_counter\u000a        loss_tot = loss * incorrect_counter\u000a        pre_pymt = base + rwrd_tot - loss_tot\u000a        final_pymt = pre_pymt - auction.cost\u000a\u000a        pymt_expl_bdwn = u'\u005cxa3' + '{0:.2f}'.format(base) + u' base payment'+ u'\u005cn+ \u005cxa3' + '{0:.2f}'.format(rwrd_tot) + ' reward for ' + str(correct_counter) + u' correct responses (\u005cxa3' + '{0:.2f}'.format(rwrd) + u' each)' + u'\u005cn- \u005cxa3' + '{0:.2f}'.format(auction.cost) + ' cost of auction item' \u000a        pymt_expl_tot = u'Your total payment is: \u005cxa3' + '{0:.2f}'.format(final_pymt) + '\u005cn\u005cnThank you for participating!'\u000a\u000a\u000a    # Initialize components for Routine "auc_disp"\u000a    auc_dispClock = core.Clock()\u000a    pic_auc_itm = visual.ImageStim(win=win, name='pic_auc_itm',\u000a        image=dir_path+auction.rand_itm_img, mask=None,\u000a        ori=0, pos=[0, 0], size=None,\u000a        color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a        flipHoriz=False, flipVert=False,\u000a        texRes=128, interpolate=False, depth=0.0)\u000a    auc_txt1 = visual.TextStim(win=win, ori=0, name='auc_txt1',\u000a        text=auction.auc_res_txt, font=u'Arial',\u000a        pos=[0, 0.6], height=0.07, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    auc_txt2 = visual.TextStim(win=win, ori=0, name='auc_txt2',\u000a        text=auction.auc_prc_txt, font=u'Arial',\u000a        pos=[0, -0.6], height=0.07, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a\u000a    #------Prepare to start Routine "auc_disp"-------\u000a    t = 0\u000a    auc_dispClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    key_resp_auc_disp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_auc_disp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    auc_dispComponents = []\u000a    auc_dispComponents.append(pic_auc_itm)\u000a    auc_dispComponents.append(auc_txt1)\u000a    auc_dispComponents.append(auc_txt2)\u000a    for thisComponent in auc_dispComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "auc_disp"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = auc_dispClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *pic_auc_itm* updates\u000a        if t >= 0.2 and pic_auc_itm.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            pic_auc_itm.tStart = t  # underestimates by a little under one frame\u000a            pic_auc_itm.frameNStart = frameN  # exact frame index\u000a            pic_auc_itm.setAutoDraw(True)\u000a        \u000a        # *auc_txt1* updates\u000a        if t >= 0.2 and auc_txt1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            auc_txt1.tStart = t  # underestimates by a little under one frame\u000a            auc_txt1.frameNStart = frameN  # exact frame index\u000a            auc_txt1.setAutoDraw(True)\u000a\u000a        # *auc_txt2* updates\u000a        if t >= 0.2 and auc_txt2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            auc_txt2.tStart = t  # underestimates by a little under one frame\u000a            auc_txt2.frameNStart = frameN  # exact frame index\u000a            auc_txt2.setAutoDraw(True)\u000a        \u000a        # *key_resp_auc_disp* updates\u000a        if t >= 0.2 and key_resp_auc_disp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_auc_disp.tStart = t  # underestimates by a little under one frame\u000a            key_resp_auc_disp.frameNStart = frameN  # exact frame index\u000a            key_resp_auc_disp.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_auc_disp.clock.reset()  # now t=0\u000a        if key_resp_auc_disp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_auc_disp.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_auc_disp.rt = key_resp_auc_disp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in auc_dispComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "auc_disp"-------\u000a    for thisComponent in auc_dispComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_auc_disp.keys in ['', [], None]:  # No response was made\u000a       key_resp_auc_disp.keys=None\u000a    # store data for thisExp (TrialHandler)\u000a    thisExp.addData('auction.win_item', auction.win_item)\u000a    thisExp.addData('auction.price', auction.price)\u000a    thisExp.addData('auction.bid', auction.bid)\u000a    thisExp.addData('auction.rand_itm_img', auction.rand_itm_img)\u000a    thisExp.addData('score.base', score.base)\u000a    thisExp.addData('score.rwrd', score.rwrd)\u000a    thisExp.addData('score.loss', score.loss)\u000a    thisExp.addData('correct_counter', correct_counter)\u000a    thisExp.addData('incorrect_counter', incorrect_counter)\u000a    thisExp.addData('score.final_pymt', score.final_pymt)\u000a    thisExp.nextEntry()\u000a\u000a\u000a    # Initialize components for Routine "pymt_disp"\u000a    pymt_dispClock = core.Clock()\u000a    pymt_disp_txt1 = visual.TextStim(win=win, ori=0, name='pymt_disp_txt1',\u000a        text=score.pymt_expl_bdwn, font=u'Arial',\u000a        pos=[0, 0.6], height=0.07, wrapWidth=1.5,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    pymt_disp_txt2 = visual.TextStim(win=win, ori=0, name='pymt_disp_txt2',\u000a        text=score.pymt_expl_tot, font=u'Arial',\u000a        pos=[0, -0.65], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    #------Prepare to start Routine "pymt_disp"-------\u000a    t = 0\u000a    pymt_dispClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    key_resp_pymt_disp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_pymt_disp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    pymt_dispComponents = []\u000a    pymt_dispComponents.append(pic_auc_itm)\u000a    pymt_dispComponents.append(pymt_disp_txt1)\u000a    pymt_dispComponents.append(pymt_disp_txt2)\u000a    pymt_dispComponents.append(key_resp_pymt_disp)\u000a    for thisComponent in pymt_dispComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "pymt_disp"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = pymt_dispClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        if auction.win_item==True:\u000a            # *pic_auc_itm* updates\u000a            if t >= 0.0 and pic_auc_itm.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                pic_auc_itm.tStart = t  # underestimates by a little under one frame\u000a                pic_auc_itm.frameNStart = frameN  # exact frame index\u000a                pic_auc_itm.setAutoDraw(True)\u000a\u000a        # *pymt_disp_txt1* updates\u000a        if t >= 0.0 and pymt_disp_txt1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            pymt_disp_txt1.tStart = t  # underestimates by a little under one frame\u000a            pymt_disp_txt1.frameNStart = frameN  # exact frame index\u000a            pymt_disp_txt1.setAutoDraw(True)\u000a\u000a        # *pymt_disp_txt2* updates\u000a        if t >= 0.0 and pymt_disp_txt2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            pymt_disp_txt2.tStart = t  # underestimates by a little under one frame\u000a            pymt_disp_txt2.frameNStart = frameN  # exact frame index\u000a            pymt_disp_txt2.setAutoDraw(True)\u000a        \u000a        # *key_resp_pymt_disp* updates\u000a        if t >= 3.0 and key_resp_pymt_disp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_pymt_disp.tStart = t  # underestimates by a little under one frame\u000a            key_resp_pymt_disp.frameNStart = frameN  # exact frame index\u000a            key_resp_pymt_disp.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_pymt_disp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if key_resp_pymt_disp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_pymt_disp.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_pymt_disp.rt = key_resp_pymt_disp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in pymt_dispComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "pymt_disp"-------\u000a    for thisComponent in pymt_dispComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_pymt_disp.keys in ['', [], None]:  # No response was made\u000a       key_resp_pymt_disp.keys=None\u000a\u000aelse: # If S didn't complete the entire binary choice and BDM routines during this session, prompt a manual auction\u000a    # Initialize components for Routine "auc_manual"\u000a    auc_manualClock = core.Clock()\u000a    auc_manual_txt = visual.TextStim(win=win, ori=0, name='auc_manual_txt',\u000a        text=u'Thank you! This completes the experiment. The experimenter will now run the auction and calculate your final payment.\u005cn\u005cnCorrect: ' + str(correct_counter) + '\u005cnIncorrect: ' + str(incorrect_counter),    font=u'Arial',\u000a        pos=[0, 0], height=0.07, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    #------Prepare to start Routine "auc_manual"-------\u000a    t = 0\u000a    auc_manualClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    auc_manualComponents = []\u000a    auc_manualComponents.append(auc_manual_txt)\u000a    for thisComponent in auc_manualComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "auc_manual"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = auc_manualClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *auc_manual_txt* updates\u000a        if t >= 0.0 and auc_manual_txt.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            auc_manual_txt.tStart = t  # underestimates by a little under one frame\u000a            auc_manual_txt.frameNStart = frameN  # exact frame index\u000a            auc_manual_txt.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in auc_manualComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "auc_manual"-------\u000a    for thisComponent in auc_manualComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000athisExp.nextEntry()\u000a\u000a# io.quit() # Close iohub\u000a\u000a\u000awin.close()\u000acore.quit()\u000a
p9397
sg9107
(lp9398
sg9109
I85328720
sg10
S'trial_loop'
p9399
sg6
g9111
sg9112
I1
sg52
I01
sg53
g54
sg9113
g1
(g9114
g9115
(dp9400
g33
g9118
(g9119
g92
g9120
S'b'
tRp9401
(I1
(I200
I1
tg9244
I00
S'\xc0\xb0\xef\x0c\xe8\xb0\xef\x0c\x10\xb1\xef\x0c\xe0\xa0\xef\x0c\x00\xa2\xef\x0c\xe0\xa0\xef\x0c\x00\xd9\x87\x04\x10\xa1\xef\x0c`\xb1\xef\x0c\x80\xd5\x87\x04\xa0\xb2\xef\x0c8\xb1\xef\x0c\x88\xb1\xef\x0c\x80\xd5\x87\x04`\xa2\xef\x0c\xe0\xda\x87\x04\xc0\xdd\x87\x04\x88\xb1\xef\x0c\xf0\xb2\xef\x0c\x88\xb1\xef\x0c\x08v\xef\x0c\xb0\xb1\xef\x0c8\xb1\xef\x0c\xd8\xb1\xef\x0c\x10\xb1\xef\x0c\xb0\xb1\xef\x0c\x10\xa1\xef\x0cp\xa1\xef\x0cxv\xef\x0c8\xb1\xef\x0c\xb0\xb1\xef\x0c\x00\xb2\xef\x0cp\xa1\xef\x0c\xd8\xb1\xef\x0c\xe0\xda\x87\x04\xc0\xdd\x87\x04\x08v\xef\x0c\xd8\xb1\xef\x0c\x08v\xef\x0c\xf0\xb2\xef\x0c\xb0\xb1\xef\x0cp\xa1\xef\x0c(\xb2\xef\x0c\xe8\xb0\xef\x0cp\xa1\xef\x0c\xc0\xb0\xef\x0c\xc0\xdd\x87\x04\xe0\xa0\xef\x0c\xe8\xb0\xef\x0c\x10\xa1\xef\x0c\xe0\xda\x87\x04`\xb1\xef\x0cXw\xef\x0c\x80\xd5\x87\x04\x00\xd9\x87\x04\x00\xb2\xef\x0c\xc0\xb0\xef\x0cxv\xef\x0c\x88\xb1\xef\x0c\xa0\xa1\xef\x0c\xc0\xdd\x87\x04\xc0\xb0\xef\x0c\xf0\xb2\xef\x0c\xc0\xa2\xef\x0c\xe0\xa0\xef\x0cp\xa1\xef\x0c\x10\xb1\xef\x0c@v\xef\x0c@\xa1\xef\x0cxv\xef\x0c8\xb1\xef\x0c@\xa1\xef\x0c`\xd6\x87\x04\xc0\xdd\x87\x04(\xb2\xef\x0c\xc0\xb0\xef\x0c\xc0\xdd\x87\x04\x10\xb1\xef\x0c@\xa1\xef\x0c\xa0\xb2\xef\x0c8\xb1\xef\x0c\x00\xb2\xef\x0c\x88\xb1\xef\x0c(\xb2\xef\x0c\x10\xb1\xef\x0c@v\xef\x0c\xb0\xb1\xef\x0c(\xb2\xef\x0c\xe8\xb0\xef\x0c\x10\xb1\xef\x0c\x00\xd9\x87\x04\x00\xb2\xef\x0c\xe8\xb0\xef\x0c\xc0\xdd\x87\x04`\xa2\xef\x0cXw\xef\x0c\x00\xb2\xef\x0c\xe0\xa0\xef\x0c\xc0\xdd\x87\x04\x90\xa2\xef\x0cp\xa1\xef\x0c@\xa1\xef\x0c\xb0\xb1\xef\x0c\xc0\xdd\x87\x04p\xa1\xef\x0c\xd8\xb1\xef\x0c`\xd6\x87\x04\x00\xb2\xef\x0c\xd0\xa1\xef\x0c\x80\xd5\x87\x04`\xb1\xef\x0c\x88\xb1\xef\x0c\x00\xb2\xef\x0c8\xb1\xef\x0c w\xef\x0c\x08v\xef\x0c@\xa1\xef\x0c`\xb1\xef\x0c\x00\xd9\x87\x04`\xb1\xef\x0c@v\xef\x0c8\xb1\xef\x0c\xc0\xb0\xef\x0c\xd8\xb1\xef\x0c\xd0\xa1\xef\x0c\x10\xb1\xef\x0c`\xd6\x87\x04\xf0\xa2\xef\x0c\x18\xb3\xef\x0c@\xa1\xef\x0cp\xa1\xef\x0c\xb0\xb1\xef\x0c\x10\xa1\xef\x0c8\xb1\xef\x0c\xe0\xa0\xef\x0c\x88\xb1\xef\x0c@v\xef\x0c\x80\xd5\x87\x04\x10\xa1\xef\x0c\xc8\xb2\xef\x0c\xc0\xb0\xef\x0c\x08v\xef\x0c0\xa2\xef\x0c\x88\xb1\xef\x0c\xe8\xb0\xef\x0c\xe0\xa0\xef\x0c\xa0\xb2\xef\x0c`\xd6\x87\x04\x08v\xef\x0c\xc0\xdd\x87\x04\xa0\xd3\x87\x04\x88\xb1\xef\x0c`\xb1\xef\x0c(\xb2\xef\x0c@v\xef\x0c\xc8\xb2\xef\x0c\x08v\xef\x0c`\xb1\xef\x0c\x08v\xef\x0c`\xd6\x87\x04\x10\xb1\xef\x0c\x80\xd5\x87\x04\xe0\xda\x87\x04\xd8\xb1\xef\x0c\xc8\xb2\xef\x0c\x80\xd5\x87\x04\xd8\xb1\xef\x0c\xb0\xb1\xef\x0c\x10\xa1\xef\x0c(\xb2\xef\x0c\x00\xa2\xef\x0c\xd8\xb1\xef\x0c\x10\xa1\xef\x0c\x00\xb2\xef\x0cx\xb2\xef\x0c\x00\xb2\xef\x0c@\xa1\xef\x0c\xa0\xb2\xef\x0c\x10\xa1\xef\x0c@\xa1\xef\x0c\xb0\xb1\xef\x0c(\xb2\xef\x0c@v\xef\x0c\xe0\xa0\xef\x0c\xd8\xb1\xef\x0cp\xa1\xef\x0c\x08v\xef\x0c\x10\xa1\xef\x0c(\xb2\xef\x0c\xe0\xda\x87\x04\x10\xb1\xef\x0c`\xd6\x87\x04\xe0\xda\x87\x04Xw\xef\x0c\xc0\xb0\xef\x0c`\xd6\x87\x04@v\xef\x0c(\xb2\xef\x0c\x88\xb1\xef\x0c\xc0\xb0\xef\x0c'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg9117
g9118
(g9119
g92
g9120
S'b'
tRp9402
(I1
(I200
I1
tg9122
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg38
g9118
(g9119
g92
g9120
S'b'
tRp9403
(I1
(I200
I1
tg9244
I00
S'\xe0`\xb0\x0c@k\x89\x04\xc0k\x89\x04\xe0#\xb1\x0c\x80(\xb1\x0c\x00"\xb1\x0c\xa0!\xb1\x0c\xc0-\xb1\x0c\xa0h\x89\x04`k\x89\x04\x80k\x89\x04\x80\xd9\x87\x04 \xeb\x86\x0c \xe7\x86\x0c\xe0\xe2\x86\x0c\xa0\xe2\x86\x0c\xa0\xec\x86\x0c\xa0\xe6\x86\x0c`\xed\x86\x0c@\xe6\x86\x0c \xe0\x86\x0c\x80\xe2\x86\x0c@\xe3\x86\x0c\xe0\xeb\x86\x0c`\xec\x86\x0c\xa0\xe3\x86\x0c@\xeb\x86\x0c\xa0\xe7\x86\x0c\x80\xe3\x86\x0c\x80\xec\x86\x0c\x00\xe6\x86\x0c\x80\xed\x86\x0c`\xe6\x86\x0c\xc0\xeb\x86\x0c\x00\xe3\x86\x0c@\xe7\x86\x0c\xe0\xe7\x86\x0c\x00\xec\x86\x0c\x00\xe7\x86\x0c\xe0\xe6\x86\x0c\xc0\xe2\x86\x0c@\xe0\x86\x0c\x80\xe6\x86\x0c \xe6\x86\x0c\xc0\xe7\x86\x0c\xe0\xef\x86\x0c@\xed\x86\x0c\x00\xeb\x86\x0c\x80\xe7\x86\x0c \xed\x86\x0c\x80\xeb\x86\x0c\x00\xde\x88\x04\x00U\x83\x0c X\x83\x0c\xe0T\x83\x0c\x80\\\x83\x0c@T\x83\x0c\xa0[\x83\x0c\x80Z\x83\x0c\xc0[\x83\x0c\x00V\x83\x0c`Z\x83\x0c\xc0S\x83\x0c@U\x83\x0c\x00T\x83\x0c\x80T\x83\x0c`T\x83\x0c`X\x83\x0c`]\x83\x0c\xe0h\x89\x04\xe0?\x81\x0c\x00>\x81\x0c`?\x81\x0c\xe0>\x81\x0c\x80?\x81\x0c`\xb0\xb0\x0c`\xe7\x86\x0c\xe0\xf1\x87\x04`\xf1\x87\x04 \xf9\x87\x04\xc0\xfb\x87\x04@\xf2\x87\x04\xe0\xfb\x87\x04\x80:\x81\x0c@\xf9\x87\x04 \xfb\x87\x04\x80\x80\xad\x0c@\x81\xad\x0c\xa0\x80\xad\x0c\x00\x89\xad\x0c\xc0\x8a\xad\x0c@\x83\xad\x0c\xe0\x82\xad\x0c\xa0\x82\xad\x0c\x00\x8b\xad\x0c B\xc1\x04\xc0A\xc1\x04\x80A\xc1\x04`A\xc1\x04\x00C\xc1\x04\x80B\xc1\x04\xe0B\xc1\x04\xa0C\xc1\x04`C\xc1\x04@C\xc1\x04\x80C\xc1\x04 ?\x81\x0c@[\x82\x0c`D\xc1\x04\xc0@\xc1\x04\xc0C\xc1\x04`B\xc1\x04@D\xc1\x04\x80D\xc1\x04\xc0D\xc1\x04\xa0D\xc1\x04\x00E\xc1\x04 E\xc1\x04@E\xc1\x04\xe0C\xc1\x04\x80E\xc1\x04`E\xc1\x04\xc0E\xc1\x04\xa0E\xc1\x04@A\xc1\x04 F\xc1\x04\x00F\xc1\x04`F\xc1\x04@F\xc1\x04\xa0F\xc1\x04\xc0F\xc1\x04\x00A\xc1\x04@B\xc1\x04\xe0F\xc1\x04@G\xc1\x04`G\xc1\x04\x80G\xc1\x04\xa0G\xc1\x04\xc0B\xc1\x04\xe0G\xc1\x04\xc0G\xc1\x04\xe0E\xc1\x04@H\xc1\x04`H\xc1\x04\xa0@\xc1\x04\xa0H\xc1\x04\xc0H\xc1\x04\xe0@\xc1\x04\x00I\xc1\x04 I\xc1\x04@I\xc1\x04\x00B\xc1\x04\x80I\xc1\x04`I\xc1\x04\xa0A\xc1\x04\xe0I\xc1\x04\xc0I\xc1\x04 J\xc1\x04@J\xc1\x04 D\xc1\x04 H\xc1\x04`J\xc1\x04\x80J\xc1\x04\xa0J\xc1\x04\x00K\xc1\x04\xe0J\xc1\x04 C\xc1\x04 K\xc1\x04\x00H\xc1\x04`K\xc1\x04\x80K\xc1\x04\xe0K\xc1\x04\xc0K\xc1\x04\xa0I\xc1\x04@L\xc1\x04 L\xc1\x04\x80H\xc1\x04\xa0L\xc1\x04\xc0L\xc1\x04\xe0L\xc1\x04 G\xc1\x04\xc0J\xc1\x04\x00M\xc1\x04 M\xc1\x04\x80M\xc1\x04`M\xc1\x04\xe0D\xc1\x04\xe0M\xc1\x04\xc0M\xc1\x04@K\xc1\x04\x00N\xc1\x04 N\xc1\x04@N\xc1\x04`N\xc1\x04\x80N\xc1\x04\xa0N\xc1\x04\x00O\xc1\x04 O\xc1\x04\x00G\xc1\x04\x80F\xc1\x04'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg9125
g9118
(g9119
g92
g9120
S'b'
tRp9404
(I1
(I200
I1
tg9122
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00@\x00\x00@@\x00\x00\x80@\x00\x00\xa0@\x00\x00\xc0@\x00\x00\xe0@\x00\x00\x00A\x00\x00\x10A\x00\x00 A\x00\x000A\x00\x00@A\x00\x00PA\x00\x00`A\x00\x00pA\x00\x00\x80A\x00\x00\x88A\x00\x00\x90A\x00\x00\x98A\x00\x00\xa0A\x00\x00\xa8A\x00\x00\xb0A\x00\x00\xb8A\x00\x00\xc0A\x00\x00\xc8A\x00\x00\xd0A\x00\x00\xd8A\x00\x00\xe0A\x00\x00\xe8A\x00\x00\xf0A\x00\x00\xf8A\x00\x00\x00B\x00\x00\x04B\x00\x00\x08B\x00\x00\x0cB\x00\x00\x10B\x00\x00\x14B\x00\x00\x18B\x00\x00\x1cB\x00\x00 B\x00\x00$B\x00\x00(B\x00\x00,B\x00\x000B\x00\x004B\x00\x008B\x00\x00<B\x00\x00@B\x00\x00DB\x00\x00HB\x00\x00LB\x00\x00PB\x00\x00TB\x00\x00XB\x00\x00\\B\x00\x00`B\x00\x00dB\x00\x00hB\x00\x00lB\x00\x00pB\x00\x00tB\x00\x00xB\x00\x00|B\x00\x00\x80B\x00\x00\x82B\x00\x00\x84B\x00\x00\x86B\x00\x00\x88B\x00\x00\x8aB\x00\x00\x8cB\x00\x00\x8eB\x00\x00\x90B\x00\x00\x92B\x00\x00\x94B\x00\x00\x96B\x00\x00\x98B\x00\x00\x9aB\x00\x00\x9cB\x00\x00\x9eB\x00\x00\xa0B\x00\x00\xa2B\x00\x00\xa4B\x00\x00\xa6B\x00\x00\xa8B\x00\x00\xaaB\x00\x00\xacB\x00\x00\xaeB\x00\x00\xb0B\x00\x00\xb2B\x00\x00\xb4B\x00\x00\xb6B\x00\x00\xb8B\x00\x00\xbaB\x00\x00\xbcB\x00\x00\xbeB\x00\x00\xc0B\x00\x00\xc2B\x00\x00\xc4B\x00\x00\xc6B\x00\x00\xc8B\x00\x00\xcaB\x00\x00\xccB\x00\x00\xceB\x00\x00\xd0B\x00\x00\xd2B\x00\x00\xd4B\x00\x00\xd6B\x00\x00\xd8B\x00\x00\xdaB\x00\x00\xdcB\x00\x00\xdeB\x00\x00\xe0B\x00\x00\xe2B\x00\x00\xe4B\x00\x00\xe6B\x00\x00\xe8B\x00\x00\xeaB\x00\x00\xecB\x00\x00\xeeB\x00\x00\xf0B\x00\x00\xf2B\x00\x00\xf4B\x00\x00\xf6B\x00\x00\xf8B\x00\x00\xfaB\x00\x00\xfcB\x00\x00\xfeB\x00\x00\x00C\x00\x00\x01C\x00\x00\x02C\x00\x00\x03C\x00\x00\x04C\x00\x00\x05C\x00\x00\x06C\x00\x00\x07C\x00\x00\x08C\x00\x00\tC\x00\x00\nC\x00\x00\x0bC\x00\x00\x0cC\x00\x00\rC\x00\x00\x0eC\x00\x00\x0fC\x00\x00\x10C\x00\x00\x11C\x00\x00\x12C\x00\x00\x13C\x00\x00\x14C\x00\x00\x15C\x00\x00\x16C\x00\x00\x17C\x00\x00\x18C\x00\x00\x19C\x00\x00\x1aC\x00\x00\x1bC\x00\x00\x1cC\x00\x00\x1dC\x00\x00\x1eC\x00\x00\x1fC\x00\x00 C\x00\x00!C\x00\x00"C\x00\x00#C\x00\x00$C\x00\x00%C\x00\x00&C\x00\x00\'C\x00\x00(C\x00\x00)C\x00\x00*C\x00\x00+C\x00\x00,C\x00\x00-C\x00\x00.C\x00\x00/C\x00\x000C\x00\x001C\x00\x002C\x00\x003C\x00\x004C\x00\x005C\x00\x006C\x00\x007C\x00\x008C\x00\x009C\x00\x00:C\x00\x00;C\x00\x00<C\x00\x00=C\x00\x00>C\x00\x00?C\x00\x00@C\x00\x00AC\x00\x00BC\x00\x00CC\x00\x00DC\x00\x00EC\x00\x00FC\x00\x00GC'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg39
g9118
(g9119
g92
g9120
S'b'
tRp9405
(I1
(I200
I1
tg9122
I00
S'\x1az\xd7?\xadl\x86?\xc6\x05\xc0?\xdd\xf0n@\xf3\xef\x9d?\xcf\xef\xae?K\x14\x91?B\xcf\x8c?=\xd2\xcc?\x7f\xf2\x96@m\xdf}@\x93w\xe7@\x033\xd3?\x15+"@X\xad\xca?\xe8\x9b\x19@J\xb0\xea?\xd2w\'@\xbe\xd2\xac?\xcd\xf0\xae?\xc5\xef\x86@"\xa8\x8a?\xec\xb0\xca?\x16g\xa6@\xd9h6@\x87c\xa6?\xfa\xbd\xbb?\xd5\x16\xf1?\xac\x8e\xe8?h\x11\x91?\xf9\x87\x88?\xc6\x9a\x99@|\xa29@o\x89\x90@k\x02P@S\xae\x8a?8i\x86@\x8e\x9ai@\xb9\xf4n?\x03\xcf,@\xb3rw?\xd7\x8e\xe8?\xee\x9e\xf9?oF\x14@\x19J\xc4?\xd1h\x16@\xf0Gb?U\xf1\xee?\xb8!\xb2@n\xc1\x9b?M\x13\xa0?\xc1\xbc\x8b@^\x02@@\x85\x9bY@\xe6\x88\xb7?_5S@L;s?\x92g\x16@n\xcc<@/|\x97?P\x97H?\xf0\xf5n?\xed\x8c\x88?C\xc9\xac?P\xd6\xac?\x185\x03@\xa7\xb0\x8a?~\xbeK@D\x15\xa1@cxW@\xf3U5@\xa7\xb0\x8a?\xa8,b?\xb8\xfan?L3\x83@\x12I\x84?&\x1eQ?L\xe3\xbd?\x90.b?:\x9f\xf9?\x1c\xd1\x8c?\xd1\xbf\xdb?\xfe\xd9\xac?\x15\xd2\xac?\xfe\xf4\x8e?\xffx\x17@\xab`\x86?\xd0\x00\x8f?&7\x93?+\xc8{?\xc7w\xbf@V\x03\x80?\xddF4@(\xd3\x8c?\xa0\x8d\xe8?=|\xb7?\xf3\x05\x80?z6\x82?\xd7 Q?\t\xc6{?\xc5\x13\xd1?\x82\xb7j?\x16\xdc]?\xddy\'@\xd1h&@\xa8\xdf}@\xeb.b?E\xaf\x8a?\xec>s?\xa8\xc1\x9b?k\xd1\x8c?\xf4\xfc]?$\xa6Y?2\xad\xea?\xc5\xd8L?m\xf2\xae?\x80\xeb]?\x01J\xe4?\xa3\x12\x11@/}\xb7?.\x03\x00@G\xb1\xaa?\xee\'\x82?*|\x97?\'\xe0\x1d@(~w?g3\xc2?{\x9f\x99?\xc7h\xa6?\xa9sf?\nJ\xa4?C\xe1]?\x85\xd1\xcc?\x81Y\x95?\xda\xc1{?\xec%\xa2?3\xa0\x99?V\x02 @w(\x82?\x029\x93?e\x18Q?\x00Ib?\xf9\xfbn?\xff\xafj?\xf1!\x92@s\x8e\x88?_\xd3\xac?\xc8\xdfm@%\xd9L?\x8a;s?\xeb\xc1\xbb?\x13\x06\xc0?\x04\xe9]?\x11m\x86?\xa6\x7fw?|\xeb]?^\xa4Y?\xf1\x03^?\x83\x96H?$X\x95?z\x03\x80?9\x89\x18@s\xde\xcc?\th&@bRD?\xe7\xf4\xee?\xd2D\xa4?\xfd\x8f\xc8?\\\x82w?\x82\x14\x91?\xae\xc7{?\x8a43@r5Q?\xf5j\x86?;\x07@?\xc5G\x84?L\xe9]?\xd8~\x07@o(\xa2?\x06\x0b@?\x02\xb2{?\x8aY\xb5?\xe1\x8e\x88?\x88%\xa2?\x0f\xf5\x8e?59\x93?+93?\x1c\xcbj?6\xf1\x8e?0\x84w?\x7f\x83w?\x96|\xd7?\x9d\x9a\xa8?\x8f$\x82?"\xc1j?\xd6\xd2\x8c?g\x17\x91?\xa4D\x93?\x17\xf1\x8e?.\xa0Y?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg34
g9118
(g9119
g92
g9120
S'b'
tRp9406
(I1
(I200
I1
tg9244
I00
S'8\xb0\xb7\x04\x10\xb7\xb7\x04\xf8 \xf1\x04\xb8\'\xf1\x04\x98&\xf1\x04P \xf1\x04\xe0&\xf1\x04 /\xf1\x04\xa0*\xf1\x04\x90"\xf1\x04@\'\xf1\x04@$\xf1\x04\xd0\'\xf1\x04\x00+\xf1\x04\x80,\xf1\x04X$\xf1\x04P/\xf1\x04\xd8(\xf1\x040%\xf1\x048,\xf1\x04\xc8 \xf1\x04\x10*\xf1\x04\x10!\xf1\x048)\xf1\x04\xa8"\xf1\x04h)\xf1\x04\xe8$\xf1\x04\xf0"\xf1\x04\xa0!\xf1\x04\x90+\xf1\x04X-\xf1\x04\x00%\xf1\x04\xe0/\xf1\x04\x18.\xf1\x04\x88*\xf1\x04\xc8/\xf1\x04\xf8#\xf1\x04\xe0 \xf1\x048#\xf1\x040.\xf1\x04(*\xf1\x04@*\xf1\x04\xf0(\xf1\x04\x80&\xf1\x040+\xf1\x04X*\xf1\x04\x80 \xf1\x04\xd0*\xf1\x04\xb0 \xf1\x04\xb8!\xf1\x04\x90(\xf1\x04\x98,\xf1\x04\x88\'\xf1\x04\xb8-\xf1\x04\xf0+\xf1\x040(\xf1\x04`+\xf1\x04X!\xf1\x04\xd0-\xf1\x04(!\xf1\x04h#\xf1\x04\xe0)\xf1\x04\x00(\xf1\x04`%\xf1\x04\xb0&\xf1\x04\x98 \xf1\x04\x90.\xf1\x04\xe0#\xf1\x04\x80)\xf1\x04x.\xf1\x04\xd0$\xf1\x04p\'\xf1\x04\xe0,\xf1\x04\xb0/\xf1\x04H.\xf1\x04H%\xf1\x04\xf0.\xf1\x04\xc0"\xf1\x04\xc0+\xf1\x04p$\xf1\x04\xc8)\xf1\x048/\xf1\x04h,\xf1\x04H+\xf1\x04($\xf1\x04\xf8&\xf1\x04P&\xf1\x04\xc0.\xf1\x04X\'\xf1\x04p-\xf1\x04 #\xf1\x04P#\xf1\x04\xa0\'\xf1\x04\xd8.\xf1\x04h&\xf1\x04\xa8+\xf1\x04x(\xf1\x04 )\xf1\x04\xf8,\xf1\x04(-\xf1\x04\xe8!\xf1\x04\xb0,\xf1\x04p*\xf1\x04H"\xf1\x04 ,\xf1\x04\xa8(\xf1\x04\x08)\xf1\x04\xb0#\xf1\x04\xa0-\xf1\x04\xa8.\xf1\x04\x88!\xf1\x04\x18"\xf1\x04P,\xf1\x04\x10-\xf1\x04\x08,\xf1\x04\xd0!\xf1\x04`.\xf1\x04\xe8\'\xf1\x04\xd8+\xf1\x04h/\xf1\x04h \xf1\x04\x80/\xf1\x04\x98)\xf1\x04x"\xf1\x04\xc8,\xf1\x04\xc0(\xf1\x04\x88-\xf1\x04\xe8*\xf1\x04  \xf1\x04\x18%\xf1\x04`(\xf1\x04(\'\xf1\x04\x80#\xf1\x04\x08#\xf1\x04\x98/\xf1\x04\x10$\xf1\x04H(\xf1\x04\x08/\xf1\x04\xf8)\xf1\x04\xe0\xdc\xf1\x04\xf8\xc0\xb7\x04\x98\xcf\xb7\x04P\xc9\xb7\x04\x10\xc7\xb7\x04\x18\xce\xb7\x04\xf0\xc8\xb7\x04@\xc7\xb7\x04\x80\xcf\xb7\x048\xc9\xb7\x04P\xc6\xb7\x04\xb8\xc4\xb7\x04\xc0\xce\xb7\x04\x08\xc9\xb7\x04\x00\xce\xb7\x04\x98\xc3\xb7\x04P\xcf\xb7\x04 \xc9\xb7\x04\xb0\xc3\xb7\x04 \xcf\xb7\x04\xd8\xc2\xb7\x04\xf8\xc3\xb7\x04\xa0\xc1\xb7\x04\xa8\xc8\xb7\x048\xc6\xb7\x04\x80\xc6\xb7\x04(\xca\xb7\x04\x10\xcd\xb7\x04\xd0\xcd\xb7\x04H\xc5\xb7\x04\x88\xca\xb7\x04h\xcf\xb7\x04@\xca\xb7\x04\xe8\xcd\xb7\x048\xc0\xb7\x04\xa0\xca\xb7\x04\xa8\xc2\xb7\x04X\xca\xb7\x04p\xca\xb7\x04\xb8\xc1\xb7\x04x\xce\xb7\x04 \xc0\xb7\x04\xb0\xcf\xb7\x04p\xc7\xb7\x04\x90\xc8\xb7\x04\xb8\xc7\xb7\x04`\xc5\xb7\x04\x80\xc0\xb7\x04@\xcd\xb7\x040\xc8\xb7\x04\xe0\xcc\xb7\x04\x18\xc2\xb7\x04\x08\xc6\xb7\x04\x00.\xf1\x04`"\xf1\x04x+\xf1\x04\x88$\xf1\x04\xb8*\xf1\x04\x00"\xf1\x040"\xf1\x04\xc8&\xf1\x04'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp9407
(dp9408
g9130
(dp9409
g9117
I01
sg38
I00
sg33
I00
sg9125
I01
sg39
I01
sg34
I00
ssg9132
g9395
sg9133
(lp9410
g9117
ag9125
ag38
ag39
ag33
ag34
asg9135
(lp9411
I200
aI1
asbsg9137
g9252
sg9139
g91
(g92
(I0
tS'b'
tRp9412
(I1
(I200
I1
tg98
I00
S'\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00\x04\x00\x00\x00\x05\x00\x00\x00\x06\x00\x00\x00\x07\x00\x00\x00\x08\x00\x00\x00\t\x00\x00\x00\n\x00\x00\x00\x0b\x00\x00\x00\x0c\x00\x00\x00\r\x00\x00\x00\x0e\x00\x00\x00\x0f\x00\x00\x00\x10\x00\x00\x00\x11\x00\x00\x00\x12\x00\x00\x00\x13\x00\x00\x00\x14\x00\x00\x00\x15\x00\x00\x00\x16\x00\x00\x00\x17\x00\x00\x00\x18\x00\x00\x00\x19\x00\x00\x00\x1a\x00\x00\x00\x1b\x00\x00\x00\x1c\x00\x00\x00\x1d\x00\x00\x00\x1e\x00\x00\x00\x1f\x00\x00\x00 \x00\x00\x00!\x00\x00\x00"\x00\x00\x00#\x00\x00\x00$\x00\x00\x00%\x00\x00\x00&\x00\x00\x00\'\x00\x00\x00(\x00\x00\x00)\x00\x00\x00*\x00\x00\x00+\x00\x00\x00,\x00\x00\x00-\x00\x00\x00.\x00\x00\x00/\x00\x00\x000\x00\x00\x001\x00\x00\x002\x00\x00\x003\x00\x00\x004\x00\x00\x005\x00\x00\x006\x00\x00\x007\x00\x00\x008\x00\x00\x009\x00\x00\x00:\x00\x00\x00;\x00\x00\x00<\x00\x00\x00=\x00\x00\x00>\x00\x00\x00?\x00\x00\x00@\x00\x00\x00A\x00\x00\x00B\x00\x00\x00C\x00\x00\x00D\x00\x00\x00E\x00\x00\x00F\x00\x00\x00G\x00\x00\x00H\x00\x00\x00I\x00\x00\x00J\x00\x00\x00K\x00\x00\x00L\x00\x00\x00M\x00\x00\x00N\x00\x00\x00O\x00\x00\x00P\x00\x00\x00Q\x00\x00\x00R\x00\x00\x00S\x00\x00\x00T\x00\x00\x00U\x00\x00\x00V\x00\x00\x00W\x00\x00\x00X\x00\x00\x00Y\x00\x00\x00Z\x00\x00\x00[\x00\x00\x00\\\x00\x00\x00]\x00\x00\x00^\x00\x00\x00_\x00\x00\x00`\x00\x00\x00a\x00\x00\x00b\x00\x00\x00c\x00\x00\x00d\x00\x00\x00e\x00\x00\x00f\x00\x00\x00g\x00\x00\x00h\x00\x00\x00i\x00\x00\x00j\x00\x00\x00k\x00\x00\x00l\x00\x00\x00m\x00\x00\x00n\x00\x00\x00o\x00\x00\x00p\x00\x00\x00q\x00\x00\x00r\x00\x00\x00s\x00\x00\x00t\x00\x00\x00u\x00\x00\x00v\x00\x00\x00w\x00\x00\x00x\x00\x00\x00y\x00\x00\x00z\x00\x00\x00{\x00\x00\x00|\x00\x00\x00}\x00\x00\x00~\x00\x00\x00\x7f\x00\x00\x00\x80\x00\x00\x00\x81\x00\x00\x00\x82\x00\x00\x00\x83\x00\x00\x00\x84\x00\x00\x00\x85\x00\x00\x00\x86\x00\x00\x00\x87\x00\x00\x00\x88\x00\x00\x00\x89\x00\x00\x00\x8a\x00\x00\x00\x8b\x00\x00\x00\x8c\x00\x00\x00\x8d\x00\x00\x00\x8e\x00\x00\x00\x8f\x00\x00\x00\x90\x00\x00\x00\x91\x00\x00\x00\x92\x00\x00\x00\x93\x00\x00\x00\x94\x00\x00\x00\x95\x00\x00\x00\x96\x00\x00\x00\x97\x00\x00\x00\x98\x00\x00\x00\x99\x00\x00\x00\x9a\x00\x00\x00\x9b\x00\x00\x00\x9c\x00\x00\x00\x9d\x00\x00\x00\x9e\x00\x00\x00\x9f\x00\x00\x00\xa0\x00\x00\x00\xa1\x00\x00\x00\xa2\x00\x00\x00\xa3\x00\x00\x00\xa4\x00\x00\x00\xa5\x00\x00\x00\xa6\x00\x00\x00\xa7\x00\x00\x00\xa8\x00\x00\x00\xa9\x00\x00\x00\xaa\x00\x00\x00\xab\x00\x00\x00\xac\x00\x00\x00\xad\x00\x00\x00\xae\x00\x00\x00\xaf\x00\x00\x00\xb0\x00\x00\x00\xb1\x00\x00\x00\xb2\x00\x00\x00\xb3\x00\x00\x00\xb4\x00\x00\x00\xb5\x00\x00\x00\xb6\x00\x00\x00\xb7\x00\x00\x00\xb8\x00\x00\x00\xb9\x00\x00\x00\xba\x00\x00\x00\xbb\x00\x00\x00\xbc\x00\x00\x00\xbd\x00\x00\x00\xbe\x00\x00\x00\xbf\x00\x00\x00\xc0\x00\x00\x00\xc1\x00\x00\x00\xc2\x00\x00\x00\xc3\x00\x00\x00\xc4\x00\x00\x00\xc5\x00\x00\x00\xc6\x00\x00\x00\xc7\x00\x00\x00'
tbsg9141
I01
sg9142
I1
sg9143
I-1
sg9144
(lp9413
g1
(g9146
g9115
(dp9414
g906
g899
sg894
g895
sg908
g909
sg903
g904
stRp9415
ag1
(g9146
g9115
(dp9416
g906
g919
sg894
g915
sg908
g926
sg903
g923
stRp9417
ag1
(g9146
g9115
(dp9418
g906
g936
sg894
g932
sg908
g943
sg903
g940
stRp9419
ag1
(g9146
g9115
(dp9420
g906
g953
sg894
g949
sg908
g960
sg903
g957
stRp9421
ag1
(g9146
g9115
(dp9422
g906
g976
sg894
g966
sg908
g970
sg903
g974
stRp9423
ag1
(g9146
g9115
(dp9424
g906
g953
sg894
g949
sg908
g960
sg903
g957
stRp9425
ag1
(g9146
g9115
(dp9426
g906
g1006
sg894
g996
sg908
g1000
sg903
g1004
stRp9427
ag1
(g9146
g9115
(dp9428
g906
g1017
sg894
g1013
sg908
g1024
sg903
g1021
stRp9429
ag1
(g9146
g9115
(dp9430
g906
g1034
sg894
g1030
sg908
g1041
sg903
g1038
stRp9431
ag1
(g9146
g9115
(dp9432
g906
g1051
sg894
g1047
sg908
g1058
sg903
g1055
stRp9433
ag1
(g9146
g9115
(dp9434
g906
g919
sg894
g915
sg908
g926
sg903
g923
stRp9435
ag1
(g9146
g9115
(dp9436
g906
g976
sg894
g1077
sg908
g970
sg903
g1084
stRp9437
ag1
(g9146
g9115
(dp9438
g906
g1096
sg894
g1092
sg908
g1103
sg903
g1100
stRp9439
ag1
(g9146
g9115
(dp9440
g906
g1051
sg894
g1109
sg908
g1058
sg903
g1116
stRp9441
ag1
(g9146
g9115
(dp9442
g906
g1134
sg894
g1124
sg908
g1128
sg903
g1132
stRp9443
ag1
(g9146
g9115
(dp9444
g906
g1006
sg894
g1141
sg908
g1000
sg903
g1148
stRp9445
ag1
(g9146
g9115
(dp9446
g906
g1160
sg894
g1156
sg908
g1167
sg903
g1164
stRp9447
ag1
(g9146
g9115
(dp9448
g906
g1096
sg894
g1173
sg908
g1103
sg903
g1180
stRp9449
ag1
(g9146
g9115
(dp9450
g906
g1198
sg894
g1188
sg908
g1192
sg903
g1196
stRp9451
ag1
(g9146
g9115
(dp9452
g906
g1096
sg894
g1092
sg908
g1103
sg903
g1100
stRp9453
ag1
(g9146
g9115
(dp9454
g906
g1222
sg894
g1218
sg908
g1229
sg903
g1226
stRp9455
ag1
(g9146
g9115
(dp9456
g906
g1239
sg894
g1235
sg908
g1246
sg903
g1243
stRp9457
ag1
(g9146
g9115
(dp9458
g906
g976
sg894
g1077
sg908
g970
sg903
g1084
stRp9459
ag1
(g9146
g9115
(dp9460
g906
g1269
sg894
g1265
sg908
g1276
sg903
g1273
stRp9461
ag1
(g9146
g9115
(dp9462
g906
g936
sg894
g1282
sg908
g943
sg903
g1289
stRp9463
ag1
(g9146
g9115
(dp9464
g906
g1239
sg894
g1297
sg908
g1246
sg903
g1304
stRp9465
ag1
(g9146
g9115
(dp9466
g906
g1017
sg894
g1312
sg908
g1024
sg903
g1319
stRp9467
ag1
(g9146
g9115
(dp9468
g906
g1331
sg894
g1327
sg908
g1338
sg903
g1335
stRp9469
ag1
(g9146
g9115
(dp9470
g906
g1051
sg894
g1109
sg908
g1058
sg903
g1116
stRp9471
ag1
(g9146
g9115
(dp9472
g906
g976
sg894
g1077
sg908
g970
sg903
g1084
stRp9473
ag1
(g9146
g9115
(dp9474
g906
g1239
sg894
g1297
sg908
g1246
sg903
g1304
stRp9475
ag1
(g9146
g9115
(dp9476
g906
g1387
sg894
g1383
sg908
g1394
sg903
g1391
stRp9477
ag1
(g9146
g9115
(dp9478
g906
g1331
sg894
g1400
sg908
g1338
sg903
g1407
stRp9479
ag1
(g9146
g9115
(dp9480
g906
g1269
sg894
g1415
sg908
g1276
sg903
g1422
stRp9481
ag1
(g9146
g9115
(dp9482
g906
g1006
sg894
g996
sg908
g1000
sg903
g1004
stRp9483
ag1
(g9146
g9115
(dp9484
g906
g1160
sg894
g1156
sg908
g1167
sg903
g1164
stRp9485
ag1
(g9146
g9115
(dp9486
g906
g1222
sg894
g1218
sg908
g1229
sg903
g1226
stRp9487
ag1
(g9146
g9115
(dp9488
g906
g1269
sg894
g1415
sg908
g1276
sg903
g1422
stRp9489
ag1
(g9146
g9115
(dp9490
g906
g1222
sg894
g1218
sg908
g1229
sg903
g1226
stRp9491
ag1
(g9146
g9115
(dp9492
g906
g1198
sg894
g1495
sg908
g1192
sg903
g1502
stRp9493
ag1
(g9146
g9115
(dp9494
g906
g1239
sg894
g1235
sg908
g1246
sg903
g1243
stRp9495
ag1
(g9146
g9115
(dp9496
g906
g1331
sg894
g1327
sg908
g1338
sg903
g1335
stRp9497
ag1
(g9146
g9115
(dp9498
g906
g1540
sg894
g1536
sg908
g1547
sg903
g1544
stRp9499
ag1
(g9146
g9115
(dp9500
g906
g919
sg894
g1553
sg908
g926
sg903
g1560
stRp9501
ag1
(g9146
g9115
(dp9502
g906
g1331
sg894
g1400
sg908
g1338
sg903
g1407
stRp9503
ag1
(g9146
g9115
(dp9504
g906
g899
sg894
g1581
sg908
g909
sg903
g1588
stRp9505
ag1
(g9146
g9115
(dp9506
g906
g1160
sg894
g1596
sg908
g1167
sg903
g1603
stRp9507
ag1
(g9146
g9115
(dp9508
g906
g953
sg894
g1611
sg908
g960
sg903
g1618
stRp9509
ag1
(g9146
g9115
(dp9510
g906
g919
sg894
g915
sg908
g926
sg903
g923
stRp9511
ag1
(g9146
g9115
(dp9512
g906
g1017
sg894
g1013
sg908
g1024
sg903
g1021
stRp9513
ag1
(g9146
g9115
(dp9514
g906
g1006
sg894
g1141
sg908
g1000
sg903
g1148
stRp9515
ag1
(g9146
g9115
(dp9516
g906
g1034
sg894
g1030
sg908
g1041
sg903
g1038
stRp9517
ag1
(g9146
g9115
(dp9518
g906
g1688
sg894
g1678
sg908
g1682
sg903
g1686
stRp9519
ag1
(g9146
g9115
(dp9520
g906
g1051
sg894
g1047
sg908
g1058
sg903
g1055
stRp9521
ag1
(g9146
g9115
(dp9522
g906
g1006
sg894
g1141
sg908
g1000
sg903
g1148
stRp9523
ag1
(g9146
g9115
(dp9524
g906
g1387
sg894
g1383
sg908
g1394
sg903
g1391
stRp9525
ag1
(g9146
g9115
(dp9526
g906
g899
sg894
g895
sg908
g909
sg903
g904
stRp9527
ag1
(g9146
g9115
(dp9528
g906
g1051
sg894
g1047
sg908
g1058
sg903
g1055
stRp9529
ag1
(g9146
g9115
(dp9530
g906
g1096
sg894
g1092
sg908
g1103
sg903
g1100
stRp9531
ag1
(g9146
g9115
(dp9532
g906
g936
sg894
g932
sg908
g943
sg903
g940
stRp9533
ag1
(g9146
g9115
(dp9534
g906
g1160
sg894
g1596
sg908
g1167
sg903
g1603
stRp9535
ag1
(g9146
g9115
(dp9536
g906
g899
sg894
g1581
sg908
g909
sg903
g1588
stRp9537
ag1
(g9146
g9115
(dp9538
g906
g1198
sg894
g1188
sg908
g1192
sg903
g1196
stRp9539
ag1
(g9146
g9115
(dp9540
g906
g1239
sg894
g1235
sg908
g1246
sg903
g1243
stRp9541
ag1
(g9146
g9115
(dp9542
g906
g953
sg894
g949
sg908
g960
sg903
g957
stRp9543
ag1
(g9146
g9115
(dp9544
g906
g1331
sg894
g1327
sg908
g1338
sg903
g1335
stRp9545
ag1
(g9146
g9115
(dp9546
g906
g936
sg894
g1282
sg908
g943
sg903
g1289
stRp9547
ag1
(g9146
g9115
(dp9548
g906
g1688
sg894
g1877
sg908
g1682
sg903
g1884
stRp9549
ag1
(g9146
g9115
(dp9550
g906
g1134
sg894
g1892
sg908
g1128
sg903
g1899
stRp9551
ag1
(g9146
g9115
(dp9552
g906
g1051
sg894
g1109
sg908
g1058
sg903
g1116
stRp9553
ag1
(g9146
g9115
(dp9554
g906
g976
sg894
g966
sg908
g970
sg903
g974
stRp9555
ag1
(g9146
g9115
(dp9556
g906
g1134
sg894
g1124
sg908
g1128
sg903
g1132
stRp9557
ag1
(g9146
g9115
(dp9558
g906
g1198
sg894
g1495
sg908
g1192
sg903
g1502
stRp9559
ag1
(g9146
g9115
(dp9560
g906
g1160
sg894
g1596
sg908
g1167
sg903
g1603
stRp9561
ag1
(g9146
g9115
(dp9562
g906
g1540
sg894
g1972
sg908
g1547
sg903
g1979
stRp9563
ag1
(g9146
g9115
(dp9564
g906
g899
sg894
g895
sg908
g909
sg903
g904
stRp9565
ag1
(g9146
g9115
(dp9566
g906
g1160
sg894
g1596
sg908
g1167
sg903
g1603
stRp9567
ag1
(g9146
g9115
(dp9568
g906
g936
sg894
g932
sg908
g943
sg903
g940
stRp9569
ag1
(g9146
g9115
(dp9570
g906
g1134
sg894
g1124
sg908
g1128
sg903
g1132
stRp9571
ag1
(g9146
g9115
(dp9572
g906
g919
sg894
g1553
sg908
g926
sg903
g1560
stRp9573
ag1
(g9146
g9115
(dp9574
g906
g976
sg894
g1077
sg908
g970
sg903
g1084
stRp9575
ag1
(g9146
g9115
(dp9576
g906
g1387
sg894
g2065
sg908
g1394
sg903
g2072
stRp9577
ag1
(g9146
g9115
(dp9578
g906
g1096
sg894
g1173
sg908
g1103
sg903
g1180
stRp9579
ag1
(g9146
g9115
(dp9580
g906
g1540
sg894
g1536
sg908
g1547
sg903
g1544
stRp9581
ag1
(g9146
g9115
(dp9582
g906
g936
sg894
g1282
sg908
g943
sg903
g1289
stRp9583
ag1
(g9146
g9115
(dp9584
g906
g1688
sg894
g1877
sg908
g1682
sg903
g1884
stRp9585
ag1
(g9146
g9115
(dp9586
g906
g1239
sg894
g1235
sg908
g1246
sg903
g1243
stRp9587
ag1
(g9146
g9115
(dp9588
g906
g1540
sg894
g1536
sg908
g1547
sg903
g1544
stRp9589
ag1
(g9146
g9115
(dp9590
g906
g919
sg894
g1553
sg908
g926
sg903
g1560
stRp9591
ag1
(g9146
g9115
(dp9592
g906
g936
sg894
g1282
sg908
g943
sg903
g1289
stRp9593
ag1
(g9146
g9115
(dp9594
g906
g1006
sg894
g1141
sg908
g1000
sg903
g1148
stRp9595
ag1
(g9146
g9115
(dp9596
g906
g1387
sg894
g2065
sg908
g1394
sg903
g2072
stRp9597
ag1
(g9146
g9115
(dp9598
g906
g919
sg894
g915
sg908
g926
sg903
g923
stRp9599
ag1
(g9146
g9115
(dp9600
g906
g1160
sg894
g1156
sg908
g1167
sg903
g1164
stRp9601
ag1
(g9146
g9115
(dp9602
g906
g1134
sg894
g1892
sg908
g1128
sg903
g1899
stRp9603
ag1
(g9146
g9115
(dp9604
g906
g1688
sg894
g1678
sg908
g1682
sg903
g1686
stRp9605
ag1
(g9146
g9115
(dp9606
g906
g1387
sg894
g2065
sg908
g1394
sg903
g2072
stRp9607
ag1
(g9146
g9115
(dp9608
g906
g953
sg894
g949
sg908
g960
sg903
g957
stRp9609
ag1
(g9146
g9115
(dp9610
g906
g1160
sg894
g1156
sg908
g1167
sg903
g1164
stRp9611
ag1
(g9146
g9115
(dp9612
g906
g1222
sg894
g1218
sg908
g1229
sg903
g1226
stRp9613
ag1
(g9146
g9115
(dp9614
g906
g1331
sg894
g1327
sg908
g1338
sg903
g1335
stRp9615
ag1
(g9146
g9115
(dp9616
g906
g1134
sg894
g1124
sg908
g1128
sg903
g1132
stRp9617
ag1
(g9146
g9115
(dp9618
g906
g1239
sg894
g1297
sg908
g1246
sg903
g1304
stRp9619
ag1
(g9146
g9115
(dp9620
g906
g1160
sg894
g1596
sg908
g1167
sg903
g1603
stRp9621
ag1
(g9146
g9115
(dp9622
g906
g1331
sg894
g1400
sg908
g1338
sg903
g1407
stRp9623
ag1
(g9146
g9115
(dp9624
g906
g1269
sg894
g1415
sg908
g1276
sg903
g1422
stRp9625
ag1
(g9146
g9115
(dp9626
g906
g1198
sg894
g1188
sg908
g1192
sg903
g1196
stRp9627
ag1
(g9146
g9115
(dp9628
g906
g1387
sg894
g2065
sg908
g1394
sg903
g2072
stRp9629
ag1
(g9146
g9115
(dp9630
g906
g953
sg894
g949
sg908
g960
sg903
g957
stRp9631
ag1
(g9146
g9115
(dp9632
g906
g1051
sg894
g1047
sg908
g1058
sg903
g1055
stRp9633
ag1
(g9146
g9115
(dp9634
g906
g1034
sg894
g2444
sg908
g1041
sg903
g2451
stRp9635
ag1
(g9146
g9115
(dp9636
g906
g1096
sg894
g1173
sg908
g1103
sg903
g1180
stRp9637
ag1
(g9146
g9115
(dp9638
g906
g1387
sg894
g1383
sg908
g1394
sg903
g1391
stRp9639
ag1
(g9146
g9115
(dp9640
g906
g976
sg894
g966
sg908
g970
sg903
g974
stRp9641
ag1
(g9146
g9115
(dp9642
g906
g1387
sg894
g1383
sg908
g1394
sg903
g1391
stRp9643
ag1
(g9146
g9115
(dp9644
g906
g1222
sg894
g2511
sg908
g1229
sg903
g2518
stRp9645
ag1
(g9146
g9115
(dp9646
g906
g1134
sg894
g1892
sg908
g1128
sg903
g1899
stRp9647
ag1
(g9146
g9115
(dp9648
g906
g1034
sg894
g1030
sg908
g1041
sg903
g1038
stRp9649
ag1
(g9146
g9115
(dp9650
g906
g1006
sg894
g1141
sg908
g1000
sg903
g1148
stRp9651
ag1
(g9146
g9115
(dp9652
g906
g1034
sg894
g1030
sg908
g1041
sg903
g1038
stRp9653
ag1
(g9146
g9115
(dp9654
g906
g1688
sg894
g1678
sg908
g1682
sg903
g1686
stRp9655
ag1
(g9146
g9115
(dp9656
g906
g976
sg894
g966
sg908
g970
sg903
g974
stRp9657
ag1
(g9146
g9115
(dp9658
g906
g899
sg894
g1581
sg908
g909
sg903
g1588
stRp9659
ag1
(g9146
g9115
(dp9660
g906
g1269
sg894
g1265
sg908
g1276
sg903
g1273
stRp9661
ag1
(g9146
g9115
(dp9662
g906
g953
sg894
g1611
sg908
g960
sg903
g1618
stRp9663
ag1
(g9146
g9115
(dp9664
g906
g936
sg894
g932
sg908
g943
sg903
g940
stRp9665
ag1
(g9146
g9115
(dp9666
g906
g1198
sg894
g1495
sg908
g1192
sg903
g1502
stRp9667
ag1
(g9146
g9115
(dp9668
g906
g1331
sg894
g1400
sg908
g1338
sg903
g1407
stRp9669
ag1
(g9146
g9115
(dp9670
g906
g1269
sg894
g1415
sg908
g1276
sg903
g1422
stRp9671
ag1
(g9146
g9115
(dp9672
g906
g1134
sg894
g1892
sg908
g1128
sg903
g1899
stRp9673
ag1
(g9146
g9115
(dp9674
g906
g1331
sg894
g1400
sg908
g1338
sg903
g1407
stRp9675
ag1
(g9146
g9115
(dp9676
g906
g1239
sg894
g1297
sg908
g1246
sg903
g1304
stRp9677
ag1
(g9146
g9115
(dp9678
g906
g1017
sg894
g1312
sg908
g1024
sg903
g1319
stRp9679
ag1
(g9146
g9115
(dp9680
g906
g976
sg894
g966
sg908
g970
sg903
g974
stRp9681
ag1
(g9146
g9115
(dp9682
g906
g953
sg894
g1611
sg908
g960
sg903
g1618
stRp9683
ag1
(g9146
g9115
(dp9684
g906
g1096
sg894
g1173
sg908
g1103
sg903
g1180
stRp9685
ag1
(g9146
g9115
(dp9686
g906
g1688
sg894
g1877
sg908
g1682
sg903
g1884
stRp9687
ag1
(g9146
g9115
(dp9688
g906
g1051
sg894
g1109
sg908
g1058
sg903
g1116
stRp9689
ag1
(g9146
g9115
(dp9690
g906
g1017
sg894
g1013
sg908
g1024
sg903
g1021
stRp9691
ag1
(g9146
g9115
(dp9692
g906
g1034
sg894
g2444
sg908
g1041
sg903
g2451
stRp9693
ag1
(g9146
g9115
(dp9694
g906
g899
sg894
g1581
sg908
g909
sg903
g1588
stRp9695
ag1
(g9146
g9115
(dp9696
g906
g1222
sg894
g2511
sg908
g1229
sg903
g2518
stRp9697
ag1
(g9146
g9115
(dp9698
g906
g1017
sg894
g1013
sg908
g1024
sg903
g1021
stRp9699
ag1
(g9146
g9115
(dp9700
g906
g1096
sg894
g1092
sg908
g1103
sg903
g1100
stRp9701
ag1
(g9146
g9115
(dp9702
g906
g919
sg894
g1553
sg908
g926
sg903
g1560
stRp9703
ag1
(g9146
g9115
(dp9704
g906
g953
sg894
g1611
sg908
g960
sg903
g1618
stRp9705
ag1
(g9146
g9115
(dp9706
g906
g919
sg894
g915
sg908
g926
sg903
g923
stRp9707
ag1
(g9146
g9115
(dp9708
g906
g1198
sg894
g1495
sg908
g1192
sg903
g1502
stRp9709
ag1
(g9146
g9115
(dp9710
g906
g1222
sg894
g2511
sg908
g1229
sg903
g2518
stRp9711
ag1
(g9146
g9115
(dp9712
g906
g1160
sg894
g1156
sg908
g1167
sg903
g1164
stRp9713
ag1
(g9146
g9115
(dp9714
g906
g1540
sg894
g1972
sg908
g1547
sg903
g1979
stRp9715
ag1
(g9146
g9115
(dp9716
g906
g1096
sg894
g1173
sg908
g1103
sg903
g1180
stRp9717
ag1
(g9146
g9115
(dp9718
g906
g1034
sg894
g2444
sg908
g1041
sg903
g2451
stRp9719
ag1
(g9146
g9115
(dp9720
g906
g1540
sg894
g1536
sg908
g1547
sg903
g1544
stRp9721
ag1
(g9146
g9115
(dp9722
g906
g1688
sg894
g1877
sg908
g1682
sg903
g1884
stRp9723
ag1
(g9146
g9115
(dp9724
g906
g1034
sg894
g2444
sg908
g1041
sg903
g2451
stRp9725
ag1
(g9146
g9115
(dp9726
g906
g1222
sg894
g2511
sg908
g1229
sg903
g2518
stRp9727
ag1
(g9146
g9115
(dp9728
g906
g1034
sg894
g1030
sg908
g1041
sg903
g1038
stRp9729
ag1
(g9146
g9115
(dp9730
g906
g1222
sg894
g1218
sg908
g1229
sg903
g1226
stRp9731
ag1
(g9146
g9115
(dp9732
g906
g1198
sg894
g1188
sg908
g1192
sg903
g1196
stRp9733
ag1
(g9146
g9115
(dp9734
g906
g936
sg894
g1282
sg908
g943
sg903
g1289
stRp9735
ag1
(g9146
g9115
(dp9736
g906
g1051
sg894
g1047
sg908
g1058
sg903
g1055
stRp9737
ag1
(g9146
g9115
(dp9738
g906
g1006
sg894
g996
sg908
g1000
sg903
g1004
stRp9739
ag1
(g9146
g9115
(dp9740
g906
g1269
sg894
g1415
sg908
g1276
sg903
g1422
stRp9741
ag1
(g9146
g9115
(dp9742
g906
g1034
sg894
g2444
sg908
g1041
sg903
g2451
stRp9743
ag1
(g9146
g9115
(dp9744
g906
g1051
sg894
g1109
sg908
g1058
sg903
g1116
stRp9745
ag1
(g9146
g9115
(dp9746
g906
g1269
sg894
g1265
sg908
g1276
sg903
g1273
stRp9747
ag1
(g9146
g9115
(dp9748
g906
g1239
sg894
g1235
sg908
g1246
sg903
g1243
stRp9749
ag1
(g9146
g9115
(dp9750
g906
g1017
sg894
g1312
sg908
g1024
sg903
g1319
stRp9751
ag1
(g9146
g9115
(dp9752
g906
g1540
sg894
g1536
sg908
g1547
sg903
g1544
stRp9753
ag1
(g9146
g9115
(dp9754
g906
g976
sg894
g1077
sg908
g970
sg903
g1084
stRp9755
ag1
(g9146
g9115
(dp9756
g906
g1269
sg894
g1265
sg908
g1276
sg903
g1273
stRp9757
ag1
(g9146
g9115
(dp9758
g906
g1017
sg894
g1312
sg908
g1024
sg903
g1319
stRp9759
ag1
(g9146
g9115
(dp9760
g906
g1387
sg894
g2065
sg908
g1394
sg903
g2072
stRp9761
ag1
(g9146
g9115
(dp9762
g906
g899
sg894
g1581
sg908
g909
sg903
g1588
stRp9763
ag1
(g9146
g9115
(dp9764
g906
g1387
sg894
g1383
sg908
g1394
sg903
g1391
stRp9765
ag1
(g9146
g9115
(dp9766
g906
g1134
sg894
g1892
sg908
g1128
sg903
g1899
stRp9767
ag1
(g9146
g9115
(dp9768
g906
g919
sg894
g1553
sg908
g926
sg903
g1560
stRp9769
ag1
(g9146
g9115
(dp9770
g906
g1017
sg894
g1013
sg908
g1024
sg903
g1021
stRp9771
ag1
(g9146
g9115
(dp9772
g906
g1134
sg894
g1124
sg908
g1128
sg903
g1132
stRp9773
ag1
(g9146
g9115
(dp9774
g906
g1239
sg894
g1297
sg908
g1246
sg903
g1304
stRp9775
ag1
(g9146
g9115
(dp9776
g906
g1540
sg894
g1972
sg908
g1547
sg903
g1979
stRp9777
ag1
(g9146
g9115
(dp9778
g906
g1688
sg894
g1678
sg908
g1682
sg903
g1686
stRp9779
ag1
(g9146
g9115
(dp9780
g906
g953
sg894
g1611
sg908
g960
sg903
g1618
stRp9781
ag1
(g9146
g9115
(dp9782
g906
g1269
sg894
g1265
sg908
g1276
sg903
g1273
stRp9783
ag1
(g9146
g9115
(dp9784
g906
g1331
sg894
g1327
sg908
g1338
sg903
g1335
stRp9785
ag1
(g9146
g9115
(dp9786
g906
g1222
sg894
g2511
sg908
g1229
sg903
g2518
stRp9787
ag1
(g9146
g9115
(dp9788
g906
g1017
sg894
g1312
sg908
g1024
sg903
g1319
stRp9789
ag1
(g9146
g9115
(dp9790
g906
g1540
sg894
g1972
sg908
g1547
sg903
g1979
stRp9791
ag1
(g9146
g9115
(dp9792
g906
g1006
sg894
g996
sg908
g1000
sg903
g1004
stRp9793
ag1
(g9146
g9115
(dp9794
g906
g936
sg894
g932
sg908
g943
sg903
g940
stRp9795
ag1
(g9146
g9115
(dp9796
g906
g1198
sg894
g1188
sg908
g1192
sg903
g1196
stRp9797
ag1
(g9146
g9115
(dp9798
g906
g1006
sg894
g996
sg908
g1000
sg903
g1004
stRp9799
ag1
(g9146
g9115
(dp9800
g906
g1688
sg894
g1678
sg908
g1682
sg903
g1686
stRp9801
ag1
(g9146
g9115
(dp9802
g906
g899
sg894
g895
sg908
g909
sg903
g904
stRp9803
ag1
(g9146
g9115
(dp9804
g906
g1198
sg894
g1495
sg908
g1192
sg903
g1502
stRp9805
ag1
(g9146
g9115
(dp9806
g906
g1688
sg894
g1877
sg908
g1682
sg903
g1884
stRp9807
ag1
(g9146
g9115
(dp9808
g906
g1540
sg894
g1972
sg908
g1547
sg903
g1979
stRp9809
ag1
(g9146
g9115
(dp9810
g906
g1096
sg894
g1092
sg908
g1103
sg903
g1100
stRp9811
ag1
(g9146
g9115
(dp9812
g906
g899
sg894
g895
sg908
g909
sg903
g904
stRp9813
asg9227
Nsg9228
g3609
sg9229
I200
sg9230
I0
sg9231
I200
sg9232
I01
sbag1
(g9102
g3
NtRp9814
(dp9815
g9105
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a\u000a######################## CITATIONS ########################## \u000a##### Binary choice, BDM, auction routines, and instructions are modified from:\u000a##### \u000a##### De Martino, B., Fleming, S. M., Garrett, N., & Dolan, R. J. (2012). Confidence in value-based choice. Nature Neuroscience, 16(1), 105-110. \u000a#####\u000a##### Food item images are original.\u000a\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.80.01), July 16, 2014, at 03:20\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things bdm STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000afrom pyglet.window import key # to detect key state, whether key is held down, to move slider on key hold\u000aimport pandas as pd\u000aimport datetime\u000afrom psychopy.iohub import launchHubServer\u000aimport pylink\u000a\u000a# Initialize IOHub for eye tracker\u000a# io=launchHubServer(iohub_config_name='iohub_config.yaml')\u000a# tracker = io.devices.tracker\u000a\u000a# Store info about the experiment session\u000aexpName = 'infer_design1_no_eyetracking'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u'', u'eye': u'', u'glasses': u'', u'contacts': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Setup filename for saving\u000afilename = 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# set up variable to track current state of key press, to move slider when keys held down\u000akeyState=key.KeyStateHandler()\u000a\u000a# Setup the Window\u000ascreenwidth = 1920\u000ascreenheight = 1080\u000awin = visual.Window(size=(screenwidth, screenheight), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color='black', colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000awin.winHandle.push_handlers(keyState)\u000a\u000a\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a\u000a######################## COMPONENTS ##########################\u000a\u000a# Set up directory path for stimuli. This avoids us having to put the entire image path in the conditions spreadsheet.\u000adir_path = 'stimuli/itempics/modified/small/'\u000a\u000a# Initialize components for Routine "instr_main"\u000ainstr_mainClock = core.Clock()\u000ainstr_main_txt = visual.TextStim(win=win, ori=0, name='instr_main_txt',\u000a    text=u'Welcome!\u005cn\u005cnPlease read the instructions carefully and get the experimenter when you\u005c're finished. Take as much time as you need.',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "instr_bdm"\u000ainstr_bdmClock = core.Clock()\u000ainstr_bdm_txt = visual.TextStim(win=win, ori=0, name='instr_bdm_txt',\u000a    text=u'The bidding task is about to begin. Use the LEFT and RIGHT arrow keys to move the cursor along the slider, then press the DOWN arrow to enter your bid.\u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "fixation"\u000afixationClock = core.Clock()\u000afixation_text = visual.TextStim(win=win, ori=0, name='fixation_text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "bdm"\u000abdmClock = core.Clock()\u000abdm_pic = visual.ImageStim(win=win, name='bdm_pic',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=0.0)\u000abdm_bid = visual.RatingScale(win=win, name='bdm_bid', marker=u'triangle', markerColor=u'orange', leftKeys=None, rightKeys=None,\u000a    size=1.0, pos=[0.0, -0.6], low=0, high=3, precision=100, labels=[u'\u005cxa30', u'\u005cxa33'],\u000a    scale=u'', markerStart=u'1.5', tickHeight=u'1', showAccept=False, acceptKeys=[u'down', u'return'])\u000a\u000a# Initialize components for Routine "instr_choice"\u000ainstr_choiceClock = core.Clock()\u000ainstr_choice_txt = visual.TextStim(win=win, ori=0, name='instr_choice_txt',\u000a    text=u'The choice task is about to begin. Choose your preferred item by pressing the LEFT or RIGHT arrow keys, then use the slider to indicate how confident you are that you made the best choice.\u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "choice"\u000achoiceClock = core.Clock()\u000achoice_pic_left = visual.ImageStim(win=win, name='choice_pic_left',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[-0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=0.0)\u000achoice_pic_right = visual.ImageStim(win=win, name='choice_pic_right',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=-1.0)\u000a\u000a# Initialize components for Routine "choice_selection"\u000achoice_selectionClock = core.Clock()\u000astar_left_selection = visual.TextStim(win=win, ori=0, name='star_left_selection',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[-0.5, -0.8], height=0.5, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=-2.0)\u000astar_right_selection = visual.TextStim(win=win, ori=0, name='star_right_selection',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[0.5, -0.8], height=0.5, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=-3.0)\u000a\u000a# Initialize components for Routine "confidence"\u000aconfidenceClock = core.Clock()\u000aconfidence_rating = visual.RatingScale(win=win, name='confidence_rating', marker=u'triangle', markerColor=u'orange', leftKeys=None, rightKeys=None,\u000a    size=1.0, pos=[0.0, 0.0], low=1, high=6, precision=20,\u000a    scale=u'', markerStart=u'3.5', tickHeight=u'1', showAccept=False, acceptKeys=[u'down', u'return'])\u000a\u000a# Initialize components for Routine "instr_infer_intro"\u000ainstr_infer_introClock = core.Clock()\u000ainstr_infer_intro_txt = visual.TextStim(win=win, ori=0, name='instr_infer_intro_txt',\u000a    text=u'Thanks! Now please get the experimenter, who will give you the instructions for the second part of the experiment. \u005cn\u005cnPlease read these instructions carefully and get the experimenter again when you\u005c're finished. Take as much time as you need.',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=1.5,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "instr_infer_practice"\u000ainstr_infer_practiceClock = core.Clock()\u000ainstr_infer_practice_txt = visual.TextStim(win=win, ori=0, name='instr_infer_practice_txt',\u000a    text=u'First, you\u005c'll do some practice trials. These are just for you to get used to the task; your responses won\u005c't count. \u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=1.5,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "instr_infer"\u000ainstr_inferClock = core.Clock()\u000ainstr_infer_txt = visual.TextStim(win=win, ori=0, name='instr_infer_txt',\u000a    text=u'Great! Now that you\u005c've done some practice trials, we\u005c're ready to start the real trials. Please call the experimenter into the room.',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=1.5,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "get_ready"\u000aget_readyClock = core.Clock()\u000aget_ready_text = visual.TextStim(win=win, ori=0, name='get_ready_text',\u000a    text=u'Get ready!',    font=u'Arial',\u000a    pos=[0, 0], height=0.12, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000aimg_left_infer = visual.ImageStim(win=win, name='img_left_infer',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[-0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=0.0)\u000aimg_right_infer = visual.ImageStim(win=win, name='img_right_infer',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=-1.0)\u000a\u000a# Initialize components for Routine "trial_post_response"\u000atrial_post_responseClock = core.Clock()\u000aselection_arrow_left = visual.TextStim(win=win, ori=0, name='selection_arrow_left',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[-0.5, -0.09], height=0.5, wrapWidth=None,\u000a    color=u'red', colorSpace=u'rgb', opacity=1,\u000a    depth=-2.0)\u000aselection_arrow_right = visual.TextStim(win=win, ori=0, name='selection_arrow_right',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[0.5, -0.09], height=0.5, wrapWidth=None,\u000a    color=u'red', colorSpace=u'rgb', opacity=1,\u000a    depth=-3.0)\u000afeedback_box_left = visual.Rect(win=win, name='feedback_box_left',\u000a    width=[0.9, 0.9][0], height=[0.9, 0.9][1],\u000a    ori=0, pos=[-0.5, 0],\u000a    lineWidth=5, lineColor=u'yellow', lineColorSpace=u'rgb',\u000a    fillColor=None, fillColorSpace=u'rgb',\u000a    opacity=1, depth=-4.0, interpolate=True)\u000afeedback_box_right = visual.Rect(win=win, name='feedback_box_right',\u000a    width=[0.9, 0.9][0], height=[0.9, 0.9][1],\u000a    ori=0, pos=[0.5, 0],\u000a    lineWidth=5, lineColor=u'yellow', lineColorSpace=u'rgb',\u000a    fillColor=None, fillColorSpace=u'rgb',\u000a    opacity=1, depth=-5.0, interpolate=True)\u000a\u000a# Initialize components for Routine "rest_prompt"\u000arest_promptClock = core.Clock()\u000arest_prompt_txt = visual.TextStim(win=win, ori=0, name='rest_prompt_txt',\u000a    text=u'Great! Now take a rest and press the space bar when you\u005cu2019re ready to begin the next block.',    font=u'Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create counters for the number of correct and incorrect guesses made by subjects to determine extra payment.\u000acorrect_counter = 0\u000aincorrect_counter = 0\u000a\u000a# Create list of lists to store binary choice and BDM data to generate food reward at the end of the experiment\u000aprefs = [['left', 'right', 'choice', 'bid']]\u000abids = [['item', 'bid']] # For the bids collected during the first BDM routine, at the beginning of the experiment\u000a\u000a### CHOICE & INFERENCE RANDOMIZATION ###\u000a\u000a# Define two functions to generate constrained pseudorandom sequences of item pair presentations for the binary choice and inference\u000a# parts of the task. The constraint ensures that the same pair of items does not appear twice in a row (flipped or not).\u000a# In the conditions spreadsheet that the item pairs are drawn from, the flipped version of the same item pair is 20\u000a# rows apart.\u000a\u000a# Binary choice randomization\u000adef genseq_choice():\u000a    done = False\u000a    while done==False:\u000a        counter = 0\u000a        ans = np.random.choice(40, 40, replace=False) # Generate a pseudorandom sequence of 40 numbers\u000a        for x in range(1,40):\u000a            if (ans[x]-ans[x-1]) % 20 == 0: # Is the difference between any sequential numbers divisible by 20?\u000a                counter += 1\u000a        if counter==0: # If not, end the loop and return the array\u000a            done = True\u000a            return ans\u000a        else: # If so, continue the loop and try again\u000a            done = False\u000a\u000a# Inference practice block randomization\u000adef genseq_infer_practice():\u000a    done = False\u000a    while done==False:\u000a        counter = 0\u000a        ans = np.random.choice(14, 14, replace=False) # Generate a pseudorandom sequence of 200 numbers\u000a        for x in range(1,14):\u000a            if (ans[x]-ans[x-1]) % 7 == 0: # Is the difference between any sequential numbers divisible by 20?\u000a                counter += 1\u000a        if counter==0: # If not, end the loop and return the array\u000a            done = True\u000a            return ans\u000a        else: # If so, continue the loop and try again\u000a            done = False\u000a\u000a# Inference randomization\u000adef genseq_infer():\u000a    done = False\u000a    while done==False:\u000a        counter = 0\u000a        ans = np.random.choice(200, 200, replace=False) # Generate a pseudorandom sequence of 200 numbers\u000a        for x in range(1,200):\u000a            if (ans[x]-ans[x-1]) % 20 == 0: # Is the difference between any sequential numbers divisible by 20?\u000a                counter += 1\u000a        if counter==0: # If not, end the loop and return the array\u000a            done = True\u000a            return ans\u000a        else: # If so, continue the loop and try again\u000a            done = False\u000a\u000a\u000a# Set independent sequences for each of the two choice blocks, the inference practice block, and the three inference rest blocks. Each rest block contains 10 presentations of\u000a# each pair.\u000a\u000achoiceseq = genseq_choice()\u000apracticeseq = genseq_infer_practice()\u000ablock1seq = genseq_infer()\u000ablock2seq = genseq_infer()\u000ablock3seq = genseq_infer()\u000a\u000a\u000a# Choose a pilot participant whose choices will form the basis of the learning task\u000apartners = ['P1','P2','P3','P4','P5','P6','P8','P9','P10','P11','P12'] # List of pilot participants, P7 excluded for perfectly inconsistent choices\u000apartner = np.random.choice(partners,1) # Choose one at random\u000apartner_file = 'conditions/choices/infer_design1_value_pairs_' + partner[0] + '.csv' # Path to that participant's choice data\u000a\u000a# Create separate CSV files, one for each choice, practice, and rest block, with the item pairs in the pseudorandomly generated order.\u000a# These CSV files will be used as PsychoPy's conditions spreadsheets and run sequentially in the choice, practice, and inference loops below.\u000a\u000a\u000achoicecond_src = pd.read_csv('conditions/choice_design1_binary.csv', index_col=None, header=0)\u000achoicecond = choicecond_src.copy()\u000afor x in range(40):\u000a    seq = choiceseq[x]\u000a    choicecond.iloc[x] = choicecond_src.iloc[seq]\u000achoicecond.to_csv(path_or_buf=filename+'_choicecond.csv', index=False)\u000a\u000apracticecond_src = pd.read_csv('conditions/choices/infer_design1_value_pairs_practice.csv', index_col=None, header=0)\u000apracticecond = practicecond_src.copy()\u000afor x in range(14):\u000a    seq = practiceseq[x]\u000a    practicecond.iloc[x] = practicecond_src.iloc[seq]\u000apracticecond.to_csv(path_or_buf=filename+'_practicecond.csv', index=False)\u000a\u000ablock1cond_src = pd.read_csv(partner_file, index_col=None, header=0)\u000ablock1cond = block1cond_src.copy()\u000afor x in range(200):\u000a    seq = block1seq[x]\u000a    block1cond.iloc[x] = block1cond_src.iloc[seq]\u000ablock1cond.to_csv(path_or_buf=filename+'_block1cond.csv', index=False)\u000a\u000ablock2cond_src = pd.read_csv(partner_file, index_col=None, header=0)\u000ablock2cond = block2cond_src.copy()\u000afor x in range(200):\u000a    seq = block2seq[x]\u000a    block2cond.iloc[x] = block2cond_src.iloc[seq]\u000ablock2cond.to_csv(path_or_buf=filename+'_block2cond.csv', index=False)\u000a\u000ablock3cond_src = pd.read_csv(partner_file, index_col=None, header=0)\u000ablock3cond = block3cond_src.copy()\u000afor x in range(200):\u000a    seq = block3seq[x]\u000a    block3cond.iloc[x] = block3cond_src.iloc[seq]\u000ablock3cond.to_csv(path_or_buf=filename+'_block3cond.csv', index=False)\u000a\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instr_main"-------\u000at = 0\u000ainstr_mainClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_main_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_main_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_mainComponents = []\u000ainstr_mainComponents.append(instr_main_txt)\u000ainstr_mainComponents.append(instr_main_resp)\u000afor thisComponent in instr_mainComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_main"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_mainClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_main_txt* updates\u000a    if t >= 0.0 and instr_main_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_main_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_main_txt.frameNStart = frameN  # exact frame index\u000a        instr_main_txt.setAutoDraw(True)\u000a    \u000a    # *instr_main_resp* updates\u000a    if t >= 5.0 and instr_main_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_main_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_main_resp.frameNStart = frameN  # exact frame index\u000a        instr_main_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_main_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_main_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_main_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_main_resp.rt = instr_main_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_mainComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_main"-------\u000afor thisComponent in instr_mainComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_main_resp.keys in ['', [], None]:  # No response was made\u000a   instr_main_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_main_resp.keys',instr_main_resp.keys)\u000aif instr_main_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_main_resp.rt', instr_main_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a\u000a#------Prepare to start Routine "instr_bdm"-------\u000at = 0\u000ainstr_bdmClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_bdm_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_bdm_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_bdmComponents = []\u000ainstr_bdmComponents.append(instr_bdm_txt)\u000ainstr_bdmComponents.append(instr_bdm_resp)\u000afor thisComponent in instr_bdmComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_bdm"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_bdmClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_bdm_txt* updates\u000a    if t >= 0.0 and instr_bdm_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_bdm_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_bdm_txt.frameNStart = frameN  # exact frame index\u000a        instr_bdm_txt.setAutoDraw(True)\u000a    \u000a    # *instr_bdm_resp* updates\u000a    if t >= 2.0 and instr_bdm_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_bdm_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_bdm_resp.frameNStart = frameN  # exact frame index\u000a        instr_bdm_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_bdm_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_bdm_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space', 's'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_bdm_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_bdm_resp.rt = instr_bdm_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_bdmComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_bdm"-------\u000afor thisComponent in instr_bdmComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_bdm_resp.keys in ['', [], None]:  # No response was made\u000a   instr_bdm_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_bdm_resp.keys',instr_bdm_resp.keys)\u000athisExp.addData('partnered_pilot_participant', partner)\u000aif instr_bdm_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_bdm_resp.rt', instr_bdm_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## BDM LOOP 1 ##########################\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000abdm_loop1 = data.TrialHandler(nReps=1, method=u'random', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'conditions/choice_design1_bdm.xlsx'),\u000a    seed=None, name='bdm_loop1')\u000athisExp.addLoop(bdm_loop1)  # add the loop to the experiment\u000athisbdm_loop1 = bdm_loop1.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisbdm_loop1.rgb)\u000aif thisbdm_loop1 != None:\u000a    for paramName in thisbdm_loop1.keys():\u000a        exec(paramName + '= thisbdm_loop1.' + paramName)\u000a\u000a# Check if the 'skip' key was pressed in the instructions routine; if so, end the loop and move on to the inference task\u000aif instr_bdm_resp.keys=='s':\u000a    bdm_loop1.finished = True\u000a\u000afor thisbdm_loop1 in bdm_loop1:\u000a    currentLoop = bdm_loop1\u000a    # abbreviate parameter names if possible (e.g. rgb = thisbdm_loop1.rgb)\u000a    if thisbdm_loop1 != None:\u000a        for paramName in thisbdm_loop1.keys():\u000a            exec(paramName + '= thisbdm_loop1.' + paramName)\u000a    \u000a    #------Prepare to start Routine "bdm"-------\u000a    t = 0\u000a    bdmClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    bdm_pic.setImage(dir_path+bdm_img)\u000a    bdm_bid.reset()\u000a    # jitter the starting position of the BDM scale from a uniform distribution between 1 and 2, rounded to the nearest decimal place\u000a    bdm_marker_start = float(np.round(np.random.uniform(1, 2, 1)[0], 1))\u000a    bdm_bid.setMarkerPos(bdm_marker_start)\u000a    # keep track of which components have finished\u000a    bdmComponents = []\u000a    bdmComponents.append(fixation_text)\u000a    bdmComponents.append(bdm_pic)\u000a    bdmComponents.append(bdm_bid)\u000a    for thisComponent in bdmComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "bdm"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = bdmClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation_text* updates\u000a        if t >= 0 and fixation_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation_text.tStart = t  # underestimates by a little under one frame\u000a            fixation_text.frameNStart = frameN  # exact frame index\u000a            fixation_text.setAutoDraw(True)\u000a        elif fixation_text.status == STARTED and t>= (0 + (1.0-win.monitorFramePeriod*0.75)):\u000a            fixation_text.setAutoDraw(False)\u000a\u000a        # *bdm_pic* updates\u000a        if t >= 1.0 and bdm_pic.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bdm_pic.tStart = t  # underestimates by a little under one frame\u000a            bdm_pic.frameNStart = frameN  # exact frame index\u000a            bdm_pic.setAutoDraw(True)\u000a        # *bdm_bid* updates\u000a        if t >= 1.0:\u000a            bdm_bid.draw()\u000a            continueRoutine = bdm_bid.noResponse\u000a            if bdm_bid.noResponse == False:\u000a                bdm_bid.response = bdm_bid.getRating()\u000a                bdm_bid.rt = bdm_bid.getRT()\u000a            elif bdm_bid.noResponse==True:\u000a                if keyState[key.LEFT]==True and bdm_bid.markerPlacedAt >0.01:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt - 0.02\u000a                    bdm_bid.draw()\u000a                elif keyState[key.LEFT]==True and bdm_bid.markerPlacedAt==0.01:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt - 0.01\u000a                    bdm_bid.draw()\u000a                elif keyState[key.RIGHT]==True and bdm_bid.markerPlacedAt <2.99:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt + 0.02\u000a                    bdm_bid.draw()\u000a                elif keyState[key.RIGHT]==True and bdm_bid.markerPlacedAt==2.99:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt + 0.01\u000a                    bdm_bid.draw()\u000a                    \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in bdmComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "bdm"-------\u000a    for thisComponent in bdmComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # store data for bdm (TrialHandler)\u000a    bdm_loop1.addData('bdm_bid1.response', bdm_bid.getRating())\u000a    bdm_loop1.addData('bdm_bid1.rt', bdm_bid.getRT())\u000a    bdm_loop1.addData('bdm_marker_start', bdm_marker_start)\u000a\u000a    # Add the item and the subject's bid to the 'bids' list, which will be merged with the 'prefs' list later in order to run the auction\u000a    bids.append([bdm_img, bdm_bid.response])\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeat of 'bdm_loop1'\u000a\u000a\u000a#------Prepare to start Routine "instr_choice"-------\u000at = 0\u000ainstr_choiceClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_choice_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_choice_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_choiceComponents = []\u000ainstr_choiceComponents.append(instr_choice_txt)\u000ainstr_choiceComponents.append(instr_choice_resp)\u000afor thisComponent in instr_choiceComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_choice"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_choiceClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_choice_txt* updates\u000a    if t >= 0.0 and instr_choice_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_choice_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_choice_txt.frameNStart = frameN  # exact frame index\u000a        instr_choice_txt.setAutoDraw(True)\u000a    \u000a    # *instr_choice_resp* updates\u000a    if t >= 2.0 and instr_choice_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_choice_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_choice_resp.frameNStart = frameN  # exact frame index\u000a        instr_choice_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_choice_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_choice_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space', 's'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_choice_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_choice_resp.rt = instr_choice_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_choiceComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_choice"-------\u000afor thisComponent in instr_choiceComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_choice_resp.keys in ['', [], None]:  # No response was made\u000a   instr_choice_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_choice_resp.keys',instr_choice_resp.keys)\u000aif instr_choice_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_choice_resp.rt', instr_choice_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## BINARY LOOP ##########################\u000a\u000a# set up handler to look after randomisation of conditions etc\u000abinary = data.TrialHandler(nReps=1, method=u'sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(filename+'_choicecond.csv'),\u000a    seed=None, name='binary')\u000athisExp.addLoop(binary)  # add the loop to the experiment\u000athisBinary1 = binary.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBinary1.rgb)\u000aif thisBinary1 != None:\u000a    for paramName in thisBinary1.keys():\u000a        exec(paramName + '= thisBinary1.' + paramName)\u000a\u000a# Check if the 'skip' key was pressed in the instructions routine; if so, end the loop and move on to the BDM\u000aif instr_choice_resp.keys=='s':\u000a    binary.finished = True\u000a\u000afor thisBinary1 in binary:\u000a    currentLoop = binary\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBinary1.rgb)\u000a    if thisBinary1 != None:\u000a        for paramName in thisBinary1.keys():\u000a            exec(paramName + '= thisBinary1.' + paramName)\u000a    \u000a    #------Prepare to start Routine "choice"-------\u000a    t = 0\u000a    choiceClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    choice_pic_left.setImage(dir_path+choice_left)\u000a    choice_pic_right.setImage(dir_path+choice_right)\u000a    event.clearEvents(eventType='keyboard') # Clear keyboard event log to avoid last key press from prior loop being used\u000a    key_resp_choice = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_choice.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    choiceComponents = []\u000a    choiceComponents.append(fixation_text)\u000a    choiceComponents.append(choice_pic_left)\u000a    choiceComponents.append(choice_pic_right)\u000a    choiceComponents.append(key_resp_choice)\u000a    for thisComponent in choiceComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    \u000a    #-------Start Routine "choice"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = choiceClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation_text* updates\u000a        if t >= 0 and fixation_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation_text.tStart = t  # underestimates by a little under one frame\u000a            fixation_text.frameNStart = frameN  # exact frame index\u000a            fixation_text.setAutoDraw(True)\u000a        elif fixation_text.status == STARTED and t>= (0 + (1.0-win.monitorFramePeriod*0.75)):\u000a            fixation_text.setAutoDraw(False)\u000a\u000a        # *choice_pic_left* updates\u000a        if t >= 1.0 and choice_pic_left.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_left.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_left.frameNStart = frameN  # exact frame index\u000a            choice_pic_left.setAutoDraw(True)\u000a        \u000a        # *choice_pic_right* updates\u000a        if t >= 1.0 and choice_pic_right.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_right.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_right.frameNStart = frameN  # exact frame index\u000a            choice_pic_right.setAutoDraw(True)\u000a\u000a        # *key_resp_choice* updates\u000a        if t >= 1.0 and key_resp_choice.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_choice.tStart = t  # underestimates by a little under one frame\u000a            key_resp_choice.frameNStart = frameN  # exact frame index\u000a            key_resp_choice.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_choice.clock.reset()  # now t=0\u000a        if key_resp_choice.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_choice.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_choice.rt = key_resp_choice.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in choiceComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "choice"-------\u000a    for thisComponent in choiceComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_choice.keys in ['', [], None]:  # No response was made\u000a       key_resp_choice.keys=None\u000a    # store data for binary (TrialHandler)\u000a    binary.addData('key_resp_choice.keys',key_resp_choice.keys)\u000a    if key_resp_choice.keys != None:  # we had a response\u000a        binary.addData('key_resp_choice.rt', key_resp_choice.rt)\u000a\u000a    # define a function to append binary choices and the bid for the chosen item to the preference list\u000a    # lft is the left image displayed during that choice trial\u000a    # rt is the right image displayed\u000a    def rec_choice(lft, rt): \u000a        bd = False\u000a        if key_resp_choice.keys=='left':\u000a            chc = lft\u000a        elif key_resp_choice.keys=='right':\u000a            chc = rt\u000a        for x in range(len(bids)):\u000a            if bids[x][0]==chc:\u000a                bd = bids[x][1]\u000a        prefs.append([lft, rt, chc, bd])\u000a\u000a    # call the function\u000a    rec_choice(choice_left, choice_right)\u000a    \u000a\u000a    #------Prepare to start Routine "choice_selection"-------\u000a    t = 0\u000a    choice_selectionClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # keep track of which components have finished\u000a    choice_selectionComponents = []\u000a    choice_selectionComponents.append(choice_pic_left)\u000a    choice_selectionComponents.append(choice_pic_right)\u000a    choice_selectionComponents.append(star_left_selection)\u000a    choice_selectionComponents.append(star_right_selection)\u000a    for thisComponent in choice_selectionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "choice_selection"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = choice_selectionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *choice_pic_left* updates\u000a        if t >= 0.0 and choice_pic_left.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_left.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_left.frameNStart = frameN  # exact frame index\u000a            choice_pic_left.setAutoDraw(True)\u000a        elif choice_pic_left.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            choice_pic_left.setAutoDraw(False)\u000a        \u000a        # *choice_pic_right* updates\u000a        if t >= 0.0 and choice_pic_right.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_right.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_right.frameNStart = frameN  # exact frame index\u000a            choice_pic_right.setAutoDraw(True)\u000a        elif choice_pic_right.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            choice_pic_right.setAutoDraw(False)\u000a        \u000a        # *star_left_selection* updates\u000a        if key_resp_choice.keys=='left':\u000a            if t >= 0.0 and star_left_selection.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                star_left_selection.tStart = t  # underestimates by a little under one frame\u000a                star_left_selection.frameNStart = frameN  # exact frame index\u000a                star_left_selection.setAutoDraw(True)\u000a            elif star_left_selection.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                star_left_selection.setAutoDraw(False)\u000a        \u000a        # *star_right_selection* updates\u000a        if key_resp_choice.keys=='right':\u000a            if t >= 0.0 and star_right_selection.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                star_right_selection.tStart = t  # underestimates by a little under one frame\u000a                star_right_selection.frameNStart = frameN  # exact frame index\u000a                star_right_selection.setAutoDraw(True)\u000a            elif star_right_selection.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                star_right_selection.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in choice_selectionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "choice_selection"-------\u000a    for thisComponent in choice_selectionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    #thisExp.nextEntry()\u000a\u000a    #------Prepare to start Routine "confidence"-------\u000a    t = 0\u000a    confidenceClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    confidence_rating.reset()\u000a    # jitter the starting position of the confidence rating scale from a uniform distribution between 1.7 and 3.3 (the middle third of the scale), rounded to the nearest decimal place\u000a    confidence_marker_start = float(np.round(np.random.uniform(1.7, 3.3, 1)[0], 1))\u000a    confidence_rating.setMarkerPos(confidence_marker_start)\u000a    # keep track of which components have finished\u000a    confidenceComponents = []\u000a    confidenceComponents.append(confidence_rating)\u000a    for thisComponent in confidenceComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "confidence"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = confidenceClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *confidence_rating* updates\u000a        if t > 0.5:\u000a            confidence_rating.draw()\u000a            continueRoutine = confidence_rating.noResponse\u000a            if confidence_rating.noResponse == False:\u000a                confidence_rating.response = confidence_rating.getRating()\u000a                confidence_rating.rt = confidence_rating.getRT()\u000a            elif confidence_rating.noResponse==True:\u000a                if keyState[key.LEFT]==True and confidence_rating.markerPlacedAt >0:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt - 0.1\u000a                    confidence_rating.draw()\u000a                elif keyState[key.LEFT]==True and confidence_rating.markerPlacedAt==0.1:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt - 0.1\u000a                    confidence_rating.draw()\u000a                elif keyState[key.RIGHT]==True and confidence_rating.markerPlacedAt <4.9:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt + 0.1\u000a                    confidence_rating.draw()\u000a                elif keyState[key.RIGHT]==True and confidence_rating.markerPlacedAt==4.9:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt + 0.1\u000a                    confidence_rating.draw()\u000a                    \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in confidenceComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "confidence"-------\u000a    for thisComponent in confidenceComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # store data for confidence (TrialHandler)\u000a    binary.addData('confidence_rating1.response', confidence_rating.getRating())\u000a    binary.addData('confidence_rating1.rt', confidence_rating.getRT())\u000a    binary.addData('confidence_marker_start', confidence_marker_start+1) # Add 1 to convert from 0-5 to 1-6 scale\u000a\u000a    thisExp.nextEntry()\u000a\u000a\u000a# completed 1 repeat of 'binary'        \u000a\u000a#------Prepare to start Routine "instr_infer_intro"-------\u000at = 0\u000ainstr_infer_introClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_infer_intro_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_infer_intro_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_infer_introComponents = []\u000ainstr_infer_introComponents.append(instr_infer_intro_txt)\u000ainstr_infer_introComponents.append(instr_infer_intro_resp)\u000afor thisComponent in instr_infer_introComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_infer_intro"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_infer_introClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_infer_intro_txt* updates\u000a    if t >= 0.0 and instr_infer_intro_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_intro_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_intro_txt.frameNStart = frameN  # exact frame index\u000a        instr_infer_intro_txt.setAutoDraw(True)\u000a    \u000a    # *instr_infer_intro_resp* updates\u000a    if t >= 5.0 and instr_infer_intro_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_intro_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_intro_resp.frameNStart = frameN  # exact frame index\u000a        instr_infer_intro_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_infer_intro_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_infer_intro_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_infer_intro_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_infer_intro_resp.rt = instr_infer_intro_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_infer_introComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_infer_intro"-------\u000afor thisComponent in instr_infer_introComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_infer_intro_resp.keys in ['', [], None]:  # No response was made\u000a   instr_infer_intro_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_infer_intro_resp.keys',instr_infer_intro_resp.keys)\u000aif instr_infer_intro_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_infer_intro_resp.rt', instr_infer_intro_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a#------Prepare to start Routine "instr_infer_practice"-------\u000at = 0\u000ainstr_infer_practiceClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_infer_practice_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_infer_practice_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_infer_practiceComponents = []\u000ainstr_infer_practiceComponents.append(instr_infer_practice_txt)\u000ainstr_infer_practiceComponents.append(instr_infer_practice_resp)\u000afor thisComponent in instr_infer_practiceComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_infer_practice"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_infer_practiceClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_infer_practice_txt* updates\u000a    if t >= 0.0 and instr_infer_practice_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_practice_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_practice_txt.frameNStart = frameN  # exact frame index\u000a        instr_infer_practice_txt.setAutoDraw(True)\u000a    \u000a    # *instr_infer_practice_resp* updates\u000a    if t >= 5.0 and instr_infer_practice_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_practice_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_practice_resp.frameNStart = frameN  # exact frame index\u000a        instr_infer_practice_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_infer_practice_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_infer_practice_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_infer_practice_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_infer_practice_resp.rt = instr_infer_practice_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_infer_practiceComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_infer_practice"-------\u000afor thisComponent in instr_infer_practiceComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_infer_practice_resp.keys in ['', [], None]:  # No response was made\u000a   instr_infer_practice_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_infer_practice_resp.keys',instr_infer_practice_resp.keys)\u000aif instr_infer_practice_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_infer_practice_resp.rt', instr_infer_practice_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## PRACTICE LOOP ##########################\u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_loop = data.TrialHandler(nReps=1, method=u'sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(filename+'_practicecond.csv'),\u000a    seed=None, name='practice_loop')\u000athisExp.addLoop(practice_loop)  # add the loop to the experiment\u000athisPractice_loop = practice_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_loop.rgb)\u000aif thisPractice_loop != None:\u000a    for paramName in thisPractice_loop.keys():\u000a        exec(paramName + '= thisPractice_loop.' + paramName)\u000a\u000a  \u000afor thisPractice_loop in practice_loop:\u000a    currentLoop = practice_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_loop.rgb)\u000a    if thisPractice_loop != None:\u000a        for paramName in thisPractice_loop.keys():\u000a            exec(paramName + '= thisPractice_loop.' + paramName)    \u000a    \u000a        \u000a    # Define class for setting the feedback image\u000a    class set_feedback:\u000a        options = ['correct', 'wrong']\u000a        feedback = np.random.choice(options, replace=True, p=[0.8, 0.2])\u000a        if feedback=='correct':\u000a            feedback_img = img_correct\u000a        elif feedback=='wrong':\u000a            feedback_img = img_wrong\u000a\u000a        if feedback_img==img_left:\u000a            feedback_side = 'left'\u000a        elif feedback_img==img_right:\u000a            feedback_side = 'right'\u000a\u000a\u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialtime = datetime.datetime.now()\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    img_left_infer.setImage(dir_path+img_left)\u000a    img_right_infer.setImage(dir_path+img_right)\u000a    infer_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    infer_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(fixation_text)\u000a    trialComponents.append(img_left_infer)\u000a    trialComponents.append(img_right_infer)\u000a    trialComponents.append(infer_resp)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation_text* updates\u000a        if t >= 0 and fixation_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation_text.tStart = t  # underestimates by a little under one frame\u000a            fixation_text.frameNStart = frameN  # exact frame index\u000a            fixation_text.setAutoDraw(True)\u000a        elif fixation_text.status == STARTED and t>= (0 + (2.0-win.monitorFramePeriod*0.75)):\u000a            fixation_text.setAutoDraw(False)\u000a\u000a        # *img_left_infer* updates\u000a        if t >= 2.0 and img_left_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_left_infer.tStart = t  # underestimates by a little under one frame\u000a            img_left_infer.frameNStart = frameN  # exact frame index\u000a            img_left_infer.setAutoDraw(True)\u000a        \u000a        # *img_right_infer* updates\u000a        if t >= 2.0 and img_right_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_right_infer.tStart = t  # underestimates by a little under one frame\u000a            img_right_infer.frameNStart = frameN  # exact frame index\u000a            img_right_infer.setAutoDraw(True)\u000a                  \u000a        # *infer_resp* updates\u000a        if t >= 2.0 and infer_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            infer_resp.tStart = t  # underestimates by a little under one frame\u000a            infer_resp.frameNStart = frameN  # exact frame index\u000a            infer_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            infer_resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if infer_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                infer_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                infer_resp.rt = infer_resp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a\u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if infer_resp.keys in ['', [], None]:  # No response was made\u000a       infer_resp.keys=None\u000a    # # store data for practice_loop (TrialHandler)\u000a    # practice_loop.addData('infer_resp.keys',infer_resp.keys)\u000a    # if infer_resp.keys != None:  # we had a response\u000a    #     practice_loop.addData('infer_resp.rt', infer_resp.rt)\u000a    practice_loop.addData('set_feedback.feedback_img', set_feedback.feedback_img)\u000a    practice_loop.addData('trial_start_time', trialtime)\u000a    \u000a    # # Increase correct and incorrect response counters by 1 based on S's response\u000a    # if infer_resp.keys=='left' and img_correct==img_left:\u000a    #     correct_counter += 1\u000a    # elif infer_resp.keys=='left' and img_correct==img_right:\u000a    #     incorrect_counter += 1\u000a    # elif infer_resp.keys=='right' and img_correct==img_right:\u000a    #     correct_counter += 1\u000a    # elif infer_resp.keys=='right' and img_correct==img_left:\u000a    #     incorrect_counter += 1\u000a    \u000a\u000a    #------Prepare to start Routine "trial_post_response"-------\u000a    t = 0\u000a    trial_post_responseClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(3.000000)\u000a    # keep track of which components have finished\u000a    trial_post_responseComponents = []\u000a    trial_post_responseComponents.append(img_left_infer)\u000a    trial_post_responseComponents.append(img_right_infer)\u000a    trial_post_responseComponents.append(selection_arrow_left)\u000a    trial_post_responseComponents.append(selection_arrow_right)\u000a    trial_post_responseComponents.append(feedback_box_left)\u000a    trial_post_responseComponents.append(feedback_box_right)\u000a    for thisComponent in trial_post_responseComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial_post_response"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = trial_post_responseClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a\u000a        # *img_left_infer* updates\u000a        if t >= 0.0 and img_left_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_left_infer.tStart = t  # underestimates by a little under one frame\u000a            img_left_infer.frameNStart = frameN  # exact frame index\u000a            img_left_infer.setAutoDraw(True)\u000a        elif img_left_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            img_left_infer.setAutoDraw(False)\u000a        \u000a        # *img_right_infer* updates\u000a        if t >= 0.0 and img_right_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_right_infer.tStart = t  # underestimates by a little under one frame\u000a            img_right_infer.frameNStart = frameN  # exact frame index\u000a            img_right_infer.setAutoDraw(True)\u000a        elif img_right_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            img_right_infer.setAutoDraw(False)\u000a        \u000a        if infer_resp.keys == 'left':\u000a            # *selection_arrow_left* updates\u000a            if t >= 0.0 and selection_arrow_left.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                selection_arrow_left.tStart = t  # underestimates by a little under one frame\u000a                selection_arrow_left.frameNStart = frameN  # exact frame index\u000a                selection_arrow_left.setAutoDraw(True)\u000a            elif selection_arrow_left.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                selection_arrow_left.setAutoDraw(False)\u000a        \u000a        if infer_resp.keys == 'right':\u000a            # *selection_arrow_right* updates\u000a            if t >= 0.0 and selection_arrow_right.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                selection_arrow_right.tStart = t  # underestimates by a little under one frame\u000a                selection_arrow_right.frameNStart = frameN  # exact frame index\u000a                selection_arrow_right.setAutoDraw(True)\u000a            elif selection_arrow_right.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                selection_arrow_right.setAutoDraw(False)\u000a        \u000a        if set_feedback.feedback_side == 'left':\u000a            # *feedback_box_left* updates\u000a            if t >= 1.0 and feedback_box_left.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                feedback_box_left.tStart = t  # underestimates by a little under one frame\u000a                feedback_box_left.frameNStart = frameN  # exact frame index\u000a                feedback_box_left.setAutoDraw(True)\u000a            elif feedback_box_left.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                feedback_box_left.setAutoDraw(False)\u000a        \u000a        if set_feedback.feedback_side == 'right':\u000a            # *feedback_box_right* updates\u000a            if t >= 1.0 and feedback_box_right.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                feedback_box_right.tStart = t  # underestimates by a little under one frame\u000a                feedback_box_right.frameNStart = frameN  # exact frame index\u000a                feedback_box_right.setAutoDraw(True)\u000a            elif feedback_box_right.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period right\u000a                feedback_box_right.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trial_post_responseComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "trial_post_response"-------\u000a    for thisComponent in trial_post_responseComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000a    \u000a    thisExp.nextEntry()\u000a                        \u000a# completed 1 repeat of 'practice_loop'\u000a\u000a\u000a#------Prepare to start Routine "instr_infer"-------\u000at = 0\u000ainstr_inferClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_infer_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_infer_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_inferComponents = []\u000ainstr_inferComponents.append(instr_infer_txt)\u000ainstr_inferComponents.append(instr_infer_resp)\u000afor thisComponent in instr_inferComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_infer"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_inferClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_infer_txt* updates\u000a    if t >= 0.0 and instr_infer_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_txt.frameNStart = frameN  # exact frame index\u000a        instr_infer_txt.setAutoDraw(True)\u000a    \u000a    # *instr_infer_resp* updates\u000a    if t >= 5.0 and instr_infer_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_resp.frameNStart = frameN  # exact frame index\u000a        instr_infer_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_infer_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_infer_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_infer_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_infer_resp.rt = instr_infer_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_inferComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_infer"-------\u000afor thisComponent in instr_inferComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_infer_resp.keys in ['', [], None]:  # No response was made\u000a   instr_infer_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_infer_resp.keys',instr_infer_resp.keys)\u000aif instr_infer_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_infer_resp.rt', instr_infer_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## BLOCK LOOP ##########################\u000a\u000a# This loop runs a second nested loop that shows each item pair 10 times, followed by a rest break prompt.\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=3, method=u'sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=[None],\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000a# Set up counter to keep track of block loop cycle, so that the rest prompt is only shown twice\u000ablock_loop_counter = 0\u000a\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    # Increase loop counter by one\u000a    block_loop_counter += 1\u000a    \u000a    # Change the condition file for the feedback block based on which block loop we're on\u000a    condfilename = filename+u'_block'+str(block_loop_counter)+u'cond.csv'\u000a    \u000a    # # Minimize the psychopy window so the calibration window can be seen\u000a    # win.winHandle.minimize()\u000a    # #Do the eye tracker setup at the beginning of each block\u000a    # tracker.runSetupProcedure()\u000a    # # Re-display the psychopy window after setup is completed\u000a    # win.winHandle.maximize()\u000a    # win.winHandle.activate()\u000a    \u000a\u000a    \u000a    #------Prepare to start Routine "get_ready"-------\u000a    t = 0\u000a    get_readyClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(3.000000)\u000a    # update component parameters for each repeat\u000a    get_ready_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    get_ready_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    get_readyComponents = []\u000a    get_readyComponents.append(get_ready_text)\u000a    get_readyComponents.append(get_ready_resp)\u000a    for thisComponent in get_readyComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    \u000a    #-------Start Routine "get_ready"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = get_readyClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *get_ready_text* updates\u000a        if t >= 0.0 and get_ready_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            get_ready_text.tStart = t  # underestimates by a little under one frame\u000a            get_ready_text.frameNStart = frameN  # exact frame index\u000a            get_ready_text.setAutoDraw(True)\u000a        \u000a        # *get_ready_resp* updates\u000a        if t >= 0.0 and get_ready_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            get_ready_resp.tStart = t  # underestimates by a little under one frame\u000a            get_ready_resp.frameNStart = frameN  # exact frame index\u000a            get_ready_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            get_ready_resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if get_ready_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['p'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                get_ready_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                get_ready_resp.rt = get_ready_resp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in get_readyComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "get_ready"-------\u000a    for thisComponent in get_readyComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if get_ready_resp.keys in ['', [], None]:  # No response was made\u000a       get_ready_resp.keys=None\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('get_ready_resp.keys',get_ready_resp.keys)\u000a    if get_ready_resp.keys != None:  # we had a response\u000a        thisExp.addData('get_ready_resp.rt', get_ready_resp.rt)\u000a    thisExp.nextEntry()\u000a\u000a    ######################## TRIAL LOOP ##########################\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    trial_loop = data.TrialHandler(nReps=1, method=u'sequential', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(condfilename),\u000a        seed=None, name='trial_loop')\u000a    thisExp.addLoop(trial_loop)  # add the loop to the experiment\u000a    thisTrial_loop = trial_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_loop.rgb)\u000a    if thisTrial_loop != None:\u000a        for paramName in thisTrial_loop.keys():\u000a            exec(paramName + '= thisTrial_loop.' + paramName)\u000a    \u000a      \u000a    for thisTrial_loop in trial_loop:\u000a        currentLoop = trial_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_loop.rgb)\u000a        if thisTrial_loop != None:\u000a            for paramName in thisTrial_loop.keys():\u000a                exec(paramName + '= thisTrial_loop.' + paramName)    \u000a        \u000a            \u000a        # Define class for setting the feedback image\u000a        class set_feedback:\u000a            options = ['correct', 'wrong']\u000a            feedback = np.random.choice(options, replace=True, p=[0.8, 0.2])\u000a            if feedback=='correct':\u000a                feedback_img = img_correct\u000a            elif feedback=='wrong':\u000a                feedback_img = img_wrong\u000a\u000a            if feedback_img==img_left:\u000a                feedback_side = 'left'\u000a            elif feedback_img==img_right:\u000a                feedback_side = 'right'\u000a                        \u000a        # # Start getting data from the eye tracker\u000a        # tracker.enableEventReporting(True)\u000a        # # Send beginning-of-trial messages to eye tracker data file\u000a        # trial_number = (block_loop.thisN * 200) + trial_loop.thisTrialN # Trial number out of 599 (starts at 0)\u000a        # tracker.sendCommand("record_status_message 'INFERRING, Block %d/3, Trial %d/600 '" % (block_loop.thisN + 1, trial_number + 1))\u000a        # tracker.sendMessage("TRIALID %d" % trial_number)\u000a        # tracker.sendMessage("!V TRIAL_VAR_DATA %d" % trial_number)\u000a\u000a        \u000a        #------Prepare to start Routine "trial"-------\u000a        t = 0\u000a        trialtime = datetime.datetime.now()\u000a        trialClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        img_left_infer.setImage(dir_path+img_left)\u000a        img_right_infer.setImage(dir_path+img_right)\u000a        infer_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        infer_resp.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trialComponents = []\u000a        trialComponents.append(fixation_text)\u000a        trialComponents.append(img_left_infer)\u000a        trialComponents.append(img_right_infer)\u000a        trialComponents.append(infer_resp)\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        # Set indicator variable for whether eye tracker messages were sent during the first loop of the routine\u000a        eye_sync_messages_sent = 0\u000a        \u000a        #-------Start Routine "trial"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = trialClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *fixation_text* updates\u000a            if t >= 0 and fixation_text.status == NOT_STARTED:\u000a                if eye_sync_messages_sent==0:\u000a                    startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                # keep track of start time/frame for later\u000a                fixation_text.tStart = t  # underestimates by a little under one frame\u000a                fixation_text.frameNStart = frameN  # exact frame index\u000a                fixation_text.setAutoDraw(True)\u000a                if eye_sync_messages_sent==0:\u000a                    drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                    # tracker.sendMessage("%d DISPLAY ON" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                    # tracker.sendMessage("SYNCTIME %d" %drawTime)\u000a                    eye_sync_messages_sent = 1\u000a            elif fixation_text.status == STARTED and t>= (0 + (2.0-win.monitorFramePeriod*0.75)):\u000a                fixation_text.setAutoDraw(False)\u000a            \u000a            # *img_left_infer* updates\u000a            if t >= 2.0 and img_left_infer.status == NOT_STARTED:\u000a                if eye_sync_messages_sent==1:\u000a                    startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                # keep track of start time/frame for later\u000a                img_left_infer.tStart = t  # underestimates by a little under one frame\u000a                img_left_infer.frameNStart = frameN  # exact frame index\u000a                img_left_infer.setAutoDraw(True)\u000a            \u000a            # *img_right_infer* updates\u000a            if t >= 2.0 and img_right_infer.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                img_right_infer.tStart = t  # underestimates by a little under one frame\u000a                img_right_infer.frameNStart = frameN  # exact frame index\u000a                img_right_infer.setAutoDraw(True)\u000a                if eye_sync_messages_sent==1:\u000a                    drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                    # tracker.sendMessage("%d DISPLAY ON ITEMS" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                    eye_sync_messages_sent = 2\u000a                      \u000a            # *infer_resp* updates\u000a            if t >= 2.0 and infer_resp.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                infer_resp.tStart = t  # underestimates by a little under one frame\u000a                infer_resp.frameNStart = frameN  # exact frame index\u000a                infer_resp.status = STARTED\u000a                # keyboard checking is just starting\u000a                infer_resp.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            if infer_resp.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['left', 'right'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    infer_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                    infer_resp.rt = infer_resp.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trialComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                # tracker.enableEventReporting(False) # End eye tracker data recording\u000a                # tracker.sendMessage("EXPERIMENT ABORTED")\u000a                # io.quit() # Close iohub\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial"-------\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if infer_resp.keys in ['', [], None]:  # No response was made\u000a           infer_resp.keys=None\u000a        # store data for trial_loop (TrialHandler)\u000a        trial_loop.addData('infer_resp.keys',infer_resp.keys)\u000a        if infer_resp.keys != None:  # we had a response\u000a            trial_loop.addData('infer_resp.rt', infer_resp.rt)\u000a        trial_loop.addData('set_feedback.feedback_img', set_feedback.feedback_img)\u000a        trial_loop.addData('trial_start_time', trialtime)\u000a        \u000a        # Increase correct and incorrect response counters by 1 based on S's response\u000a        if infer_resp.keys=='left' and img_correct==img_left:\u000a            correct_counter += 1\u000a        elif infer_resp.keys=='left' and img_correct==img_right:\u000a            incorrect_counter += 1\u000a        elif infer_resp.keys=='right' and img_correct==img_right:\u000a            correct_counter += 1\u000a        elif infer_resp.keys=='right' and img_correct==img_left:\u000a            incorrect_counter += 1\u000a        \u000a\u000a        #------Prepare to start Routine "trial_post_response"-------\u000a        t = 0\u000a        trial_post_responseClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(3.000000)\u000a        # keep track of which components have finished\u000a        trial_post_responseComponents = []\u000a        trial_post_responseComponents.append(img_left_infer)\u000a        trial_post_responseComponents.append(img_right_infer)\u000a        trial_post_responseComponents.append(selection_arrow_left)\u000a        trial_post_responseComponents.append(selection_arrow_right)\u000a        trial_post_responseComponents.append(feedback_box_left)\u000a        trial_post_responseComponents.append(feedback_box_right)\u000a        for thisComponent in trial_post_responseComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        # Set indicator variable for whether eye tracker messages were sent during the first loop of the routine\u000a        eye_sync_messages_sent = 0\u000a\u000a        #-------Start Routine "trial_post_response"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = trial_post_responseClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a\u000a            # *img_left_infer* updates\u000a            if t >= 0.0 and img_left_infer.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                img_left_infer.tStart = t  # underestimates by a little under one frame\u000a                img_left_infer.frameNStart = frameN  # exact frame index\u000a                img_left_infer.setAutoDraw(True)\u000a            elif img_left_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                img_left_infer.setAutoDraw(False)\u000a            \u000a            # *img_right_infer* updates\u000a            if t >= 0.0 and img_right_infer.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                img_right_infer.tStart = t  # underestimates by a little under one frame\u000a                img_right_infer.frameNStart = frameN  # exact frame index\u000a                img_right_infer.setAutoDraw(True)\u000a            elif img_right_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                img_right_infer.setAutoDraw(False)\u000a            \u000a            if infer_resp.keys == 'left':\u000a                # *selection_arrow_left* updates\u000a                if t >= 0.0 and selection_arrow_left.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==0:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    selection_arrow_left.tStart = t  # underestimates by a little under one frame\u000a                    selection_arrow_left.frameNStart = frameN  # exact frame index\u000a                    selection_arrow_left.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==0:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        # tracker.sendMessage("%d DISPLAY ON SELECTION" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 1\u000a                elif selection_arrow_left.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    if eye_sync_messages_sent==1:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    selection_arrow_left.setAutoDraw(False)\u000a                    if eye_sync_messages_sent==1:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        # tracker.sendMessage("%d DISPLAY ON SELECTION OFF" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 2\u000a            \u000a            if infer_resp.keys == 'right':\u000a                # *selection_arrow_right* updates\u000a                if t >= 0.0 and selection_arrow_right.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==0:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    selection_arrow_right.tStart = t  # underestimates by a little under one frame\u000a                    selection_arrow_right.frameNStart = frameN  # exact frame index\u000a                    selection_arrow_right.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==0:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        # tracker.sendMessage("%d DISPLAY ON SELECTION" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 1\u000a                elif selection_arrow_right.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    if eye_sync_messages_sent==1:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    selection_arrow_right.setAutoDraw(False)\u000a                    if eye_sync_messages_sent==1:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        # tracker.sendMessage("%d DISPLAY ON SELECTION OFF" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 2\u000a            \u000a            if set_feedback.feedback_side == 'left':\u000a                # *feedback_box_left* updates\u000a                if t >= 1.0 and feedback_box_left.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==2:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    feedback_box_left.tStart = t  # underestimates by a little under one frame\u000a                    feedback_box_left.frameNStart = frameN  # exact frame index\u000a                    feedback_box_left.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==2:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        # tracker.sendMessage("%d DISPLAY ON FEEDBACK" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 3\u000a                elif feedback_box_left.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    feedback_box_left.setAutoDraw(False)\u000a            \u000a            if set_feedback.feedback_side == 'right':\u000a                # *feedback_box_right* updates\u000a                if t >= 1.0 and feedback_box_right.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==2:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    feedback_box_right.tStart = t  # underestimates by a little under one frame\u000a                    feedback_box_right.frameNStart = frameN  # exact frame index\u000a                    feedback_box_right.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==2:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        # tracker.sendMessage("%d DISPLAY ON FEEDBACK" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 3\u000a                elif feedback_box_right.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period right\u000a                    feedback_box_right.setAutoDraw(False)\u000a\u000a\u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial_post_responseComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                # tracker.enableEventReporting(False) # End eye tracker data recording\u000a                # tracker.sendMessage("EXPERIMENT ABORTED")\u000a                # io.quit() # Close iohub\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "trial_post_response"-------\u000a        for thisComponent in trial_post_responseComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a        thisExp.nextEntry()\u000a                            \u000a    # completed 5 repeats of 'trial_loop'\u000a    \u000a    if block_loop_counter <= 2: # If this is the first or second cycle of the loop, display the rest break prompt\u000a\u000a        #------Prepare to start Routine "rest_prompt"-------\u000a        t = 0\u000a        rest_promptClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        rest_prompt_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        rest_prompt_resp.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        rest_promptComponents = []\u000a        rest_promptComponents.append(rest_prompt_txt)\u000a        rest_promptComponents.append(rest_prompt_resp)\u000a        for thisComponent in rest_promptComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a\u000a        #-------Start Routine "rest_prompt"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = rest_promptClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *rest_prompt_txt* updates\u000a            if t >= 0.0 and rest_prompt_txt.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                rest_prompt_txt.tStart = t  # underestimates by a little under one frame\u000a                rest_prompt_txt.frameNStart = frameN  # exact frame index\u000a                rest_prompt_txt.setAutoDraw(True)\u000a            \u000a            # *rest_prompt_resp* updates\u000a            if t >= 2.0 and rest_prompt_resp.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                rest_prompt_resp.tStart = t  # underestimates by a little under one frame\u000a                rest_prompt_resp.frameNStart = frameN  # exact frame index\u000a                rest_prompt_resp.status = STARTED\u000a                # keyboard checking is just starting\u000a                rest_prompt_resp.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            if rest_prompt_resp.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    rest_prompt_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                    rest_prompt_resp.rt = rest_prompt_resp.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in rest_promptComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                # tracker.enableEventReporting(False) # End eye tracker data recording\u000a                # tracker.sendMessage("EXPERIMENT ABORTED")\u000a                # io.quit() # CLose iohub\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a\u000a        #-------Ending Routine "rest_prompt"-------\u000a        for thisComponent in rest_promptComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if rest_prompt_resp.keys in ['', [], None]:  # No response was made\u000a           rest_prompt_resp.keys=None\u000a        # store data for thisExp (ExperimentHandler)\u000a        thisExp.addData('rest_prompt_resp.keys',rest_prompt_resp.keys)\u000a        if rest_prompt_resp.keys != None:  # we had a response\u000a            thisExp.addData('rest_prompt_resp.rt', rest_prompt_resp.rt)\u000a\u000a\u000a    thisExp.nextEntry()\u000a    \u000a# completed 3 repeats of 'block_loop'\u000a\u000a\u000a# store data for total number of correct and incorrect responses    \u000athisExp.addData('correct_counter', correct_counter)\u000athisExp.addData('incorrect_counter', incorrect_counter)\u000athisExp.nextEntry()     \u000a\u000a# tracker.setConnectionState(False) # Close and transfer eye-tracking data, then close down eye tracker connection\u000a\u000a\u000a######################## AUCTION ##########################\u000a\u000aif len(prefs)==41 and len(bids)==41: # If S completed the entire binary choice and BDM routines, run the auction\u000a\u000a    # run the auction\u000a    class auction:\u000a        rand_itm = randint(1, (len(prefs))) # pick index for S's chosen item from a random choice\u000a        price = float((randint(1, 300)))/100 # assign a price to the item randomly from between 0.01 and 3 pounds\u000a        bid = prefs[rand_itm][3]\u000a        # check if S's bid for that item was above or below the price\u000a        if bid >= price:\u000a            win_item=True\u000a        elif bid < price:\u000a            win_item=False\u000a\u000a        # set text for the auction screen\u000a        if win_item==True:\u000a            auc_res_txt = u'Congratulations! You won the following item at auction. \u005cnThis was your preferred item out of a randomly selected pair from one of the choice tasks.'\u000a            auc_prc_txt = u'Your bid of \u005cxa3' + '{0:.2f}'.format(bid) + u' matched or exceeded the randomly generated price of \u005cxa3' + '{0:.2f}'.format(price) + '.\u005cn\u005cn[Press space bar to continue]'\u000a            cost = price\u000a        elif win_item==False:\u000a            auc_res_txt = u'Sorry, you did not win the following item at auction. \u005cnThis was your preferred item out of a randomly selected pair from one of the choice tasks.'\u000a            auc_prc_txt = u'Your bid of \u005cxa3' + '{0:.2f}'.format(bid) + u' was lower than the randomly generated price of \u005cxa3' + '{0:.2f}'.format(price) + '.\u005cn\u005cn[Press space bar to continue]'\u000a            cost = 0\u000a\u000a        # find the image path of the auction item\u000a        rand_itm_img = prefs[rand_itm][2]\u000a\u000a    # add up each component of S's payment\u000a    class score:\u000a        base = 25\u000a        rwrd = 0.01\u000a        loss = 0\u000a        rwrd_tot = rwrd * correct_counter\u000a        loss_tot = loss * incorrect_counter\u000a        pre_pymt = base + rwrd_tot - loss_tot\u000a        final_pymt = pre_pymt - auction.cost\u000a\u000a        pymt_expl_bdwn = u'\u005cxa3' + '{0:.2f}'.format(base) + u' base payment'+ u'\u005cn+ \u005cxa3' + '{0:.2f}'.format(rwrd_tot) + ' reward for ' + str(correct_counter) + u' correct responses (\u005cxa3' + '{0:.2f}'.format(rwrd) + u' each)' + u'\u005cn- \u005cxa3' + '{0:.2f}'.format(auction.cost) + ' cost of auction item' \u000a        pymt_expl_tot = u'Your total payment is: \u005cxa3' + '{0:.2f}'.format(final_pymt) + '\u005cn\u005cnThank you for participating!'\u000a\u000a\u000a    # Initialize components for Routine "auc_disp"\u000a    auc_dispClock = core.Clock()\u000a    pic_auc_itm = visual.ImageStim(win=win, name='pic_auc_itm',\u000a        image=dir_path+auction.rand_itm_img, mask=None,\u000a        ori=0, pos=[0, 0], size=None,\u000a        color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a        flipHoriz=False, flipVert=False,\u000a        texRes=128, interpolate=False, depth=0.0)\u000a    auc_txt1 = visual.TextStim(win=win, ori=0, name='auc_txt1',\u000a        text=auction.auc_res_txt, font=u'Arial',\u000a        pos=[0, 0.6], height=0.07, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    auc_txt2 = visual.TextStim(win=win, ori=0, name='auc_txt2',\u000a        text=auction.auc_prc_txt, font=u'Arial',\u000a        pos=[0, -0.6], height=0.07, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a\u000a    #------Prepare to start Routine "auc_disp"-------\u000a    t = 0\u000a    auc_dispClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    key_resp_auc_disp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_auc_disp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    auc_dispComponents = []\u000a    auc_dispComponents.append(pic_auc_itm)\u000a    auc_dispComponents.append(auc_txt1)\u000a    auc_dispComponents.append(auc_txt2)\u000a    for thisComponent in auc_dispComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "auc_disp"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = auc_dispClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *pic_auc_itm* updates\u000a        if t >= 0.2 and pic_auc_itm.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            pic_auc_itm.tStart = t  # underestimates by a little under one frame\u000a            pic_auc_itm.frameNStart = frameN  # exact frame index\u000a            pic_auc_itm.setAutoDraw(True)\u000a        \u000a        # *auc_txt1* updates\u000a        if t >= 0.2 and auc_txt1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            auc_txt1.tStart = t  # underestimates by a little under one frame\u000a            auc_txt1.frameNStart = frameN  # exact frame index\u000a            auc_txt1.setAutoDraw(True)\u000a\u000a        # *auc_txt2* updates\u000a        if t >= 0.2 and auc_txt2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            auc_txt2.tStart = t  # underestimates by a little under one frame\u000a            auc_txt2.frameNStart = frameN  # exact frame index\u000a            auc_txt2.setAutoDraw(True)\u000a        \u000a        # *key_resp_auc_disp* updates\u000a        if t >= 0.2 and key_resp_auc_disp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_auc_disp.tStart = t  # underestimates by a little under one frame\u000a            key_resp_auc_disp.frameNStart = frameN  # exact frame index\u000a            key_resp_auc_disp.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_auc_disp.clock.reset()  # now t=0\u000a        if key_resp_auc_disp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_auc_disp.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_auc_disp.rt = key_resp_auc_disp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in auc_dispComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "auc_disp"-------\u000a    for thisComponent in auc_dispComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_auc_disp.keys in ['', [], None]:  # No response was made\u000a       key_resp_auc_disp.keys=None\u000a    # store data for thisExp (TrialHandler)\u000a    thisExp.addData('auction.win_item', auction.win_item)\u000a    thisExp.addData('auction.price', auction.price)\u000a    thisExp.addData('auction.bid', auction.bid)\u000a    thisExp.addData('auction.rand_itm_img', auction.rand_itm_img)\u000a    thisExp.addData('score.base', score.base)\u000a    thisExp.addData('score.rwrd', score.rwrd)\u000a    thisExp.addData('score.loss', score.loss)\u000a    thisExp.addData('correct_counter', correct_counter)\u000a    thisExp.addData('incorrect_counter', incorrect_counter)\u000a    thisExp.addData('score.final_pymt', score.final_pymt)\u000a    thisExp.nextEntry()\u000a\u000a\u000a    # Initialize components for Routine "pymt_disp"\u000a    pymt_dispClock = core.Clock()\u000a    pymt_disp_txt1 = visual.TextStim(win=win, ori=0, name='pymt_disp_txt1',\u000a        text=score.pymt_expl_bdwn, font=u'Arial',\u000a        pos=[0, 0.6], height=0.07, wrapWidth=1.5,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    pymt_disp_txt2 = visual.TextStim(win=win, ori=0, name='pymt_disp_txt2',\u000a        text=score.pymt_expl_tot, font=u'Arial',\u000a        pos=[0, -0.65], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    #------Prepare to start Routine "pymt_disp"-------\u000a    t = 0\u000a    pymt_dispClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    key_resp_pymt_disp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_pymt_disp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    pymt_dispComponents = []\u000a    pymt_dispComponents.append(pic_auc_itm)\u000a    pymt_dispComponents.append(pymt_disp_txt1)\u000a    pymt_dispComponents.append(pymt_disp_txt2)\u000a    pymt_dispComponents.append(key_resp_pymt_disp)\u000a    for thisComponent in pymt_dispComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "pymt_disp"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = pymt_dispClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        if auction.win_item==True:\u000a            # *pic_auc_itm* updates\u000a            if t >= 0.0 and pic_auc_itm.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                pic_auc_itm.tStart = t  # underestimates by a little under one frame\u000a                pic_auc_itm.frameNStart = frameN  # exact frame index\u000a                pic_auc_itm.setAutoDraw(True)\u000a\u000a        # *pymt_disp_txt1* updates\u000a        if t >= 0.0 and pymt_disp_txt1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            pymt_disp_txt1.tStart = t  # underestimates by a little under one frame\u000a            pymt_disp_txt1.frameNStart = frameN  # exact frame index\u000a            pymt_disp_txt1.setAutoDraw(True)\u000a\u000a        # *pymt_disp_txt2* updates\u000a        if t >= 0.0 and pymt_disp_txt2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            pymt_disp_txt2.tStart = t  # underestimates by a little under one frame\u000a            pymt_disp_txt2.frameNStart = frameN  # exact frame index\u000a            pymt_disp_txt2.setAutoDraw(True)\u000a        \u000a        # *key_resp_pymt_disp* updates\u000a        if t >= 3.0 and key_resp_pymt_disp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_pymt_disp.tStart = t  # underestimates by a little under one frame\u000a            key_resp_pymt_disp.frameNStart = frameN  # exact frame index\u000a            key_resp_pymt_disp.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_pymt_disp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if key_resp_pymt_disp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_pymt_disp.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_pymt_disp.rt = key_resp_pymt_disp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in pymt_dispComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "pymt_disp"-------\u000a    for thisComponent in pymt_dispComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_pymt_disp.keys in ['', [], None]:  # No response was made\u000a       key_resp_pymt_disp.keys=None\u000a\u000aelse: # If S didn't complete the entire binary choice and BDM routines during this session, prompt a manual auction\u000a    # Initialize components for Routine "auc_manual"\u000a    auc_manualClock = core.Clock()\u000a    auc_manual_txt = visual.TextStim(win=win, ori=0, name='auc_manual_txt',\u000a        text=u'Thank you! This completes the experiment. The experimenter will now run the auction and calculate your final payment.\u005cn\u005cnCorrect: ' + str(correct_counter) + '\u005cnIncorrect: ' + str(incorrect_counter),    font=u'Arial',\u000a        pos=[0, 0], height=0.07, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    #------Prepare to start Routine "auc_manual"-------\u000a    t = 0\u000a    auc_manualClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    auc_manualComponents = []\u000a    auc_manualComponents.append(auc_manual_txt)\u000a    for thisComponent in auc_manualComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "auc_manual"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = auc_manualClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *auc_manual_txt* updates\u000a        if t >= 0.0 and auc_manual_txt.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            auc_manual_txt.tStart = t  # underestimates by a little under one frame\u000a            auc_manual_txt.frameNStart = frameN  # exact frame index\u000a            auc_manual_txt.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in auc_manualComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "auc_manual"-------\u000a    for thisComponent in auc_manualComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000athisExp.nextEntry()\u000a\u000a# io.quit() # Close iohub\u000a\u000a\u000awin.close()\u000acore.quit()\u000a
p9816
sg9107
(lp9817
sg9109
I85328720
sg10
g9399
sg6
g9111
sg9112
I1
sg52
I01
sg53
g54
sg9113
g1
(g9114
g9115
(dp9818
g33
g9118
(g9119
g92
g9120
S'b'
tRp9819
(I1
(I200
I1
tg9244
I00
S'0D\x8b\x12x\xcd\x8a\x12p\xf7\x8a\x12XD\x8b\x12\xb0\xcd\x8a\x12\x80D\x8b\x12\x08\xcd\x8a\x12\x10F\x8b\x12\xd0D\x8b\x12\x08\xcd\x8a\x12\xc0O\xc1\x04\xf8D\x8b\x12 E\x8b\x12\xd0D\x8b\x12\xe8E\x8b\x12\x00D\xc1\x04p\xf7\x8a\x12\xd0D\x8b\x12\x80D\x8b\x12\xc0O\xc1\x040D\x8b\x12\xa8D\x8b\x12\x88F\x8b\x12\xf8D\x8b\x12 P\x8b\x12\xa0\xf7\x8a\x12XD\x8b\x12\xe8E\x8b\x12XD\x8b\x12\xa0O\xc1\x04 E\x8b\x120D\x8b\x12HE\x8b\x12\xe0O\xc1\x04\x00D\xc1\x04\xe0O\xc1\x04\x08\xcd\x8a\x12\xd0D\x8b\x12\xd0\xf7\x8a\x12XD\x8b\x12\x80D\x8b\x12`F\x8b\x12\xe8\xcd\x8a\x12\x10F\x8b\x120D\x8b\x12@\xcd\x8a\x12\xc0O\xc1\x04\xa8D\x8b\x12\xd0\xf7\x8a\x12HE\x8b\x12\xa0O\xc1\x04\xd0D\x8b\x12@\xcd\x8a\x12p\xf7\x8a\x12 E\x8b\x12pE\x8b\x12@P\x8b\x12pE\x8b\x12XD\x8b\x12\xa0\xf7\x8a\x12\xe0O\xc1\x04 \xce\x8a\x12\x00D\xc1\x04\xd0\xf7\x8a\x12\xe0O\xc1\x04\xd0\xf7\x8a\x12\xf8D\x8b\x12 E\x8b\x12XD\x8b\x12pE\x8b\x128F\x8b\x12x\xcd\x8a\x12\x08\xcd\x8a\x120D\x8b\x12\xf8D\x8b\x12\xf0\xf8\x8a\x12\xd0D\x8b\x12\xd0\xf7\x8a\x12\x00D\xc1\x04 E\x8b\x12\xf8D\x8b\x12\xe8E\x8b\x12\xe0O\xc1\x04@\xcd\x8a\x12\x00D\xc1\x04\x90\xf8\x8a\x12\xe8E\x8b\x12\x98E\x8b\x12\xc0O\xc1\x04\x98E\x8b\x12\xa8D\x8b\x12 E\x8b\x12\x00\xf8\x8a\x12HE\x8b\x12pE\x8b\x12\xc0O\xc1\x04 E\x8b\x12@\xcd\x8a\x12\xc0O\xc1\x04\xe8E\x8b\x12p\xf7\x8a\x12\xd0\xf7\x8a\x12\xa0O\xc1\x04\xd0D\x8b\x12@\xcd\x8a\x12\x00\xf8\x8a\x12 E\x8b\x12\x08\xcd\x8a\x12\xa0O\xc1\x04\x98E\x8b\x12\xe0O\xc1\x04XD\x8b\x12\x80\xf9\x8a\x12 \xce\x8a\x12\xe0O\xc1\x04\x90\xf8\x8a\x12\xa8D\x8b\x12\xd0\xf7\x8a\x12\xf8D\x8b\x12\xa8D\x8b\x12\x98E\x8b\x12HE\x8b\x12\x00D\xc1\x04\xc0O\xc1\x04 \xf9\x8a\x12\x00\xf8\x8a\x120D\x8b\x12 E\x8b\x12pE\x8b\x12\xa0O\xc1\x04\x80D\x8b\x12p\xf7\x8a\x12\x98E\x8b\x12\xa0\xf7\x8a\x12`\xf8\x8a\x120D\x8b\x12 \xce\x8a\x12@\xcd\x8a\x12\x98E\x8b\x12`\xf8\x8a\x12\xd0D\x8b\x12pE\x8b\x12\xc0O\xc1\x04pE\x8b\x12HE\x8b\x120\xf8\x8a\x12\x00\xf8\x8a\x12HE\x8b\x12pE\x8b\x12\x80D\x8b\x120D\x8b\x12P\xf9\x8a\x12\x08\xcd\x8a\x12XD\x8b\x12HE\x8b\x12@\xcd\x8a\x12@P\x8b\x120\xf8\x8a\x12\x98E\x8b\x12\x00D\xc1\x04HE\x8b\x12pE\x8b\x12@\xcd\x8a\x12\xa0O\xc1\x04@\xcd\x8a\x12\xf8D\x8b\x12\xa0\xf7\x8a\x12\xc0\xf8\x8a\x12\x00\xf8\x8a\x12HE\x8b\x12\x00\xf8\x8a\x12\xf0\xf8\x8a\x12\x08\xcd\x8a\x12\x00\xf8\x8a\x12\x98E\x8b\x12\x00\xf8\x8a\x12p\xf7\x8a\x12\x08\xcd\x8a\x12\xd0\xf7\x8a\x12\x10F\x8b\x12\xf8D\x8b\x12p\xf7\x8a\x12\xa0\xf7\x8a\x12\x00\xf8\x8a\x12\x08\xcd\x8a\x12\x00D\xc1\x04\x88F\x8b\x120\xf8\x8a\x12\xa8D\x8b\x12P\xf9\x8a\x12\xa0\xf7\x8a\x12\xa0O\xc1\x04\x10F\x8b\x12\xa0\xf7\x8a\x120D\x8b\x12\xe0O\xc1\x04pE\x8b\x12\xf8D\x8b\x12\xa0\xf7\x8a\x12\xe8\xcd\x8a\x12'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg9117
g9118
(g9119
g92
g9120
S'b'
tRp9820
(I1
(I200
I1
tg9122
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg38
g9118
(g9119
g92
g9120
S'b'
tRp9821
(I1
(I200
I1
tg9244
I00
S' R\x8b\x12 \xf1\x87\x04\x80\xf0\x87\x04\xe0Z\x83\x0c@Q\x8b\x12`Q\x8b\x12\xa0R\x8b\x12@R\x8b\x12\x00S\x8b\x12\xc0R\x8b\x12 S\x8b\x12\x00R\x8b\x12@S\x8b\x12`S\x8b\x12\x80S\x8b\x12\xa0S\x8b\x12\xc0S\x8b\x12 T\x8b\x12@T\x8b\x12\x00Q\x8b\x12\xe0P\x8b\x12`T\x8b\x12\x80T\x8b\x12\xa0T\x8b\x12\x00U\x8b\x12\xe0T\x8b\x12\xa0Q\x8b\x12 U\x8b\x12@U\x8b\x12`U\x8b\x12\x80U\x8b\x12\xe0R\x8b\x12\xc0U\x8b\x12 V\x8b\x12@V\x8b\x12\x00T\x8b\x12\x80V\x8b\x12`V\x8b\x12\x80R\x8b\x12\xe0V\x8b\x12\xc0V\x8b\x12\xe0U\x8b\x12\x00W\x8b\x12`W\x8b\x12\x80W\x8b\x12\xa0U\x8b\x12\xc0P\x8b\x12\xa0W\x8b\x12\x00X\x8b\x12 X\x8b\x12@X\x8b\x12`X\x8b\x12`R\x8b\x12\xa0V\x8b\x12\x80X\x8b\x12\xe0X\x8b\x12\xc0X\x8b\x12 W\x8b\x12\x00Y\x8b\x12 Y\x8b\x12\x80Y\x8b\x12`Y\x8b\x12@W\x8b\x12\xa0Y\x8b\x12\x00Z\x8b\x12\xe0Y\x8b\x12@0\x8a\x04\xa00\x8a\x04\x800\x8a\x04\xe00\x8a\x04`2\x8a\x04\x801\x8a\x04\xc02\x8a\x04\x805\x8a\x04`1\x8a\x04@2\x8a\x04\x802\x8a\x04\xc01\x8a\x04 2\x8a\x04@o\x89\x04\x80n\x89\x04 f\x89\x04\xa0n\x89\x04\xc0o\x89\x04`o\x89\x04`j\x89\x04\xc0d\x89\x04\x00f\x89\x04\x00c\x89\x04@f\x89\x04\x00d\x89\x04@d\x89\x04\x80d\x89\x04\x00i\x89\x04\xa0e\x89\x04\xe0d\x89\x04`c\x89\x04 m\x89\x04\xa0m\x89\x04\xc0h\x89\x04\xa0k\x89\x04\xc0m\x89\x04\x00j\x89\x04\xe0l\x89\x04\x80j\x89\x04`i\x89\x04\xa0i\x89\x04\x80i\x89\x04`h\x89\x04\xc0j\x89\x04\xe0m\x89\x04`e\x89\x04`m\x89\x04\xe0j\x89\x04 h\x89\x04\x80l\x89\x04@l\x89\x04@j\x89\x04 k\x89\x04 j\x89\x04`l\x89\x04\x00m\x89\x04\xc0l\x89\x04\xa0j\x89\x04\xa0o\x89\x04\x80`\x89\x04 o\x89\x04\x80o\x89\x04\xe0o\x89\x04\xa0c\x89\x04@i\x89\x04\xe0i\x89\x04`f\x89\x04\x003\x8a\x04\x80f\x89\x04 e\x89\x04\xa01\x8a\x04@m\x89\x04\x00k\x89\x04 1\x8a\x04`\xdf\x88\x04`\xdd\x88\x04 \xe2\x86\x0c`\xe2\x86\x0c\xe0\xda\x88\x04 \xdf\x88\x04\x00\xd9\x88\x04`\xdc\x88\x04\xa0\xdc\x88\x04 \xdd\x88\x04 \xdb\x88\x04`\xde\x88\x04\xe0\xdb\x88\x04\xa0\xdf\x88\x04\xa0\xdd\x88\x04`\xdb\x88\x04\xc00\x8a\x04\x001\x8a\x04\xc0U\x83\x0c\x00Z\x83\x0c U\x83\x0c\xa0T\x83\x0c\xe0U\x83\x0c@[\x83\x0c \xdc\x88\x04\xc0Y\x83\x0c\xe0\xef\xbe\x04\xe0\xff\x83\x0c\x80\xf4\x83\x0c\x00\xfc\x83\x0c\xc0\xfa\x83\x0c\x00\xf2\x83\x0c\xe0\xf4\x83\x0c\xe0\xf3\x83\x0c\xc0i\x89\x04 \xf1\x83\x0c`\xfe\x83\x0c`\xf3\x83\x0c\x00\xf1\x83\x0c\xc0\xf7\x83\x0c\xe0\xf6\x83\x0c\xe0\xf1\x83\x0c\xa0\xfb\x83\x0c\x00R\x83\x0c\xe0\xfb\x83\x0c`\x81\xad\x0c@\x80\xad\x0c\xa0\x8a\xad\x0c \x83\xad\x0c\x00\x83\xad\x0c\x00\x87\xad\x0c@R\x82\x0c`\x8a\xad\x0c\xa0`\xb0\x0c\x00g\xb0\x0c\xa0f\xb0\x0c\xe0f\xb0\x0c\xe0b\xb0\x0c@`\xb0\x0c\xc0d\xb0\x0c'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg9125
g9118
(g9119
g92
g9120
S'b'
tRp9822
(I1
(I200
I1
tg9122
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00@\x00\x00@@\x00\x00\x80@\x00\x00\xa0@\x00\x00\xc0@\x00\x00\xe0@\x00\x00\x00A\x00\x00\x10A\x00\x00 A\x00\x000A\x00\x00@A\x00\x00PA\x00\x00`A\x00\x00pA\x00\x00\x80A\x00\x00\x88A\x00\x00\x90A\x00\x00\x98A\x00\x00\xa0A\x00\x00\xa8A\x00\x00\xb0A\x00\x00\xb8A\x00\x00\xc0A\x00\x00\xc8A\x00\x00\xd0A\x00\x00\xd8A\x00\x00\xe0A\x00\x00\xe8A\x00\x00\xf0A\x00\x00\xf8A\x00\x00\x00B\x00\x00\x04B\x00\x00\x08B\x00\x00\x0cB\x00\x00\x10B\x00\x00\x14B\x00\x00\x18B\x00\x00\x1cB\x00\x00 B\x00\x00$B\x00\x00(B\x00\x00,B\x00\x000B\x00\x004B\x00\x008B\x00\x00<B\x00\x00@B\x00\x00DB\x00\x00HB\x00\x00LB\x00\x00PB\x00\x00TB\x00\x00XB\x00\x00\\B\x00\x00`B\x00\x00dB\x00\x00hB\x00\x00lB\x00\x00pB\x00\x00tB\x00\x00xB\x00\x00|B\x00\x00\x80B\x00\x00\x82B\x00\x00\x84B\x00\x00\x86B\x00\x00\x88B\x00\x00\x8aB\x00\x00\x8cB\x00\x00\x8eB\x00\x00\x90B\x00\x00\x92B\x00\x00\x94B\x00\x00\x96B\x00\x00\x98B\x00\x00\x9aB\x00\x00\x9cB\x00\x00\x9eB\x00\x00\xa0B\x00\x00\xa2B\x00\x00\xa4B\x00\x00\xa6B\x00\x00\xa8B\x00\x00\xaaB\x00\x00\xacB\x00\x00\xaeB\x00\x00\xb0B\x00\x00\xb2B\x00\x00\xb4B\x00\x00\xb6B\x00\x00\xb8B\x00\x00\xbaB\x00\x00\xbcB\x00\x00\xbeB\x00\x00\xc0B\x00\x00\xc2B\x00\x00\xc4B\x00\x00\xc6B\x00\x00\xc8B\x00\x00\xcaB\x00\x00\xccB\x00\x00\xceB\x00\x00\xd0B\x00\x00\xd2B\x00\x00\xd4B\x00\x00\xd6B\x00\x00\xd8B\x00\x00\xdaB\x00\x00\xdcB\x00\x00\xdeB\x00\x00\xe0B\x00\x00\xe2B\x00\x00\xe4B\x00\x00\xe6B\x00\x00\xe8B\x00\x00\xeaB\x00\x00\xecB\x00\x00\xeeB\x00\x00\xf0B\x00\x00\xf2B\x00\x00\xf4B\x00\x00\xf6B\x00\x00\xf8B\x00\x00\xfaB\x00\x00\xfcB\x00\x00\xfeB\x00\x00\x00C\x00\x00\x01C\x00\x00\x02C\x00\x00\x03C\x00\x00\x04C\x00\x00\x05C\x00\x00\x06C\x00\x00\x07C\x00\x00\x08C\x00\x00\tC\x00\x00\nC\x00\x00\x0bC\x00\x00\x0cC\x00\x00\rC\x00\x00\x0eC\x00\x00\x0fC\x00\x00\x10C\x00\x00\x11C\x00\x00\x12C\x00\x00\x13C\x00\x00\x14C\x00\x00\x15C\x00\x00\x16C\x00\x00\x17C\x00\x00\x18C\x00\x00\x19C\x00\x00\x1aC\x00\x00\x1bC\x00\x00\x1cC\x00\x00\x1dC\x00\x00\x1eC\x00\x00\x1fC\x00\x00 C\x00\x00!C\x00\x00"C\x00\x00#C\x00\x00$C\x00\x00%C\x00\x00&C\x00\x00\'C\x00\x00(C\x00\x00)C\x00\x00*C\x00\x00+C\x00\x00,C\x00\x00-C\x00\x00.C\x00\x00/C\x00\x000C\x00\x001C\x00\x002C\x00\x003C\x00\x004C\x00\x005C\x00\x006C\x00\x007C\x00\x008C\x00\x009C\x00\x00:C\x00\x00;C\x00\x00<C\x00\x00=C\x00\x00>C\x00\x00?C\x00\x00@C\x00\x00AC\x00\x00BC\x00\x00CC\x00\x00DC\x00\x00EC\x00\x00FC\x00\x00GC'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg39
g9118
(g9119
g92
g9120
S'b'
tRp9823
(I1
(I200
I1
tg9122
I00
S'\x9e\xa5Y?\x7f\xf6n?\x94\xe2\xbd?\xa4\xb1*?0\x9dw?\xf7\x837?\'\r@?\xf9\xac\x8a?\x8ad\x86?\xb8\xb1\x8a?\'\x9aH?\xb3\xca\xac?,\x847?<8s?\x98\'\xa2?\xccG\x04@`\xc2{?.4\xd3?\xe8\xc9{?\xd1\xd3\x8c?2\x01^?\xb9`U?\x17\xf0\x8e?\n"b@\t\xe7]?\xa4@3?K/b?\xfcLD?\xa5\xfc.?E\xc9;?\xa2\xae\xca?\xcb\x1eb?\xec\xb7j?t\x9e\xb9?\x9a\xa1Y?y\xd2L?T\xf6\x8e?)\xaa\xaa?\xad\x89\x88?x\x11@?*\n@?&\x1eQ?s\x02\x80?\x93\x95H?\x85Z\x95?\xe8\xfc.?\xc7\xf4\x8e?\xedO\xa4?\xfcH\x84?\xc1]U?u\xb1*?\xf4W\x95?\xf6o&?\xac\x88\x97?\xfa\xef\x0e@\xd8j\x86?wX\x15@u\x03\x80?tH3?\xe5^U?F\x8a\x88?\\\xd4L?\xc1}\xb7?d\xe4\x9d?\xc9\xc1\x9b?o|\xd7?\xd6\x00\x00@;>s?J\xf4L?5\xdcL?\xf4\x16\xb1?\xbfX\xb5?\xc2l\x86?\xeb\x84w?\x8cI\xa4?2\xa6Y?\x8a\xcc\xac?\xca\xd8L?\x8e\x06^?\x98\xd3\x8c?\xe3\xca\x9b?(\x03\x80?\xac$\xa2?PyU?\x009s?\xff\t@?5QD?hf\xa6?J\xb0\x8a?\x1e)3?\xa6J\x84?\x1b\xf2\x0e@\x98H\x84?\x12\x9c\x88?\xb2\xd4L?\x87.b?\\\xa1Y?\xb6\xc2{?I\xf2\xbd?\xd2\xcc;?KH\xc4?o\x9c\x99?\x07\xc9;?\xa7\x1f\xb1?\xac\x06@?\xb5\'\xa2?\xcf\xb9*?w=s?}n&?\xa1\xa0Y?\xc2\x8e\x88?\xf4rf?\xea\xaej?H\xc6;?YdU?\x0f\xb1H?l\x16\x91?FJ\x84?\x14J\x84?Z\xd0\xac?`\xc1j?_ Q?\xd5\xc1\x9b?\x81Y\x95?!\xc8{?\xfc\x11\x80?X\xaf\x8a?\xb6\x16\x91?p\x8eH?o\xb7*?\x8c\xd7\xac?\t?s?\x17\xb7;?\'aU?\xba\xffn?\xc5\xd8L?\xd1\x0e@?d\x1eQ?\xca/3??\x847?TSU?\xe7\x0b@?\xcf"\x91?\xcc\xc3{?\x93{\x97?\x1f\xfan?\x8e\x9f\x99?\x7f\xde\x8c?\xba\x06\xc0?\xd9\xd0\x8c?*\xb1\x8a?\x0b\x0f\x91?\xd5\xbej?M\x9fY?B\xf1\x8e?Jmf?S\x96H?d\xe5]?\xeb\xfe??\xb5z\x97?>\x8bH?\x02RD?\xda\xa0Y?\xfa]U?D\x96H?-\xd1\xac?/\xd3L?\xcc-b?\xd9\x90\x88?\x19\x03^?\xc9D$@\x98\xd3L?\x19\xd8L?P\xeb]?\x80\x85Y?PbU?>\x03\x80?{\x85w?o\xb5j?G\xcf\x8c?\xba\x8e\x88?\xb9\x83w?\xf8\x05\x80?z\xf0\x1e@\xd8\x12o?\xae\x05\xc0?\x98\xb6j?&\xaf\x8a?*\x9a\x99@\x9f)\x82?\x9a\x847?\x8d\xfd??k6\x03@c\xb6*?\x17\\\x95?\xf0.b?\x94\\U?jl\x86??\x84w?:\xba\xaa?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg34
g9118
(g9119
g92
g9120
S'b'
tRp9824
(I1
(I200
I1
tg9244
I00
S'\xc8\xdf\xf1\x04\x80\xd9\xf1\x04\xe0\xf0\xb2\x04\x00\xf2\xb2\x04\x08\xff\xb2\x04\xc8\xf6\xb2\x04X\xf7\xb2\x04\x88\xf4\xb2\x04\x90\xf8\xb2\x04P\xf6\xb2\x04h\xff\xb2\x04\xe8\xfd\xb2\x04\x90\xf2\xb2\x04\x80\xf3\xb2\x04X\xf1\xb2\x04X\xfa\xb2\x04\x18\xfe\xb2\x04\x18\xfb\xb2\x04\x10\xf7\xb2\x048\xf6\xb2\x04\x08\xf9\xb2\x040\xf8\xb2\x04`\xfe\xb2\x04\x00\xf8\xb2\x04h\xf6\xb2\x04\xa8\xfb\xb2\x04H\xf8\xb2\x04(\xfa\xb2\x04\x90\xfe\xb2\x04h\xf0\xb2\x04p\xfa\xb2\x04\xe0\xf6\xb2\x04\x80\xf9\xb2\x04P\xff\xb2\x04 \xfc\xb2\x04\xc0\xf8\xb2\x048\xf0\xb2\x04X\xfd\xb2\x04\x80\xfc\xb2\x04\xd8\xfe\xb2\x04\xd8\xf8\xb2\x04x\xfe\xb2\x04P\xf0\xb2\x04\xc8\xff\xb2\x048\xfc\xb2\x04\x88\xfa\xb2\x04\x18\xf8\xb2\x04\x18\xf2\xb2\x048\xff\xb2\x04\x10\xfd\xb2\x04\x98\xff\xb2\x04\xd0\xfd\xb2\x04p\xf7\xb2\x04\xd0\xf1\xb2\x04p\xfd\xb2\x04\xa0\xfd\xb2\x04\xf0\xfb\xb2\x04\x98\xf6\xb2\x04P\xfc\xb2\x04\xb8\xfa\xb2\x04\xf0\xfe\xb2\x04\xe0\xfc\xb2\x04\xb8\xfd\xb2\x04\xb0\xff\xb2\x04\xf0\xf8\xb2\x04\x80\xf0\xb2\x04@!\xf1\x04(\xfd\xb2\x04@\xf1\xb2\x04\xc0\xfe\xb2\x04\x80\xff\xb2\x04H\xfe\xb2\x04\xf8\xfc\xb2\x04\xd0\xfa\xb2\x04\xb0\xf9\xb2\x04\x10\xfa\xb2\x040\xfe\xb2\x04\x88\xfd\xb2\x04 \xff\xb2\x04\xe8\xfa\xb2\x04\x08\xfc\xb2\x04h\xf3\xb2\x04\xe0\xff\xb2\x04\x80?\xee\x04H>\xee\x04X7\xee\x04 ?\xee\x04h9\xee\x04p7\xee\x04\xe09\xee\x04(=\xee\x04\x00>\xee\x04\xe87\xee\x04`;\xee\x04\xf8<\xee\x04\x089\xee\x04 9\xee\x04\x10=\xee\x04\x90;\xee\x04\xc8?\xee\x0408\xee\x04\x104\xee\x04\xf89\xee\x04x5\xee\x04\x884\xee\x04\xb0?\xee\x04\xe03\xee\x04\x98?\xee\x04\x10\xba\xb7\x048\xb3\xb7\x04(\xb4\xb7\x04\xb8\xb4\xb7\x04\xa0\xbd\xb7\x04\xf8\xbc\xb7\x04\x90\xbe\xb7\x04\x90\xb8\xb7\x04x\xb5\xb7\x04\xf0\xb5\xb7\x04\x18\xb2\xb7\x04\x80\xb9\xb7\x04\xd8\xb8\xb7\x04\xd0\xb7\xb7\x04\x08\xb3\xb7\x04\xc0\xbe\xb7\x048\xb9\xb7\x04\xe8\xb7\xb7\x04\xb8\xba\xb7\x04\x18\xbe\xb7\x04\x00\xb5\xb7\x04 \xb9\xb7\x04X\xbd\xb7\x04\xd8\xbe\xb7\x04`\xbb\xb7\x04h\xb6\xb7\x04`\xf2\xb2\x04h\xf9\xb2\x048\xf3\xb2\x04@\xfa\xb2\x04\x00\xfb\xb2\x04(\xf7\xb2\x04@\xf7\xb2\x04\xe0\xf9\xb2\x04\x98\xf0\xb2\x04\xf8\xf0\xb2\x04\xb0\xfc\xb2\x04\xa0\xf4\xb2\x048\xf9\xb2\x04\xb0\xf6\xb2\x04\xc8\xfc\xb2\x04h\xfc\xb2\x04\x88\xf7\xb2\x04\xe0\xf3\xb2\x04 \xf0\xb2\x04\xe8\xf1\xb2\x04\x00\xfe\xb2\x04P\xf9\xb2\x04\x88\xf1\xb2\x04\x08\xf6\xb2\x04\x98\xf9\xb2\x04\xa0\xf7\xb2\x04`\xf8\xb2\x04@\xfd\xb2\x04\xe8\xf7\xb2\x04\xb0\xf0\xb2\x04\xa8\xf5\xb2\x04\x10\xf4\xb2\x04\xb8\xf1\xb2\x04\xd8\xf5\xb2\x04\x10\xf1\xb2\x04\x80\xf6\xb2\x04\xa0\xfa\xb2\x04\xc8\xf0\xb2\x04\xc8\xf9\xb2\x04\xb0\xf3\xb2\x04\xb8\xf7\xb2\x04H\xfb\xb2\x04`\xfb\xb2\x04\xc8\xf3\xb2\x04\xc0\xfb\xb2\x04 \xf9\xb2\x04x\xf8\xb2\x04\xf0\xf5\xb2\x04\xa8\xf8\xb2\x04\xd0\xf7\xb2\x04P\xf3\xb2\x040\xf2\xb2\x040\xfb\xb2\x04(\xf1\xb2\x04\xf8\xf9\xb2\x04\xc0\xf5\xb2\x04\xf8\xf6\xb2\x04X\xf4\xb2\x04\xa0\xf1\xb2\x04 \xf3\xb2\x04H\xf2\xb2\x04\x98\xf3\xb2\x04\xa8\xfe\xb2\x04p\xf1\xb2\x04\x98\xfc\xb2\x04\xd8\xfb\xb2\x04'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp9825
(dp9826
g9130
(dp9827
g9117
I01
sg38
I00
sg33
I00
sg9125
I01
sg39
I01
sg34
I00
ssg9132
g9814
sg9133
(lp9828
g9117
ag9125
ag38
ag39
ag33
ag34
asg9135
(lp9829
I200
aI1
asbsg9137
g9252
sg9139
g91
(g92
(I0
tS'b'
tRp9830
(I1
(I200
I1
tg98
I00
S'\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00\x04\x00\x00\x00\x05\x00\x00\x00\x06\x00\x00\x00\x07\x00\x00\x00\x08\x00\x00\x00\t\x00\x00\x00\n\x00\x00\x00\x0b\x00\x00\x00\x0c\x00\x00\x00\r\x00\x00\x00\x0e\x00\x00\x00\x0f\x00\x00\x00\x10\x00\x00\x00\x11\x00\x00\x00\x12\x00\x00\x00\x13\x00\x00\x00\x14\x00\x00\x00\x15\x00\x00\x00\x16\x00\x00\x00\x17\x00\x00\x00\x18\x00\x00\x00\x19\x00\x00\x00\x1a\x00\x00\x00\x1b\x00\x00\x00\x1c\x00\x00\x00\x1d\x00\x00\x00\x1e\x00\x00\x00\x1f\x00\x00\x00 \x00\x00\x00!\x00\x00\x00"\x00\x00\x00#\x00\x00\x00$\x00\x00\x00%\x00\x00\x00&\x00\x00\x00\'\x00\x00\x00(\x00\x00\x00)\x00\x00\x00*\x00\x00\x00+\x00\x00\x00,\x00\x00\x00-\x00\x00\x00.\x00\x00\x00/\x00\x00\x000\x00\x00\x001\x00\x00\x002\x00\x00\x003\x00\x00\x004\x00\x00\x005\x00\x00\x006\x00\x00\x007\x00\x00\x008\x00\x00\x009\x00\x00\x00:\x00\x00\x00;\x00\x00\x00<\x00\x00\x00=\x00\x00\x00>\x00\x00\x00?\x00\x00\x00@\x00\x00\x00A\x00\x00\x00B\x00\x00\x00C\x00\x00\x00D\x00\x00\x00E\x00\x00\x00F\x00\x00\x00G\x00\x00\x00H\x00\x00\x00I\x00\x00\x00J\x00\x00\x00K\x00\x00\x00L\x00\x00\x00M\x00\x00\x00N\x00\x00\x00O\x00\x00\x00P\x00\x00\x00Q\x00\x00\x00R\x00\x00\x00S\x00\x00\x00T\x00\x00\x00U\x00\x00\x00V\x00\x00\x00W\x00\x00\x00X\x00\x00\x00Y\x00\x00\x00Z\x00\x00\x00[\x00\x00\x00\\\x00\x00\x00]\x00\x00\x00^\x00\x00\x00_\x00\x00\x00`\x00\x00\x00a\x00\x00\x00b\x00\x00\x00c\x00\x00\x00d\x00\x00\x00e\x00\x00\x00f\x00\x00\x00g\x00\x00\x00h\x00\x00\x00i\x00\x00\x00j\x00\x00\x00k\x00\x00\x00l\x00\x00\x00m\x00\x00\x00n\x00\x00\x00o\x00\x00\x00p\x00\x00\x00q\x00\x00\x00r\x00\x00\x00s\x00\x00\x00t\x00\x00\x00u\x00\x00\x00v\x00\x00\x00w\x00\x00\x00x\x00\x00\x00y\x00\x00\x00z\x00\x00\x00{\x00\x00\x00|\x00\x00\x00}\x00\x00\x00~\x00\x00\x00\x7f\x00\x00\x00\x80\x00\x00\x00\x81\x00\x00\x00\x82\x00\x00\x00\x83\x00\x00\x00\x84\x00\x00\x00\x85\x00\x00\x00\x86\x00\x00\x00\x87\x00\x00\x00\x88\x00\x00\x00\x89\x00\x00\x00\x8a\x00\x00\x00\x8b\x00\x00\x00\x8c\x00\x00\x00\x8d\x00\x00\x00\x8e\x00\x00\x00\x8f\x00\x00\x00\x90\x00\x00\x00\x91\x00\x00\x00\x92\x00\x00\x00\x93\x00\x00\x00\x94\x00\x00\x00\x95\x00\x00\x00\x96\x00\x00\x00\x97\x00\x00\x00\x98\x00\x00\x00\x99\x00\x00\x00\x9a\x00\x00\x00\x9b\x00\x00\x00\x9c\x00\x00\x00\x9d\x00\x00\x00\x9e\x00\x00\x00\x9f\x00\x00\x00\xa0\x00\x00\x00\xa1\x00\x00\x00\xa2\x00\x00\x00\xa3\x00\x00\x00\xa4\x00\x00\x00\xa5\x00\x00\x00\xa6\x00\x00\x00\xa7\x00\x00\x00\xa8\x00\x00\x00\xa9\x00\x00\x00\xaa\x00\x00\x00\xab\x00\x00\x00\xac\x00\x00\x00\xad\x00\x00\x00\xae\x00\x00\x00\xaf\x00\x00\x00\xb0\x00\x00\x00\xb1\x00\x00\x00\xb2\x00\x00\x00\xb3\x00\x00\x00\xb4\x00\x00\x00\xb5\x00\x00\x00\xb6\x00\x00\x00\xb7\x00\x00\x00\xb8\x00\x00\x00\xb9\x00\x00\x00\xba\x00\x00\x00\xbb\x00\x00\x00\xbc\x00\x00\x00\xbd\x00\x00\x00\xbe\x00\x00\x00\xbf\x00\x00\x00\xc0\x00\x00\x00\xc1\x00\x00\x00\xc2\x00\x00\x00\xc3\x00\x00\x00\xc4\x00\x00\x00\xc5\x00\x00\x00\xc6\x00\x00\x00\xc7\x00\x00\x00'
tbsg9141
I01
sg9142
I1
sg9143
I-1
sg9144
(lp9831
g1
(g9146
g9115
(dp9832
g3644
g3637
sg3632
g3633
sg3646
g3647
sg3641
g3642
stRp9833
ag1
(g9146
g9115
(dp9834
g3644
g3663
sg3632
g3653
sg3646
g3657
sg3641
g3661
stRp9835
ag1
(g9146
g9115
(dp9836
g3644
g3674
sg3632
g3670
sg3646
g3681
sg3641
g3678
stRp9837
ag1
(g9146
g9115
(dp9838
g3644
g3691
sg3632
g3687
sg3646
g3698
sg3641
g3695
stRp9839
ag1
(g9146
g9115
(dp9840
g3644
g3714
sg3632
g3704
sg3646
g3708
sg3641
g3712
stRp9841
ag1
(g9146
g9115
(dp9842
g3644
g3725
sg3632
g3721
sg3646
g3732
sg3641
g3729
stRp9843
ag1
(g9146
g9115
(dp9844
g3644
g3714
sg3632
g3704
sg3646
g3708
sg3641
g3712
stRp9845
ag1
(g9146
g9115
(dp9846
g3644
g3761
sg3632
g3751
sg3646
g3755
sg3641
g3759
stRp9847
ag1
(g9146
g9115
(dp9848
g3644
g3772
sg3632
g3768
sg3646
g3779
sg3641
g3776
stRp9849
ag1
(g9146
g9115
(dp9850
g3644
g3714
sg3632
g3704
sg3646
g3708
sg3641
g3712
stRp9851
ag1
(g9146
g9115
(dp9852
g3644
g3802
sg3632
g3798
sg3646
g3809
sg3641
g3806
stRp9853
ag1
(g9146
g9115
(dp9854
g3644
g3819
sg3632
g3815
sg3646
g3826
sg3641
g3823
stRp9855
ag1
(g9146
g9115
(dp9856
g3644
g3836
sg3632
g3832
sg3646
g3843
sg3641
g3840
stRp9857
ag1
(g9146
g9115
(dp9858
g3644
g3772
sg3632
g3849
sg3646
g3779
sg3641
g3856
stRp9859
ag1
(g9146
g9115
(dp9860
g3644
g3725
sg3632
g3864
sg3646
g3732
sg3641
g3871
stRp9861
ag1
(g9146
g9115
(dp9862
g3644
g3663
sg3632
g3653
sg3646
g3657
sg3641
g3661
stRp9863
ag1
(g9146
g9115
(dp9864
g3644
g3674
sg3632
g3892
sg3646
g3681
sg3641
g3899
stRp9865
ag1
(g9146
g9115
(dp9866
g3644
g3772
sg3632
g3768
sg3646
g3779
sg3641
g3776
stRp9867
ag1
(g9146
g9115
(dp9868
g3644
g3725
sg3632
g3721
sg3646
g3732
sg3641
g3729
stRp9869
ag1
(g9146
g9115
(dp9870
g3644
g3802
sg3632
g3933
sg3646
g3809
sg3641
g3940
stRp9871
ag1
(g9146
g9115
(dp9872
g3644
g3637
sg3632
g3633
sg3646
g3647
sg3641
g3642
stRp9873
ag1
(g9146
g9115
(dp9874
g3644
g3761
sg3632
g3751
sg3646
g3755
sg3641
g3759
stRp9875
ag1
(g9146
g9115
(dp9876
g3644
g3984
sg3632
g3974
sg3646
g3978
sg3641
g3982
stRp9877
ag1
(g9146
g9115
(dp9878
g3644
g3819
sg3632
g3991
sg3646
g3826
sg3641
g3998
stRp9879
ag1
(g9146
g9115
(dp9880
g3644
g3637
sg3632
g4006
sg3646
g3647
sg3641
g4013
stRp9881
ag1
(g9146
g9115
(dp9882
g3644
g4025
sg3632
g4021
sg3646
g4032
sg3641
g4029
stRp9883
ag1
(g9146
g9115
(dp9884
g3644
g3691
sg3632
g4038
sg3646
g3698
sg3641
g4045
stRp9885
ag1
(g9146
g9115
(dp9886
g3644
g3725
sg3632
g3864
sg3646
g3732
sg3641
g3871
stRp9887
ag1
(g9146
g9115
(dp9888
g3644
g3691
sg3632
g4038
sg3646
g3698
sg3641
g4045
stRp9889
ag1
(g9146
g9115
(dp9890
g3644
g4083
sg3632
g4079
sg3646
g4090
sg3641
g4087
stRp9891
ag1
(g9146
g9115
(dp9892
g3644
g3836
sg3632
g4096
sg3646
g3843
sg3641
g4103
stRp9893
ag1
(g9146
g9115
(dp9894
g3644
g3637
sg3632
g3633
sg3646
g3647
sg3641
g3642
stRp9895
ag1
(g9146
g9115
(dp9896
g3644
g4128
sg3632
g4124
sg3646
g4135
sg3641
g4132
stRp9897
ag1
(g9146
g9115
(dp9898
g3644
g3984
sg3632
g4141
sg3646
g3978
sg3641
g4148
stRp9899
ag1
(g9146
g9115
(dp9900
g3644
g3663
sg3632
g4156
sg3646
g3657
sg3641
g4163
stRp9901
ag1
(g9146
g9115
(dp9902
g3644
g3984
sg3632
g4141
sg3646
g3978
sg3641
g4148
stRp9903
ag1
(g9146
g9115
(dp9904
g3644
g3714
sg3632
g3704
sg3646
g3708
sg3641
g3712
stRp9905
ag1
(g9146
g9115
(dp9906
g3644
g3772
sg3632
g3849
sg3646
g3779
sg3641
g3856
stRp9907
ag1
(g9146
g9115
(dp9908
g3644
g4214
sg3632
g4210
sg3646
g4221
sg3641
g4218
stRp9909
ag1
(g9146
g9115
(dp9910
g3644
g3691
sg3632
g3687
sg3646
g3698
sg3641
g3695
stRp9911
ag1
(g9146
g9115
(dp9912
g3644
g3725
sg3632
g3721
sg3646
g3732
sg3641
g3729
stRp9913
ag1
(g9146
g9115
(dp9914
g3644
g3836
sg3632
g3832
sg3646
g3843
sg3641
g3840
stRp9915
ag1
(g9146
g9115
(dp9916
g3644
g3772
sg3632
g3768
sg3646
g3779
sg3641
g3776
stRp9917
ag1
(g9146
g9115
(dp9918
g3644
g3761
sg3632
g4279
sg3646
g3755
sg3641
g4286
stRp9919
ag1
(g9146
g9115
(dp9920
g3644
g3637
sg3632
g4006
sg3646
g3647
sg3641
g4013
stRp9921
ag1
(g9146
g9115
(dp9922
g3644
g4311
sg3632
g4307
sg3646
g4318
sg3641
g4315
stRp9923
ag1
(g9146
g9115
(dp9924
g3644
g3802
sg3632
g3933
sg3646
g3809
sg3641
g3940
stRp9925
ag1
(g9146
g9115
(dp9926
g3644
g3761
sg3632
g4279
sg3646
g3755
sg3641
g4286
stRp9927
ag1
(g9146
g9115
(dp9928
g3644
g4214
sg3632
g4350
sg3646
g4221
sg3641
g4357
stRp9929
ag1
(g9146
g9115
(dp9930
g3644
g4128
sg3632
g4124
sg3646
g4135
sg3641
g4132
stRp9931
ag1
(g9146
g9115
(dp9932
g3644
g4083
sg3632
g4378
sg3646
g4090
sg3641
g4385
stRp9933
ag1
(g9146
g9115
(dp9934
g3644
g3772
sg3632
g3849
sg3646
g3779
sg3641
g3856
stRp9935
ag1
(g9146
g9115
(dp9936
g3644
g4311
sg3632
g4307
sg3646
g4318
sg3641
g4315
stRp9937
ag1
(g9146
g9115
(dp9938
g3644
g3674
sg3632
g3670
sg3646
g3681
sg3641
g3678
stRp9939
ag1
(g9146
g9115
(dp9940
g3644
g3836
sg3632
g4096
sg3646
g3843
sg3641
g4103
stRp9941
ag1
(g9146
g9115
(dp9942
g3644
g4449
sg3632
g4445
sg3646
g4456
sg3641
g4453
stRp9943
ag1
(g9146
g9115
(dp9944
g3644
g3802
sg3632
g3798
sg3646
g3809
sg3641
g3806
stRp9945
ag1
(g9146
g9115
(dp9946
g3644
g4449
sg3632
g4445
sg3646
g4456
sg3641
g4453
stRp9947
ag1
(g9146
g9115
(dp9948
g3644
g3691
sg3632
g3687
sg3646
g3698
sg3641
g3695
stRp9949
ag1
(g9146
g9115
(dp9950
g3644
g4025
sg3632
g4501
sg3646
g4032
sg3641
g4508
stRp9951
ag1
(g9146
g9115
(dp9952
g3644
g3984
sg3632
g3974
sg3646
g3978
sg3641
g3982
stRp9953
ag1
(g9146
g9115
(dp9954
g3644
g4083
sg3632
g4079
sg3646
g4090
sg3641
g4087
stRp9955
ag1
(g9146
g9115
(dp9956
g3644
g3663
sg3632
g4156
sg3646
g3657
sg3641
g4163
stRp9957
ag1
(g9146
g9115
(dp9958
g3644
g4214
sg3632
g4350
sg3646
g4221
sg3641
g4357
stRp9959
ag1
(g9146
g9115
(dp9960
g3644
g3984
sg3632
g3974
sg3646
g3978
sg3641
g3982
stRp9961
ag1
(g9146
g9115
(dp9962
g3644
g4214
sg3632
g4210
sg3646
g4221
sg3641
g4218
stRp9963
ag1
(g9146
g9115
(dp9964
g3644
g3819
sg3632
g3991
sg3646
g3826
sg3641
g3998
stRp9965
ag1
(g9146
g9115
(dp9966
g3644
g3836
sg3632
g3832
sg3646
g3843
sg3641
g3840
stRp9967
ag1
(g9146
g9115
(dp9968
g3644
g3691
sg3632
g3687
sg3646
g3698
sg3641
g3695
stRp9969
ag1
(g9146
g9115
(dp9970
g3644
g4449
sg3632
g4633
sg3646
g4456
sg3641
g4640
stRp9971
ag1
(g9146
g9115
(dp9972
g3644
g3819
sg3632
g3991
sg3646
g3826
sg3641
g3998
stRp9973
ag1
(g9146
g9115
(dp9974
g3644
g3663
sg3632
g4156
sg3646
g3657
sg3641
g4163
stRp9975
ag1
(g9146
g9115
(dp9976
g3644
g3714
sg3632
g4674
sg3646
g3708
sg3641
g4681
stRp9977
ag1
(g9146
g9115
(dp9978
g3644
g3637
sg3632
g4006
sg3646
g3647
sg3641
g4013
stRp9979
ag1
(g9146
g9115
(dp9980
g3644
g3819
sg3632
g3991
sg3646
g3826
sg3641
g3998
stRp9981
ag1
(g9146
g9115
(dp9982
g3644
g4214
sg3632
g4350
sg3646
g4221
sg3641
g4357
stRp9983
ag1
(g9146
g9115
(dp9984
g3644
g3772
sg3632
g3849
sg3646
g3779
sg3641
g3856
stRp9985
ag1
(g9146
g9115
(dp9986
g3644
g4214
sg3632
g4350
sg3646
g4221
sg3641
g4357
stRp9987
ag1
(g9146
g9115
(dp9988
g3644
g3663
sg3632
g4156
sg3646
g3657
sg3641
g4163
stRp9989
ag1
(g9146
g9115
(dp9990
g3644
g3836
sg3632
g3832
sg3646
g3843
sg3641
g3840
stRp9991
ag1
(g9146
g9115
(dp9992
g3644
g3819
sg3632
g3815
sg3646
g3826
sg3641
g3823
stRp9993
ag1
(g9146
g9115
(dp9994
g3644
g3725
sg3632
g3721
sg3646
g3732
sg3641
g3729
stRp9995
ag1
(g9146
g9115
(dp9996
g3644
g3984
sg3632
g4141
sg3646
g3978
sg3641
g4148
stRp9997
ag1
(g9146
g9115
(dp9998
g3644
g4311
sg3632
g4307
sg3646
g4318
sg3641
g4315
stRp9999
ag1
(g9146
g9115
(dp10000
g3644
g3663
sg3632
g3653
sg3646
g3657
sg3641
g3661
stRp10001
ag1
(g9146
g9115
(dp10002
g3644
g4025
sg3632
g4501
sg3646
g4032
sg3641
g4508
stRp10003
ag1
(g9146
g9115
(dp10004
g3644
g3725
sg3632
g3721
sg3646
g3732
sg3641
g3729
stRp10005
ag1
(g9146
g9115
(dp10006
g3644
g4875
sg3632
g4871
sg3646
g4882
sg3641
g4879
stRp10007
ag1
(g9146
g9115
(dp10008
g3644
g3802
sg3632
g3933
sg3646
g3809
sg3641
g3940
stRp10009
ag1
(g9146
g9115
(dp10010
g3644
g4875
sg3632
g4871
sg3646
g4882
sg3641
g4879
stRp10011
ag1
(g9146
g9115
(dp10012
g3644
g3761
sg3632
g4279
sg3646
g3755
sg3641
g4286
stRp10013
ag1
(g9146
g9115
(dp10014
g3644
g3836
sg3632
g3832
sg3646
g3843
sg3641
g3840
stRp10015
ag1
(g9146
g9115
(dp10016
g3644
g4944
sg3632
g4940
sg3646
g4951
sg3641
g4948
stRp10017
ag1
(g9146
g9115
(dp10018
g3644
g4128
sg3632
g4124
sg3646
g4135
sg3641
g4132
stRp10019
ag1
(g9146
g9115
(dp10020
g3644
g4449
sg3632
g4445
sg3646
g4456
sg3641
g4453
stRp10021
ag1
(g9146
g9115
(dp10022
g3644
g3802
sg3632
g3933
sg3646
g3809
sg3641
g3940
stRp10023
ag1
(g9146
g9115
(dp10024
g3644
g3836
sg3632
g4096
sg3646
g3843
sg3641
g4103
stRp10025
ag1
(g9146
g9115
(dp10026
g3644
g4311
sg3632
g5009
sg3646
g4318
sg3641
g5016
stRp10027
ag1
(g9146
g9115
(dp10028
g3644
g3802
sg3632
g3798
sg3646
g3809
sg3641
g3806
stRp10029
ag1
(g9146
g9115
(dp10030
g3644
g3725
sg3632
g3864
sg3646
g3732
sg3641
g3871
stRp10031
ag1
(g9146
g9115
(dp10032
g3644
g3674
sg3632
g3892
sg3646
g3681
sg3641
g3899
stRp10033
ag1
(g9146
g9115
(dp10034
g3644
g4214
sg3632
g4210
sg3646
g4221
sg3641
g4218
stRp10035
ag1
(g9146
g9115
(dp10036
g3644
g4083
sg3632
g4378
sg3646
g4090
sg3641
g4385
stRp10037
ag1
(g9146
g9115
(dp10038
g3644
g3772
sg3632
g3849
sg3646
g3779
sg3641
g3856
stRp10039
ag1
(g9146
g9115
(dp10040
g3644
g4311
sg3632
g5009
sg3646
g4318
sg3641
g5016
stRp10041
ag1
(g9146
g9115
(dp10042
g3644
g4944
sg3632
g5115
sg3646
g4951
sg3641
g5122
stRp10043
ag1
(g9146
g9115
(dp10044
g3644
g3836
sg3632
g4096
sg3646
g3843
sg3641
g4103
stRp10045
ag1
(g9146
g9115
(dp10046
g3644
g3714
sg3632
g3704
sg3646
g3708
sg3641
g3712
stRp10047
ag1
(g9146
g9115
(dp10048
g3644
g4083
sg3632
g4378
sg3646
g4090
sg3641
g4385
stRp10049
ag1
(g9146
g9115
(dp10050
g3644
g4875
sg3632
g5169
sg3646
g4882
sg3641
g5176
stRp10051
ag1
(g9146
g9115
(dp10052
g3644
g3984
sg3632
g3974
sg3646
g3978
sg3641
g3982
stRp10053
ag1
(g9146
g9115
(dp10054
g3644
g3691
sg3632
g4038
sg3646
g3698
sg3641
g4045
stRp10055
ag1
(g9146
g9115
(dp10056
g3644
g4944
sg3632
g5115
sg3646
g4951
sg3641
g5122
stRp10057
ag1
(g9146
g9115
(dp10058
g3644
g4083
sg3632
g4079
sg3646
g4090
sg3641
g4087
stRp10059
ag1
(g9146
g9115
(dp10060
g3644
g3984
sg3632
g3974
sg3646
g3978
sg3641
g3982
stRp10061
ag1
(g9146
g9115
(dp10062
g3644
g4025
sg3632
g4501
sg3646
g4032
sg3641
g4508
stRp10063
ag1
(g9146
g9115
(dp10064
g3644
g3761
sg3632
g3751
sg3646
g3755
sg3641
g3759
stRp10065
ag1
(g9146
g9115
(dp10066
g3644
g4214
sg3632
g4210
sg3646
g4221
sg3641
g4218
stRp10067
ag1
(g9146
g9115
(dp10068
g3644
g3819
sg3632
g3815
sg3646
g3826
sg3641
g3823
stRp10069
ag1
(g9146
g9115
(dp10070
g3644
g3761
sg3632
g4279
sg3646
g3755
sg3641
g4286
stRp10071
ag1
(g9146
g9115
(dp10072
g3644
g4875
sg3632
g4871
sg3646
g4882
sg3641
g4879
stRp10073
ag1
(g9146
g9115
(dp10074
g3644
g4128
sg3632
g5327
sg3646
g4135
sg3641
g5334
stRp10075
ag1
(g9146
g9115
(dp10076
g3644
g3663
sg3632
g4156
sg3646
g3657
sg3641
g4163
stRp10077
ag1
(g9146
g9115
(dp10078
g3644
g3802
sg3632
g3933
sg3646
g3809
sg3641
g3940
stRp10079
ag1
(g9146
g9115
(dp10080
g3644
g4311
sg3632
g5009
sg3646
g4318
sg3641
g5016
stRp10081
ag1
(g9146
g9115
(dp10082
g3644
g4944
sg3632
g4940
sg3646
g4951
sg3641
g4948
stRp10083
ag1
(g9146
g9115
(dp10084
g3644
g3637
sg3632
g4006
sg3646
g3647
sg3641
g4013
stRp10085
ag1
(g9146
g9115
(dp10086
g3644
g3836
sg3632
g4096
sg3646
g3843
sg3641
g4103
stRp10087
ag1
(g9146
g9115
(dp10088
g3644
g4449
sg3632
g4633
sg3646
g4456
sg3641
g4640
stRp10089
ag1
(g9146
g9115
(dp10090
g3644
g4083
sg3632
g4378
sg3646
g4090
sg3641
g4385
stRp10091
ag1
(g9146
g9115
(dp10092
g3644
g3725
sg3632
g3864
sg3646
g3732
sg3641
g3871
stRp10093
ag1
(g9146
g9115
(dp10094
g3644
g3674
sg3632
g3670
sg3646
g3681
sg3641
g3678
stRp10095
ag1
(g9146
g9115
(dp10096
g3644
g4875
sg3632
g4871
sg3646
g4882
sg3641
g4879
stRp10097
ag1
(g9146
g9115
(dp10098
g3644
g4025
sg3632
g4501
sg3646
g4032
sg3641
g4508
stRp10099
ag1
(g9146
g9115
(dp10100
g3644
g3691
sg3632
g3687
sg3646
g3698
sg3641
g3695
stRp10101
ag1
(g9146
g9115
(dp10102
g3644
g3637
sg3632
g3633
sg3646
g3647
sg3641
g3642
stRp10103
ag1
(g9146
g9115
(dp10104
g3644
g4083
sg3632
g4079
sg3646
g4090
sg3641
g4087
stRp10105
ag1
(g9146
g9115
(dp10106
g3644
g4311
sg3632
g4307
sg3646
g4318
sg3641
g4315
stRp10107
ag1
(g9146
g9115
(dp10108
g3644
g4875
sg3632
g5169
sg3646
g4882
sg3641
g5176
stRp10109
ag1
(g9146
g9115
(dp10110
g3644
g3691
sg3632
g4038
sg3646
g3698
sg3641
g4045
stRp10111
ag1
(g9146
g9115
(dp10112
g3644
g3772
sg3632
g3768
sg3646
g3779
sg3641
g3776
stRp10113
ag1
(g9146
g9115
(dp10114
g3644
g4449
sg3632
g4633
sg3646
g4456
sg3641
g4640
stRp10115
ag1
(g9146
g9115
(dp10116
g3644
g3802
sg3632
g3798
sg3646
g3809
sg3641
g3806
stRp10117
ag1
(g9146
g9115
(dp10118
g3644
g4449
sg3632
g4445
sg3646
g4456
sg3641
g4453
stRp10119
ag1
(g9146
g9115
(dp10120
g3644
g4128
sg3632
g5327
sg3646
g4135
sg3641
g5334
stRp10121
ag1
(g9146
g9115
(dp10122
g3644
g3674
sg3632
g3892
sg3646
g3681
sg3641
g3899
stRp10123
ag1
(g9146
g9115
(dp10124
g3644
g4944
sg3632
g4940
sg3646
g4951
sg3641
g4948
stRp10125
ag1
(g9146
g9115
(dp10126
g3644
g4128
sg3632
g5327
sg3646
g4135
sg3641
g5334
stRp10127
ag1
(g9146
g9115
(dp10128
g3644
g4449
sg3632
g4445
sg3646
g4456
sg3641
g4453
stRp10129
ag1
(g9146
g9115
(dp10130
g3644
g3725
sg3632
g3864
sg3646
g3732
sg3641
g3871
stRp10131
ag1
(g9146
g9115
(dp10132
g3644
g3637
sg3632
g3633
sg3646
g3647
sg3641
g3642
stRp10133
ag1
(g9146
g9115
(dp10134
g3644
g4875
sg3632
g5169
sg3646
g4882
sg3641
g5176
stRp10135
ag1
(g9146
g9115
(dp10136
g3644
g3714
sg3632
g4674
sg3646
g3708
sg3641
g4681
stRp10137
ag1
(g9146
g9115
(dp10138
g3644
g3691
sg3632
g4038
sg3646
g3698
sg3641
g4045
stRp10139
ag1
(g9146
g9115
(dp10140
g3644
g4128
sg3632
g4124
sg3646
g4135
sg3641
g4132
stRp10141
ag1
(g9146
g9115
(dp10142
g3644
g4311
sg3632
g5009
sg3646
g4318
sg3641
g5016
stRp10143
ag1
(g9146
g9115
(dp10144
g3644
g3802
sg3632
g3798
sg3646
g3809
sg3641
g3806
stRp10145
ag1
(g9146
g9115
(dp10146
g3644
g3674
sg3632
g3892
sg3646
g3681
sg3641
g3899
stRp10147
ag1
(g9146
g9115
(dp10148
g3644
g4875
sg3632
g4871
sg3646
g4882
sg3641
g4879
stRp10149
ag1
(g9146
g9115
(dp10150
g3644
g3663
sg3632
g3653
sg3646
g3657
sg3641
g3661
stRp10151
ag1
(g9146
g9115
(dp10152
g3644
g4128
sg3632
g5327
sg3646
g4135
sg3641
g5334
stRp10153
ag1
(g9146
g9115
(dp10154
g3644
g4449
sg3632
g4633
sg3646
g4456
sg3641
g4640
stRp10155
ag1
(g9146
g9115
(dp10156
g3644
g4311
sg3632
g4307
sg3646
g4318
sg3641
g4315
stRp10157
ag1
(g9146
g9115
(dp10158
g3644
g4083
sg3632
g4378
sg3646
g4090
sg3641
g4385
stRp10159
ag1
(g9146
g9115
(dp10160
g3644
g4311
sg3632
g5009
sg3646
g4318
sg3641
g5016
stRp10161
ag1
(g9146
g9115
(dp10162
g3644
g3819
sg3632
g3991
sg3646
g3826
sg3641
g3998
stRp10163
ag1
(g9146
g9115
(dp10164
g3644
g4025
sg3632
g4021
sg3646
g4032
sg3641
g4029
stRp10165
ag1
(g9146
g9115
(dp10166
g3644
g4128
sg3632
g5327
sg3646
g4135
sg3641
g5334
stRp10167
ag1
(g9146
g9115
(dp10168
g3644
g4944
sg3632
g4940
sg3646
g4951
sg3641
g4948
stRp10169
ag1
(g9146
g9115
(dp10170
g3644
g4128
sg3632
g4124
sg3646
g4135
sg3641
g4132
stRp10171
ag1
(g9146
g9115
(dp10172
g3644
g4944
sg3632
g5115
sg3646
g4951
sg3641
g5122
stRp10173
ag1
(g9146
g9115
(dp10174
g3644
g4214
sg3632
g4350
sg3646
g4221
sg3641
g4357
stRp10175
ag1
(g9146
g9115
(dp10176
g3644
g3714
sg3632
g4674
sg3646
g3708
sg3641
g4681
stRp10177
ag1
(g9146
g9115
(dp10178
g3644
g4944
sg3632
g5115
sg3646
g4951
sg3641
g5122
stRp10179
ag1
(g9146
g9115
(dp10180
g3644
g4875
sg3632
g5169
sg3646
g4882
sg3641
g5176
stRp10181
ag1
(g9146
g9115
(dp10182
g3644
g4944
sg3632
g4940
sg3646
g4951
sg3641
g4948
stRp10183
ag1
(g9146
g9115
(dp10184
g3644
g3674
sg3632
g3670
sg3646
g3681
sg3641
g3678
stRp10185
ag1
(g9146
g9115
(dp10186
g3644
g3714
sg3632
g4674
sg3646
g3708
sg3641
g4681
stRp10187
ag1
(g9146
g9115
(dp10188
g3644
g4214
sg3632
g4210
sg3646
g4221
sg3641
g4218
stRp10189
ag1
(g9146
g9115
(dp10190
g3644
g3761
sg3632
g3751
sg3646
g3755
sg3641
g3759
stRp10191
ag1
(g9146
g9115
(dp10192
g3644
g3819
sg3632
g3815
sg3646
g3826
sg3641
g3823
stRp10193
ag1
(g9146
g9115
(dp10194
g3644
g3674
sg3632
g3670
sg3646
g3681
sg3641
g3678
stRp10195
ag1
(g9146
g9115
(dp10196
g3644
g4025
sg3632
g4021
sg3646
g4032
sg3641
g4029
stRp10197
ag1
(g9146
g9115
(dp10198
g3644
g4944
sg3632
g5115
sg3646
g4951
sg3641
g5122
stRp10199
ag1
(g9146
g9115
(dp10200
g3644
g3714
sg3632
g4674
sg3646
g3708
sg3641
g4681
stRp10201
ag1
(g9146
g9115
(dp10202
g3644
g3663
sg3632
g3653
sg3646
g3657
sg3641
g3661
stRp10203
ag1
(g9146
g9115
(dp10204
g3644
g3984
sg3632
g4141
sg3646
g3978
sg3641
g4148
stRp10205
ag1
(g9146
g9115
(dp10206
g3644
g3674
sg3632
g3892
sg3646
g3681
sg3641
g3899
stRp10207
ag1
(g9146
g9115
(dp10208
g3644
g3761
sg3632
g4279
sg3646
g3755
sg3641
g4286
stRp10209
ag1
(g9146
g9115
(dp10210
g3644
g4875
sg3632
g5169
sg3646
g4882
sg3641
g5176
stRp10211
ag1
(g9146
g9115
(dp10212
g3644
g4025
sg3632
g4501
sg3646
g4032
sg3641
g4508
stRp10213
ag1
(g9146
g9115
(dp10214
g3644
g4083
sg3632
g4079
sg3646
g4090
sg3641
g4087
stRp10215
ag1
(g9146
g9115
(dp10216
g3644
g3761
sg3632
g3751
sg3646
g3755
sg3641
g3759
stRp10217
ag1
(g9146
g9115
(dp10218
g3644
g4025
sg3632
g4021
sg3646
g4032
sg3641
g4029
stRp10219
ag1
(g9146
g9115
(dp10220
g3644
g3637
sg3632
g4006
sg3646
g3647
sg3641
g4013
stRp10221
ag1
(g9146
g9115
(dp10222
g3644
g3984
sg3632
g4141
sg3646
g3978
sg3641
g4148
stRp10223
ag1
(g9146
g9115
(dp10224
g3644
g4449
sg3632
g4633
sg3646
g4456
sg3641
g4640
stRp10225
ag1
(g9146
g9115
(dp10226
g3644
g3819
sg3632
g3815
sg3646
g3826
sg3641
g3823
stRp10227
ag1
(g9146
g9115
(dp10228
g3644
g4025
sg3632
g4021
sg3646
g4032
sg3641
g4029
stRp10229
ag1
(g9146
g9115
(dp10230
g3644
g3772
sg3632
g3768
sg3646
g3779
sg3641
g3776
stRp10231
asg9227
Nsg9228
g6347
sg9229
I200
sg9230
I0
sg9231
I200
sg9232
I01
sbag1
(g9102
g3
NtRp10232
(dp10233
g9105
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a\u000a######################## CITATIONS ########################## \u000a##### Binary choice, BDM, auction routines, and instructions are modified from:\u000a##### \u000a##### De Martino, B., Fleming, S. M., Garrett, N., & Dolan, R. J. (2012). Confidence in value-based choice. Nature Neuroscience, 16(1), 105-110. \u000a#####\u000a##### Food item images are original.\u000a\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.80.01), July 16, 2014, at 03:20\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things bdm STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000afrom pyglet.window import key # to detect key state, whether key is held down, to move slider on key hold\u000aimport pandas as pd\u000aimport datetime\u000afrom psychopy.iohub import launchHubServer\u000aimport pylink\u000a\u000a# Initialize IOHub for eye tracker\u000a# io=launchHubServer(iohub_config_name='iohub_config.yaml')\u000a# tracker = io.devices.tracker\u000a\u000a# Store info about the experiment session\u000aexpName = 'infer_design1_no_eyetracking'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u'', u'eye': u'', u'glasses': u'', u'contacts': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Setup filename for saving\u000afilename = 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# set up variable to track current state of key press, to move slider when keys held down\u000akeyState=key.KeyStateHandler()\u000a\u000a# Setup the Window\u000ascreenwidth = 1920\u000ascreenheight = 1080\u000awin = visual.Window(size=(screenwidth, screenheight), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color='black', colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000awin.winHandle.push_handlers(keyState)\u000a\u000a\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a\u000a######################## COMPONENTS ##########################\u000a\u000a# Set up directory path for stimuli. This avoids us having to put the entire image path in the conditions spreadsheet.\u000adir_path = 'stimuli/itempics/modified/small/'\u000a\u000a# Initialize components for Routine "instr_main"\u000ainstr_mainClock = core.Clock()\u000ainstr_main_txt = visual.TextStim(win=win, ori=0, name='instr_main_txt',\u000a    text=u'Welcome!\u005cn\u005cnPlease read the instructions carefully and get the experimenter when you\u005c're finished. Take as much time as you need.',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "instr_bdm"\u000ainstr_bdmClock = core.Clock()\u000ainstr_bdm_txt = visual.TextStim(win=win, ori=0, name='instr_bdm_txt',\u000a    text=u'The bidding task is about to begin. Use the LEFT and RIGHT arrow keys to move the cursor along the slider, then press the DOWN arrow to enter your bid.\u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "fixation"\u000afixationClock = core.Clock()\u000afixation_text = visual.TextStim(win=win, ori=0, name='fixation_text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "bdm"\u000abdmClock = core.Clock()\u000abdm_pic = visual.ImageStim(win=win, name='bdm_pic',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=0.0)\u000abdm_bid = visual.RatingScale(win=win, name='bdm_bid', marker=u'triangle', markerColor=u'orange', leftKeys=None, rightKeys=None,\u000a    size=1.0, pos=[0.0, -0.6], low=0, high=3, precision=100, labels=[u'\u005cxa30', u'\u005cxa33'],\u000a    scale=u'', markerStart=u'1.5', tickHeight=u'1', showAccept=False, acceptKeys=[u'down', u'return'])\u000a\u000a# Initialize components for Routine "instr_choice"\u000ainstr_choiceClock = core.Clock()\u000ainstr_choice_txt = visual.TextStim(win=win, ori=0, name='instr_choice_txt',\u000a    text=u'The choice task is about to begin. Choose your preferred item by pressing the LEFT or RIGHT arrow keys, then use the slider to indicate how confident you are that you made the best choice.\u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "choice"\u000achoiceClock = core.Clock()\u000achoice_pic_left = visual.ImageStim(win=win, name='choice_pic_left',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[-0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=0.0)\u000achoice_pic_right = visual.ImageStim(win=win, name='choice_pic_right',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=-1.0)\u000a\u000a# Initialize components for Routine "choice_selection"\u000achoice_selectionClock = core.Clock()\u000astar_left_selection = visual.TextStim(win=win, ori=0, name='star_left_selection',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[-0.5, -0.8], height=0.5, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=-2.0)\u000astar_right_selection = visual.TextStim(win=win, ori=0, name='star_right_selection',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[0.5, -0.8], height=0.5, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=-3.0)\u000a\u000a# Initialize components for Routine "confidence"\u000aconfidenceClock = core.Clock()\u000aconfidence_rating = visual.RatingScale(win=win, name='confidence_rating', marker=u'triangle', markerColor=u'orange', leftKeys=None, rightKeys=None,\u000a    size=1.0, pos=[0.0, 0.0], low=1, high=6, precision=20,\u000a    scale=u'', markerStart=u'3.5', tickHeight=u'1', showAccept=False, acceptKeys=[u'down', u'return'])\u000a\u000a# Initialize components for Routine "instr_infer_intro"\u000ainstr_infer_introClock = core.Clock()\u000ainstr_infer_intro_txt = visual.TextStim(win=win, ori=0, name='instr_infer_intro_txt',\u000a    text=u'Thanks! Now please get the experimenter, who will give you the instructions for the second part of the experiment. \u005cn\u005cnPlease read these instructions carefully and get the experimenter again when you\u005c're finished. Take as much time as you need.',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=1.5,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "instr_infer_practice"\u000ainstr_infer_practiceClock = core.Clock()\u000ainstr_infer_practice_txt = visual.TextStim(win=win, ori=0, name='instr_infer_practice_txt',\u000a    text=u'First, you\u005c'll do some practice trials. These are just for you to get used to the task; your responses won\u005c't count. \u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=1.5,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "instr_infer"\u000ainstr_inferClock = core.Clock()\u000ainstr_infer_txt = visual.TextStim(win=win, ori=0, name='instr_infer_txt',\u000a    text=u'Great! Now that you\u005c've done some practice trials, we\u005c're ready to start the real trials. Please call the experimenter into the room.',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=1.5,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "get_ready"\u000aget_readyClock = core.Clock()\u000aget_ready_text = visual.TextStim(win=win, ori=0, name='get_ready_text',\u000a    text=u'Get ready!',    font=u'Arial',\u000a    pos=[0, 0], height=0.12, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000aimg_left_infer = visual.ImageStim(win=win, name='img_left_infer',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[-0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=0.0)\u000aimg_right_infer = visual.ImageStim(win=win, name='img_right_infer',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=-1.0)\u000a\u000a# Initialize components for Routine "trial_post_response"\u000atrial_post_responseClock = core.Clock()\u000aselection_arrow_left = visual.TextStim(win=win, ori=0, name='selection_arrow_left',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[-0.5, -0.09], height=0.5, wrapWidth=None,\u000a    color=u'red', colorSpace=u'rgb', opacity=1,\u000a    depth=-2.0)\u000aselection_arrow_right = visual.TextStim(win=win, ori=0, name='selection_arrow_right',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[0.5, -0.09], height=0.5, wrapWidth=None,\u000a    color=u'red', colorSpace=u'rgb', opacity=1,\u000a    depth=-3.0)\u000afeedback_box_left = visual.Rect(win=win, name='feedback_box_left',\u000a    width=[0.9, 0.9][0], height=[0.9, 0.9][1],\u000a    ori=0, pos=[-0.5, 0],\u000a    lineWidth=5, lineColor=u'yellow', lineColorSpace=u'rgb',\u000a    fillColor=None, fillColorSpace=u'rgb',\u000a    opacity=1, depth=-4.0, interpolate=True)\u000afeedback_box_right = visual.Rect(win=win, name='feedback_box_right',\u000a    width=[0.9, 0.9][0], height=[0.9, 0.9][1],\u000a    ori=0, pos=[0.5, 0],\u000a    lineWidth=5, lineColor=u'yellow', lineColorSpace=u'rgb',\u000a    fillColor=None, fillColorSpace=u'rgb',\u000a    opacity=1, depth=-5.0, interpolate=True)\u000a\u000a# Initialize components for Routine "rest_prompt"\u000arest_promptClock = core.Clock()\u000arest_prompt_txt = visual.TextStim(win=win, ori=0, name='rest_prompt_txt',\u000a    text=u'Great! Now take a rest and press the space bar when you\u005cu2019re ready to begin the next block.',    font=u'Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create counters for the number of correct and incorrect guesses made by subjects to determine extra payment.\u000acorrect_counter = 0\u000aincorrect_counter = 0\u000a\u000a# Create list of lists to store binary choice and BDM data to generate food reward at the end of the experiment\u000aprefs = [['left', 'right', 'choice', 'bid']]\u000abids = [['item', 'bid']] # For the bids collected during the first BDM routine, at the beginning of the experiment\u000a\u000a### CHOICE & INFERENCE RANDOMIZATION ###\u000a\u000a# Define two functions to generate constrained pseudorandom sequences of item pair presentations for the binary choice and inference\u000a# parts of the task. The constraint ensures that the same pair of items does not appear twice in a row (flipped or not).\u000a# In the conditions spreadsheet that the item pairs are drawn from, the flipped version of the same item pair is 20\u000a# rows apart.\u000a\u000a# Binary choice randomization\u000adef genseq_choice():\u000a    done = False\u000a    while done==False:\u000a        counter = 0\u000a        ans = np.random.choice(40, 40, replace=False) # Generate a pseudorandom sequence of 40 numbers\u000a        for x in range(1,40):\u000a            if (ans[x]-ans[x-1]) % 20 == 0: # Is the difference between any sequential numbers divisible by 20?\u000a                counter += 1\u000a        if counter==0: # If not, end the loop and return the array\u000a            done = True\u000a            return ans\u000a        else: # If so, continue the loop and try again\u000a            done = False\u000a\u000a# Inference practice block randomization\u000adef genseq_infer_practice():\u000a    done = False\u000a    while done==False:\u000a        counter = 0\u000a        ans = np.random.choice(14, 14, replace=False) # Generate a pseudorandom sequence of 200 numbers\u000a        for x in range(1,14):\u000a            if (ans[x]-ans[x-1]) % 7 == 0: # Is the difference between any sequential numbers divisible by 20?\u000a                counter += 1\u000a        if counter==0: # If not, end the loop and return the array\u000a            done = True\u000a            return ans\u000a        else: # If so, continue the loop and try again\u000a            done = False\u000a\u000a# Inference randomization\u000adef genseq_infer():\u000a    done = False\u000a    while done==False:\u000a        counter = 0\u000a        ans = np.random.choice(200, 200, replace=False) # Generate a pseudorandom sequence of 200 numbers\u000a        for x in range(1,200):\u000a            if (ans[x]-ans[x-1]) % 20 == 0: # Is the difference between any sequential numbers divisible by 20?\u000a                counter += 1\u000a        if counter==0: # If not, end the loop and return the array\u000a            done = True\u000a            return ans\u000a        else: # If so, continue the loop and try again\u000a            done = False\u000a\u000a\u000a# Set independent sequences for each of the two choice blocks, the inference practice block, and the three inference rest blocks. Each rest block contains 10 presentations of\u000a# each pair.\u000a\u000achoiceseq = genseq_choice()\u000apracticeseq = genseq_infer_practice()\u000ablock1seq = genseq_infer()\u000ablock2seq = genseq_infer()\u000ablock3seq = genseq_infer()\u000a\u000a\u000a# Choose a pilot participant whose choices will form the basis of the learning task\u000apartners = ['P1','P2','P3','P4','P5','P6','P8','P9','P10','P11','P12'] # List of pilot participants, P7 excluded for perfectly inconsistent choices\u000apartner = np.random.choice(partners,1) # Choose one at random\u000apartner_file = 'conditions/choices/infer_design1_value_pairs_' + partner[0] + '.csv' # Path to that participant's choice data\u000a\u000a# Create separate CSV files, one for each choice, practice, and rest block, with the item pairs in the pseudorandomly generated order.\u000a# These CSV files will be used as PsychoPy's conditions spreadsheets and run sequentially in the choice, practice, and inference loops below.\u000a\u000a\u000achoicecond_src = pd.read_csv('conditions/choice_design1_binary.csv', index_col=None, header=0)\u000achoicecond = choicecond_src.copy()\u000afor x in range(40):\u000a    seq = choiceseq[x]\u000a    choicecond.iloc[x] = choicecond_src.iloc[seq]\u000achoicecond.to_csv(path_or_buf=filename+'_choicecond.csv', index=False)\u000a\u000apracticecond_src = pd.read_csv('conditions/choices/infer_design1_value_pairs_practice.csv', index_col=None, header=0)\u000apracticecond = practicecond_src.copy()\u000afor x in range(14):\u000a    seq = practiceseq[x]\u000a    practicecond.iloc[x] = practicecond_src.iloc[seq]\u000apracticecond.to_csv(path_or_buf=filename+'_practicecond.csv', index=False)\u000a\u000ablock1cond_src = pd.read_csv(partner_file, index_col=None, header=0)\u000ablock1cond = block1cond_src.copy()\u000afor x in range(200):\u000a    seq = block1seq[x]\u000a    block1cond.iloc[x] = block1cond_src.iloc[seq]\u000ablock1cond.to_csv(path_or_buf=filename+'_block1cond.csv', index=False)\u000a\u000ablock2cond_src = pd.read_csv(partner_file, index_col=None, header=0)\u000ablock2cond = block2cond_src.copy()\u000afor x in range(200):\u000a    seq = block2seq[x]\u000a    block2cond.iloc[x] = block2cond_src.iloc[seq]\u000ablock2cond.to_csv(path_or_buf=filename+'_block2cond.csv', index=False)\u000a\u000ablock3cond_src = pd.read_csv(partner_file, index_col=None, header=0)\u000ablock3cond = block3cond_src.copy()\u000afor x in range(200):\u000a    seq = block3seq[x]\u000a    block3cond.iloc[x] = block3cond_src.iloc[seq]\u000ablock3cond.to_csv(path_or_buf=filename+'_block3cond.csv', index=False)\u000a\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instr_main"-------\u000at = 0\u000ainstr_mainClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_main_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_main_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_mainComponents = []\u000ainstr_mainComponents.append(instr_main_txt)\u000ainstr_mainComponents.append(instr_main_resp)\u000afor thisComponent in instr_mainComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_main"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_mainClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_main_txt* updates\u000a    if t >= 0.0 and instr_main_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_main_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_main_txt.frameNStart = frameN  # exact frame index\u000a        instr_main_txt.setAutoDraw(True)\u000a    \u000a    # *instr_main_resp* updates\u000a    if t >= 5.0 and instr_main_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_main_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_main_resp.frameNStart = frameN  # exact frame index\u000a        instr_main_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_main_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_main_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_main_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_main_resp.rt = instr_main_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_mainComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_main"-------\u000afor thisComponent in instr_mainComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_main_resp.keys in ['', [], None]:  # No response was made\u000a   instr_main_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_main_resp.keys',instr_main_resp.keys)\u000aif instr_main_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_main_resp.rt', instr_main_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a\u000a#------Prepare to start Routine "instr_bdm"-------\u000at = 0\u000ainstr_bdmClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_bdm_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_bdm_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_bdmComponents = []\u000ainstr_bdmComponents.append(instr_bdm_txt)\u000ainstr_bdmComponents.append(instr_bdm_resp)\u000afor thisComponent in instr_bdmComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_bdm"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_bdmClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_bdm_txt* updates\u000a    if t >= 0.0 and instr_bdm_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_bdm_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_bdm_txt.frameNStart = frameN  # exact frame index\u000a        instr_bdm_txt.setAutoDraw(True)\u000a    \u000a    # *instr_bdm_resp* updates\u000a    if t >= 2.0 and instr_bdm_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_bdm_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_bdm_resp.frameNStart = frameN  # exact frame index\u000a        instr_bdm_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_bdm_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_bdm_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space', 's'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_bdm_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_bdm_resp.rt = instr_bdm_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_bdmComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_bdm"-------\u000afor thisComponent in instr_bdmComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_bdm_resp.keys in ['', [], None]:  # No response was made\u000a   instr_bdm_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_bdm_resp.keys',instr_bdm_resp.keys)\u000athisExp.addData('partnered_pilot_participant', partner)\u000aif instr_bdm_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_bdm_resp.rt', instr_bdm_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## BDM LOOP 1 ##########################\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000abdm_loop1 = data.TrialHandler(nReps=1, method=u'random', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'conditions/choice_design1_bdm.xlsx'),\u000a    seed=None, name='bdm_loop1')\u000athisExp.addLoop(bdm_loop1)  # add the loop to the experiment\u000athisbdm_loop1 = bdm_loop1.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisbdm_loop1.rgb)\u000aif thisbdm_loop1 != None:\u000a    for paramName in thisbdm_loop1.keys():\u000a        exec(paramName + '= thisbdm_loop1.' + paramName)\u000a\u000a# Check if the 'skip' key was pressed in the instructions routine; if so, end the loop and move on to the inference task\u000aif instr_bdm_resp.keys=='s':\u000a    bdm_loop1.finished = True\u000a\u000afor thisbdm_loop1 in bdm_loop1:\u000a    currentLoop = bdm_loop1\u000a    # abbreviate parameter names if possible (e.g. rgb = thisbdm_loop1.rgb)\u000a    if thisbdm_loop1 != None:\u000a        for paramName in thisbdm_loop1.keys():\u000a            exec(paramName + '= thisbdm_loop1.' + paramName)\u000a    \u000a    #------Prepare to start Routine "bdm"-------\u000a    t = 0\u000a    bdmClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    bdm_pic.setImage(dir_path+bdm_img)\u000a    bdm_bid.reset()\u000a    # jitter the starting position of the BDM scale from a uniform distribution between 1 and 2, rounded to the nearest decimal place\u000a    bdm_marker_start = float(np.round(np.random.uniform(1, 2, 1)[0], 1))\u000a    bdm_bid.setMarkerPos(bdm_marker_start)\u000a    # keep track of which components have finished\u000a    bdmComponents = []\u000a    bdmComponents.append(fixation_text)\u000a    bdmComponents.append(bdm_pic)\u000a    bdmComponents.append(bdm_bid)\u000a    for thisComponent in bdmComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "bdm"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = bdmClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation_text* updates\u000a        if t >= 0 and fixation_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation_text.tStart = t  # underestimates by a little under one frame\u000a            fixation_text.frameNStart = frameN  # exact frame index\u000a            fixation_text.setAutoDraw(True)\u000a        elif fixation_text.status == STARTED and t>= (0 + (1.0-win.monitorFramePeriod*0.75)):\u000a            fixation_text.setAutoDraw(False)\u000a\u000a        # *bdm_pic* updates\u000a        if t >= 1.0 and bdm_pic.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bdm_pic.tStart = t  # underestimates by a little under one frame\u000a            bdm_pic.frameNStart = frameN  # exact frame index\u000a            bdm_pic.setAutoDraw(True)\u000a        # *bdm_bid* updates\u000a        if t >= 1.0:\u000a            bdm_bid.draw()\u000a            continueRoutine = bdm_bid.noResponse\u000a            if bdm_bid.noResponse == False:\u000a                bdm_bid.response = bdm_bid.getRating()\u000a                bdm_bid.rt = bdm_bid.getRT()\u000a            elif bdm_bid.noResponse==True:\u000a                if keyState[key.LEFT]==True and bdm_bid.markerPlacedAt >0.01:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt - 0.02\u000a                    bdm_bid.draw()\u000a                elif keyState[key.LEFT]==True and bdm_bid.markerPlacedAt==0.01:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt - 0.01\u000a                    bdm_bid.draw()\u000a                elif keyState[key.RIGHT]==True and bdm_bid.markerPlacedAt <2.99:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt + 0.02\u000a                    bdm_bid.draw()\u000a                elif keyState[key.RIGHT]==True and bdm_bid.markerPlacedAt==2.99:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt + 0.01\u000a                    bdm_bid.draw()\u000a                    \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in bdmComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "bdm"-------\u000a    for thisComponent in bdmComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # store data for bdm (TrialHandler)\u000a    bdm_loop1.addData('bdm_bid1.response', bdm_bid.getRating())\u000a    bdm_loop1.addData('bdm_bid1.rt', bdm_bid.getRT())\u000a    bdm_loop1.addData('bdm_marker_start', bdm_marker_start)\u000a\u000a    # Add the item and the subject's bid to the 'bids' list, which will be merged with the 'prefs' list later in order to run the auction\u000a    bids.append([bdm_img, bdm_bid.response])\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeat of 'bdm_loop1'\u000a\u000a\u000a#------Prepare to start Routine "instr_choice"-------\u000at = 0\u000ainstr_choiceClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_choice_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_choice_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_choiceComponents = []\u000ainstr_choiceComponents.append(instr_choice_txt)\u000ainstr_choiceComponents.append(instr_choice_resp)\u000afor thisComponent in instr_choiceComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_choice"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_choiceClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_choice_txt* updates\u000a    if t >= 0.0 and instr_choice_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_choice_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_choice_txt.frameNStart = frameN  # exact frame index\u000a        instr_choice_txt.setAutoDraw(True)\u000a    \u000a    # *instr_choice_resp* updates\u000a    if t >= 2.0 and instr_choice_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_choice_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_choice_resp.frameNStart = frameN  # exact frame index\u000a        instr_choice_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_choice_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_choice_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space', 's'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_choice_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_choice_resp.rt = instr_choice_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_choiceComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_choice"-------\u000afor thisComponent in instr_choiceComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_choice_resp.keys in ['', [], None]:  # No response was made\u000a   instr_choice_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_choice_resp.keys',instr_choice_resp.keys)\u000aif instr_choice_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_choice_resp.rt', instr_choice_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## BINARY LOOP ##########################\u000a\u000a# set up handler to look after randomisation of conditions etc\u000abinary = data.TrialHandler(nReps=1, method=u'sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(filename+'_choicecond.csv'),\u000a    seed=None, name='binary')\u000athisExp.addLoop(binary)  # add the loop to the experiment\u000athisBinary1 = binary.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBinary1.rgb)\u000aif thisBinary1 != None:\u000a    for paramName in thisBinary1.keys():\u000a        exec(paramName + '= thisBinary1.' + paramName)\u000a\u000a# Check if the 'skip' key was pressed in the instructions routine; if so, end the loop and move on to the BDM\u000aif instr_choice_resp.keys=='s':\u000a    binary.finished = True\u000a\u000afor thisBinary1 in binary:\u000a    currentLoop = binary\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBinary1.rgb)\u000a    if thisBinary1 != None:\u000a        for paramName in thisBinary1.keys():\u000a            exec(paramName + '= thisBinary1.' + paramName)\u000a    \u000a    #------Prepare to start Routine "choice"-------\u000a    t = 0\u000a    choiceClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    choice_pic_left.setImage(dir_path+choice_left)\u000a    choice_pic_right.setImage(dir_path+choice_right)\u000a    event.clearEvents(eventType='keyboard') # Clear keyboard event log to avoid last key press from prior loop being used\u000a    key_resp_choice = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_choice.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    choiceComponents = []\u000a    choiceComponents.append(fixation_text)\u000a    choiceComponents.append(choice_pic_left)\u000a    choiceComponents.append(choice_pic_right)\u000a    choiceComponents.append(key_resp_choice)\u000a    for thisComponent in choiceComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    \u000a    #-------Start Routine "choice"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = choiceClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation_text* updates\u000a        if t >= 0 and fixation_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation_text.tStart = t  # underestimates by a little under one frame\u000a            fixation_text.frameNStart = frameN  # exact frame index\u000a            fixation_text.setAutoDraw(True)\u000a        elif fixation_text.status == STARTED and t>= (0 + (1.0-win.monitorFramePeriod*0.75)):\u000a            fixation_text.setAutoDraw(False)\u000a\u000a        # *choice_pic_left* updates\u000a        if t >= 1.0 and choice_pic_left.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_left.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_left.frameNStart = frameN  # exact frame index\u000a            choice_pic_left.setAutoDraw(True)\u000a        \u000a        # *choice_pic_right* updates\u000a        if t >= 1.0 and choice_pic_right.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_right.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_right.frameNStart = frameN  # exact frame index\u000a            choice_pic_right.setAutoDraw(True)\u000a\u000a        # *key_resp_choice* updates\u000a        if t >= 1.0 and key_resp_choice.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_choice.tStart = t  # underestimates by a little under one frame\u000a            key_resp_choice.frameNStart = frameN  # exact frame index\u000a            key_resp_choice.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_choice.clock.reset()  # now t=0\u000a        if key_resp_choice.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_choice.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_choice.rt = key_resp_choice.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in choiceComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "choice"-------\u000a    for thisComponent in choiceComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_choice.keys in ['', [], None]:  # No response was made\u000a       key_resp_choice.keys=None\u000a    # store data for binary (TrialHandler)\u000a    binary.addData('key_resp_choice.keys',key_resp_choice.keys)\u000a    if key_resp_choice.keys != None:  # we had a response\u000a        binary.addData('key_resp_choice.rt', key_resp_choice.rt)\u000a\u000a    # define a function to append binary choices and the bid for the chosen item to the preference list\u000a    # lft is the left image displayed during that choice trial\u000a    # rt is the right image displayed\u000a    def rec_choice(lft, rt): \u000a        bd = False\u000a        if key_resp_choice.keys=='left':\u000a            chc = lft\u000a        elif key_resp_choice.keys=='right':\u000a            chc = rt\u000a        for x in range(len(bids)):\u000a            if bids[x][0]==chc:\u000a                bd = bids[x][1]\u000a        prefs.append([lft, rt, chc, bd])\u000a\u000a    # call the function\u000a    rec_choice(choice_left, choice_right)\u000a    \u000a\u000a    #------Prepare to start Routine "choice_selection"-------\u000a    t = 0\u000a    choice_selectionClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # keep track of which components have finished\u000a    choice_selectionComponents = []\u000a    choice_selectionComponents.append(choice_pic_left)\u000a    choice_selectionComponents.append(choice_pic_right)\u000a    choice_selectionComponents.append(star_left_selection)\u000a    choice_selectionComponents.append(star_right_selection)\u000a    for thisComponent in choice_selectionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "choice_selection"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = choice_selectionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *choice_pic_left* updates\u000a        if t >= 0.0 and choice_pic_left.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_left.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_left.frameNStart = frameN  # exact frame index\u000a            choice_pic_left.setAutoDraw(True)\u000a        elif choice_pic_left.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            choice_pic_left.setAutoDraw(False)\u000a        \u000a        # *choice_pic_right* updates\u000a        if t >= 0.0 and choice_pic_right.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_right.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_right.frameNStart = frameN  # exact frame index\u000a            choice_pic_right.setAutoDraw(True)\u000a        elif choice_pic_right.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            choice_pic_right.setAutoDraw(False)\u000a        \u000a        # *star_left_selection* updates\u000a        if key_resp_choice.keys=='left':\u000a            if t >= 0.0 and star_left_selection.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                star_left_selection.tStart = t  # underestimates by a little under one frame\u000a                star_left_selection.frameNStart = frameN  # exact frame index\u000a                star_left_selection.setAutoDraw(True)\u000a            elif star_left_selection.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                star_left_selection.setAutoDraw(False)\u000a        \u000a        # *star_right_selection* updates\u000a        if key_resp_choice.keys=='right':\u000a            if t >= 0.0 and star_right_selection.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                star_right_selection.tStart = t  # underestimates by a little under one frame\u000a                star_right_selection.frameNStart = frameN  # exact frame index\u000a                star_right_selection.setAutoDraw(True)\u000a            elif star_right_selection.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                star_right_selection.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in choice_selectionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "choice_selection"-------\u000a    for thisComponent in choice_selectionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    #thisExp.nextEntry()\u000a\u000a    #------Prepare to start Routine "confidence"-------\u000a    t = 0\u000a    confidenceClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    confidence_rating.reset()\u000a    # jitter the starting position of the confidence rating scale from a uniform distribution between 1.7 and 3.3 (the middle third of the scale), rounded to the nearest decimal place\u000a    confidence_marker_start = float(np.round(np.random.uniform(1.7, 3.3, 1)[0], 1))\u000a    confidence_rating.setMarkerPos(confidence_marker_start)\u000a    # keep track of which components have finished\u000a    confidenceComponents = []\u000a    confidenceComponents.append(confidence_rating)\u000a    for thisComponent in confidenceComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "confidence"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = confidenceClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *confidence_rating* updates\u000a        if t > 0.5:\u000a            confidence_rating.draw()\u000a            continueRoutine = confidence_rating.noResponse\u000a            if confidence_rating.noResponse == False:\u000a                confidence_rating.response = confidence_rating.getRating()\u000a                confidence_rating.rt = confidence_rating.getRT()\u000a            elif confidence_rating.noResponse==True:\u000a                if keyState[key.LEFT]==True and confidence_rating.markerPlacedAt >0:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt - 0.1\u000a                    confidence_rating.draw()\u000a                elif keyState[key.LEFT]==True and confidence_rating.markerPlacedAt==0.1:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt - 0.1\u000a                    confidence_rating.draw()\u000a                elif keyState[key.RIGHT]==True and confidence_rating.markerPlacedAt <4.9:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt + 0.1\u000a                    confidence_rating.draw()\u000a                elif keyState[key.RIGHT]==True and confidence_rating.markerPlacedAt==4.9:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt + 0.1\u000a                    confidence_rating.draw()\u000a                    \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in confidenceComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "confidence"-------\u000a    for thisComponent in confidenceComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # store data for confidence (TrialHandler)\u000a    binary.addData('confidence_rating1.response', confidence_rating.getRating())\u000a    binary.addData('confidence_rating1.rt', confidence_rating.getRT())\u000a    binary.addData('confidence_marker_start', confidence_marker_start+1) # Add 1 to convert from 0-5 to 1-6 scale\u000a\u000a    thisExp.nextEntry()\u000a\u000a\u000a# completed 1 repeat of 'binary'        \u000a\u000a#------Prepare to start Routine "instr_infer_intro"-------\u000at = 0\u000ainstr_infer_introClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_infer_intro_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_infer_intro_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_infer_introComponents = []\u000ainstr_infer_introComponents.append(instr_infer_intro_txt)\u000ainstr_infer_introComponents.append(instr_infer_intro_resp)\u000afor thisComponent in instr_infer_introComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_infer_intro"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_infer_introClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_infer_intro_txt* updates\u000a    if t >= 0.0 and instr_infer_intro_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_intro_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_intro_txt.frameNStart = frameN  # exact frame index\u000a        instr_infer_intro_txt.setAutoDraw(True)\u000a    \u000a    # *instr_infer_intro_resp* updates\u000a    if t >= 5.0 and instr_infer_intro_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_intro_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_intro_resp.frameNStart = frameN  # exact frame index\u000a        instr_infer_intro_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_infer_intro_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_infer_intro_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_infer_intro_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_infer_intro_resp.rt = instr_infer_intro_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_infer_introComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_infer_intro"-------\u000afor thisComponent in instr_infer_introComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_infer_intro_resp.keys in ['', [], None]:  # No response was made\u000a   instr_infer_intro_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_infer_intro_resp.keys',instr_infer_intro_resp.keys)\u000aif instr_infer_intro_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_infer_intro_resp.rt', instr_infer_intro_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a#------Prepare to start Routine "instr_infer_practice"-------\u000at = 0\u000ainstr_infer_practiceClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_infer_practice_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_infer_practice_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_infer_practiceComponents = []\u000ainstr_infer_practiceComponents.append(instr_infer_practice_txt)\u000ainstr_infer_practiceComponents.append(instr_infer_practice_resp)\u000afor thisComponent in instr_infer_practiceComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_infer_practice"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_infer_practiceClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_infer_practice_txt* updates\u000a    if t >= 0.0 and instr_infer_practice_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_practice_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_practice_txt.frameNStart = frameN  # exact frame index\u000a        instr_infer_practice_txt.setAutoDraw(True)\u000a    \u000a    # *instr_infer_practice_resp* updates\u000a    if t >= 5.0 and instr_infer_practice_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_practice_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_practice_resp.frameNStart = frameN  # exact frame index\u000a        instr_infer_practice_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_infer_practice_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_infer_practice_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_infer_practice_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_infer_practice_resp.rt = instr_infer_practice_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_infer_practiceComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_infer_practice"-------\u000afor thisComponent in instr_infer_practiceComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_infer_practice_resp.keys in ['', [], None]:  # No response was made\u000a   instr_infer_practice_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_infer_practice_resp.keys',instr_infer_practice_resp.keys)\u000aif instr_infer_practice_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_infer_practice_resp.rt', instr_infer_practice_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## PRACTICE LOOP ##########################\u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_loop = data.TrialHandler(nReps=1, method=u'sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(filename+'_practicecond.csv'),\u000a    seed=None, name='practice_loop')\u000athisExp.addLoop(practice_loop)  # add the loop to the experiment\u000athisPractice_loop = practice_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_loop.rgb)\u000aif thisPractice_loop != None:\u000a    for paramName in thisPractice_loop.keys():\u000a        exec(paramName + '= thisPractice_loop.' + paramName)\u000a\u000a  \u000afor thisPractice_loop in practice_loop:\u000a    currentLoop = practice_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_loop.rgb)\u000a    if thisPractice_loop != None:\u000a        for paramName in thisPractice_loop.keys():\u000a            exec(paramName + '= thisPractice_loop.' + paramName)    \u000a    \u000a        \u000a    # Define class for setting the feedback image\u000a    class set_feedback:\u000a        options = ['correct', 'wrong']\u000a        feedback = np.random.choice(options, replace=True, p=[0.8, 0.2])\u000a        if feedback=='correct':\u000a            feedback_img = img_correct\u000a        elif feedback=='wrong':\u000a            feedback_img = img_wrong\u000a\u000a        if feedback_img==img_left:\u000a            feedback_side = 'left'\u000a        elif feedback_img==img_right:\u000a            feedback_side = 'right'\u000a\u000a\u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialtime = datetime.datetime.now()\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    img_left_infer.setImage(dir_path+img_left)\u000a    img_right_infer.setImage(dir_path+img_right)\u000a    infer_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    infer_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(fixation_text)\u000a    trialComponents.append(img_left_infer)\u000a    trialComponents.append(img_right_infer)\u000a    trialComponents.append(infer_resp)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation_text* updates\u000a        if t >= 0 and fixation_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation_text.tStart = t  # underestimates by a little under one frame\u000a            fixation_text.frameNStart = frameN  # exact frame index\u000a            fixation_text.setAutoDraw(True)\u000a        elif fixation_text.status == STARTED and t>= (0 + (2.0-win.monitorFramePeriod*0.75)):\u000a            fixation_text.setAutoDraw(False)\u000a\u000a        # *img_left_infer* updates\u000a        if t >= 2.0 and img_left_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_left_infer.tStart = t  # underestimates by a little under one frame\u000a            img_left_infer.frameNStart = frameN  # exact frame index\u000a            img_left_infer.setAutoDraw(True)\u000a        \u000a        # *img_right_infer* updates\u000a        if t >= 2.0 and img_right_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_right_infer.tStart = t  # underestimates by a little under one frame\u000a            img_right_infer.frameNStart = frameN  # exact frame index\u000a            img_right_infer.setAutoDraw(True)\u000a                  \u000a        # *infer_resp* updates\u000a        if t >= 2.0 and infer_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            infer_resp.tStart = t  # underestimates by a little under one frame\u000a            infer_resp.frameNStart = frameN  # exact frame index\u000a            infer_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            infer_resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if infer_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                infer_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                infer_resp.rt = infer_resp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a\u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if infer_resp.keys in ['', [], None]:  # No response was made\u000a       infer_resp.keys=None\u000a    # # store data for practice_loop (TrialHandler)\u000a    # practice_loop.addData('infer_resp.keys',infer_resp.keys)\u000a    # if infer_resp.keys != None:  # we had a response\u000a    #     practice_loop.addData('infer_resp.rt', infer_resp.rt)\u000a    practice_loop.addData('set_feedback.feedback_img', set_feedback.feedback_img)\u000a    practice_loop.addData('trial_start_time', trialtime)\u000a    \u000a    # # Increase correct and incorrect response counters by 1 based on S's response\u000a    # if infer_resp.keys=='left' and img_correct==img_left:\u000a    #     correct_counter += 1\u000a    # elif infer_resp.keys=='left' and img_correct==img_right:\u000a    #     incorrect_counter += 1\u000a    # elif infer_resp.keys=='right' and img_correct==img_right:\u000a    #     correct_counter += 1\u000a    # elif infer_resp.keys=='right' and img_correct==img_left:\u000a    #     incorrect_counter += 1\u000a    \u000a\u000a    #------Prepare to start Routine "trial_post_response"-------\u000a    t = 0\u000a    trial_post_responseClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(3.000000)\u000a    # keep track of which components have finished\u000a    trial_post_responseComponents = []\u000a    trial_post_responseComponents.append(img_left_infer)\u000a    trial_post_responseComponents.append(img_right_infer)\u000a    trial_post_responseComponents.append(selection_arrow_left)\u000a    trial_post_responseComponents.append(selection_arrow_right)\u000a    trial_post_responseComponents.append(feedback_box_left)\u000a    trial_post_responseComponents.append(feedback_box_right)\u000a    for thisComponent in trial_post_responseComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial_post_response"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = trial_post_responseClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a\u000a        # *img_left_infer* updates\u000a        if t >= 0.0 and img_left_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_left_infer.tStart = t  # underestimates by a little under one frame\u000a            img_left_infer.frameNStart = frameN  # exact frame index\u000a            img_left_infer.setAutoDraw(True)\u000a        elif img_left_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            img_left_infer.setAutoDraw(False)\u000a        \u000a        # *img_right_infer* updates\u000a        if t >= 0.0 and img_right_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_right_infer.tStart = t  # underestimates by a little under one frame\u000a            img_right_infer.frameNStart = frameN  # exact frame index\u000a            img_right_infer.setAutoDraw(True)\u000a        elif img_right_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            img_right_infer.setAutoDraw(False)\u000a        \u000a        if infer_resp.keys == 'left':\u000a            # *selection_arrow_left* updates\u000a            if t >= 0.0 and selection_arrow_left.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                selection_arrow_left.tStart = t  # underestimates by a little under one frame\u000a                selection_arrow_left.frameNStart = frameN  # exact frame index\u000a                selection_arrow_left.setAutoDraw(True)\u000a            elif selection_arrow_left.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                selection_arrow_left.setAutoDraw(False)\u000a        \u000a        if infer_resp.keys == 'right':\u000a            # *selection_arrow_right* updates\u000a            if t >= 0.0 and selection_arrow_right.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                selection_arrow_right.tStart = t  # underestimates by a little under one frame\u000a                selection_arrow_right.frameNStart = frameN  # exact frame index\u000a                selection_arrow_right.setAutoDraw(True)\u000a            elif selection_arrow_right.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                selection_arrow_right.setAutoDraw(False)\u000a        \u000a        if set_feedback.feedback_side == 'left':\u000a            # *feedback_box_left* updates\u000a            if t >= 1.0 and feedback_box_left.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                feedback_box_left.tStart = t  # underestimates by a little under one frame\u000a                feedback_box_left.frameNStart = frameN  # exact frame index\u000a                feedback_box_left.setAutoDraw(True)\u000a            elif feedback_box_left.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                feedback_box_left.setAutoDraw(False)\u000a        \u000a        if set_feedback.feedback_side == 'right':\u000a            # *feedback_box_right* updates\u000a            if t >= 1.0 and feedback_box_right.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                feedback_box_right.tStart = t  # underestimates by a little under one frame\u000a                feedback_box_right.frameNStart = frameN  # exact frame index\u000a                feedback_box_right.setAutoDraw(True)\u000a            elif feedback_box_right.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period right\u000a                feedback_box_right.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trial_post_responseComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "trial_post_response"-------\u000a    for thisComponent in trial_post_responseComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000a    \u000a    thisExp.nextEntry()\u000a                        \u000a# completed 1 repeat of 'practice_loop'\u000a\u000a\u000a#------Prepare to start Routine "instr_infer"-------\u000at = 0\u000ainstr_inferClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_infer_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_infer_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_inferComponents = []\u000ainstr_inferComponents.append(instr_infer_txt)\u000ainstr_inferComponents.append(instr_infer_resp)\u000afor thisComponent in instr_inferComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_infer"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_inferClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_infer_txt* updates\u000a    if t >= 0.0 and instr_infer_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_txt.frameNStart = frameN  # exact frame index\u000a        instr_infer_txt.setAutoDraw(True)\u000a    \u000a    # *instr_infer_resp* updates\u000a    if t >= 5.0 and instr_infer_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_resp.frameNStart = frameN  # exact frame index\u000a        instr_infer_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_infer_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_infer_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_infer_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_infer_resp.rt = instr_infer_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_inferComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_infer"-------\u000afor thisComponent in instr_inferComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_infer_resp.keys in ['', [], None]:  # No response was made\u000a   instr_infer_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_infer_resp.keys',instr_infer_resp.keys)\u000aif instr_infer_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_infer_resp.rt', instr_infer_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## BLOCK LOOP ##########################\u000a\u000a# This loop runs a second nested loop that shows each item pair 10 times, followed by a rest break prompt.\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=3, method=u'sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=[None],\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000a# Set up counter to keep track of block loop cycle, so that the rest prompt is only shown twice\u000ablock_loop_counter = 0\u000a\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    # Increase loop counter by one\u000a    block_loop_counter += 1\u000a    \u000a    # Change the condition file for the feedback block based on which block loop we're on\u000a    condfilename = filename+u'_block'+str(block_loop_counter)+u'cond.csv'\u000a    \u000a    # # Minimize the psychopy window so the calibration window can be seen\u000a    # win.winHandle.minimize()\u000a    # #Do the eye tracker setup at the beginning of each block\u000a    # tracker.runSetupProcedure()\u000a    # # Re-display the psychopy window after setup is completed\u000a    # win.winHandle.maximize()\u000a    # win.winHandle.activate()\u000a    \u000a\u000a    \u000a    #------Prepare to start Routine "get_ready"-------\u000a    t = 0\u000a    get_readyClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(3.000000)\u000a    # update component parameters for each repeat\u000a    get_ready_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    get_ready_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    get_readyComponents = []\u000a    get_readyComponents.append(get_ready_text)\u000a    get_readyComponents.append(get_ready_resp)\u000a    for thisComponent in get_readyComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    \u000a    #-------Start Routine "get_ready"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = get_readyClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *get_ready_text* updates\u000a        if t >= 0.0 and get_ready_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            get_ready_text.tStart = t  # underestimates by a little under one frame\u000a            get_ready_text.frameNStart = frameN  # exact frame index\u000a            get_ready_text.setAutoDraw(True)\u000a        \u000a        # *get_ready_resp* updates\u000a        if t >= 0.0 and get_ready_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            get_ready_resp.tStart = t  # underestimates by a little under one frame\u000a            get_ready_resp.frameNStart = frameN  # exact frame index\u000a            get_ready_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            get_ready_resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if get_ready_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['p'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                get_ready_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                get_ready_resp.rt = get_ready_resp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in get_readyComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "get_ready"-------\u000a    for thisComponent in get_readyComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if get_ready_resp.keys in ['', [], None]:  # No response was made\u000a       get_ready_resp.keys=None\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('get_ready_resp.keys',get_ready_resp.keys)\u000a    if get_ready_resp.keys != None:  # we had a response\u000a        thisExp.addData('get_ready_resp.rt', get_ready_resp.rt)\u000a    thisExp.nextEntry()\u000a\u000a    ######################## TRIAL LOOP ##########################\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    trial_loop = data.TrialHandler(nReps=1, method=u'sequential', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(condfilename),\u000a        seed=None, name='trial_loop')\u000a    thisExp.addLoop(trial_loop)  # add the loop to the experiment\u000a    thisTrial_loop = trial_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_loop.rgb)\u000a    if thisTrial_loop != None:\u000a        for paramName in thisTrial_loop.keys():\u000a            exec(paramName + '= thisTrial_loop.' + paramName)\u000a    \u000a      \u000a    for thisTrial_loop in trial_loop:\u000a        currentLoop = trial_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_loop.rgb)\u000a        if thisTrial_loop != None:\u000a            for paramName in thisTrial_loop.keys():\u000a                exec(paramName + '= thisTrial_loop.' + paramName)    \u000a        \u000a            \u000a        # Define class for setting the feedback image\u000a        class set_feedback:\u000a            options = ['correct', 'wrong']\u000a            feedback = np.random.choice(options, replace=True, p=[0.8, 0.2])\u000a            if feedback=='correct':\u000a                feedback_img = img_correct\u000a            elif feedback=='wrong':\u000a                feedback_img = img_wrong\u000a\u000a            if feedback_img==img_left:\u000a                feedback_side = 'left'\u000a            elif feedback_img==img_right:\u000a                feedback_side = 'right'\u000a                        \u000a        # # Start getting data from the eye tracker\u000a        # tracker.enableEventReporting(True)\u000a        # # Send beginning-of-trial messages to eye tracker data file\u000a        # trial_number = (block_loop.thisN * 200) + trial_loop.thisTrialN # Trial number out of 599 (starts at 0)\u000a        # tracker.sendCommand("record_status_message 'INFERRING, Block %d/3, Trial %d/600 '" % (block_loop.thisN + 1, trial_number + 1))\u000a        # tracker.sendMessage("TRIALID %d" % trial_number)\u000a        # tracker.sendMessage("!V TRIAL_VAR_DATA %d" % trial_number)\u000a\u000a        \u000a        #------Prepare to start Routine "trial"-------\u000a        t = 0\u000a        trialtime = datetime.datetime.now()\u000a        trialClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        img_left_infer.setImage(dir_path+img_left)\u000a        img_right_infer.setImage(dir_path+img_right)\u000a        infer_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        infer_resp.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trialComponents = []\u000a        trialComponents.append(fixation_text)\u000a        trialComponents.append(img_left_infer)\u000a        trialComponents.append(img_right_infer)\u000a        trialComponents.append(infer_resp)\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        # Set indicator variable for whether eye tracker messages were sent during the first loop of the routine\u000a        eye_sync_messages_sent = 0\u000a        \u000a        #-------Start Routine "trial"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = trialClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *fixation_text* updates\u000a            if t >= 0 and fixation_text.status == NOT_STARTED:\u000a                if eye_sync_messages_sent==0:\u000a                    startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                # keep track of start time/frame for later\u000a                fixation_text.tStart = t  # underestimates by a little under one frame\u000a                fixation_text.frameNStart = frameN  # exact frame index\u000a                fixation_text.setAutoDraw(True)\u000a                if eye_sync_messages_sent==0:\u000a                    drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                    # tracker.sendMessage("%d DISPLAY ON" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                    # tracker.sendMessage("SYNCTIME %d" %drawTime)\u000a                    eye_sync_messages_sent = 1\u000a            elif fixation_text.status == STARTED and t>= (0 + (2.0-win.monitorFramePeriod*0.75)):\u000a                fixation_text.setAutoDraw(False)\u000a            \u000a            # *img_left_infer* updates\u000a            if t >= 2.0 and img_left_infer.status == NOT_STARTED:\u000a                if eye_sync_messages_sent==1:\u000a                    startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                # keep track of start time/frame for later\u000a                img_left_infer.tStart = t  # underestimates by a little under one frame\u000a                img_left_infer.frameNStart = frameN  # exact frame index\u000a                img_left_infer.setAutoDraw(True)\u000a            \u000a            # *img_right_infer* updates\u000a            if t >= 2.0 and img_right_infer.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                img_right_infer.tStart = t  # underestimates by a little under one frame\u000a                img_right_infer.frameNStart = frameN  # exact frame index\u000a                img_right_infer.setAutoDraw(True)\u000a                if eye_sync_messages_sent==1:\u000a                    drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                    # tracker.sendMessage("%d DISPLAY ON ITEMS" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                    eye_sync_messages_sent = 2\u000a                      \u000a            # *infer_resp* updates\u000a            if t >= 2.0 and infer_resp.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                infer_resp.tStart = t  # underestimates by a little under one frame\u000a                infer_resp.frameNStart = frameN  # exact frame index\u000a                infer_resp.status = STARTED\u000a                # keyboard checking is just starting\u000a                infer_resp.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            if infer_resp.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['left', 'right'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    infer_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                    infer_resp.rt = infer_resp.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trialComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                # tracker.enableEventReporting(False) # End eye tracker data recording\u000a                # tracker.sendMessage("EXPERIMENT ABORTED")\u000a                # io.quit() # Close iohub\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial"-------\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if infer_resp.keys in ['', [], None]:  # No response was made\u000a           infer_resp.keys=None\u000a        # store data for trial_loop (TrialHandler)\u000a        trial_loop.addData('infer_resp.keys',infer_resp.keys)\u000a        if infer_resp.keys != None:  # we had a response\u000a            trial_loop.addData('infer_resp.rt', infer_resp.rt)\u000a        trial_loop.addData('set_feedback.feedback_img', set_feedback.feedback_img)\u000a        trial_loop.addData('trial_start_time', trialtime)\u000a        \u000a        # Increase correct and incorrect response counters by 1 based on S's response\u000a        if infer_resp.keys=='left' and img_correct==img_left:\u000a            correct_counter += 1\u000a        elif infer_resp.keys=='left' and img_correct==img_right:\u000a            incorrect_counter += 1\u000a        elif infer_resp.keys=='right' and img_correct==img_right:\u000a            correct_counter += 1\u000a        elif infer_resp.keys=='right' and img_correct==img_left:\u000a            incorrect_counter += 1\u000a        \u000a\u000a        #------Prepare to start Routine "trial_post_response"-------\u000a        t = 0\u000a        trial_post_responseClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(3.000000)\u000a        # keep track of which components have finished\u000a        trial_post_responseComponents = []\u000a        trial_post_responseComponents.append(img_left_infer)\u000a        trial_post_responseComponents.append(img_right_infer)\u000a        trial_post_responseComponents.append(selection_arrow_left)\u000a        trial_post_responseComponents.append(selection_arrow_right)\u000a        trial_post_responseComponents.append(feedback_box_left)\u000a        trial_post_responseComponents.append(feedback_box_right)\u000a        for thisComponent in trial_post_responseComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        # Set indicator variable for whether eye tracker messages were sent during the first loop of the routine\u000a        eye_sync_messages_sent = 0\u000a\u000a        #-------Start Routine "trial_post_response"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = trial_post_responseClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a\u000a            # *img_left_infer* updates\u000a            if t >= 0.0 and img_left_infer.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                img_left_infer.tStart = t  # underestimates by a little under one frame\u000a                img_left_infer.frameNStart = frameN  # exact frame index\u000a                img_left_infer.setAutoDraw(True)\u000a            elif img_left_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                img_left_infer.setAutoDraw(False)\u000a            \u000a            # *img_right_infer* updates\u000a            if t >= 0.0 and img_right_infer.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                img_right_infer.tStart = t  # underestimates by a little under one frame\u000a                img_right_infer.frameNStart = frameN  # exact frame index\u000a                img_right_infer.setAutoDraw(True)\u000a            elif img_right_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                img_right_infer.setAutoDraw(False)\u000a            \u000a            if infer_resp.keys == 'left':\u000a                # *selection_arrow_left* updates\u000a                if t >= 0.0 and selection_arrow_left.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==0:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    selection_arrow_left.tStart = t  # underestimates by a little under one frame\u000a                    selection_arrow_left.frameNStart = frameN  # exact frame index\u000a                    selection_arrow_left.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==0:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        # tracker.sendMessage("%d DISPLAY ON SELECTION" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 1\u000a                elif selection_arrow_left.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    if eye_sync_messages_sent==1:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    selection_arrow_left.setAutoDraw(False)\u000a                    if eye_sync_messages_sent==1:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        # tracker.sendMessage("%d DISPLAY ON SELECTION OFF" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 2\u000a            \u000a            if infer_resp.keys == 'right':\u000a                # *selection_arrow_right* updates\u000a                if t >= 0.0 and selection_arrow_right.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==0:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    selection_arrow_right.tStart = t  # underestimates by a little under one frame\u000a                    selection_arrow_right.frameNStart = frameN  # exact frame index\u000a                    selection_arrow_right.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==0:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        # tracker.sendMessage("%d DISPLAY ON SELECTION" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 1\u000a                elif selection_arrow_right.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    if eye_sync_messages_sent==1:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    selection_arrow_right.setAutoDraw(False)\u000a                    if eye_sync_messages_sent==1:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        # tracker.sendMessage("%d DISPLAY ON SELECTION OFF" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 2\u000a            \u000a            if set_feedback.feedback_side == 'left':\u000a                # *feedback_box_left* updates\u000a                if t >= 1.0 and feedback_box_left.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==2:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    feedback_box_left.tStart = t  # underestimates by a little under one frame\u000a                    feedback_box_left.frameNStart = frameN  # exact frame index\u000a                    feedback_box_left.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==2:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        # tracker.sendMessage("%d DISPLAY ON FEEDBACK" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 3\u000a                elif feedback_box_left.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    feedback_box_left.setAutoDraw(False)\u000a            \u000a            if set_feedback.feedback_side == 'right':\u000a                # *feedback_box_right* updates\u000a                if t >= 1.0 and feedback_box_right.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==2:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    feedback_box_right.tStart = t  # underestimates by a little under one frame\u000a                    feedback_box_right.frameNStart = frameN  # exact frame index\u000a                    feedback_box_right.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==2:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        # tracker.sendMessage("%d DISPLAY ON FEEDBACK" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 3\u000a                elif feedback_box_right.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period right\u000a                    feedback_box_right.setAutoDraw(False)\u000a\u000a\u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial_post_responseComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                # tracker.enableEventReporting(False) # End eye tracker data recording\u000a                # tracker.sendMessage("EXPERIMENT ABORTED")\u000a                # io.quit() # Close iohub\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "trial_post_response"-------\u000a        for thisComponent in trial_post_responseComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a        thisExp.nextEntry()\u000a                            \u000a    # completed 5 repeats of 'trial_loop'\u000a    \u000a    if block_loop_counter <= 2: # If this is the first or second cycle of the loop, display the rest break prompt\u000a\u000a        #------Prepare to start Routine "rest_prompt"-------\u000a        t = 0\u000a        rest_promptClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        rest_prompt_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        rest_prompt_resp.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        rest_promptComponents = []\u000a        rest_promptComponents.append(rest_prompt_txt)\u000a        rest_promptComponents.append(rest_prompt_resp)\u000a        for thisComponent in rest_promptComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a\u000a        #-------Start Routine "rest_prompt"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = rest_promptClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *rest_prompt_txt* updates\u000a            if t >= 0.0 and rest_prompt_txt.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                rest_prompt_txt.tStart = t  # underestimates by a little under one frame\u000a                rest_prompt_txt.frameNStart = frameN  # exact frame index\u000a                rest_prompt_txt.setAutoDraw(True)\u000a            \u000a            # *rest_prompt_resp* updates\u000a            if t >= 2.0 and rest_prompt_resp.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                rest_prompt_resp.tStart = t  # underestimates by a little under one frame\u000a                rest_prompt_resp.frameNStart = frameN  # exact frame index\u000a                rest_prompt_resp.status = STARTED\u000a                # keyboard checking is just starting\u000a                rest_prompt_resp.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            if rest_prompt_resp.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    rest_prompt_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                    rest_prompt_resp.rt = rest_prompt_resp.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in rest_promptComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                # tracker.enableEventReporting(False) # End eye tracker data recording\u000a                # tracker.sendMessage("EXPERIMENT ABORTED")\u000a                # io.quit() # CLose iohub\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a\u000a        #-------Ending Routine "rest_prompt"-------\u000a        for thisComponent in rest_promptComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if rest_prompt_resp.keys in ['', [], None]:  # No response was made\u000a           rest_prompt_resp.keys=None\u000a        # store data for thisExp (ExperimentHandler)\u000a        thisExp.addData('rest_prompt_resp.keys',rest_prompt_resp.keys)\u000a        if rest_prompt_resp.keys != None:  # we had a response\u000a            thisExp.addData('rest_prompt_resp.rt', rest_prompt_resp.rt)\u000a\u000a\u000a    thisExp.nextEntry()\u000a    \u000a# completed 3 repeats of 'block_loop'\u000a\u000a\u000a# store data for total number of correct and incorrect responses    \u000athisExp.addData('correct_counter', correct_counter)\u000athisExp.addData('incorrect_counter', incorrect_counter)\u000athisExp.nextEntry()     \u000a\u000a# tracker.setConnectionState(False) # Close and transfer eye-tracking data, then close down eye tracker connection\u000a\u000a\u000a######################## AUCTION ##########################\u000a\u000aif len(prefs)==41 and len(bids)==41: # If S completed the entire binary choice and BDM routines, run the auction\u000a\u000a    # run the auction\u000a    class auction:\u000a        rand_itm = randint(1, (len(prefs))) # pick index for S's chosen item from a random choice\u000a        price = float((randint(1, 300)))/100 # assign a price to the item randomly from between 0.01 and 3 pounds\u000a        bid = prefs[rand_itm][3]\u000a        # check if S's bid for that item was above or below the price\u000a        if bid >= price:\u000a            win_item=True\u000a        elif bid < price:\u000a            win_item=False\u000a\u000a        # set text for the auction screen\u000a        if win_item==True:\u000a            auc_res_txt = u'Congratulations! You won the following item at auction. \u005cnThis was your preferred item out of a randomly selected pair from one of the choice tasks.'\u000a            auc_prc_txt = u'Your bid of \u005cxa3' + '{0:.2f}'.format(bid) + u' matched or exceeded the randomly generated price of \u005cxa3' + '{0:.2f}'.format(price) + '.\u005cn\u005cn[Press space bar to continue]'\u000a            cost = price\u000a        elif win_item==False:\u000a            auc_res_txt = u'Sorry, you did not win the following item at auction. \u005cnThis was your preferred item out of a randomly selected pair from one of the choice tasks.'\u000a            auc_prc_txt = u'Your bid of \u005cxa3' + '{0:.2f}'.format(bid) + u' was lower than the randomly generated price of \u005cxa3' + '{0:.2f}'.format(price) + '.\u005cn\u005cn[Press space bar to continue]'\u000a            cost = 0\u000a\u000a        # find the image path of the auction item\u000a        rand_itm_img = prefs[rand_itm][2]\u000a\u000a    # add up each component of S's payment\u000a    class score:\u000a        base = 25\u000a        rwrd = 0.01\u000a        loss = 0\u000a        rwrd_tot = rwrd * correct_counter\u000a        loss_tot = loss * incorrect_counter\u000a        pre_pymt = base + rwrd_tot - loss_tot\u000a        final_pymt = pre_pymt - auction.cost\u000a\u000a        pymt_expl_bdwn = u'\u005cxa3' + '{0:.2f}'.format(base) + u' base payment'+ u'\u005cn+ \u005cxa3' + '{0:.2f}'.format(rwrd_tot) + ' reward for ' + str(correct_counter) + u' correct responses (\u005cxa3' + '{0:.2f}'.format(rwrd) + u' each)' + u'\u005cn- \u005cxa3' + '{0:.2f}'.format(auction.cost) + ' cost of auction item' \u000a        pymt_expl_tot = u'Your total payment is: \u005cxa3' + '{0:.2f}'.format(final_pymt) + '\u005cn\u005cnThank you for participating!'\u000a\u000a\u000a    # Initialize components for Routine "auc_disp"\u000a    auc_dispClock = core.Clock()\u000a    pic_auc_itm = visual.ImageStim(win=win, name='pic_auc_itm',\u000a        image=dir_path+auction.rand_itm_img, mask=None,\u000a        ori=0, pos=[0, 0], size=None,\u000a        color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a        flipHoriz=False, flipVert=False,\u000a        texRes=128, interpolate=False, depth=0.0)\u000a    auc_txt1 = visual.TextStim(win=win, ori=0, name='auc_txt1',\u000a        text=auction.auc_res_txt, font=u'Arial',\u000a        pos=[0, 0.6], height=0.07, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    auc_txt2 = visual.TextStim(win=win, ori=0, name='auc_txt2',\u000a        text=auction.auc_prc_txt, font=u'Arial',\u000a        pos=[0, -0.6], height=0.07, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a\u000a    #------Prepare to start Routine "auc_disp"-------\u000a    t = 0\u000a    auc_dispClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    key_resp_auc_disp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_auc_disp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    auc_dispComponents = []\u000a    auc_dispComponents.append(pic_auc_itm)\u000a    auc_dispComponents.append(auc_txt1)\u000a    auc_dispComponents.append(auc_txt2)\u000a    for thisComponent in auc_dispComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "auc_disp"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = auc_dispClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *pic_auc_itm* updates\u000a        if t >= 0.2 and pic_auc_itm.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            pic_auc_itm.tStart = t  # underestimates by a little under one frame\u000a            pic_auc_itm.frameNStart = frameN  # exact frame index\u000a            pic_auc_itm.setAutoDraw(True)\u000a        \u000a        # *auc_txt1* updates\u000a        if t >= 0.2 and auc_txt1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            auc_txt1.tStart = t  # underestimates by a little under one frame\u000a            auc_txt1.frameNStart = frameN  # exact frame index\u000a            auc_txt1.setAutoDraw(True)\u000a\u000a        # *auc_txt2* updates\u000a        if t >= 0.2 and auc_txt2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            auc_txt2.tStart = t  # underestimates by a little under one frame\u000a            auc_txt2.frameNStart = frameN  # exact frame index\u000a            auc_txt2.setAutoDraw(True)\u000a        \u000a        # *key_resp_auc_disp* updates\u000a        if t >= 0.2 and key_resp_auc_disp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_auc_disp.tStart = t  # underestimates by a little under one frame\u000a            key_resp_auc_disp.frameNStart = frameN  # exact frame index\u000a            key_resp_auc_disp.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_auc_disp.clock.reset()  # now t=0\u000a        if key_resp_auc_disp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_auc_disp.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_auc_disp.rt = key_resp_auc_disp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in auc_dispComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "auc_disp"-------\u000a    for thisComponent in auc_dispComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_auc_disp.keys in ['', [], None]:  # No response was made\u000a       key_resp_auc_disp.keys=None\u000a    # store data for thisExp (TrialHandler)\u000a    thisExp.addData('auction.win_item', auction.win_item)\u000a    thisExp.addData('auction.price', auction.price)\u000a    thisExp.addData('auction.bid', auction.bid)\u000a    thisExp.addData('auction.rand_itm_img', auction.rand_itm_img)\u000a    thisExp.addData('score.base', score.base)\u000a    thisExp.addData('score.rwrd', score.rwrd)\u000a    thisExp.addData('score.loss', score.loss)\u000a    thisExp.addData('correct_counter', correct_counter)\u000a    thisExp.addData('incorrect_counter', incorrect_counter)\u000a    thisExp.addData('score.final_pymt', score.final_pymt)\u000a    thisExp.nextEntry()\u000a\u000a\u000a    # Initialize components for Routine "pymt_disp"\u000a    pymt_dispClock = core.Clock()\u000a    pymt_disp_txt1 = visual.TextStim(win=win, ori=0, name='pymt_disp_txt1',\u000a        text=score.pymt_expl_bdwn, font=u'Arial',\u000a        pos=[0, 0.6], height=0.07, wrapWidth=1.5,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    pymt_disp_txt2 = visual.TextStim(win=win, ori=0, name='pymt_disp_txt2',\u000a        text=score.pymt_expl_tot, font=u'Arial',\u000a        pos=[0, -0.65], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    #------Prepare to start Routine "pymt_disp"-------\u000a    t = 0\u000a    pymt_dispClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    key_resp_pymt_disp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_pymt_disp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    pymt_dispComponents = []\u000a    pymt_dispComponents.append(pic_auc_itm)\u000a    pymt_dispComponents.append(pymt_disp_txt1)\u000a    pymt_dispComponents.append(pymt_disp_txt2)\u000a    pymt_dispComponents.append(key_resp_pymt_disp)\u000a    for thisComponent in pymt_dispComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "pymt_disp"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = pymt_dispClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        if auction.win_item==True:\u000a            # *pic_auc_itm* updates\u000a            if t >= 0.0 and pic_auc_itm.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                pic_auc_itm.tStart = t  # underestimates by a little under one frame\u000a                pic_auc_itm.frameNStart = frameN  # exact frame index\u000a                pic_auc_itm.setAutoDraw(True)\u000a\u000a        # *pymt_disp_txt1* updates\u000a        if t >= 0.0 and pymt_disp_txt1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            pymt_disp_txt1.tStart = t  # underestimates by a little under one frame\u000a            pymt_disp_txt1.frameNStart = frameN  # exact frame index\u000a            pymt_disp_txt1.setAutoDraw(True)\u000a\u000a        # *pymt_disp_txt2* updates\u000a        if t >= 0.0 and pymt_disp_txt2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            pymt_disp_txt2.tStart = t  # underestimates by a little under one frame\u000a            pymt_disp_txt2.frameNStart = frameN  # exact frame index\u000a            pymt_disp_txt2.setAutoDraw(True)\u000a        \u000a        # *key_resp_pymt_disp* updates\u000a        if t >= 3.0 and key_resp_pymt_disp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_pymt_disp.tStart = t  # underestimates by a little under one frame\u000a            key_resp_pymt_disp.frameNStart = frameN  # exact frame index\u000a            key_resp_pymt_disp.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_pymt_disp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if key_resp_pymt_disp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_pymt_disp.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_pymt_disp.rt = key_resp_pymt_disp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in pymt_dispComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "pymt_disp"-------\u000a    for thisComponent in pymt_dispComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_pymt_disp.keys in ['', [], None]:  # No response was made\u000a       key_resp_pymt_disp.keys=None\u000a\u000aelse: # If S didn't complete the entire binary choice and BDM routines during this session, prompt a manual auction\u000a    # Initialize components for Routine "auc_manual"\u000a    auc_manualClock = core.Clock()\u000a    auc_manual_txt = visual.TextStim(win=win, ori=0, name='auc_manual_txt',\u000a        text=u'Thank you! This completes the experiment. The experimenter will now run the auction and calculate your final payment.\u005cn\u005cnCorrect: ' + str(correct_counter) + '\u005cnIncorrect: ' + str(incorrect_counter),    font=u'Arial',\u000a        pos=[0, 0], height=0.07, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    #------Prepare to start Routine "auc_manual"-------\u000a    t = 0\u000a    auc_manualClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    auc_manualComponents = []\u000a    auc_manualComponents.append(auc_manual_txt)\u000a    for thisComponent in auc_manualComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "auc_manual"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = auc_manualClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *auc_manual_txt* updates\u000a        if t >= 0.0 and auc_manual_txt.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            auc_manual_txt.tStart = t  # underestimates by a little under one frame\u000a            auc_manual_txt.frameNStart = frameN  # exact frame index\u000a            auc_manual_txt.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in auc_manualComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "auc_manual"-------\u000a    for thisComponent in auc_manualComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000athisExp.nextEntry()\u000a\u000a# io.quit() # Close iohub\u000a\u000a\u000awin.close()\u000acore.quit()\u000a
p10234
sg9107
(lp10235
sg9109
I85328720
sg10
g9399
sg6
g9111
sg9112
I1
sg52
I01
sg53
g54
sg9113
g1
(g9114
g9115
(dp10236
g33
g9118
(g9119
g92
g9120
S'b'
tRp10237
(I1
(I200
I1
tg9244
I00
S'hM\xcb\x12\xd8K\xcb\x12\x00\xfc\x87\x04\xa0\x83\xcb\x12 \x8c\xca\x12\x00L\xcb\x12\xd8K\xcb\x12 \x8c\xca\x12(L\xcb\x12PL\xcb\x12\xd8\x83\xcb\x12xL\xcb\x12\xa0L\xcb\x12\xc8L\xcb\x12\xb0K\xcb\x12\xa0\x83\xcb\x12\x00L\xcb\x12\xd8\x83\xcb\x12\xa0\x8d\xca\x12\xa0L\xcb\x12\x00\xfc\x87\x04\xa0L\xcb\x12\x80\x8c\xca\x12\xd8K\xcb\x12\xf0L\xcb\x12 \x8c\xca\x12\xd8\x83\xcb\x12xL\xcb\x12\x80\x84\xcb\x12(L\xcb\x12\xc8L\xcb\x12 \x8c\xca\x12\xb0\x8c\xca\x12\xe0\x8c\xca\x12\xa0\x83\xcb\x12\xe0\x8c\xca\x12 \x8c\xca\x12\x80\x8c\xca\x12\x00\xfc\x87\x04\x18M\xcb\x12\xb0K\xcb\x12\x10\x84\xcb\x12\xb8M\xcb\x12\xb0\x8c\xca\x12p\x8d\xca\x12\x00L\xcb\x12\xc8L\xcb\x12\xf0\x84\xcb\x12\xa0\xb9\xb0\x0c\x18M\xcb\x12\xc8L\xcb\x12\x18M\xcb\x12 \x8c\xca\x12@\xb7\xb0\x0c \x8c\xca\x12@\xb7\xb0\x0c\x00L\xcb\x12\xb0K\xcb\x12(L\xcb\x12\xb8M\xcb\x12@\x8d\xca\x12\xd8\x83\xcb\x12\x80\x8c\xca\x12\x08N\xcb\x12PL\xcb\x12\x90M\xcb\x12PL\xcb\x12\xa0\xb9\xb0\x0c\xb0\x8c\xca\x12\x80\x8c\xca\x12\xa0L\xcb\x12\xf0L\xcb\x12\x00L\xcb\x12\xc8L\xcb\x12\xa0\x83\xcb\x12(L\xcb\x12\xb0\x8c\xca\x12\x80\x8c\xca\x12\xb8M\xcb\x12\x80\xb6\xb0\x0c@\xb7\xb0\x0c \x8c\xca\x12\xc8L\xcb\x12\x00\xfc\x87\x04\x18M\xcb\x12PL\xcb\x12@\xb0\xb0\x0c\x08N\xcb\x12\xa0L\xcb\x12\x00L\xcb\x12\xd8\x83\xcb\x12\xf0L\xcb\x12@\xb7\xb0\x0c\xc8L\xcb\x12\xd8K\xcb\x12\x80\x84\xcb\x12\xb0\x8c\xca\x12\xa0L\xcb\x12\x18M\xcb\x12\xf0L\xcb\x12xL\xcb\x120\x8e\xca\x12\xa0\xb9\xb0\x0c@\x8d\xca\x12\xb8M\xcb\x12\xe0M\xcb\x12 \x8c\xca\x12\xb0\x8c\xca\x12PL\xcb\x12\x80\x8c\xca\x12\xb0K\xcb\x12\xa0\xb9\xb0\x0c\xa0\x83\xcb\x12\xb0\x8c\xca\x12\x80\xb6\xb0\x0c\xa0\x83\xcb\x12\x00\xfc\x87\x04\xa0\xb9\xb0\x0c\xf0L\xcb\x12\xb0K\xcb\x12\xa0\x8d\xca\x12(L\xcb\x12\xb8M\xcb\x12\xb0K\xcb\x12\xd8K\xcb\x12@\x8d\xca\x12\xa0\xb9\xb0\x0c(L\xcb\x12\xb0K\xcb\x12\x00L\xcb\x12\xa0\x83\xcb\x12\x00\xfc\x87\x04@\xb7\xb0\x0c\xa0L\xcb\x12\x00\xfc\x87\x04@\xb0\xb0\x0c\xa0\xb9\xb0\x0cP\x8c\xca\x12\x80\xb6\xb0\x0cH\x84\xcb\x12\x80\xb6\xb0\x0c\xb0\x8c\xca\x12\xa0\xb9\xb0\x0c\x80\xb6\xb0\x0c\xd8\x83\xcb\x12P\x8c\xca\x12\x18M\xcb\x12\xa0\x83\xcb\x12@\xb0\xb0\x0c\xa0L\xcb\x12\x00\xfc\x87\x04\xb0K\xcb\x12\xd8\x83\xcb\x12\x00L\xcb\x12\xa0\x8d\xca\x12\xd8K\xcb\x12\xf0L\xcb\x12\xb0K\xcb\x12PL\xcb\x12\xc0\xb6\xb0\x0c \x8c\xca\x12\x18M\xcb\x12\xc8L\xcb\x12P\x8c\xca\x12H\x84\xcb\x12xL\xcb\x12\xd8K\xcb\x12\xd8\x83\xcb\x12\xb8M\xcb\x12(L\xcb\x12@\xb7\xb0\x0cPL\xcb\x12\xd8K\xcb\x12P\x8c\xca\x12@\xb7\xb0\x0c\xd0\x8d\xca\x12\xb8\x84\xcb\x12\x80\xb6\xb0\x0c\x80\x8c\xca\x12\x80\xb6\xb0\x0c\xb0\x8c\xca\x12\xf0L\xcb\x12p\x8d\xca\x12\x80\xb6\xb0\x0cP\x8c\xca\x12PL\xcb\x12\xd0\x8d\xca\x12@\xb7\xb0\x0cP\x8c\xca\x12\x80\xb6\xb0\x0c\x00\xfc\x87\x04\xa0L\xcb\x12\xc8L\xcb\x12\x80\x8c\xca\x12\xa0\x8d\xca\x12\x18M\xcb\x12\xb0\x8c\xca\x12\x18M\xcb\x12@\xb7\xb0\x0c\x00L\xcb\x12'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg9117
g9118
(g9119
g92
g9120
S'b'
tRp10238
(I1
(I200
I1
tg9122
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg38
g9118
(g9119
g92
g9120
S'b'
tRp10239
(I1
(I200
I1
tg9244
I00
S'\x80[\xcc\x12\xa0Z\xcc\x12 Z\xcc\x12@Z\xcc\x12`Z\xcc\x12`\\\xcc\x12\xc0Z\xcc\x12\x80\\\xcc\x12\xe0[\xcc\x12\x00]\xcc\x12\x00[\xcc\x12\xe0Z\xcc\x12`]\xcc\x12 [\xcc\x12\xc0]\xcc\x12\x00Z\xcc\x12\xa0[\xcc\x12\xc0[\xcc\x12\xc0\\\xcc\x12\xe0Y\xcc\x12\x80Z\xcc\x12@[\xcc\x12\xe0\\\xcc\x12\xc0^\xcc\x12@]\xcc\x12 \\\xcc\x12 ^\xcc\x12`_\xcc\x12\x80_\xcc\x12 ]\xcc\x12@_\xcc\x12\xa0]\xcc\x12\xe0^\xcc\x12`^\xcc\x12\xe0_\xcc\x12\x80^\xcc\x12\xa0_\xcc\x12\x00^\xcc\x12\xe0]\xcc\x12\x00\\\xcc\x12`[\xcc\x12\xc0_\xcc\x12\x00_\xcc\x12 _\xcc\x12@^\xcc\x12\xa0\\\xcc\x12\x80]\xcc\x12\xa0^\xcc\x12\xc0\xc1\xe2\x12@\xc2\xe2\x12\xa0\xc1\xe2\x12\xc0\xc0\xe2\x12\xa0\xc2\xe2\x12\xc0\xc2\xe2\x12\x80\xc2\xe2\x12\x00\xc3\xe2\x12\xe0\xc2\xe2\x12`\xc1\xe2\x12 \xc3\xe2\x12\x80\xc3\xe2\x12\xa0\xc3\xe2\x12\xc0\xc3\xe2\x12@\xc1\xe2\x12\x00\xc4\xe2\x12 \xc4\xe2\x12@\xc4\xe2\x12`\xc4\xe2\x12\x80\xc4\xe2\x12\x00\xc1\xe2\x12`\xc2\xe2\x12\xa0\xc4\xe2\x12\xc0\xc4\xe2\x12\xe0\xc4\xe2\x12\x00\xc5\xe2\x12`\xc5\xe2\x12\x80\xc5\xe2\x12\xa0\xc5\xe2\x12\xe0\xc0\xe2\x12\xe0\xc5\xe2\x12\x00\xc6\xe2\x12 \xc6\xe2\x12\xe0\xc3\xe2\x12`\xc6\xe2\x12\x80\xc6\xe2\x12 \xc2\xe2\x12@\xc3\xe2\x12\xa0\xc6\xe2\x12\xc0\xc6\xe2\x12\xe0\xc6\xe2\x12@\xc7\xe2\x12`\xc7\xe2\x12\x80\xc7\xe2\x12 \xc5\xe2\x12`\xc0\xe2\x12\xa0\xc7\xe2\x12\xc0\xc7\xe2\x12\xe0\xc7\xe2\x12\x00\xc8\xe2\x12 \xc8\xe2\x12@\xc8\xe2\x12`\xc8\xe2\x12\x80\xc8\xe2\x12\xa0\xc8\xe2\x12\xc0\xc8\xe2\x12 \xc9\xe2\x12\x00\xc9\xe2\x12\xa0\xdb\x88\x04\x80\xc0\xe2\x12\x80\xc9\xe2\x12@\xc6\xe2\x12\xe0\xc9\xe2\x12\x00\xca\xe2\x12@\xc0\xe2\x12@\xca\xe2\x12`\xca\xe2\x12@\xc9\xe2\x12\xc0\xc5\xe2\x12@\xc5\xe2\x12\xc0\xca\xe2\x12 \xc1\xe2\x12 \xc7\xe2\x12@\xcb\xe2\x12\xa0\xc9\xe2\x12\x80\xcb\xe2\x12\xa0\xcb\xe2\x12`\xc9\xe2\x12\xc0\xcb\xe2\x12\xe0\xca\xe2\x12\xc0\xc9\xe2\x12\xe0\xc8\xe2\x12\x80\xca\xe2\x12 \xc0\xe2\x12\xa0\xc0\xe2\x12 \xcc\xe2\x12`\xc3\xe2\x12\xe0\xcc\xe2\x12 \xca\xe2\x12@\xcd\xe2\x12`\xcd\xe2\x12\x00\xc7\xe2\x12@\xcc\xe2\x12\xa0\xcd\xe2\x12\x80\xcc\xe2\x12 \xcb\xe2\x12\xe0\xcd\xe2\x12@\xce\xe2\x12\x00\xcc\xe2\x12\x00\xce\xe2\x12\xa0\xce\xe2\x12\xc0\xce\xe2\x12\x00\xcd\xe2\x12\x80\xcd\xe2\x12\xc0\xcc\xe2\x12@\xcf\xe2\x12`\xcc\xe2\x12\x80\xcf\xe2\x12\xc0\xcf\xe2\x12\xc0\xcd\xe2\x12`\xcb\xe2\x12\xe0\xcf\xe2\x12@\\\xcc\x12\xa0\xca\xe2\x12\xe0\xcb\xe2\x12\x80\xc1\xe2\x12\x00\xcf\xe2\x12 \xce\xe2\x12\xa0\xcc\xe2\x12\xa0\xcf\xe2\x12\xe0\xce\xe2\x12\xe0\xc1\xe2\x12 \xcd\xe2\x12\x00\xc2\xe2\x12`\xcf\xe2\x12\x00\xcb\xe2\x12`\xce\xe2\x12\xc0\x81\t\x13 \x81\t\x13\xa0\x82\t\x13@\x82\t\x13`\x80\t\x13\xc0\x82\t\x13\x80\x82\t\x13 \x80\t\x13\xe0\x82\t\x13@\x83\t\x13`\x83\t\x13\xe0\x81\t\x13\xa0\x80\t\x13\x80\x83\t\x13\xa0\x83\t\x13\x00\x84\t\x13\xe0\x83\t\x13@\x80\t\x13`\x84\t\x13\x80\x84\t\x13\x80\x80\t\x13\x00\x81\t\x13\xa0\x84\t\x13\xc0\x84\t\x13\xe0\x84\t\x13'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg9125
g9118
(g9119
g92
g9120
S'b'
tRp10240
(I1
(I200
I1
tg9122
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00@\x00\x00@@\x00\x00\x80@\x00\x00\xa0@\x00\x00\xc0@\x00\x00\xe0@\x00\x00\x00A\x00\x00\x10A\x00\x00 A\x00\x000A\x00\x00@A\x00\x00PA\x00\x00`A\x00\x00pA\x00\x00\x80A\x00\x00\x88A\x00\x00\x90A\x00\x00\x98A\x00\x00\xa0A\x00\x00\xa8A\x00\x00\xb0A\x00\x00\xb8A\x00\x00\xc0A\x00\x00\xc8A\x00\x00\xd0A\x00\x00\xd8A\x00\x00\xe0A\x00\x00\xe8A\x00\x00\xf0A\x00\x00\xf8A\x00\x00\x00B\x00\x00\x04B\x00\x00\x08B\x00\x00\x0cB\x00\x00\x10B\x00\x00\x14B\x00\x00\x18B\x00\x00\x1cB\x00\x00 B\x00\x00$B\x00\x00(B\x00\x00,B\x00\x000B\x00\x004B\x00\x008B\x00\x00<B\x00\x00@B\x00\x00DB\x00\x00HB\x00\x00LB\x00\x00PB\x00\x00TB\x00\x00XB\x00\x00\\B\x00\x00`B\x00\x00dB\x00\x00hB\x00\x00lB\x00\x00pB\x00\x00tB\x00\x00xB\x00\x00|B\x00\x00\x80B\x00\x00\x82B\x00\x00\x84B\x00\x00\x86B\x00\x00\x88B\x00\x00\x8aB\x00\x00\x8cB\x00\x00\x8eB\x00\x00\x90B\x00\x00\x92B\x00\x00\x94B\x00\x00\x96B\x00\x00\x98B\x00\x00\x9aB\x00\x00\x9cB\x00\x00\x9eB\x00\x00\xa0B\x00\x00\xa2B\x00\x00\xa4B\x00\x00\xa6B\x00\x00\xa8B\x00\x00\xaaB\x00\x00\xacB\x00\x00\xaeB\x00\x00\xb0B\x00\x00\xb2B\x00\x00\xb4B\x00\x00\xb6B\x00\x00\xb8B\x00\x00\xbaB\x00\x00\xbcB\x00\x00\xbeB\x00\x00\xc0B\x00\x00\xc2B\x00\x00\xc4B\x00\x00\xc6B\x00\x00\xc8B\x00\x00\xcaB\x00\x00\xccB\x00\x00\xceB\x00\x00\xd0B\x00\x00\xd2B\x00\x00\xd4B\x00\x00\xd6B\x00\x00\xd8B\x00\x00\xdaB\x00\x00\xdcB\x00\x00\xdeB\x00\x00\xe0B\x00\x00\xe2B\x00\x00\xe4B\x00\x00\xe6B\x00\x00\xe8B\x00\x00\xeaB\x00\x00\xecB\x00\x00\xeeB\x00\x00\xf0B\x00\x00\xf2B\x00\x00\xf4B\x00\x00\xf6B\x00\x00\xf8B\x00\x00\xfaB\x00\x00\xfcB\x00\x00\xfeB\x00\x00\x00C\x00\x00\x01C\x00\x00\x02C\x00\x00\x03C\x00\x00\x04C\x00\x00\x05C\x00\x00\x06C\x00\x00\x07C\x00\x00\x08C\x00\x00\tC\x00\x00\nC\x00\x00\x0bC\x00\x00\x0cC\x00\x00\rC\x00\x00\x0eC\x00\x00\x0fC\x00\x00\x10C\x00\x00\x11C\x00\x00\x12C\x00\x00\x13C\x00\x00\x14C\x00\x00\x15C\x00\x00\x16C\x00\x00\x17C\x00\x00\x18C\x00\x00\x19C\x00\x00\x1aC\x00\x00\x1bC\x00\x00\x1cC\x00\x00\x1dC\x00\x00\x1eC\x00\x00\x1fC\x00\x00 C\x00\x00!C\x00\x00"C\x00\x00#C\x00\x00$C\x00\x00%C\x00\x00&C\x00\x00\'C\x00\x00(C\x00\x00)C\x00\x00*C\x00\x00+C\x00\x00,C\x00\x00-C\x00\x00.C\x00\x00/C\x00\x000C\x00\x001C\x00\x002C\x00\x003C\x00\x004C\x00\x005C\x00\x006C\x00\x007C\x00\x008C\x00\x009C\x00\x00:C\x00\x00;C\x00\x00<C\x00\x00=C\x00\x00>C\x00\x00?C\x00\x00@C\x00\x00AC\x00\x00BC\x00\x00CC\x00\x00DC\x00\x00EC\x00\x00FC\x00\x00GC'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg39
g9118
(g9119
g92
g9120
S'b'
tRp10241
(I1
(I200
I1
tg9122
I00
S'4\xd0\x8c?\xa7\xe8.?f[U?\x11\xc3\xbb?\xef\x1eQ?\xcdyw?\xc6`f?\x867\x93?\x15\xea]?5jf?"\x0f@?|\xf1\x0e@\xf2/b?9\xe9]?\x06Ws?s9\xb3?\xa0\xb1\x8a?,\xae\n@0\xfbn?\x15y\x86?9\xd0\xac?\xb7cU?\xed\x8e\x88?\x99\x89H?:\xd2j?\x9d\x04\xa0?9\xc6;?x\xf4\x8e?\xcd\xcb\xcc?\xe8\x1e\xb1?\xf2J\xc4?\nK\x84?\xcf\x9ay@t\x0e\xb1?]\x94H?,1\x93?\xcf\x94H?u<s?\x1f\x17Q?a\xea]?R\xf3L?\xa0\xc9;?\x9fh\x86?l\x83w?+\x8f\x88?\x8a\t\x10@$\x17\x91?;\xc9;?\x88\xe3\x9d?\x8c\x96H?sm\x86?w\'\x82?\xe7\x05\x80?f[\x95?U\xb1\xaa?mA3?\xb9\xa2Y?%bU?\x7f\xf8n?GG\xc4?]kD?E\x05\xa0?\xd5qf?\x9f\xec]?\xe6\x13\x91?\xe0y\x86?\xdd|7?-\x07@?\xf5\xb7j?t\x80w?\xd8~w?\xb9yU?<i\x06@|\x1cQ?g/b?\x0erf?\x8f Q?\xbc\xb3j?\xe5h\x16@+nf?\xe3\x8f\xa8?\xdf\x86\x97?\xd4y\x07@S}\xb7?\x93bU?\xcf\x9b\xb9?\xf0\x0c\x80?3m\xa6?T8s?\xa2\xb0j?d\xc8;?\xedPD?\xd7\x1eQ?\x85\xb6j?\xdetw?\x0f\x10Q?Y\xfan?\x97\x9ew?\xf6\xea]?2\x04\xe0?PJ\x84?\x1c\\U?\x98\xeb]?\xf5aU?`\x17\x91? )b?c0s?(\xe6]?\xa3R\x84?\x87\x9e\xb9?<\xd9L?S\x03\x80?C5\x03@\xf3Z\xb5?\xed\x11a@\xca\xd1\xac?g\xe3\x9d?\xe9\x83w?\x89h\x95?\xc1&\x82?:\xc0;?k\x03\x80?\xaf\xbe\xbb?\xd5\x89\x97?b?D?Q\x1eQ?\xca\xd2L?\x9b\xea]?\xdciU?\x14j\x06@\xcd}\x97?\x18\xc4{?i\x8d\xa8?\x07\x1dQ?\xe4\xf2L?ROD?\xf9\x1cQ?\xc7\xa6Y?\x81\x91H?\x15@s?\x14\xd0*?\x007\x93?\x93D\x04@\x9b\xb1*?l\xd9L?\x19\xd0*?\xcf[U?\x8eJ\xa4?\xa2Z\xf5?\xfe\x8bH?\xb6\x11\x80?:KD?o\t@?\x07\xfa.?\xf7\xa6Y?\xa2\xf3\x7f?\x16K\x84?\xa2\x1cQ?\xe2\x12\x91?</b?\x8eQU?\x0b\xb3j?ReU?0\x16Q?S\xaf\x8a?\x14\xc1\x9b?\x05\xfc??K\xa0Y?\x86:\xd3?;\x0b@?\xc9\xc8;?g\x88H?"\xf8??\x9b@3?z\xdbL?$1b?A\xc1;?\xd1\x13Q?\xd7\x1eQ?\x98\xcfj?\x91\xd0\xec?taU?y\x94H?\xa1\xb8*?\x96\xea\x1d?S\xef.@\xcc\xac:@c\xf1\xae?\x7f\xfe.?~\x1fQ?C;s?|\x95H?\x85\x95H?2\xe6]?\xe5?3?\x02\xbfY?\x13\x1eQ?\xf8?3?\xe7[U?\xd2\x05\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg34
g9118
(g9119
g92
g9120
S'b'
tRp10242
(I1
(I200
I1
tg9244
I00
S'\xf05\xee\x0483\xee\x04\xe0\xb0\xf0\x04X\xb1\xf0\x04\xc8\xbf\xf0\x04P\xbc\xf0\x04\x90\xb8\xf0\x040\xb8\xf0\x04 \xbf\xf0\x04\xe8\xba\xf0\x04\xe8\xbd\xf0\x04\x98\xb9\xf0\x048\xb9\xf0\x04\x80\xb9\xf0\x04\xd8\xb2\xf0\x04@\xba\xf0\x04\x80\xb3\xf0\x04\x18\xbb\xf0\x048\xbf\xf0\x04H\xb8\xf0\x04\xd0\xb7\xf0\x04\x98\xbc\xf0\x04`\xb5\xf0\x04`\xb8\xf0\x04@\xb7\xf0\x04p\xbd\xf0\x04p\xb7\xf0\x04P\xb9\xf0\x04x\xbe\xf0\x04\xf8\xb0\xf0\x04x\xb2\xf0\x040\xbe\xf0\x04P\xb3\xf0\x04H\xbe\xf0\x04h\xb0\xf0\x04\xc0\xbe\xf0\x04\x18\xb8\xf0\x04\xb8\xb4\xf0\x04\x98\xbf\xf0\x04\x80\xb6\xf0\x04\xc8f\xf7\x04\xf8`\xf7\x04 l\xf7\x04Hn\xf7\x04\xa0d\xf7\x04\xf8i\xf7\x048o\xf7\x04\x88d\xf7\x04\x18e\xf7\x04\x80f\xf7\x04\xc8o\xf7\x048`\xf7\x04(a\xf7\x04\xb0f\xf7\x04\xe8d\xf7\x040e\xf7\x04\x08i\xf7\x04pj\xf7\x04\x10m\xf7\x04xb\xf7\x04\xc8i\xf7\x04\xf8l\xf7\x04\xb0`\xf7\x04\xa0a\xf7\x04\xd0a\xf7\x04xe\xf7\x04\x88m\xf7\x04\x08c\xf7\x04Pf\xf7\x04Pc\xf7\x04 `\xf7\x04\x80i\xf7\x04\x98`\xf7\x04\x88a\xf7\x04Xa\xf7\x04\xc0k\xf7\x04\xd8h\xf7\x04\xb8d\xf7\x04\x90e\xf7\x04\x98f\xf7\x040k\xf7\x040b\xf7\x04\x10a\xf7\x04Hh\xf7\x04\xd0g\xf7\x04\xd8b\xf7\x04\xe8a\xf7\x04\xa8e\xf7\x04\x80l\xf7\x04\xd0j\xf7\x04\x90b\xf7\x04\x18h\xf7\x04 o\xf7\x04hl\xf7\x04\xa0g\xf7\x04@g\xf7\x04@a\xf7\x04hf\xf7\x04\xc0h\xf7\x04\x80`\xf7\x04\x80o\xf7\x04Xg\xf7\x048l\xf7\x04\xf0e\xf7\x04\xb8m\xf7\x04\x00n\xf7\x04@m\xf7\x04\x88j\xf7\x04\xb8j\xf7\x04\xa8h\xf7\x04\xb8g\xf7\x04\xa8n\xf7\x04He\xf7\x04\x90h\xf7\x04(g\xf7\x04pg\xf7\x04\x08l\xf7\x04\x98o\xf7\x04hi\xf7\x04`k\xf7\x04\xa0j\xf7\x040n\xf7\x04`h\xf7\x04\xa8k\xf7\x04\x18b\xf7\x04\x98l\xf7\x04ho\xf7\x04\xd8n\xf7\x04\xd0m\xf7\x04Hk\xf7\x04\xe0l\xf7\x04\xb8a\xf7\x04\xa0m\xf7\x04`n\xf7\x04\xb0l\xf7\x048f\xf7\x04\xe8g\xf7\x04\x00k\xf7\x04\xb0o\xf7\x04\xb0i\xf7\x04(m\xf7\x04Pl\xf7\x04Xj\xf7\x04\x18n\xf7\x04P`\xf7\x04\x08f\xf7\x04xh\xf7\x04\xe0o\xf7\x04\xd8k\xf7\x04\xc0e\xf7\x04\xf8f\xf7\x04\x18k\xf7\x04\xd0d\xf7\x04\xe0f\xf7\x04\xf0n\xf7\x04\x98i\xf7\x04pm\xf7\x048i\xf7\x04\x10j\xf7\x04Xm\xf7\x04\xf0k\xf7\x04\x88g\xf7\x04\xe0i\xf7\x04\xa8b\xf7\x04(d\xf7\x04@j\xf7\x04Xd\xf7\x04 f\xf7\x04\xf0h\xf7\x04xn\xf7\x04\x00e\xf7\x04Po\xf7\x04(j\xf7\x04 i\xf7\x04\xe8m\xf7\x04\x08o\xf7\x040h\xf7\x04h\xb9\xf0\x04\x90\xb5\xf0\x04\x88\xbd\xf0\x04\x00\xb2\xf0\x04\xf0\xb5\xf0\x04p\xb4\xf0\x04\xb0\xbc\xf0\x04\x10\xb4\xf0\x04\x10\xbd\xf0\x04\xe8\xb7\xf0\x04\x98\xb0\xf0\x04\xa8\xb2\xf0\x04\xa0\xb1\xf0\x04\xd0\xb1\xf0\x04\xc8\xb0\xf0\x04\xe0\xb6\xf0\x04(\xbd\xf0\x04\xc0\xb2\xf0\x04X\xbd\xf0\x04\x08\xbf\xf0\x04\xf8\xb6\xf0\x04h\xb6\xf0\x04\x10\xb7\xf0\x04'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp10243
(dp10244
g9130
(dp10245
g9117
I01
sg38
I00
sg33
I00
sg9125
I01
sg39
I01
sg34
I00
ssg9132
g10232
sg9133
(lp10246
g9117
ag9125
ag38
ag39
ag33
ag34
asg9135
(lp10247
I200
aI1
asbsg9137
g9252
sg9139
g91
(g92
(I0
tS'b'
tRp10248
(I1
(I200
I1
tg98
I00
S'\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00\x04\x00\x00\x00\x05\x00\x00\x00\x06\x00\x00\x00\x07\x00\x00\x00\x08\x00\x00\x00\t\x00\x00\x00\n\x00\x00\x00\x0b\x00\x00\x00\x0c\x00\x00\x00\r\x00\x00\x00\x0e\x00\x00\x00\x0f\x00\x00\x00\x10\x00\x00\x00\x11\x00\x00\x00\x12\x00\x00\x00\x13\x00\x00\x00\x14\x00\x00\x00\x15\x00\x00\x00\x16\x00\x00\x00\x17\x00\x00\x00\x18\x00\x00\x00\x19\x00\x00\x00\x1a\x00\x00\x00\x1b\x00\x00\x00\x1c\x00\x00\x00\x1d\x00\x00\x00\x1e\x00\x00\x00\x1f\x00\x00\x00 \x00\x00\x00!\x00\x00\x00"\x00\x00\x00#\x00\x00\x00$\x00\x00\x00%\x00\x00\x00&\x00\x00\x00\'\x00\x00\x00(\x00\x00\x00)\x00\x00\x00*\x00\x00\x00+\x00\x00\x00,\x00\x00\x00-\x00\x00\x00.\x00\x00\x00/\x00\x00\x000\x00\x00\x001\x00\x00\x002\x00\x00\x003\x00\x00\x004\x00\x00\x005\x00\x00\x006\x00\x00\x007\x00\x00\x008\x00\x00\x009\x00\x00\x00:\x00\x00\x00;\x00\x00\x00<\x00\x00\x00=\x00\x00\x00>\x00\x00\x00?\x00\x00\x00@\x00\x00\x00A\x00\x00\x00B\x00\x00\x00C\x00\x00\x00D\x00\x00\x00E\x00\x00\x00F\x00\x00\x00G\x00\x00\x00H\x00\x00\x00I\x00\x00\x00J\x00\x00\x00K\x00\x00\x00L\x00\x00\x00M\x00\x00\x00N\x00\x00\x00O\x00\x00\x00P\x00\x00\x00Q\x00\x00\x00R\x00\x00\x00S\x00\x00\x00T\x00\x00\x00U\x00\x00\x00V\x00\x00\x00W\x00\x00\x00X\x00\x00\x00Y\x00\x00\x00Z\x00\x00\x00[\x00\x00\x00\\\x00\x00\x00]\x00\x00\x00^\x00\x00\x00_\x00\x00\x00`\x00\x00\x00a\x00\x00\x00b\x00\x00\x00c\x00\x00\x00d\x00\x00\x00e\x00\x00\x00f\x00\x00\x00g\x00\x00\x00h\x00\x00\x00i\x00\x00\x00j\x00\x00\x00k\x00\x00\x00l\x00\x00\x00m\x00\x00\x00n\x00\x00\x00o\x00\x00\x00p\x00\x00\x00q\x00\x00\x00r\x00\x00\x00s\x00\x00\x00t\x00\x00\x00u\x00\x00\x00v\x00\x00\x00w\x00\x00\x00x\x00\x00\x00y\x00\x00\x00z\x00\x00\x00{\x00\x00\x00|\x00\x00\x00}\x00\x00\x00~\x00\x00\x00\x7f\x00\x00\x00\x80\x00\x00\x00\x81\x00\x00\x00\x82\x00\x00\x00\x83\x00\x00\x00\x84\x00\x00\x00\x85\x00\x00\x00\x86\x00\x00\x00\x87\x00\x00\x00\x88\x00\x00\x00\x89\x00\x00\x00\x8a\x00\x00\x00\x8b\x00\x00\x00\x8c\x00\x00\x00\x8d\x00\x00\x00\x8e\x00\x00\x00\x8f\x00\x00\x00\x90\x00\x00\x00\x91\x00\x00\x00\x92\x00\x00\x00\x93\x00\x00\x00\x94\x00\x00\x00\x95\x00\x00\x00\x96\x00\x00\x00\x97\x00\x00\x00\x98\x00\x00\x00\x99\x00\x00\x00\x9a\x00\x00\x00\x9b\x00\x00\x00\x9c\x00\x00\x00\x9d\x00\x00\x00\x9e\x00\x00\x00\x9f\x00\x00\x00\xa0\x00\x00\x00\xa1\x00\x00\x00\xa2\x00\x00\x00\xa3\x00\x00\x00\xa4\x00\x00\x00\xa5\x00\x00\x00\xa6\x00\x00\x00\xa7\x00\x00\x00\xa8\x00\x00\x00\xa9\x00\x00\x00\xaa\x00\x00\x00\xab\x00\x00\x00\xac\x00\x00\x00\xad\x00\x00\x00\xae\x00\x00\x00\xaf\x00\x00\x00\xb0\x00\x00\x00\xb1\x00\x00\x00\xb2\x00\x00\x00\xb3\x00\x00\x00\xb4\x00\x00\x00\xb5\x00\x00\x00\xb6\x00\x00\x00\xb7\x00\x00\x00\xb8\x00\x00\x00\xb9\x00\x00\x00\xba\x00\x00\x00\xbb\x00\x00\x00\xbc\x00\x00\x00\xbd\x00\x00\x00\xbe\x00\x00\x00\xbf\x00\x00\x00\xc0\x00\x00\x00\xc1\x00\x00\x00\xc2\x00\x00\x00\xc3\x00\x00\x00\xc4\x00\x00\x00\xc5\x00\x00\x00\xc6\x00\x00\x00\xc7\x00\x00\x00'
tbsg9141
I01
sg9142
I1
sg9143
I-1
sg9144
(lp10249
g1
(g9146
g9115
(dp10250
g6382
g6383
sg6370
g6371
sg6385
g6375
sg6379
g6380
stRp10251
ag1
(g9146
g9115
(dp10252
g6382
g6395
sg6370
g6391
sg6385
g6402
sg6379
g6399
stRp10253
ag1
(g9146
g9115
(dp10254
g6382
g6412
sg6370
g6408
sg6385
g6419
sg6379
g6416
stRp10255
ag1
(g9146
g9115
(dp10256
g6382
g6429
sg6370
g6425
sg6385
g6436
sg6379
g6433
stRp10257
ag1
(g9146
g9115
(dp10258
g6382
g6446
sg6370
g6442
sg6385
g6453
sg6379
g6450
stRp10259
ag1
(g9146
g9115
(dp10260
g6382
g6463
sg6370
g6459
sg6385
g6470
sg6379
g6467
stRp10261
ag1
(g9146
g9115
(dp10262
g6382
g6395
sg6370
g6476
sg6385
g6402
sg6379
g6483
stRp10263
ag1
(g9146
g9115
(dp10264
g6382
g6446
sg6370
g6491
sg6385
g6453
sg6379
g6498
stRp10265
ag1
(g9146
g9115
(dp10266
g6382
g6510
sg6370
g6506
sg6385
g6517
sg6379
g6514
stRp10267
ag1
(g9146
g9115
(dp10268
g6382
g6527
sg6370
g6523
sg6385
g6534
sg6379
g6531
stRp10269
ag1
(g9146
g9115
(dp10270
g6382
g6544
sg6370
g6540
sg6385
g6551
sg6379
g6548
stRp10271
ag1
(g9146
g9115
(dp10272
g6382
g6561
sg6370
g6557
sg6385
g6568
sg6379
g6565
stRp10273
ag1
(g9146
g9115
(dp10274
g6382
g6578
sg6370
g6574
sg6385
g6585
sg6379
g6582
stRp10275
ag1
(g9146
g9115
(dp10276
g6382
g6595
sg6370
g6591
sg6385
g6602
sg6379
g6599
stRp10277
ag1
(g9146
g9115
(dp10278
g6382
g6383
sg6370
g6371
sg6385
g6375
sg6379
g6380
stRp10279
ag1
(g9146
g9115
(dp10280
g6382
g6429
sg6370
g6425
sg6385
g6436
sg6379
g6433
stRp10281
ag1
(g9146
g9115
(dp10282
g6382
g6463
sg6370
g6634
sg6385
g6470
sg6379
g6641
stRp10283
ag1
(g9146
g9115
(dp10284
g6382
g6544
sg6370
g6540
sg6385
g6551
sg6379
g6548
stRp10285
ag1
(g9146
g9115
(dp10286
g6382
g6672
sg6370
g6662
sg6385
g6666
sg6379
g6670
stRp10287
ag1
(g9146
g9115
(dp10288
g6382
g6578
sg6370
g6574
sg6385
g6585
sg6379
g6582
stRp10289
ag1
(g9146
g9115
(dp10290
g6382
g6412
sg6370
g6692
sg6385
g6419
sg6379
g6699
stRp10291
ag1
(g9146
g9115
(dp10292
g6382
g6578
sg6370
g6707
sg6385
g6585
sg6379
g6714
stRp10293
ag1
(g9146
g9115
(dp10294
g6382
g6726
sg6370
g6722
sg6385
g6733
sg6379
g6730
stRp10295
ag1
(g9146
g9115
(dp10296
g6382
g6395
sg6370
g6476
sg6385
g6402
sg6379
g6483
stRp10297
ag1
(g9146
g9115
(dp10298
g6382
g6756
sg6370
g6752
sg6385
g6763
sg6379
g6760
stRp10299
ag1
(g9146
g9115
(dp10300
g6382
g6446
sg6370
g6442
sg6385
g6453
sg6379
g6450
stRp10301
ag1
(g9146
g9115
(dp10302
g6382
g6544
sg6370
g6540
sg6385
g6551
sg6379
g6548
stRp10303
ag1
(g9146
g9115
(dp10304
g6382
g6561
sg6370
g6795
sg6385
g6568
sg6379
g6802
stRp10305
ag1
(g9146
g9115
(dp10306
g6382
g6527
sg6370
g6810
sg6385
g6534
sg6379
g6817
stRp10307
ag1
(g9146
g9115
(dp10308
g6382
g6510
sg6370
g6825
sg6385
g6517
sg6379
g6832
stRp10309
ag1
(g9146
g9115
(dp10310
g6382
g6595
sg6370
g6840
sg6385
g6602
sg6379
g6847
stRp10311
ag1
(g9146
g9115
(dp10312
g6382
g6446
sg6370
g6442
sg6385
g6453
sg6379
g6450
stRp10313
ag1
(g9146
g9115
(dp10314
g6382
g6872
sg6370
g6868
sg6385
g6879
sg6379
g6876
stRp10315
ag1
(g9146
g9115
(dp10316
g6382
g6395
sg6370
g6391
sg6385
g6402
sg6379
g6399
stRp10317
ag1
(g9146
g9115
(dp10318
g6382
g6429
sg6370
g6425
sg6385
g6436
sg6379
g6433
stRp10319
ag1
(g9146
g9115
(dp10320
g6382
g6395
sg6370
g6391
sg6385
g6402
sg6379
g6399
stRp10321
ag1
(g9146
g9115
(dp10322
g6382
g6446
sg6370
g6442
sg6385
g6453
sg6379
g6450
stRp10323
ag1
(g9146
g9115
(dp10324
g6382
g6726
sg6370
g6937
sg6385
g6733
sg6379
g6944
stRp10325
ag1
(g9146
g9115
(dp10326
g6382
g6412
sg6370
g6692
sg6385
g6419
sg6379
g6699
stRp10327
ag1
(g9146
g9115
(dp10328
g6382
g6969
sg6370
g6965
sg6385
g6976
sg6379
g6973
stRp10329
ag1
(g9146
g9115
(dp10330
g6382
g6383
sg6370
g6982
sg6385
g6375
sg6379
g6989
stRp10331
ag1
(g9146
g9115
(dp10332
g6382
g6412
sg6370
g6408
sg6385
g6419
sg6379
g6416
stRp10333
ag1
(g9146
g9115
(dp10334
g6382
g6561
sg6370
g6795
sg6385
g6568
sg6379
g6802
stRp10335
ag1
(g9146
g9115
(dp10336
g6382
g6872
sg6370
g7023
sg6385
g6879
sg6379
g7030
stRp10337
ag1
(g9146
g9115
(dp10338
g6382
g6544
sg6370
g6540
sg6385
g6551
sg6379
g6548
stRp10339
ag1
(g9146
g9115
(dp10340
g6382
g6463
sg6370
g6634
sg6385
g6470
sg6379
g6641
stRp10341
ag1
(g9146
g9115
(dp10342
g6382
g6595
sg6370
g6591
sg6385
g6602
sg6379
g6599
stRp10343
ag1
(g9146
g9115
(dp10344
g6382
g7087
sg6370
g7077
sg6385
g7081
sg6379
g7085
stRp10345
ag1
(g9146
g9115
(dp10346
g6382
g7098
sg6370
g7094
sg6385
g7105
sg6379
g7102
stRp10347
ag1
(g9146
g9115
(dp10348
g6382
g6969
sg6370
g7111
sg6385
g6976
sg6379
g7118
stRp10349
ag1
(g9146
g9115
(dp10350
g6382
g6595
sg6370
g6591
sg6385
g6602
sg6379
g6599
stRp10351
ag1
(g9146
g9115
(dp10352
g6382
g6969
sg6370
g6965
sg6385
g6976
sg6379
g6973
stRp10353
ag1
(g9146
g9115
(dp10354
g6382
g6446
sg6370
g6491
sg6385
g6453
sg6379
g6498
stRp10355
ag1
(g9146
g9115
(dp10356
g6382
g7169
sg6370
g7165
sg6385
g7176
sg6379
g7173
stRp10357
ag1
(g9146
g9115
(dp10358
g6382
g6446
sg6370
g6442
sg6385
g6453
sg6379
g6450
stRp10359
ag1
(g9146
g9115
(dp10360
g6382
g7169
sg6370
g7165
sg6385
g7176
sg6379
g7173
stRp10361
ag1
(g9146
g9115
(dp10362
g6382
g6463
sg6370
g6459
sg6385
g6470
sg6379
g6467
stRp10363
ag1
(g9146
g9115
(dp10364
g6382
g6383
sg6370
g6982
sg6385
g6375
sg6379
g6989
stRp10365
ag1
(g9146
g9115
(dp10366
g6382
g6510
sg6370
g6825
sg6385
g6517
sg6379
g6832
stRp10367
ag1
(g9146
g9115
(dp10368
g6382
g6561
sg6370
g6557
sg6385
g6568
sg6379
g6565
stRp10369
ag1
(g9146
g9115
(dp10370
g6382
g6510
sg6370
g6825
sg6385
g6517
sg6379
g6832
stRp10371
ag1
(g9146
g9115
(dp10372
g6382
g6544
sg6370
g7273
sg6385
g6551
sg6379
g7280
stRp10373
ag1
(g9146
g9115
(dp10374
g6382
g6726
sg6370
g6722
sg6385
g6733
sg6379
g6730
stRp10375
ag1
(g9146
g9115
(dp10376
g6382
g7098
sg6370
g7094
sg6385
g7105
sg6379
g7102
stRp10377
ag1
(g9146
g9115
(dp10378
g6382
g6527
sg6370
g6523
sg6385
g6534
sg6379
g6531
stRp10379
ag1
(g9146
g9115
(dp10380
g6382
g6463
sg6370
g6634
sg6385
g6470
sg6379
g6641
stRp10381
ag1
(g9146
g9115
(dp10382
g6382
g6527
sg6370
g6523
sg6385
g6534
sg6379
g6531
stRp10383
ag1
(g9146
g9115
(dp10384
g6382
g7098
sg6370
g7353
sg6385
g7105
sg6379
g7360
stRp10385
ag1
(g9146
g9115
(dp10386
g6382
g6872
sg6370
g6868
sg6385
g6879
sg6379
g6876
stRp10387
ag1
(g9146
g9115
(dp10388
g6382
g6726
sg6370
g6937
sg6385
g6733
sg6379
g6944
stRp10389
ag1
(g9146
g9115
(dp10390
g6382
g6578
sg6370
g6574
sg6385
g6585
sg6379
g6582
stRp10391
ag1
(g9146
g9115
(dp10392
g6382
g6756
sg6370
g6752
sg6385
g6763
sg6379
g6760
stRp10393
ag1
(g9146
g9115
(dp10394
g6382
g6463
sg6370
g6459
sg6385
g6470
sg6379
g6467
stRp10395
ag1
(g9146
g9115
(dp10396
g6382
g6595
sg6370
g6840
sg6385
g6602
sg6379
g6847
stRp10397
ag1
(g9146
g9115
(dp10398
g6382
g6429
sg6370
g7446
sg6385
g6436
sg6379
g7453
stRp10399
ag1
(g9146
g9115
(dp10400
g6382
g6510
sg6370
g6825
sg6385
g6517
sg6379
g6832
stRp10401
ag1
(g9146
g9115
(dp10402
g6382
g6872
sg6370
g7023
sg6385
g6879
sg6379
g7030
stRp10403
ag1
(g9146
g9115
(dp10404
g6382
g6726
sg6370
g6722
sg6385
g6733
sg6379
g6730
stRp10405
ag1
(g9146
g9115
(dp10406
g6382
g6561
sg6370
g6557
sg6385
g6568
sg6379
g6565
stRp10407
ag1
(g9146
g9115
(dp10408
g6382
g7087
sg6370
g7513
sg6385
g7081
sg6379
g7520
stRp10409
ag1
(g9146
g9115
(dp10410
g6382
g7169
sg6370
g7165
sg6385
g7176
sg6379
g7173
stRp10411
ag1
(g9146
g9115
(dp10412
g6382
g6446
sg6370
g6491
sg6385
g6453
sg6379
g6498
stRp10413
ag1
(g9146
g9115
(dp10414
g6382
g6595
sg6370
g6840
sg6385
g6602
sg6379
g6847
stRp10415
ag1
(g9146
g9115
(dp10416
g6382
g6412
sg6370
g6408
sg6385
g6419
sg6379
g6416
stRp10417
ag1
(g9146
g9115
(dp10418
g6382
g6969
sg6370
g6965
sg6385
g6976
sg6379
g6973
stRp10419
ag1
(g9146
g9115
(dp10420
g6382
g6527
sg6370
g6810
sg6385
g6534
sg6379
g6817
stRp10421
ag1
(g9146
g9115
(dp10422
g6382
g6756
sg6370
g7606
sg6385
g6763
sg6379
g7613
stRp10423
ag1
(g9146
g9115
(dp10424
g6382
g7098
sg6370
g7353
sg6385
g7105
sg6379
g7360
stRp10425
ag1
(g9146
g9115
(dp10426
g6382
g6578
sg6370
g6707
sg6385
g6585
sg6379
g6714
stRp10427
ag1
(g9146
g9115
(dp10428
g6382
g6463
sg6370
g6634
sg6385
g6470
sg6379
g6641
stRp10429
ag1
(g9146
g9115
(dp10430
g6382
g6544
sg6370
g6540
sg6385
g6551
sg6379
g6548
stRp10431
ag1
(g9146
g9115
(dp10432
g6382
g6756
sg6370
g6752
sg6385
g6763
sg6379
g6760
stRp10433
ag1
(g9146
g9115
(dp10434
g6382
g7169
sg6370
g7686
sg6385
g7176
sg6379
g7693
stRp10435
ag1
(g9146
g9115
(dp10436
g6382
g6595
sg6370
g6591
sg6385
g6602
sg6379
g6599
stRp10437
ag1
(g9146
g9115
(dp10438
g6382
g6395
sg6370
g6476
sg6385
g6402
sg6379
g6483
stRp10439
ag1
(g9146
g9115
(dp10440
g6382
g6527
sg6370
g6810
sg6385
g6534
sg6379
g6817
stRp10441
ag1
(g9146
g9115
(dp10442
g6382
g6872
sg6370
g7023
sg6385
g6879
sg6379
g7030
stRp10443
ag1
(g9146
g9115
(dp10444
g6382
g6578
sg6370
g6574
sg6385
g6585
sg6379
g6582
stRp10445
ag1
(g9146
g9115
(dp10446
g6382
g6969
sg6370
g7111
sg6385
g6976
sg6379
g7118
stRp10447
ag1
(g9146
g9115
(dp10448
g6382
g6756
sg6370
g7606
sg6385
g6763
sg6379
g7613
stRp10449
ag1
(g9146
g9115
(dp10450
g6382
g6561
sg6370
g6795
sg6385
g6568
sg6379
g6802
stRp10451
ag1
(g9146
g9115
(dp10452
g6382
g6969
sg6370
g6965
sg6385
g6976
sg6379
g6973
stRp10453
ag1
(g9146
g9115
(dp10454
g6382
g7098
sg6370
g7353
sg6385
g7105
sg6379
g7360
stRp10455
ag1
(g9146
g9115
(dp10456
g6382
g6510
sg6370
g6506
sg6385
g6517
sg6379
g6514
stRp10457
ag1
(g9146
g9115
(dp10458
g6382
g6561
sg6370
g6795
sg6385
g6568
sg6379
g6802
stRp10459
ag1
(g9146
g9115
(dp10460
g6382
g6595
sg6370
g6840
sg6385
g6602
sg6379
g6847
stRp10461
ag1
(g9146
g9115
(dp10462
g6382
g6446
sg6370
g6491
sg6385
g6453
sg6379
g6498
stRp10463
ag1
(g9146
g9115
(dp10464
g6382
g6872
sg6370
g7023
sg6385
g6879
sg6379
g7030
stRp10465
ag1
(g9146
g9115
(dp10466
g6382
g6527
sg6370
g6523
sg6385
g6534
sg6379
g6531
stRp10467
ag1
(g9146
g9115
(dp10468
g6382
g6726
sg6370
g6722
sg6385
g6733
sg6379
g6730
stRp10469
ag1
(g9146
g9115
(dp10470
g6382
g6383
sg6370
g6371
sg6385
g6375
sg6379
g6380
stRp10471
ag1
(g9146
g9115
(dp10472
g6382
g7098
sg6370
g7094
sg6385
g7105
sg6379
g7102
stRp10473
ag1
(g9146
g9115
(dp10474
g6382
g6429
sg6370
g7446
sg6385
g6436
sg6379
g7453
stRp10475
ag1
(g9146
g9115
(dp10476
g6382
g6872
sg6370
g6868
sg6385
g6879
sg6379
g6876
stRp10477
ag1
(g9146
g9115
(dp10478
g6382
g7087
sg6370
g7513
sg6385
g7081
sg6379
g7520
stRp10479
ag1
(g9146
g9115
(dp10480
g6382
g6429
sg6370
g6425
sg6385
g6436
sg6379
g6433
stRp10481
ag1
(g9146
g9115
(dp10482
g6382
g6412
sg6370
g6692
sg6385
g6419
sg6379
g6699
stRp10483
ag1
(g9146
g9115
(dp10484
g6382
g7098
sg6370
g7094
sg6385
g7105
sg6379
g7102
stRp10485
ag1
(g9146
g9115
(dp10486
g6382
g6756
sg6370
g7606
sg6385
g6763
sg6379
g7613
stRp10487
ag1
(g9146
g9115
(dp10488
g6382
g6383
sg6370
g6982
sg6385
g6375
sg6379
g6989
stRp10489
ag1
(g9146
g9115
(dp10490
g6382
g6672
sg6370
g8052
sg6385
g6666
sg6379
g8059
stRp10491
ag1
(g9146
g9115
(dp10492
g6382
g6510
sg6370
g6506
sg6385
g6517
sg6379
g6514
stRp10493
ag1
(g9146
g9115
(dp10494
g6382
g6561
sg6370
g6557
sg6385
g6568
sg6379
g6565
stRp10495
ag1
(g9146
g9115
(dp10496
g6382
g6383
sg6370
g6371
sg6385
g6375
sg6379
g6380
stRp10497
ag1
(g9146
g9115
(dp10498
g6382
g6395
sg6370
g6391
sg6385
g6402
sg6379
g6399
stRp10499
ag1
(g9146
g9115
(dp10500
g6382
g6510
sg6370
g6506
sg6385
g6517
sg6379
g6514
stRp10501
ag1
(g9146
g9115
(dp10502
g6382
g7098
sg6370
g7353
sg6385
g7105
sg6379
g7360
stRp10503
ag1
(g9146
g9115
(dp10504
g6382
g6510
sg6370
g6506
sg6385
g6517
sg6379
g6514
stRp10505
ag1
(g9146
g9115
(dp10506
g6382
g6383
sg6370
g6982
sg6385
g6375
sg6379
g6989
stRp10507
ag1
(g9146
g9115
(dp10508
g6382
g6463
sg6370
g6634
sg6385
g6470
sg6379
g6641
stRp10509
ag1
(g9146
g9115
(dp10510
g6382
g6429
sg6370
g7446
sg6385
g6436
sg6379
g7453
stRp10511
ag1
(g9146
g9115
(dp10512
g6382
g6412
sg6370
g6408
sg6385
g6419
sg6379
g6416
stRp10513
ag1
(g9146
g9115
(dp10514
g6382
g7169
sg6370
g7686
sg6385
g7176
sg6379
g7693
stRp10515
ag1
(g9146
g9115
(dp10516
g6382
g6578
sg6370
g6707
sg6385
g6585
sg6379
g6714
stRp10517
ag1
(g9146
g9115
(dp10518
g6382
g6412
sg6370
g6692
sg6385
g6419
sg6379
g6699
stRp10519
ag1
(g9146
g9115
(dp10520
g6382
g6756
sg6370
g6752
sg6385
g6763
sg6379
g6760
stRp10521
ag1
(g9146
g9115
(dp10522
g6382
g7098
sg6370
g7094
sg6385
g7105
sg6379
g7102
stRp10523
ag1
(g9146
g9115
(dp10524
g6382
g6672
sg6370
g8052
sg6385
g6666
sg6379
g8059
stRp10525
ag1
(g9146
g9115
(dp10526
g6382
g7087
sg6370
g7077
sg6385
g7081
sg6379
g7085
stRp10527
ag1
(g9146
g9115
(dp10528
g6382
g6429
sg6370
g7446
sg6385
g6436
sg6379
g7453
stRp10529
ag1
(g9146
g9115
(dp10530
g6382
g7087
sg6370
g7077
sg6385
g7081
sg6379
g7085
stRp10531
ag1
(g9146
g9115
(dp10532
g6382
g6872
sg6370
g7023
sg6385
g6879
sg6379
g7030
stRp10533
ag1
(g9146
g9115
(dp10534
g6382
g7098
sg6370
g7353
sg6385
g7105
sg6379
g7360
stRp10535
ag1
(g9146
g9115
(dp10536
g6382
g7087
sg6370
g7077
sg6385
g7081
sg6379
g7085
stRp10537
ag1
(g9146
g9115
(dp10538
g6382
g6544
sg6370
g7273
sg6385
g6551
sg6379
g7280
stRp10539
ag1
(g9146
g9115
(dp10540
g6382
g6672
sg6370
g8052
sg6385
g6666
sg6379
g8059
stRp10541
ag1
(g9146
g9115
(dp10542
g6382
g6969
sg6370
g7111
sg6385
g6976
sg6379
g7118
stRp10543
ag1
(g9146
g9115
(dp10544
g6382
g6429
sg6370
g7446
sg6385
g6436
sg6379
g7453
stRp10545
ag1
(g9146
g9115
(dp10546
g6382
g6756
sg6370
g7606
sg6385
g6763
sg6379
g7613
stRp10547
ag1
(g9146
g9115
(dp10548
g6382
g6578
sg6370
g6707
sg6385
g6585
sg6379
g6714
stRp10549
ag1
(g9146
g9115
(dp10550
g6382
g6412
sg6370
g6692
sg6385
g6419
sg6379
g6699
stRp10551
ag1
(g9146
g9115
(dp10552
g6382
g6383
sg6370
g6371
sg6385
g6375
sg6379
g6380
stRp10553
ag1
(g9146
g9115
(dp10554
g6382
g6544
sg6370
g7273
sg6385
g6551
sg6379
g7280
stRp10555
ag1
(g9146
g9115
(dp10556
g6382
g6463
sg6370
g6459
sg6385
g6470
sg6379
g6467
stRp10557
ag1
(g9146
g9115
(dp10558
g6382
g6672
sg6370
g6662
sg6385
g6666
sg6379
g6670
stRp10559
ag1
(g9146
g9115
(dp10560
g6382
g6395
sg6370
g6391
sg6385
g6402
sg6379
g6399
stRp10561
ag1
(g9146
g9115
(dp10562
g6382
g6756
sg6370
g7606
sg6385
g6763
sg6379
g7613
stRp10563
ag1
(g9146
g9115
(dp10564
g6382
g6383
sg6370
g6982
sg6385
g6375
sg6379
g6989
stRp10565
ag1
(g9146
g9115
(dp10566
g6382
g6527
sg6370
g6523
sg6385
g6534
sg6379
g6531
stRp10567
ag1
(g9146
g9115
(dp10568
g6382
g7169
sg6370
g7165
sg6385
g7176
sg6379
g7173
stRp10569
ag1
(g9146
g9115
(dp10570
g6382
g6446
sg6370
g6491
sg6385
g6453
sg6379
g6498
stRp10571
ag1
(g9146
g9115
(dp10572
g6382
g6969
sg6370
g7111
sg6385
g6976
sg6379
g7118
stRp10573
ag1
(g9146
g9115
(dp10574
g6382
g6595
sg6370
g6591
sg6385
g6602
sg6379
g6599
stRp10575
ag1
(g9146
g9115
(dp10576
g6382
g6672
sg6370
g6662
sg6385
g6666
sg6379
g6670
stRp10577
ag1
(g9146
g9115
(dp10578
g6382
g6429
sg6370
g6425
sg6385
g6436
sg6379
g6433
stRp10579
ag1
(g9146
g9115
(dp10580
g6382
g6561
sg6370
g6795
sg6385
g6568
sg6379
g6802
stRp10581
ag1
(g9146
g9115
(dp10582
g6382
g6395
sg6370
g6476
sg6385
g6402
sg6379
g6483
stRp10583
ag1
(g9146
g9115
(dp10584
g6382
g6544
sg6370
g7273
sg6385
g6551
sg6379
g7280
stRp10585
ag1
(g9146
g9115
(dp10586
g6382
g6561
sg6370
g6557
sg6385
g6568
sg6379
g6565
stRp10587
ag1
(g9146
g9115
(dp10588
g6382
g6510
sg6370
g6825
sg6385
g6517
sg6379
g6832
stRp10589
ag1
(g9146
g9115
(dp10590
g6382
g7169
sg6370
g7165
sg6385
g7176
sg6379
g7173
stRp10591
ag1
(g9146
g9115
(dp10592
g6382
g6527
sg6370
g6810
sg6385
g6534
sg6379
g6817
stRp10593
ag1
(g9146
g9115
(dp10594
g6382
g6395
sg6370
g6476
sg6385
g6402
sg6379
g6483
stRp10595
ag1
(g9146
g9115
(dp10596
g6382
g6672
sg6370
g6662
sg6385
g6666
sg6379
g6670
stRp10597
ag1
(g9146
g9115
(dp10598
g6382
g7169
sg6370
g7686
sg6385
g7176
sg6379
g7693
stRp10599
ag1
(g9146
g9115
(dp10600
g6382
g6726
sg6370
g6937
sg6385
g6733
sg6379
g6944
stRp10601
ag1
(g9146
g9115
(dp10602
g6382
g6578
sg6370
g6707
sg6385
g6585
sg6379
g6714
stRp10603
ag1
(g9146
g9115
(dp10604
g6382
g7087
sg6370
g7077
sg6385
g7081
sg6379
g7085
stRp10605
ag1
(g9146
g9115
(dp10606
g6382
g6726
sg6370
g6937
sg6385
g6733
sg6379
g6944
stRp10607
ag1
(g9146
g9115
(dp10608
g6382
g7087
sg6370
g7513
sg6385
g7081
sg6379
g7520
stRp10609
ag1
(g9146
g9115
(dp10610
g6382
g6872
sg6370
g6868
sg6385
g6879
sg6379
g6876
stRp10611
ag1
(g9146
g9115
(dp10612
g6382
g6756
sg6370
g6752
sg6385
g6763
sg6379
g6760
stRp10613
ag1
(g9146
g9115
(dp10614
g6382
g6544
sg6370
g7273
sg6385
g6551
sg6379
g7280
stRp10615
ag1
(g9146
g9115
(dp10616
g6382
g7087
sg6370
g7513
sg6385
g7081
sg6379
g7520
stRp10617
ag1
(g9146
g9115
(dp10618
g6382
g6672
sg6370
g6662
sg6385
g6666
sg6379
g6670
stRp10619
ag1
(g9146
g9115
(dp10620
g6382
g6527
sg6370
g6810
sg6385
g6534
sg6379
g6817
stRp10621
ag1
(g9146
g9115
(dp10622
g6382
g6726
sg6370
g6937
sg6385
g6733
sg6379
g6944
stRp10623
ag1
(g9146
g9115
(dp10624
g6382
g7169
sg6370
g7686
sg6385
g7176
sg6379
g7693
stRp10625
ag1
(g9146
g9115
(dp10626
g6382
g6672
sg6370
g8052
sg6385
g6666
sg6379
g8059
stRp10627
ag1
(g9146
g9115
(dp10628
g6382
g7087
sg6370
g7513
sg6385
g7081
sg6379
g7520
stRp10629
ag1
(g9146
g9115
(dp10630
g6382
g6412
sg6370
g6408
sg6385
g6419
sg6379
g6416
stRp10631
ag1
(g9146
g9115
(dp10632
g6382
g6578
sg6370
g6574
sg6385
g6585
sg6379
g6582
stRp10633
ag1
(g9146
g9115
(dp10634
g6382
g6595
sg6370
g6840
sg6385
g6602
sg6379
g6847
stRp10635
ag1
(g9146
g9115
(dp10636
g6382
g6726
sg6370
g6722
sg6385
g6733
sg6379
g6730
stRp10637
ag1
(g9146
g9115
(dp10638
g6382
g6672
sg6370
g8052
sg6385
g6666
sg6379
g8059
stRp10639
ag1
(g9146
g9115
(dp10640
g6382
g6969
sg6370
g6965
sg6385
g6976
sg6379
g6973
stRp10641
ag1
(g9146
g9115
(dp10642
g6382
g6872
sg6370
g6868
sg6385
g6879
sg6379
g6876
stRp10643
ag1
(g9146
g9115
(dp10644
g6382
g6969
sg6370
g7111
sg6385
g6976
sg6379
g7118
stRp10645
ag1
(g9146
g9115
(dp10646
g6382
g7169
sg6370
g7686
sg6385
g7176
sg6379
g7693
stRp10647
ag1
(g9146
g9115
(dp10648
g6382
g6463
sg6370
g6459
sg6385
g6470
sg6379
g6467
stRp10649
asg9227
Nsg9228
g9085
sg9229
I200
sg9230
I0
sg9231
I200
sg9232
I01
sbasS'savePickle'
p10650
I00
sb.