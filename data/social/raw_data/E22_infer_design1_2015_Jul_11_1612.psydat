ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
NsS'dataFileName'
p7
Vdata/E22_infer_design1_2015_Jul_11_1612
p8
sS'runtimeInfo'
p9
NsS'name'
p10
S'infer_design1'
p11
sS'dataNames'
p12
(lp13
S'instr_main_resp.keys'
p14
aS'instr_main_resp.rt'
p15
aS'instr_bdm_resp.keys'
p16
aS'partnered_pilot_participant'
p17
aS'instr_bdm_resp.rt'
p18
aS'bdm_bid1.response'
p19
aS'bdm_bid1.rt'
p20
aS'bdm_marker_start'
p21
aS'instr_choice_resp.keys'
p22
aS'instr_choice_resp.rt'
p23
aS'key_resp_choice.keys'
p24
aS'key_resp_choice.rt'
p25
aS'confidence_rating1.response'
p26
aS'confidence_rating1.rt'
p27
aS'confidence_marker_start'
p28
aS'instr_infer_intro_resp.keys'
p29
aS'instr_infer_intro_resp.rt'
p30
aS'instr_infer_practice_resp.keys'
p31
aS'instr_infer_practice_resp.rt'
p32
aS'set_feedback.feedback_img'
p33
aS'trial_start_time'
p34
aS'instr_infer_resp.keys'
p35
aS'instr_infer_resp.rt'
p36
aS'get_ready_resp.keys'
p37
aS'infer_resp.keys'
p38
aS'infer_resp.rt'
p39
aS'rest_prompt_resp.keys'
p40
aS'rest_prompt_resp.rt'
p41
aS'correct_counter'
p42
aS'incorrect_counter'
p43
aS'auction.win_item'
p44
aS'auction.price'
p45
aS'auction.bid'
p46
aS'auction.rand_itm_img'
p47
aS'score.base'
p48
aS'score.rwrd'
p49
aS'score.loss'
p50
aS'score.final_pymt'
p51
asS'autoLog'
p52
I01
sS'extraInfo'
p53
(dp54
S'expName'
p55
g11
sVeye
p56
Vleft
p57
sVcontacts
p58
Vy
sS'frameRate'
p59
cnumpy.core.multiarray
scalar
p60
(cnumpy
dtype
p61
(S'f8'
I0
I1
tRp62
(I3
S'<'
NNNI-1
I-1
I0
tbS"'\xef\xe7\xbb\x86\x04N@"
tRp63
sVsession
p64
V001
p65
sS'date'
p66
V2015_Jul_11_1612
p67
sVparticipant
p68
VE22
p69
sVglasses
p70
Vn
ssS'loopsUnfinished'
p71
(lp72
sS'saveWideText'
p73
I01
sS'thisEntry'
p74
(dp75
sS'version'
p76
S''
sS'_paramNamesSoFar'
p77
(lp78
Vbdm_img
p79
aS'choice_left'
p80
aS'choice_right'
p81
aS'img_correct'
p82
aS'img_left'
p83
aS'img_wrong'
p84
aS'img_right'
p85
asS'entries'
p86
(lp87
(dp88
g64
g65
sg56
g57
sg15
F0.46682411758592934
sg14
S'space'
p89
sg59
g63
sg58
Vy
sg55
g11
sg66
g67
sg68
g69
sg70
Vn
sa(dp90
g64
g65
sg56
g57
sg58
Vy
sg59
g63
sg16
S'space'
p91
sg55
g11
sg66
g67
sg68
g69
sg18
F13.400004789669765
sg17
cnumpy.core.multiarray
_reconstruct
p92
(cnumpy
ndarray
p93
(I0
tS'b'
tRp94
(I1
(I1
tg61
(S'S3'
I0
I1
tRp95
(I3
S'|'
NNNI3
I1
I0
tbI00
S'P6\x00'
tbsg70
Vn
sa(dp96
g64
g65
sg20
F12.851000000000001
sg56
g57
sg58
Vy
sg59
g63
sS'bdm_loop1.thisN'
p97
I0
sg19
F0.99999999999999978
sg55
g11
sS'bdm_loop1.thisIndex'
p98
g60
(g61
(S'i4'
I0
I1
tRp99
(I3
S'<'
NNNI-1
I-1
I0
tbS'\x04\x00\x00\x00'
tRp100
sS'bdm_loop1.thisRepN'
p101
I0
sS'bdm_loop1.thisTrialN'
p102
I0
sg66
g67
sg68
g69
sg79
V5-pineapple.png
p103
sg21
F1.2
sg70
Vn
sa(dp104
g64
g65
sg20
F4.734
sg56
g57
sg58
Vy
sg59
g63
sS'bdm_loop1.thisN'
p105
I1
sg19
F0.1599999999999985
sg55
g11
sS'bdm_loop1.thisIndex'
p106
g60
(g99
S'\x07\x00\x00\x00'
tRp107
sS'bdm_loop1.thisRepN'
p108
I0
sS'bdm_loop1.thisTrialN'
p109
I1
sg66
g67
sg68
g69
sg79
V8-liquorice_catherine_wheels.png
p110
sg21
F1.8999999999999999
sg70
Vn
sa(dp111
g64
g65
sg20
F3.4169999999999998
sg56
g57
sg58
Vy
sg59
g63
sS'bdm_loop1.thisN'
p112
I2
sg19
F0
sg55
g11
sS'bdm_loop1.thisIndex'
p113
g60
(g99
S'\x06\x00\x00\x00'
tRp114
sS'bdm_loop1.thisRepN'
p115
I0
sS'bdm_loop1.thisTrialN'
p116
I2
sg66
g67
sg68
g69
sg79
V7-olives.png
p117
sg21
F2
sg70
Vn
sa(dp118
g64
g65
sg20
F4.101
sg56
g57
sg58
Vy
sg59
g63
sS'bdm_loop1.thisN'
p119
I3
sg19
F0.47999999999999865
sg55
g11
sS'bdm_loop1.thisIndex'
p120
g60
(g99
S'\x0f\x00\x00\x00'
tRp121
sS'bdm_loop1.thisRepN'
p122
I0
sS'bdm_loop1.thisTrialN'
p123
I3
sg66
g67
sg68
g69
sg79
V21-nakd_banana_crunch.png
p124
sg21
F1.8999999999999999
sg70
Vn
sa(dp125
g64
g65
sg20
F7.5510000000000002
sg56
g57
sg58
Vy
sg59
g63
sS'bdm_loop1.thisN'
p126
I4
sg19
F1.1800000000000002
sg55
g11
sS'bdm_loop1.thisIndex'
p127
g60
(g99
S'\x1d\x00\x00\x00'
tRp128
sS'bdm_loop1.thisRepN'
p129
I0
sS'bdm_loop1.thisTrialN'
p130
I4
sg66
g67
sg68
g69
sg79
V40-sardines.png
p131
sg21
F1
sg70
Vn
sa(dp132
g64
g65
sg20
F4.1669999999999998
sg56
g57
sg58
Vy
sg59
g63
sS'bdm_loop1.thisN'
p133
I5
sg19
F0.67999999999999883
sg55
g11
sS'bdm_loop1.thisIndex'
p134
g60
(g99
S'\x19\x00\x00\x00'
tRp135
sS'bdm_loop1.thisRepN'
p136
I0
sS'bdm_loop1.thisTrialN'
p137
I5
sg66
g67
sg68
g69
sg79
V34-hula_hoops_bbq_beef_redo.png
p138
sg21
F1.8999999999999999
sg70
Vn
sa(dp139
g64
g65
sg20
F2.7010000000000001
sg56
g57
sg58
Vy
sg59
g63
sS'bdm_loop1.thisN'
p140
I6
sg19
F0.5999999999999992
sg55
g11
sS'bdm_loop1.thisIndex'
p141
g60
(g99
S'\x12\x00\x00\x00'
tRp142
sS'bdm_loop1.thisRepN'
p143
I0
sS'bdm_loop1.thisTrialN'
p144
I6
sg66
g67
sg68
g69
sg79
V25-kitkat.png
p145
sg21
F1.5
sg70
Vn
sa(dp146
g64
g65
sg20
F4.5339999999999998
sg56
g57
sg58
Vy
sg59
g63
sS'bdm_loop1.thisN'
p147
I7
sg19
F1.0599999999999992
sg55
g11
sS'bdm_loop1.thisIndex'
p148
g60
(g99
S'\x15\x00\x00\x00'
tRp149
sS'bdm_loop1.thisRepN'
p150
I0
sS'bdm_loop1.thisTrialN'
p151
I7
sg66
g67
sg68
g69
sg79
V29-beans.png
p152
sg21
F1.8999999999999999
sg70
Vn
sa(dp153
g64
g65
sg20
F3.4009999999999998
sg56
g57
sg58
Vy
sg59
g63
sS'bdm_loop1.thisN'
p154
I8
sg19
F0.27999999999999914
sg55
g11
sS'bdm_loop1.thisIndex'
p155
g60
(g99
S'"\x00\x00\x00'
tRp156
sS'bdm_loop1.thisRepN'
p157
I0
sS'bdm_loop1.thisTrialN'
p158
I8
sg66
g67
sg68
g69
sg79
V45-chewy_nougat_redo.png
p159
sg21
F1.3
sg70
Vn
sa(dp160
g64
g65
sg20
F6.367
sg56
g57
sg58
Vy
sg59
g63
sS'bdm_loop1.thisN'
p161
I9
sg19
F0.57999999999999918
sg55
g11
sS'bdm_loop1.thisIndex'
p162
g60
(g99
S'\x13\x00\x00\x00'
tRp163
sS'bdm_loop1.thisRepN'
p164
I0
sS'bdm_loop1.thisTrialN'
p165
I9
sg66
g67
sg68
g69
sg79
V26-walkers_smoky_bacon.png
p166
sg21
F1.5
sg70
Vn
sa(dp167
g64
g65
sg20
F4.117
sg56
g57
sg58
Vy
sg59
g63
sS'bdm_loop1.thisN'
p168
I10
sg19
F0.83999999999999986
sg55
g11
sS'bdm_loop1.thisIndex'
p169
g60
(g99
S'#\x00\x00\x00'
tRp170
sS'bdm_loop1.thisRepN'
p171
I0
sS'bdm_loop1.thisTrialN'
p172
I10
sg66
g67
sg68
g69
sg79
V46-pistachios.png
p173
sg21
F1.1000000000000001
sg70
Vn
sa(dp174
g64
g65
sg20
F3.9670000000000001
sg56
g57
sg58
Vy
sg59
g63
sS'bdm_loop1.thisN'
p175
I11
sg19
F0.97999999999999909
sg55
g11
sS'bdm_loop1.thisIndex'
p176
g60
(g99
S'$\x00\x00\x00'
tRp177
sS'bdm_loop1.thisRepN'
p178
I0
sS'bdm_loop1.thisTrialN'
p179
I11
sg66
g67
sg68
g69
sg79
V48-twix.png
p180
sg21
F1.8999999999999999
sg70
Vn
sa(dp181
g64
g65
sg20
F5.9169999999999998
sg56
g57
sg58
Vy
sg59
g63
sS'bdm_loop1.thisN'
p182
I12
sg19
F1.1199999999999992
sg55
g11
sS'bdm_loop1.thisIndex'
p183
g60
(g99
S'\x0b\x00\x00\x00'
tRp184
sS'bdm_loop1.thisRepN'
p185
I0
sS'bdm_loop1.thisTrialN'
p186
I12
sg66
g67
sg68
g69
sg79
V17-jacobs_mini_cheddars_redo.png
p187
sg21
F1.8999999999999999
sg70
Vn
sa(dp188
g64
g65
sg20
F2.4510000000000001
sg56
g57
sg58
Vy
sg59
g63
sS'bdm_loop1.thisN'
p189
I13
sg19
F0.55999999999999917
sg55
g11
sS'bdm_loop1.thisIndex'
p190
g60
(g99
S'\t\x00\x00\x00'
tRp191
sS'bdm_loop1.thisRepN'
p192
I0
sS'bdm_loop1.thisTrialN'
p193
I13
sg66
g67
sg68
g69
sg79
V13-mccoys_steak_crisps.png
p194
sg21
F1.5
sg70
Vn
sa(dp195
g64
g65
sg20
F5.0010000000000003
sg56
g57
sg58
Vy
sg59
g63
sS'bdm_loop1.thisN'
p196
I14
sg19
F0.45999999999999908
sg55
g11
sS'bdm_loop1.thisIndex'
p197
g60
(g99
S'\x0e\x00\x00\x00'
tRp198
sS'bdm_loop1.thisRepN'
p199
I0
sS'bdm_loop1.thisTrialN'
p200
I14
sg66
g67
sg68
g69
sg79
V20-fruit_pastilles.png
p201
sg21
F1.5
sg70
Vn
sa(dp202
g64
g65
sg20
F3.2839999999999998
sg56
g57
sg58
Vy
sg59
g63
sS'bdm_loop1.thisN'
p203
I15
sg19
F0
sg55
g11
sS'bdm_loop1.thisIndex'
p204
g60
(g99
S'\x08\x00\x00\x00'
tRp205
sS'bdm_loop1.thisRepN'
p206
I0
sS'bdm_loop1.thisTrialN'
p207
I15
sg66
g67
sg68
g69
sg79
V10-bounty_redo.png
p208
sg21
F1.5
sg70
Vn
sa(dp209
g64
g65
sg20
F4.7839999999999998
sg56
g57
sg58
Vy
sg59
g63
sS'bdm_loop1.thisN'
p210
I16
sg19
F1.2199999999999995
sg55
g11
sS'bdm_loop1.thisIndex'
p211
g60
(g99
S'!\x00\x00\x00'
tRp212
sS'bdm_loop1.thisRepN'
p213
I0
sS'bdm_loop1.thisTrialN'
p214
I16
sg66
g67
sg68
g69
sg79
V44-crunch.png
p215
sg21
F1.8
sg70
Vn
sa(dp216
g64
g65
sg20
F3.2170000000000001
sg56
g57
sg58
Vy
sg59
g63
sS'bdm_loop1.thisN'
p217
I17
sg19
F1.1799999999999993
sg55
g11
sS'bdm_loop1.thisIndex'
p218
g60
(g99
S'\x05\x00\x00\x00'
tRp219
sS'bdm_loop1.thisRepN'
p220
I0
sS'bdm_loop1.thisTrialN'
p221
I17
sg66
g67
sg68
g69
sg79
V6-sour_patch_kids.png
p222
sg21
F1.8999999999999999
sg70
Vn
sa(dp223
g64
g65
sg20
F2.9009999999999998
sg56
g57
sg58
Vy
sg59
g63
sS'bdm_loop1.thisN'
p224
I18
sg19
F1
sg55
g11
sS'bdm_loop1.thisIndex'
p225
g60
(g99
S'\x16\x00\x00\x00'
tRp226
sS'bdm_loop1.thisRepN'
p227
I0
sS'bdm_loop1.thisTrialN'
p228
I18
sg66
g67
sg68
g69
sg79
V30-spaghetti_hoops.png
p229
sg21
F1.1000000000000001
sg70
Vn
sa(dp230
g64
g65
sg20
F2.4510000000000001
sg56
g57
sg58
Vy
sg59
g63
sS'bdm_loop1.thisN'
p231
I19
sg19
F0.59999999999999942
sg55
g11
sS'bdm_loop1.thisIndex'
p232
g60
(g99
S'\x11\x00\x00\x00'
tRp233
sS'bdm_loop1.thisRepN'
p234
I0
sS'bdm_loop1.thisTrialN'
p235
I19
sg66
g67
sg68
g69
sg79
V23-crunchie_redo.png
p236
sg21
F1.2
sg70
Vn
sa(dp237
g64
g65
sg20
F3.9169999999999998
sg56
g57
sg58
Vy
sg59
g63
sS'bdm_loop1.thisN'
p238
I20
sg19
F0.63999999999999879
sg55
g11
sS'bdm_loop1.thisIndex'
p239
g60
(g99
S'\r\x00\x00\x00'
tRp240
sS'bdm_loop1.thisRepN'
p241
I0
sS'bdm_loop1.thisTrialN'
p242
I20
sg66
g67
sg68
g69
sg79
V19-caramello_redo.png
p243
sg21
F1.8999999999999999
sg70
Vn
sa(dp244
g64
g65
sg20
F5.3339999999999996
sg56
g57
sg58
Vy
sg59
g63
sS'bdm_loop1.thisN'
p245
I21
sg19
F0.47999999999999909
sg55
g11
sS'bdm_loop1.thisIndex'
p246
g60
(g99
S'\x14\x00\x00\x00'
tRp247
sS'bdm_loop1.thisRepN'
p248
I0
sS'bdm_loop1.thisTrialN'
p249
I21
sg66
g67
sg68
g69
sg79
V27-hartleys_raspberries_jelly.png
p250
sg21
F1.3999999999999999
sg70
Vn
sa(dp251
g64
g65
sg20
F5.0010000000000003
sg56
g57
sg58
Vy
sg59
g63
sS'bdm_loop1.thisN'
p252
I22
sg19
F1.3600000000000003
sg55
g11
sS'bdm_loop1.thisIndex'
p253
g60
(g99
S'\x1c\x00\x00\x00'
tRp254
sS'bdm_loop1.thisRepN'
p255
I0
sS'bdm_loop1.thisTrialN'
p256
I22
sg66
g67
sg68
g69
sg79
V38-maltesers.png
p257
sg21
F1.1000000000000001
sg70
Vn
sa(dp258
g64
g65
sg20
F6.7009999999999996
sg56
g57
sg58
Vy
sg59
g63
sS'bdm_loop1.thisN'
p259
I23
sg19
F0.99999999999999978
sg55
g11
sS'bdm_loop1.thisIndex'
p260
g60
(g99
S'\x1a\x00\x00\x00'
tRp261
sS'bdm_loop1.thisRepN'
p262
I0
sS'bdm_loop1.thisTrialN'
p263
I23
sg66
g67
sg68
g69
sg79
V35-raisins.png
p264
sg21
F1.3
sg70
Vn
sa(dp265
g64
g65
sg20
F4.468
sg56
g57
sg58
Vy
sg59
g63
sS'bdm_loop1.thisN'
p266
I24
sg19
F1.02
sg55
g11
sS'bdm_loop1.thisIndex'
p267
g60
(g99
S'\x1b\x00\x00\x00'
tRp268
sS'bdm_loop1.thisRepN'
p269
I0
sS'bdm_loop1.thisTrialN'
p270
I24
sg66
g67
sg68
g69
sg79
V36-fig_rolls.png
p271
sg21
F1.1000000000000001
sg70
Vn
sa(dp272
g64
g65
sg20
F4.4340000000000002
sg56
g57
sg58
Vy
sg59
g63
sS'bdm_loop1.thisN'
p273
I25
sg19
F0.7599999999999989
sg55
g11
sS'bdm_loop1.thisIndex'
p274
g60
(g99
S'\x18\x00\x00\x00'
tRp275
sS'bdm_loop1.thisRepN'
p276
I0
sS'bdm_loop1.thisTrialN'
p277
I25
sg66
g67
sg68
g69
sg79
V33-ambrosia_rice.png
p278
sg21
F1.8999999999999999
sg70
Vn
sa(dp279
g64
g65
sg20
F5.601
sg56
g57
sg58
Vy
sg59
g63
sS'bdm_loop1.thisN'
p280
I26
sg19
F0.91999999999999971
sg55
g11
sS'bdm_loop1.thisIndex'
p281
g60
(g99
S'%\x00\x00\x00'
tRp282
sS'bdm_loop1.thisRepN'
p283
I0
sS'bdm_loop1.thisTrialN'
p284
I26
sg66
g67
sg68
g69
sg79
V49-yorkie.png
p285
sg21
F1.2
sg70
Vn
sa(dp286
g64
g65
sg20
F2.984
sg56
g57
sg58
Vy
sg59
g63
sS'bdm_loop1.thisN'
p287
I27
sg19
F1.0799999999999996
sg55
g11
sS'bdm_loop1.thisIndex'
p288
g60
(g99
S' \x00\x00\x00'
tRp289
sS'bdm_loop1.thisRepN'
p290
I0
sS'bdm_loop1.thisTrialN'
p291
I27
sg66
g67
sg68
g69
sg79
V43-mrporky_pork_crackles_redo.png
p292
sg21
F1.6000000000000001
sg70
Vn
sa(dp293
g64
g65
sg20
F2.4340000000000002
sg56
g57
sg58
Vy
sg59
g63
sS'bdm_loop1.thisN'
p294
I28
sg19
F0.53999999999999959
sg55
g11
sS'bdm_loop1.thisIndex'
p295
g60
(g99
S'\n\x00\x00\x00'
tRp296
sS'bdm_loop1.thisRepN'
p297
I0
sS'bdm_loop1.thisTrialN'
p298
I28
sg66
g67
sg68
g69
sg79
V16-skips_prawn.png
p299
sg21
F1.1000000000000001
sg70
Vn
sa(dp300
g64
g65
sg20
F4.5510000000000002
sg56
g57
sg58
Vy
sg59
g63
sS'bdm_loop1.thisN'
p301
I29
sg19
F1.1999999999999995
sg55
g11
sS'bdm_loop1.thisIndex'
p302
g60
(g99
S'\x1f\x00\x00\x00'
tRp303
sS'bdm_loop1.thisRepN'
p304
I0
sS'bdm_loop1.thisTrialN'
p305
I29
sg66
g67
sg68
g69
sg79
V42-mrkipling_lemon_slices.png
p306
sg21
F1.7
sg70
Vn
sa(dp307
g64
g65
sg20
F3.6669999999999998
sg56
g57
sg58
Vy
sg59
g63
sS'bdm_loop1.thisN'
p308
I30
sg19
F0.73999999999999932
sg55
g11
sS'bdm_loop1.thisIndex'
p309
g60
(g99
S'\x10\x00\x00\x00'
tRp310
sS'bdm_loop1.thisRepN'
p311
I0
sS'bdm_loop1.thisTrialN'
p312
I30
sg66
g67
sg68
g69
sg79
V22-daim.png
p313
sg21
F1.3999999999999999
sg70
Vn
sa(dp314
g64
g65
sg20
F4.1340000000000003
sg56
g57
sg58
Vy
sg59
g63
sS'bdm_loop1.thisN'
p315
I31
sg19
F1.0799999999999994
sg55
g11
sS'bdm_loop1.thisIndex'
p316
g60
(g99
S'\x1e\x00\x00\x00'
tRp317
sS'bdm_loop1.thisRepN'
p318
I0
sS'bdm_loop1.thisTrialN'
p319
I31
sg66
g67
sg68
g69
sg79
V41-peanuts_redo.png
p320
sg21
F1.7
sg70
Vn
sa(dp321
g64
g65
sg20
F9.2840000000000007
sg56
g57
sg58
Vy
sg59
g63
sS'bdm_loop1.thisN'
p322
I32
sg19
F2.0200000000000005
sg55
g11
sS'bdm_loop1.thisIndex'
p323
g60
(g99
S'\x00\x00\x00\x00'
tRp324
sS'bdm_loop1.thisRepN'
p325
I0
sS'bdm_loop1.thisTrialN'
p326
I32
sg66
g67
sg68
g69
sg79
V1-treacle_cookies.png
p327
sg21
F1.2
sg70
Vn
sa(dp328
g64
g65
sg20
F2.9510000000000001
sg56
g57
sg58
Vy
sg59
g63
sS'bdm_loop1.thisN'
p329
I33
sg19
F0.39999999999999858
sg55
g11
sS'bdm_loop1.thisIndex'
p330
g60
(g99
S'\x02\x00\x00\x00'
tRp331
sS'bdm_loop1.thisRepN'
p332
I0
sS'bdm_loop1.thisTrialN'
p333
I33
sg66
g67
sg68
g69
sg79
V3-ellas_strawberries_apples.png
p334
sg21
F1.8999999999999999
sg70
Vn
sa(dp335
g64
g65
sg20
F4.4509999999999996
sg56
g57
sg58
Vy
sg59
g63
sS'bdm_loop1.thisN'
p336
I34
sg19
F1.5
sg55
g11
sS'bdm_loop1.thisIndex'
p337
g60
(g99
S'\x0c\x00\x00\x00'
tRp338
sS'bdm_loop1.thisRepN'
p339
I0
sS'bdm_loop1.thisTrialN'
p340
I34
sg66
g67
sg68
g69
sg79
V18-mms.png
p341
sg21
F1.3999999999999999
sg70
Vn
sa(dp342
g64
g65
sg20
F4.851
sg56
g57
sg58
Vy
sg59
g63
sS'bdm_loop1.thisN'
p343
I35
sg19
F1.2200000000000002
sg55
g11
sS'bdm_loop1.thisIndex'
p344
g60
(g99
S'\x17\x00\x00\x00'
tRp345
sS'bdm_loop1.thisRepN'
p346
I0
sS'bdm_loop1.thisTrialN'
p347
I35
sg66
g67
sg68
g69
sg79
V31-hobnobs.png
p348
sg21
F1.1000000000000001
sg70
Vn
sa(dp349
g64
g65
sg20
F2.7170000000000001
sg56
g57
sg58
Vy
sg59
g63
sS'bdm_loop1.thisN'
p350
I36
sg19
F0.35999999999999943
sg55
g11
sS'bdm_loop1.thisIndex'
p351
g60
(g99
S'&\x00\x00\x00'
tRp352
sS'bdm_loop1.thisRepN'
p353
I0
sS'bdm_loop1.thisTrialN'
p354
I36
sg66
g67
sg68
g69
sg79
V50-polo.png
p355
sg21
F1.1000000000000001
sg70
Vn
sa(dp356
g64
g65
sg20
F4.7839999999999998
sg56
g57
sg58
Vy
sg59
g63
sS'bdm_loop1.thisN'
p357
I37
sg19
F1.0199999999999991
sg55
g11
sS'bdm_loop1.thisIndex'
p358
g60
(g99
S'\x03\x00\x00\x00'
tRp359
sS'bdm_loop1.thisRepN'
p360
I0
sS'bdm_loop1.thisTrialN'
p361
I37
sg66
g67
sg68
g69
sg79
V4-corn.png
p362
sg21
F2
sg70
Vn
sa(dp363
g64
g65
sg20
F2.5009999999999999
sg56
g57
sg58
Vy
sg59
g63
sS'bdm_loop1.thisN'
p364
I38
sg19
F0.69999999999999885
sg55
g11
sS'bdm_loop1.thisIndex'
p365
g60
(g99
S"'\x00\x00\x00"
tRp366
sS'bdm_loop1.thisRepN'
p367
I0
sS'bdm_loop1.thisTrialN'
p368
I38
sg66
g67
sg68
g69
sg79
V51-mars.png
p369
sg21
F1.8999999999999999
sg70
Vn
sa(dp370
g64
g65
sg20
F5.617
sg56
g57
sg58
Vy
sg59
g63
sS'bdm_loop1.thisN'
p371
I39
sg19
F2.0000000000000009
sg55
g11
sS'bdm_loop1.thisIndex'
p372
g60
(g99
S'\x01\x00\x00\x00'
tRp373
sS'bdm_loop1.thisRepN'
p374
I0
sS'bdm_loop1.thisTrialN'
p375
I39
sg66
g67
sg68
g69
sg79
V2-steamed_puddings.png
p376
sg21
F1
sg70
Vn
sa(dp377
g64
g65
sg55
g11
sg56
g57
sg23
F37.94975720930961
sg58
Vy
sg59
g63
sg22
S'space'
p378
sg66
g67
sg68
g69
sg70
Vn
sa(dp379
g64
g65
sS'binary.thisRepN'
p380
I0
sg68
g69
sg80
S'5-pineapple.png'
p381
sg26
F5.9999999999999973
sg28
F3.7000000000000002
sg59
g63
sg58
Vy
sg81
S'40-sardines.png'
p382
sg66
g67
sg55
g11
sS'binary.thisN'
p383
I0
sg56
g57
sS'binary.thisIndex'
p384
g60
(g99
S'\x00\x00\x00\x00'
tRp385
sg24
S'left'
p386
sS'binary.thisTrialN'
p387
I0
sg25
F1.4333637059280591
sg27
F4.5839999999999996
sg70
Vn
sa(dp388
g64
g65
sS'binary.thisRepN'
p389
I0
sg68
g69
sg80
S'6-sour_patch_kids.png'
p390
sg26
F3.9000000000000008
sg28
F3.1000000000000001
sg59
g63
sg58
Vy
sg81
S'38-maltesers.png'
p391
sg66
g67
sg55
g11
sS'binary.thisN'
p392
I1
sg56
g57
sS'binary.thisIndex'
p393
g60
(g99
S'\x01\x00\x00\x00'
tRp394
sg24
S'right'
p395
sS'binary.thisTrialN'
p396
I1
sg25
F1.1331913348003582
sg27
F2.484
sg70
Vn
sa(dp397
g64
g65
sS'binary.thisRepN'
p398
I0
sg68
g69
sg80
S'34-hula_hoops_bbq_beef_redo.png'
p399
sg26
F3.5
sg28
F3.7000000000000002
sg59
g63
sg58
Vy
sg81
S'36-fig_rolls.png'
p400
sg66
g67
sg55
g11
sS'binary.thisN'
p401
I2
sg56
g57
sS'binary.thisIndex'
p402
g60
(g99
S'\x02\x00\x00\x00'
tRp403
sg24
S'left'
p404
sS'binary.thisTrialN'
p405
I2
sg25
F1.5834312174774823
sg27
F5.1509999999999998
sg70
Vn
sa(dp406
g64
g65
sS'binary.thisRepN'
p407
I0
sg68
g69
sg80
S'19-caramello_redo.png'
p408
sg26
F5.1000000000000005
sg28
F3.7000000000000002
sg59
g63
sg58
Vy
sg81
S'30-spaghetti_hoops.png'
p409
sg66
g67
sg55
g11
sS'binary.thisN'
p410
I3
sg56
g57
sS'binary.thisIndex'
p411
g60
(g99
S'\x03\x00\x00\x00'
tRp412
sg24
S'left'
p413
sS'binary.thisTrialN'
p414
I3
sg25
F0.96674286424604361
sg27
F1.4670000000000001
sg70
Vn
sa(dp415
g64
g65
sS'binary.thisRepN'
p416
I0
sg68
g69
sg80
S'46-pistachios.png'
p417
sg26
F4.6000000000000014
sg28
F3.2000000000000002
sg59
g63
sg58
Vy
sg81
S'29-beans.png'
p418
sg66
g67
sg55
g11
sS'binary.thisN'
p419
I4
sg56
g57
sS'binary.thisIndex'
p420
g60
(g99
S'\x04\x00\x00\x00'
tRp421
sg24
S'right'
p422
sS'binary.thisTrialN'
p423
I4
sg25
F0.88348726803087629
sg27
F1.8680000000000001
sg70
Vn
sa(dp424
g64
g65
sS'binary.thisRepN'
p425
I0
sg68
g69
sg80
S'13-mccoys_steak_crisps.png'
p426
sg26
F4
sg28
F4.2000000000000002
sg59
g63
sg58
Vy
sg81
S'3-ellas_strawberries_apples.png'
p427
sg66
g67
sg55
g11
sS'binary.thisN'
p428
I5
sg56
g57
sS'binary.thisIndex'
p429
g60
(g99
S'\x05\x00\x00\x00'
tRp430
sg24
S'left'
p431
sS'binary.thisTrialN'
p432
I5
sg25
F1.2500570198899368
sg27
F1.9339999999999999
sg70
Vn
sa(dp433
g64
g65
sS'binary.thisRepN'
p434
I0
sg68
g69
sg80
S'16-skips_prawn.png'
p435
sg26
F2.3999999999999995
sg28
F3
sg59
g63
sg58
Vy
sg81
S'42-mrkipling_lemon_slices.png'
p436
sg66
g67
sg55
g11
sS'binary.thisN'
p437
I6
sg56
g57
sS'binary.thisIndex'
p438
g60
(g99
S'\x06\x00\x00\x00'
tRp439
sg24
S'left'
p440
sS'binary.thisTrialN'
p441
I6
sg25
F3.933193216456857
sg27
F1.367
sg70
Vn
sa(dp442
g64
g65
sS'binary.thisRepN'
p443
I0
sg68
g69
sg80
S'25-kitkat.png'
p444
sg26
F5.4999999999999991
sg28
F3.5
sg59
g63
sg58
Vy
sg81
S'31-hobnobs.png'
p445
sg66
g67
sg55
g11
sS'binary.thisN'
p446
I7
sg56
g57
sS'binary.thisIndex'
p447
g60
(g99
S'\x07\x00\x00\x00'
tRp448
sg24
S'left'
p449
sS'binary.thisTrialN'
p450
I7
sg25
F0.86673510953914956
sg27
F2.2010000000000001
sg70
Vn
sa(dp451
g64
g65
sS'binary.thisRepN'
p452
I0
sg68
g69
sg80
S'1-treacle_cookies.png'
p453
sg26
F5.1000000000000014
sg28
F2.7999999999999998
sg59
g63
sg58
Vy
sg81
S'21-nakd_banana_crunch.png'
p454
sg66
g67
sg55
g11
sS'binary.thisN'
p455
I8
sg56
g57
sS'binary.thisIndex'
p456
g60
(g99
S'\x08\x00\x00\x00'
tRp457
sg24
S'left'
p458
sS'binary.thisTrialN'
p459
I8
sg25
F1.2667635624675313
sg27
F4.1680000000000001
sg70
Vn
sa(dp460
g64
g65
sS'binary.thisRepN'
p461
I0
sg68
g69
sg80
S'18-mms.png'
p462
sg26
F1.2999999999999994
sg28
F2.8999999999999999
sg59
g63
sg58
Vy
sg81
S'43-mrporky_pork_crackles_redo.png'
p463
sg66
g67
sg55
g11
sS'binary.thisN'
p464
I9
sg56
g57
sS'binary.thisIndex'
p465
g60
(g99
S'\t\x00\x00\x00'
tRp466
sg24
S'right'
p467
sS'binary.thisTrialN'
p468
I9
sg25
F4.1834033347513468
sg27
F1.4339999999999999
sg70
Vn
sa(dp469
g64
g65
sS'binary.thisRepN'
p470
I0
sg68
g69
sg80
S'48-twix.png'
p471
sg26
F4.0000000000000009
sg28
F3
sg59
g63
sg58
Vy
sg81
S'50-polo.png'
p472
sg66
g67
sg55
g11
sS'binary.thisN'
p473
I10
sg56
g57
sS'binary.thisIndex'
p474
g60
(g99
S'\n\x00\x00\x00'
tRp475
sg24
S'left'
p476
sS'binary.thisTrialN'
p477
I10
sg25
F2.1334256865447969
sg27
F2.5339999999999998
sg70
Vn
sa(dp478
g64
g65
sS'binary.thisRepN'
p479
I0
sg68
g69
sg80
S'45-chewy_nougat_redo.png'
p480
sg26
F1.099999999999999
sg28
F3.6000000000000001
sg59
g63
sg58
Vy
sg81
S'41-peanuts_redo.png'
p481
sg66
g67
sg55
g11
sS'binary.thisN'
p482
I11
sg56
g57
sS'binary.thisIndex'
p483
g60
(g99
S'\x0b\x00\x00\x00'
tRp484
sg24
S'right'
p485
sS'binary.thisTrialN'
p486
I11
sg25
F4.3167010116485471
sg27
F1.284
sg70
Vn
sa(dp487
g64
g65
sS'binary.thisRepN'
p488
I0
sg68
g69
sg80
S'3-ellas_strawberries_apples.png'
p489
sg26
F4
sg28
F4.0999999999999996
sg59
g63
sg58
Vy
sg81
S'13-mccoys_steak_crisps.png'
p490
sg66
g67
sg55
g11
sS'binary.thisN'
p491
I12
sg56
g57
sS'binary.thisIndex'
p492
g60
(g99
S'\x0c\x00\x00\x00'
tRp493
sg24
S'right'
p494
sS'binary.thisTrialN'
p495
I12
sg25
F1.4834747806708037
sg27
F6.7510000000000003
sg70
Vn
sa(dp496
g64
g65
sS'binary.thisRepN'
p497
I0
sg68
g69
sg80
S'35-raisins.png'
p498
sg26
F5.3999999999999995
sg28
F4.2000000000000002
sg59
g63
sg58
Vy
sg81
S'49-yorkie.png'
p499
sg66
g67
sg55
g11
sS'binary.thisN'
p500
I13
sg56
g57
sS'binary.thisIndex'
p501
g60
(g99
S'\r\x00\x00\x00'
tRp502
sg24
S'right'
p503
sS'binary.thisTrialN'
p504
I13
sg25
F1.0167510180908721
sg27
F1.0009999999999999
sg70
Vn
sa(dp505
g64
g65
sS'binary.thisRepN'
p506
I0
sg68
g69
sg80
S'38-maltesers.png'
p507
sg26
F5.0000000000000018
sg28
F3
sg59
g63
sg58
Vy
sg81
S'6-sour_patch_kids.png'
p508
sg66
g67
sg55
g11
sS'binary.thisN'
p509
I14
sg56
g57
sS'binary.thisIndex'
p510
g60
(g99
S'\x0e\x00\x00\x00'
tRp511
sg24
S'left'
p512
sS'binary.thisTrialN'
p513
I14
sg25
F0.74978902640577871
sg27
F3.2010000000000001
sg70
Vn
sa(dp514
g64
g65
sS'binary.thisRepN'
p515
I0
sg68
g69
sg80
S'49-yorkie.png'
p516
sg26
F5.4000000000000004
sg28
F2.8999999999999999
sg59
g63
sg58
Vy
sg81
S'35-raisins.png'
p517
sg66
g67
sg55
g11
sS'binary.thisN'
p518
I15
sg56
g57
sS'binary.thisIndex'
p519
g60
(g99
S'\x0f\x00\x00\x00'
tRp520
sg24
S'left'
p521
sS'binary.thisTrialN'
p522
I15
sg25
F0.71677023379379534
sg27
F3.4670000000000001
sg70
Vn
sa(dp523
g64
g65
sS'binary.thisRepN'
p524
I0
sg68
g69
sg80
S'8-liquorice_catherine_wheels.png'
p525
sg26
F5.9999999999999973
sg28
F3.6000000000000001
sg59
g63
sg58
Vy
sg81
S'17-jacobs_mini_cheddars_redo.png'
p526
sg66
g67
sg55
g11
sS'binary.thisN'
p527
I16
sg56
g57
sS'binary.thisIndex'
p528
g60
(g99
S'\x10\x00\x00\x00'
tRp529
sg24
S'right'
p530
sS'binary.thisTrialN'
p531
I16
sg25
F1.3333362793637207
sg27
F1.2170000000000001
sg70
Vn
sa(dp532
g64
g65
sS'binary.thisRepN'
p533
I0
sg68
g69
sg80
S'33-ambrosia_rice.png'
p534
sg26
F1.1999999999999993
sg28
F3.1000000000000001
sg59
g63
sg58
Vy
sg81
S'23-crunchie_redo.png'
p535
sg66
g67
sg55
g11
sS'binary.thisN'
p536
I17
sg56
g57
sS'binary.thisIndex'
p537
g60
(g99
S'\x11\x00\x00\x00'
tRp538
sg24
S'right'
p539
sS'binary.thisTrialN'
p540
I17
sg25
F3.8504077492289071
sg27
F1.234
sg70
Vn
sa(dp541
g64
g65
sS'binary.thisRepN'
p542
I0
sg68
g69
sg80
S'43-mrporky_pork_crackles_redo.png'
p543
sg26
F1.8999999999999988
sg28
F3.3999999999999999
sg59
g63
sg58
Vy
sg81
S'18-mms.png'
p544
sg66
g67
sg55
g11
sS'binary.thisN'
p545
I18
sg56
g57
sS'binary.thisIndex'
p546
g60
(g99
S'\x12\x00\x00\x00'
tRp547
sg24
S'left'
p548
sS'binary.thisTrialN'
p549
I18
sg25
F1.5333842901090975
sg27
F3.6509999999999998
sg70
Vn
sa(dp550
g64
g65
sS'binary.thisRepN'
p551
I0
sg68
g69
sg80
S'36-fig_rolls.png'
p552
sg26
F4.0000000000000009
sg28
F3
sg59
g63
sg58
Vy
sg81
S'34-hula_hoops_bbq_beef_redo.png'
p553
sg66
g67
sg55
g11
sS'binary.thisN'
p554
I19
sg56
g57
sS'binary.thisIndex'
p555
g60
(g99
S'\x13\x00\x00\x00'
tRp556
sg24
S'right'
p557
sS'binary.thisTrialN'
p558
I19
sg25
F1.2500612963813182
sg27
F2.7010000000000001
sg70
Vn
sa(dp559
g64
g65
sS'binary.thisRepN'
p560
I0
sg68
g69
sg80
S'23-crunchie_redo.png'
p561
sg26
F2.6999999999999997
sg28
F3.1000000000000001
sg59
g63
sg58
Vy
sg81
S'33-ambrosia_rice.png'
p562
sg66
g67
sg55
g11
sS'binary.thisN'
p563
I20
sg56
g57
sS'binary.thisIndex'
p564
g60
(g99
S'\x14\x00\x00\x00'
tRp565
sg24
S'left'
p566
sS'binary.thisTrialN'
p567
I20
sg25
F1.3667710320696642
sg27
F4.6509999999999998
sg70
Vn
sa(dp568
g64
g65
sS'binary.thisRepN'
p569
I0
sg68
g69
sg80
S'20-fruit_pastilles.png'
p570
sg26
F4
sg28
F3.7999999999999998
sg59
g63
sg58
Vy
sg81
S'2-steamed_puddings.png'
p571
sg66
g67
sg55
g11
sS'binary.thisN'
p572
I21
sg56
g57
sS'binary.thisIndex'
p573
g60
(g99
S'\x15\x00\x00\x00'
tRp574
sg24
S'right'
p575
sS'binary.thisTrialN'
p576
I21
sg25
F2.3500898633465113
sg27
F2.9009999999999998
sg70
Vn
sa(dp577
g64
g65
sS'binary.thisRepN'
p578
I0
sg68
g69
sg80
S'50-polo.png'
p579
sg26
F2.9999999999999991
sg28
F3.8999999999999999
sg59
g63
sg58
Vy
sg81
S'48-twix.png'
p580
sg66
g67
sg55
g11
sS'binary.thisN'
p581
I22
sg56
g57
sS'binary.thisIndex'
p582
g60
(g99
S'\x16\x00\x00\x00'
tRp583
sg24
S'right'
p584
sS'binary.thisTrialN'
p585
I22
sg25
F1.4834417091369687
sg27
F2.1339999999999999
sg70
Vn
sa(dp586
g64
g65
sS'binary.thisRepN'
p587
I0
sg68
g69
sg80
S'31-hobnobs.png'
p588
sg26
F5.9999999999999973
sg28
F3.6000000000000001
sg59
g63
sg58
Vy
sg81
S'25-kitkat.png'
p589
sg66
g67
sg55
g11
sS'binary.thisN'
p590
I23
sg56
g57
sS'binary.thisIndex'
p591
g60
(g99
S'\x17\x00\x00\x00'
tRp592
sg24
S'right'
p593
sS'binary.thisTrialN'
p594
I23
sg25
F1.2001024647397571
sg27
F0.90100000000000002
sg70
Vn
sa(dp595
g64
g65
sS'binary.thisRepN'
p596
I0
sg68
g69
sg80
S'10-bounty_redo.png'
p597
sg26
F5.9999999999999973
sg28
F3.8999999999999999
sg59
g63
sg58
Vy
sg81
S'4-corn.png'
p598
sg66
g67
sg55
g11
sS'binary.thisN'
p599
I24
sg56
g57
sS'binary.thisIndex'
p600
g60
(g99
S'\x18\x00\x00\x00'
tRp601
sg24
S'right'
p602
sS'binary.thisTrialN'
p603
I24
sg25
F0.90006808174803155
sg27
F0.56699999999999995
sg70
Vn
sa(dp604
g64
g65
sS'binary.thisRepN'
p605
I0
sg68
g69
sg80
S'17-jacobs_mini_cheddars_redo.png'
p606
sg26
F5.9999999999999973
sg28
F4.0999999999999996
sg59
g63
sg58
Vy
sg81
S'8-liquorice_catherine_wheels.png'
p607
sg66
g67
sg55
g11
sS'binary.thisN'
p608
I25
sg56
g57
sS'binary.thisIndex'
p609
g60
(g99
S'\x19\x00\x00\x00'
tRp610
sg24
S'left'
p611
sS'binary.thisTrialN'
p612
I25
sg25
F10.583245902838826
sg27
F0.53400000000000003
sg70
Vn
sa(dp613
g64
g65
sS'binary.thisRepN'
p614
I0
sg68
g69
sg80
S'27-hartleys_raspberries_jelly.png'
p615
sg26
F3.4999999999999991
sg28
F4.2999999999999998
sg59
g63
sg58
Vy
sg81
S'51-mars.png'
p616
sg66
g67
sg55
g11
sS'binary.thisN'
p617
I26
sg56
g57
sS'binary.thisIndex'
p618
g60
(g99
S'\x1a\x00\x00\x00'
tRp619
sg24
S'right'
p620
sS'binary.thisTrialN'
p621
I26
sg25
F1.6333740835470962
sg27
F1.0009999999999999
sg70
Vn
sa(dp622
g64
g65
sS'binary.thisRepN'
p623
I0
sg68
g69
sg80
S'26-walkers_smoky_bacon.png'
p624
sg26
F4.8000000000000016
sg28
F2.7999999999999998
sg59
g63
sg58
Vy
sg81
S'44-crunch.png'
p625
sg66
g67
sg55
g11
sS'binary.thisN'
p626
I27
sg56
g57
sS'binary.thisIndex'
p627
g60
(g99
S'\x1b\x00\x00\x00'
tRp628
sg24
S'right'
p629
sS'binary.thisTrialN'
p630
I27
sg25
F3.2500342119310517
sg27
F3.1840000000000002
sg70
Vn
sa(dp631
g64
g65
sS'binary.thisRepN'
p632
I0
sg68
g69
sg80
S'51-mars.png'
p633
sg26
F3.2999999999999998
sg28
F3.3999999999999999
sg59
g63
sg58
Vy
sg81
S'27-hartleys_raspberries_jelly.png'
p634
sg66
g67
sg55
g11
sS'binary.thisN'
p635
I28
sg56
g57
sS'binary.thisIndex'
p636
g60
(g99
S'\x1c\x00\x00\x00'
tRp637
sg24
S'left'
p638
sS'binary.thisTrialN'
p639
I28
sg25
F0.93358323250504327
sg27
F2.2669999999999999
sg70
Vn
sa(dp640
g64
g65
sS'binary.thisRepN'
p641
I0
sg68
g69
sg80
S'44-crunch.png'
p642
sg26
F4.5
sg28
F3.8999999999999999
sg59
g63
sg58
Vy
sg81
S'26-walkers_smoky_bacon.png'
p643
sg66
g67
sg55
g11
sS'binary.thisN'
p644
I29
sg56
g57
sS'binary.thisIndex'
p645
g60
(g99
S'\x1d\x00\x00\x00'
tRp646
sg24
S'left'
p647
sS'binary.thisTrialN'
p648
I29
sg25
F1.2834319017165399
sg27
F1.4510000000000001
sg70
Vn
sa(dp649
g64
g65
sS'binary.thisRepN'
p650
I0
sg68
g69
sg80
S'41-peanuts_redo.png'
p651
sg26
F4.8000000000000007
sg28
F3.3999999999999999
sg59
g63
sg58
Vy
sg81
S'45-chewy_nougat_redo.png'
p652
sg66
g67
sg55
g11
sS'binary.thisN'
p653
I30
sg56
g57
sS'binary.thisIndex'
p654
g60
(g99
S'\x1e\x00\x00\x00'
tRp655
sg24
S'left'
p656
sS'binary.thisTrialN'
p657
I30
sg25
F1.5334892067039618
sg27
F6.4669999999999996
sg70
Vn
sa(dp658
g64
g65
sS'binary.thisRepN'
p659
I0
sg68
g69
sg80
S'4-corn.png'
p660
sg26
F5.9999999999999973
sg28
F4
sg59
g63
sg58
Vy
sg81
S'10-bounty_redo.png'
p661
sg66
g67
sg55
g11
sS'binary.thisN'
p662
I31
sg56
g57
sS'binary.thisIndex'
p663
g60
(g99
S'\x1f\x00\x00\x00'
tRp664
sg24
S'left'
p665
sS'binary.thisTrialN'
p666
I31
sg25
F1.0334028215729631
sg27
F0.85099999999999998
sg70
Vn
sa(dp667
g64
g65
sS'binary.thisRepN'
p668
I0
sg68
g69
sg80
S'22-daim.png'
p669
sg26
F5.9999999999999973
sg28
F3.7000000000000002
sg59
g63
sg58
Vy
sg81
S'7-olives.png'
p670
sg66
g67
sg55
g11
sS'binary.thisN'
p671
I32
sg56
g57
sS'binary.thisIndex'
p672
g60
(g99
S' \x00\x00\x00'
tRp673
sg24
S'left'
p674
sS'binary.thisTrialN'
p675
I32
sg25
F1.4000495502841659
sg27
F0.65100000000000002
sg70
Vn
sa(dp676
g64
g65
sS'binary.thisRepN'
p677
I0
sg68
g69
sg80
S'21-nakd_banana_crunch.png'
p678
sg26
F4.9000000000000021
sg28
F2.8999999999999999
sg59
g63
sg58
Vy
sg81
S'1-treacle_cookies.png'
p679
sg66
g67
sg55
g11
sS'binary.thisN'
p680
I33
sg56
g57
sS'binary.thisIndex'
p681
g60
(g99
S'!\x00\x00\x00'
tRp682
sg24
S'right'
p683
sS'binary.thisTrialN'
p684
I33
sg25
F1.6167168631764071
sg27
F2.6509999999999998
sg70
Vn
sa(dp685
g64
g65
sS'binary.thisRepN'
p686
I0
sg68
g69
sg80
S'42-mrkipling_lemon_slices.png'
p687
sg26
F1.399999999999999
sg28
F3.5
sg59
g63
sg58
Vy
sg81
S'16-skips_prawn.png'
p688
sg66
g67
sg55
g11
sS'binary.thisN'
p689
I34
sg56
g57
sS'binary.thisIndex'
p690
g60
(g99
S'"\x00\x00\x00'
tRp691
sg24
S'right'
p692
sS'binary.thisTrialN'
p693
I34
sg25
F2.8000683098252921
sg27
F1.2669999999999999
sg70
Vn
sa(dp694
g64
g65
sS'binary.thisRepN'
p695
I0
sg68
g69
sg80
S'7-olives.png'
p696
sg26
F5.9999999999999982
sg28
F2.8999999999999999
sg59
g63
sg58
Vy
sg81
S'22-daim.png'
p697
sg66
g67
sg55
g11
sS'binary.thisN'
p698
I35
sg56
g57
sS'binary.thisIndex'
p699
g60
(g99
S'#\x00\x00\x00'
tRp700
sg24
S'right'
p701
sS'binary.thisTrialN'
p702
I35
sg25
F0.86714622294675792
sg27
F0.71699999999999997
sg70
Vn
sa(dp703
g64
g65
sS'binary.thisRepN'
p704
I0
sg68
g69
sg80
S'30-spaghetti_hoops.png'
p705
sg26
F4.6000000000000014
sg28
F3
sg59
g63
sg58
Vy
sg81
S'19-caramello_redo.png'
p706
sg66
g67
sg55
g11
sS'binary.thisN'
p707
I36
sg56
g57
sS'binary.thisIndex'
p708
g60
(g99
S'$\x00\x00\x00'
tRp709
sg24
S'right'
p710
sS'binary.thisTrialN'
p711
I36
sg25
F1.916631789499661
sg27
F2.0510000000000002
sg70
Vn
sa(dp712
g64
g65
sS'binary.thisRepN'
p713
I0
sg68
g69
sg80
S'29-beans.png'
p714
sg26
F4.8000000000000007
sg28
F3.2999999999999998
sg59
g63
sg58
Vy
sg81
S'46-pistachios.png'
p715
sg66
g67
sg55
g11
sS'binary.thisN'
p716
I37
sg56
g57
sS'binary.thisIndex'
p717
g60
(g99
S'%\x00\x00\x00'
tRp718
sg24
S'left'
p719
sS'binary.thisTrialN'
p720
I37
sg25
F1.1333837769270758
sg27
F0.81699999999999995
sg70
Vn
sa(dp721
g64
g65
sS'binary.thisRepN'
p722
I0
sg68
g69
sg80
S'40-sardines.png'
p723
sg26
F5.4999999999999991
sg28
F3.6000000000000001
sg59
g63
sg58
Vy
sg81
S'5-pineapple.png'
p724
sg66
g67
sg55
g11
sS'binary.thisN'
p725
I38
sg56
g57
sS'binary.thisIndex'
p726
g60
(g99
S'&\x00\x00\x00'
tRp727
sg24
S'right'
p728
sS'binary.thisTrialN'
p729
I38
sg25
F1.0834058436266787
sg27
F1.4339999999999999
sg70
Vn
sa(dp730
g64
g65
sS'binary.thisRepN'
p731
I0
sg68
g69
sg80
S'2-steamed_puddings.png'
p732
sg26
F4.4000000000000004
sg28
F3.8999999999999999
sg59
g63
sg58
Vy
sg81
S'20-fruit_pastilles.png'
p733
sg66
g67
sg55
g11
sS'binary.thisN'
p734
I39
sg56
g57
sS'binary.thisIndex'
p735
g60
(g99
S"'\x00\x00\x00"
tRp736
sg24
S'left'
p737
sS'binary.thisTrialN'
p738
I39
sg25
F0.91673357000399847
sg27
F1.6839999999999999
sg70
Vn
sa(dp739
g64
g65
sg56
g57
sg29
S'space'
p740
sg58
Vy
sg59
g63
sg30
F262.39491291352169
sg55
g11
sg66
g67
sg68
g69
sg70
Vn
sa(dp741
g64
g65
sg56
g57
sg58
Vy
sg31
S'space'
p742
sg59
g63
sg55
g11
sg32
F9.0833300071753911
sg66
g67
sg68
g69
sg70
Vn
sa(dp743
g64
g65
sg82
S'11-snickers.png'
p744
sg83
S'54-frubes_yogurt.png'
p745
sg56
g57
sS'practice_loop.thisN'
p746
I0
sS'practice_loop.thisTrialN'
p747
I0
sg70
Vn
sg58
Vy
sg59
g63
sS'practice_loop.thisRepN'
p748
I0
sg84
S'54-frubes_yogurt.png'
p749
sg33
g744
sg55
g11
sg66
g67
sg68
g69
sg85
S'11-snickers.png'
p750
sS'practice_loop.thisIndex'
p751
g60
(g99
S'\x00\x00\x00\x00'
tRp752
sg34
cdatetime
datetime
p753
(S'\x07\xdf\x07\x0b\x10\x1a5\x0c\xc5\x88'
tRp754
sa(dp755
g64
g65
sg82
S'53-cheestrings.png'
p756
sg83
S'47-picnic.png'
p757
sg56
g57
sS'practice_loop.thisN'
p758
I1
sS'practice_loop.thisTrialN'
p759
I1
sg70
Vn
sg58
Vy
sg59
g63
sS'practice_loop.thisRepN'
p760
I0
sg84
S'47-picnic.png'
p761
sg33
g756
sg55
g11
sg66
g67
sg68
g69
sg85
S'53-cheestrings.png'
p762
sS'practice_loop.thisIndex'
p763
g60
(g99
S'\x01\x00\x00\x00'
tRp764
sg34
g753
(S'\x07\xdf\x07\x0b\x10\x1b\x01\x0e@p'
tRp765
sa(dp766
g64
g65
sg82
S'32-hovis_crackers.png'
p767
sg83
S'32-hovis_crackers.png'
p768
sg56
g57
sS'practice_loop.thisN'
p769
I2
sS'practice_loop.thisTrialN'
p770
I2
sg70
Vn
sg58
Vy
sg59
g63
sS'practice_loop.thisRepN'
p771
I0
sg84
S'24-food_doctor_apple_walnut_bar.png'
p772
sg33
g767
sg55
g11
sg66
g67
sg68
g69
sg85
S'24-food_doctor_apple_walnut_bar.png'
p773
sS'practice_loop.thisIndex'
p774
g60
(g99
S'\x02\x00\x00\x00'
tRp775
sg34
g753
(S'\x07\xdf\x07\x0b\x10\x1b\x08\x069\xc0'
tRp776
sa(dp777
g64
g65
sg82
S'15-walnut_whip.png'
p778
sg83
S'15-walnut_whip.png'
p779
sg56
g57
sS'practice_loop.thisN'
p780
I3
sS'practice_loop.thisTrialN'
p781
I3
sg70
Vn
sg58
Vy
sg59
g63
sS'practice_loop.thisRepN'
p782
I0
sg84
S'28-maple_pecan.png'
p783
sg33
g778
sg55
g11
sg66
g67
sg68
g69
sg85
S'28-maple_pecan.png'
p784
sS'practice_loop.thisIndex'
p785
g60
(g99
S'\x03\x00\x00\x00'
tRp786
sg34
g753
(S'\x07\xdf\x07\x0b\x10\x1b\x10\t\x1f\xf0'
tRp787
sa(dp788
g64
g65
sg82
g756
sg83
S'53-cheestrings.png'
p789
sg56
g57
sS'practice_loop.thisN'
p790
I4
sS'practice_loop.thisTrialN'
p791
I4
sg70
Vn
sg58
Vy
sg59
g63
sS'practice_loop.thisRepN'
p792
I0
sg84
g761
sg33
g756
sg55
g11
sg66
g67
sg68
g69
sg85
S'47-picnic.png'
p793
sS'practice_loop.thisIndex'
p794
g60
(g99
S'\x04\x00\x00\x00'
tRp795
sg34
g753
(S'\x07\xdf\x07\x0b\x10\x1b\x19\x02\xb7P'
tRp796
sa(dp797
g64
g65
sg82
g778
sg83
S'28-maple_pecan.png'
p798
sg56
g57
sS'practice_loop.thisN'
p799
I5
sS'practice_loop.thisTrialN'
p800
I5
sg70
Vn
sg58
Vy
sg59
g63
sS'practice_loop.thisRepN'
p801
I0
sg84
g783
sg33
g778
sg55
g11
sg66
g67
sg68
g69
sg85
S'15-walnut_whip.png'
p802
sS'practice_loop.thisIndex'
p803
g60
(g99
S'\x05\x00\x00\x00'
tRp804
sg34
g753
(S'\x07\xdf\x07\x0b\x10\x1b\x1f\x04x\x88'
tRp805
sa(dp806
g64
g65
sg82
S'37-nakd_cashew_cookie.png'
p807
sg83
S'9-yu_mango_pieces.png'
p808
sg56
g57
sS'practice_loop.thisN'
p809
I6
sS'practice_loop.thisTrialN'
p810
I6
sg70
Vn
sg58
Vy
sg59
g63
sS'practice_loop.thisRepN'
p811
I0
sg84
S'9-yu_mango_pieces.png'
p812
sg33
g807
sg55
g11
sg66
g67
sg68
g69
sg85
S'37-nakd_cashew_cookie.png'
p813
sS'practice_loop.thisIndex'
p814
g60
(g99
S'\x06\x00\x00\x00'
tRp815
sg34
g753
(S'\x07\xdf\x07\x0b\x10\x1b%\x05\xff('
tRp816
sa(dp817
g64
g65
sg82
S'12-topic.png'
p818
sg83
S'39-mackerel.png'
p819
sg56
g57
sS'practice_loop.thisN'
p820
I7
sS'practice_loop.thisTrialN'
p821
I7
sg70
Vn
sg58
Vy
sg59
g63
sS'practice_loop.thisRepN'
p822
I0
sg84
S'39-mackerel.png'
p823
sg33
g818
sg55
g11
sg66
g67
sg68
g69
sg85
S'12-topic.png'
p824
sS'practice_loop.thisIndex'
p825
g60
(g99
S'\x07\x00\x00\x00'
tRp826
sg34
g753
(S'\x07\xdf\x07\x0b\x10\x1b-\x07;\x90'
tRp827
sa(dp828
g64
g65
sg82
g807
sg83
S'37-nakd_cashew_cookie.png'
p829
sg56
g57
sS'practice_loop.thisN'
p830
I8
sS'practice_loop.thisTrialN'
p831
I8
sg70
Vn
sg58
Vy
sg59
g63
sS'practice_loop.thisRepN'
p832
I0
sg84
g812
sg33
g812
sg55
g11
sg66
g67
sg68
g69
sg85
S'9-yu_mango_pieces.png'
p833
sS'practice_loop.thisIndex'
p834
g60
(g99
S'\x08\x00\x00\x00'
tRp835
sg34
g753
(S'\x07\xdf\x07\x0b\x10\x1b3\n\xe5\x10'
tRp836
sa(dp837
g64
g65
sg82
g744
sg83
S'11-snickers.png'
p838
sg56
g57
sS'practice_loop.thisN'
p839
I9
sS'practice_loop.thisTrialN'
p840
I9
sg70
Vn
sg58
Vy
sg59
g63
sS'practice_loop.thisRepN'
p841
I0
sg84
g749
sg33
g744
sg55
g11
sg66
g67
sg68
g69
sg85
S'54-frubes_yogurt.png'
p842
sS'practice_loop.thisIndex'
p843
g60
(g99
S'\t\x00\x00\x00'
tRp844
sg34
g753
(S'\x07\xdf\x07\x0b\x10\x1b9\r]\xe0'
tRp845
sa(dp846
g64
g65
sg82
S'52-aero_mousse.png'
p847
sg83
S'14-discos_salt_vinegar.png'
p848
sg56
g57
sS'practice_loop.thisN'
p849
I10
sS'practice_loop.thisTrialN'
p850
I10
sg70
Vn
sg58
Vy
sg59
g63
sS'practice_loop.thisRepN'
p851
I0
sg84
S'14-discos_salt_vinegar.png'
p852
sg33
g847
sg55
g11
sg66
g67
sg68
g69
sg85
S'52-aero_mousse.png'
p853
sS'practice_loop.thisIndex'
p854
g60
(g99
S'\n\x00\x00\x00'
tRp855
sg34
g753
(S'\x07\xdf\x07\x0b\x10\x1c\x04\x0c\xb5\xe8'
tRp856
sa(dp857
g64
g65
sg82
g818
sg83
S'12-topic.png'
p858
sg56
g57
sS'practice_loop.thisN'
p859
I11
sS'practice_loop.thisTrialN'
p860
I11
sg70
Vn
sg58
Vy
sg59
g63
sS'practice_loop.thisRepN'
p861
I0
sg84
g823
sg33
g823
sg55
g11
sg66
g67
sg68
g69
sg85
S'39-mackerel.png'
p862
sS'practice_loop.thisIndex'
p863
g60
(g99
S'\x0b\x00\x00\x00'
tRp864
sg34
g753
(S'\x07\xdf\x07\x0b\x10\x1c\x0b\r\xfa '
tRp865
sa(dp866
g64
g65
sg82
g847
sg83
S'52-aero_mousse.png'
p867
sg56
g57
sS'practice_loop.thisN'
p868
I12
sS'practice_loop.thisTrialN'
p869
I12
sg70
Vn
sg58
Vy
sg59
g63
sS'practice_loop.thisRepN'
p870
I0
sg84
g852
sg33
g847
sg55
g11
sg66
g67
sg68
g69
sg85
S'14-discos_salt_vinegar.png'
p871
sS'practice_loop.thisIndex'
p872
g60
(g99
S'\x0c\x00\x00\x00'
tRp873
sg34
g753
(S'\x07\xdf\x07\x0b\x10\x1c\x11\r\xd3\x10'
tRp874
sa(dp875
g64
g65
sg82
g767
sg83
S'24-food_doctor_apple_walnut_bar.png'
p876
sg56
g57
sS'practice_loop.thisN'
p877
I13
sS'practice_loop.thisTrialN'
p878
I13
sg70
Vn
sg58
Vy
sg59
g63
sS'practice_loop.thisRepN'
p879
I0
sg84
g772
sg33
g767
sg55
g11
sg66
g67
sg68
g69
sg85
S'32-hovis_crackers.png'
p880
sS'practice_loop.thisIndex'
p881
g60
(g99
S'\r\x00\x00\x00'
tRp882
sg34
g753
(S'\x07\xdf\x07\x0b\x10\x1c\x18\x07v('
tRp883
sa(dp884
g64
g65
sg56
g57
sg58
Vy
sg59
g63
sg35
S'space'
p885
sg55
g11
sg36
F158.36388953194546
sg66
g67
sg68
g69
sg70
Vn
sa(dp886
S'block_loop.thisRepN'
p887
I0
sg56
g57
sS'block_loop.thisIndex'
p888
g60
(g99
S'\x00\x00\x00\x00'
tRp889
sg58
Vy
sg59
g63
sS'block_loop.thisN'
p890
I0
sg37
Nsg55
g11
sg64
g65
sS'block_loop.thisTrial'
p891
Nsg66
g67
sg68
g69
sS'block_loop.thisTrialN'
p892
I0
sg70
Vn
sa(dp893
S'trial_loop.thisTrialN'
p894
I0
sS'img_left'
p895
S'26-walkers_smoky_bacon.png'
p896
sS'block_loop.thisIndex'
p897
g889
sg38
S'right'
p898
sg59
g63
sS'trial_loop.thisN'
p899
I0
sg33
S'26-walkers_smoky_bacon.png'
p900
sg64
g65
sS'trial_loop.thisIndex'
p901
g60
(g99
S'\x00\x00\x00\x00'
tRp902
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p903
I0
sS'img_right'
p904
S'44-crunch.png'
p905
sS'block_loop.thisRepN'
p906
I0
sS'img_correct'
p907
g900
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p908
I0
sS'img_wrong'
p909
S'44-crunch.png'
p910
sg55
g11
sS'block_loop.thisTrial'
p911
Nsg70
Vn
sS'block_loop.thisTrialN'
p912
I0
sg39
F2.4664848492466263
sg34
g753
(S'\x07\xdf\x07\x0b\x10"&\x05zX'
tRp913
sa(dp914
S'trial_loop.thisTrialN'
p915
I1
sg895
S'3-ellas_strawberries_apples.png'
p916
sS'block_loop.thisIndex'
p917
g889
sg38
S'right'
p918
sg59
g63
sS'trial_loop.thisN'
p919
I1
sg33
S'13-mccoys_steak_crisps.png'
p920
sg64
g65
sS'trial_loop.thisIndex'
p921
g60
(g99
S'\x01\x00\x00\x00'
tRp922
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p923
I0
sg904
S'13-mccoys_steak_crisps.png'
p924
sS'block_loop.thisRepN'
p925
I0
sg907
S'3-ellas_strawberries_apples.png'
p926
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p927
I0
sg909
g920
sg55
g11
sS'block_loop.thisTrial'
p928
Nsg70
Vn
sS'block_loop.thisTrialN'
p929
I0
sg39
F1.1000051888076996
sg34
g753
(S'\x07\xdf\x07\x0b\x10"-\r+\x18'
tRp930
sa(dp931
S'trial_loop.thisTrialN'
p932
I2
sg895
S'36-fig_rolls.png'
p933
sS'block_loop.thisIndex'
p934
g889
sg38
S'right'
p935
sg59
g63
sS'trial_loop.thisN'
p936
I2
sg33
S'34-hula_hoops_bbq_beef_redo.png'
p937
sg64
g65
sS'trial_loop.thisIndex'
p938
g60
(g99
S'\x02\x00\x00\x00'
tRp939
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p940
I0
sg904
S'34-hula_hoops_bbq_beef_redo.png'
p941
sS'block_loop.thisRepN'
p942
I0
sg907
g937
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p943
I0
sg909
S'36-fig_rolls.png'
p944
sg55
g11
sS'block_loop.thisTrial'
p945
Nsg70
Vn
sS'block_loop.thisTrialN'
p946
I0
sg39
F1.1831350561697036
sg34
g753
(S'\x07\xdf\x07\x0b\x10"3\x0f*\xd0'
tRp947
sa(dp948
S'trial_loop.thisTrialN'
p949
I3
sg895
S'29-beans.png'
p950
sS'block_loop.thisIndex'
p951
g889
sg38
S'left'
p952
sg59
g63
sS'trial_loop.thisN'
p953
I3
sg33
S'46-pistachios.png'
p954
sg64
g65
sS'trial_loop.thisIndex'
p955
g60
(g99
S'\x03\x00\x00\x00'
tRp956
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p957
I0
sg904
S'46-pistachios.png'
p958
sS'block_loop.thisRepN'
p959
I0
sg907
g954
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p960
I0
sg909
S'29-beans.png'
p961
sg55
g11
sS'block_loop.thisTrial'
p962
Nsg70
Vn
sS'block_loop.thisTrialN'
p963
I0
sg39
F1.4665341714498936
sg34
g753
(S'\x07\xdf\x07\x0b\x10":\x03\x18\xf8'
tRp964
sa(dp965
S'trial_loop.thisTrialN'
p966
I4
sg895
S'8-liquorice_catherine_wheels.png'
p967
sS'block_loop.thisIndex'
p968
g889
sg38
S'right'
p969
sg59
g63
sS'trial_loop.thisN'
p970
I4
sg33
S'17-jacobs_mini_cheddars_redo.png'
p971
sg64
g65
sS'trial_loop.thisIndex'
p972
g60
(g99
S'\x04\x00\x00\x00'
tRp973
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p974
I0
sg904
S'17-jacobs_mini_cheddars_redo.png'
p975
sS'block_loop.thisRepN'
p976
I0
sg907
g971
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p977
I0
sg909
S'8-liquorice_catherine_wheels.png'
p978
sg55
g11
sS'block_loop.thisTrial'
p979
Nsg70
Vn
sS'block_loop.thisTrialN'
p980
I0
sg39
F1.1166284823448223
sg34
g753
(S'\x07\xdf\x07\x0b\x10#\x04\n\xcd\xa0'
tRp981
sa(dp982
S'trial_loop.thisTrialN'
p983
I5
sg895
S'42-mrkipling_lemon_slices.png'
p984
sS'block_loop.thisIndex'
p985
g889
sg38
S'left'
p986
sg59
g63
sS'trial_loop.thisN'
p987
I5
sg33
S'16-skips_prawn.png'
p988
sg64
g65
sS'trial_loop.thisIndex'
p989
g60
(g99
S'\x05\x00\x00\x00'
tRp990
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p991
I0
sg904
S'16-skips_prawn.png'
p992
sS'block_loop.thisRepN'
p993
I0
sg907
g988
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p994
I0
sg909
S'42-mrkipling_lemon_slices.png'
p995
sg55
g11
sS'block_loop.thisTrial'
p996
Nsg70
Vn
sS'block_loop.thisTrialN'
p997
I0
sg39
F2.4835990840329032
sg34
g753
(S'\x07\xdf\x07\x0b\x10#\n\r\x07\xf0'
tRp998
sa(dp999
S'trial_loop.thisTrialN'
p1000
I6
sg895
S'5-pineapple.png'
p1001
sS'block_loop.thisIndex'
p1002
g889
sg38
S'left'
p1003
sg59
g63
sS'trial_loop.thisN'
p1004
I6
sg33
S'5-pineapple.png'
p1005
sg64
g65
sS'trial_loop.thisIndex'
p1006
g60
(g99
S'\x06\x00\x00\x00'
tRp1007
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1008
I0
sg904
S'40-sardines.png'
p1009
sS'block_loop.thisRepN'
p1010
I0
sg907
S'40-sardines.png'
p1011
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1012
I0
sg909
g1005
sg55
g11
sS'block_loop.thisTrial'
p1013
Nsg70
Vn
sS'block_loop.thisTrialN'
p1014
I0
sg39
F1.2665240789283416
sg34
g753
(S'\x07\xdf\x07\x0b\x10#\x12\x05\xb4\xf0'
tRp1015
sa(dp1016
S'trial_loop.thisTrialN'
p1017
I7
sg895
S'7-olives.png'
p1018
sS'block_loop.thisIndex'
p1019
g889
sg38
S'right'
p1020
sg59
g63
sS'trial_loop.thisN'
p1021
I7
sg33
S'7-olives.png'
p1022
sg64
g65
sS'trial_loop.thisIndex'
p1023
g60
(g99
S'\x07\x00\x00\x00'
tRp1024
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1025
I0
sg904
S'22-daim.png'
p1026
sS'block_loop.thisRepN'
p1027
I0
sg907
g1022
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1028
I0
sg909
S'22-daim.png'
p1029
sg55
g11
sS'block_loop.thisTrial'
p1030
Nsg70
Vn
sS'block_loop.thisTrialN'
p1031
I0
sg39
F1.1166649750739452
sg34
g753
(S'\x07\xdf\x07\x0b\x10#\x18\nP\xa0'
tRp1032
sa(dp1033
S'trial_loop.thisTrialN'
p1034
I8
sg895
S'17-jacobs_mini_cheddars_redo.png'
p1035
sS'block_loop.thisIndex'
p1036
g889
sg38
S'left'
p1037
sg59
g63
sS'trial_loop.thisN'
p1038
I8
sg33
g971
sg64
g65
sS'trial_loop.thisIndex'
p1039
g60
(g99
S'\x08\x00\x00\x00'
tRp1040
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1041
I0
sg904
S'8-liquorice_catherine_wheels.png'
p1042
sS'block_loop.thisRepN'
p1043
I0
sg907
g971
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1044
I0
sg909
g978
sg55
g11
sS'block_loop.thisTrial'
p1045
Nsg70
Vn
sS'block_loop.thisTrialN'
p1046
I0
sg39
F0.98325724979440565
sg34
g753
(S'\x07\xdf\x07\x0b\x10#\x1e\x0c\x8a\xf0'
tRp1047
sa(dp1048
S'trial_loop.thisTrialN'
p1049
I9
sg895
S'10-bounty_redo.png'
p1050
sS'block_loop.thisIndex'
p1051
g889
sg38
S'right'
p1052
sg59
g63
sS'trial_loop.thisN'
p1053
I9
sg33
S'4-corn.png'
p1054
sg64
g65
sS'trial_loop.thisIndex'
p1055
g60
(g99
S'\t\x00\x00\x00'
tRp1056
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1057
I0
sg904
S'4-corn.png'
p1058
sS'block_loop.thisRepN'
p1059
I0
sg907
g1054
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1060
I0
sg909
S'10-bounty_redo.png'
p1061
sg55
g11
sS'block_loop.thisTrial'
p1062
Nsg70
Vn
sS'block_loop.thisTrialN'
p1063
I0
sg39
F1.0998937149270205
sg34
g753
(S'\x07\xdf\x07\x0b\x10#$\x0c\xe0\xe0'
tRp1064
sa(dp1065
S'trial_loop.thisTrialN'
p1066
I10
sg895
S'46-pistachios.png'
p1067
sS'block_loop.thisIndex'
p1068
g889
sg38
S'left'
p1069
sg59
g63
sS'trial_loop.thisN'
p1070
I10
sg33
g954
sg64
g65
sS'trial_loop.thisIndex'
p1071
g60
(g99
S'\n\x00\x00\x00'
tRp1072
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1073
I0
sg904
S'29-beans.png'
p1074
sS'block_loop.thisRepN'
p1075
I0
sg907
g954
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1076
I0
sg909
g961
sg55
g11
sS'block_loop.thisTrial'
p1077
Nsg70
Vn
sS'block_loop.thisTrialN'
p1078
I0
sg39
F1.4670014494440693
sg34
g753
(S'\x07\xdf\x07\x0b\x10#*\x0e\xe0\x98'
tRp1079
sa(dp1080
S'trial_loop.thisTrialN'
p1081
I11
sg895
g1001
sS'block_loop.thisIndex'
p1082
g889
sg38
S'left'
p1083
sg59
g63
sS'trial_loop.thisN'
p1084
I11
sg33
g1011
sg64
g65
sS'trial_loop.thisIndex'
p1085
g60
(g99
S'\x0b\x00\x00\x00'
tRp1086
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1087
I0
sg904
g1009
sS'block_loop.thisRepN'
p1088
I0
sg907
g1011
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1089
I0
sg909
g1005
sg55
g11
sS'block_loop.thisTrial'
p1090
Nsg70
Vn
sS'block_loop.thisTrialN'
p1091
I0
sg39
F0.91658218219527043
sg34
g753
(S'\x07\xdf\x07\x0b\x10#1\x07S\x00'
tRp1092
sa(dp1093
S'trial_loop.thisTrialN'
p1094
I12
sg895
S'19-caramello_redo.png'
p1095
sS'block_loop.thisIndex'
p1096
g889
sg38
S'left'
p1097
sg59
g63
sS'trial_loop.thisN'
p1098
I12
sg33
S'30-spaghetti_hoops.png'
p1099
sg64
g65
sS'trial_loop.thisIndex'
p1100
g60
(g99
S'\x0c\x00\x00\x00'
tRp1101
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1102
I0
sg904
S'30-spaghetti_hoops.png'
p1103
sS'block_loop.thisRepN'
p1104
I0
sg907
g1099
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1105
I0
sg909
S'19-caramello_redo.png'
p1106
sg55
g11
sS'block_loop.thisTrial'
p1107
Nsg70
Vn
sS'block_loop.thisTrialN'
p1108
I0
sg39
F1.3498472437167948
sg34
g753
(S'\x07\xdf\x07\x0b\x10#7\x06x@'
tRp1109
sa(dp1110
S'trial_loop.thisTrialN'
p1111
I13
sg895
S'40-sardines.png'
p1112
sS'block_loop.thisIndex'
p1113
g889
sg38
S'right'
p1114
sg59
g63
sS'trial_loop.thisN'
p1115
I13
sg33
g1011
sg64
g65
sS'trial_loop.thisIndex'
p1116
g60
(g99
S'\r\x00\x00\x00'
tRp1117
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1118
I0
sg904
S'5-pineapple.png'
p1119
sS'block_loop.thisRepN'
p1120
I0
sg907
g1011
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1121
I0
sg909
g1005
sg55
g11
sS'block_loop.thisTrial'
p1122
Nsg70
Vn
sS'block_loop.thisTrialN'
p1123
I0
sg39
F1.0166224382410292
sg34
g753
(S'\x07\xdf\x07\x0b\x10$\x01\x0cD\xa0'
tRp1124
sa(dp1125
S'trial_loop.thisTrialN'
p1126
I14
sg895
S'43-mrporky_pork_crackles_redo.png'
p1127
sS'block_loop.thisIndex'
p1128
g889
sg38
S'right'
p1129
sg59
g63
sS'trial_loop.thisN'
p1130
I14
sg33
S'43-mrporky_pork_crackles_redo.png'
p1131
sg64
g65
sS'trial_loop.thisIndex'
p1132
g60
(g99
S'\x0e\x00\x00\x00'
tRp1133
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1134
I0
sg904
S'18-mms.png'
p1135
sS'block_loop.thisRepN'
p1136
I0
sg907
g1131
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1137
I0
sg909
S'18-mms.png'
p1138
sg55
g11
sS'block_loop.thisTrial'
p1139
Nsg70
Vn
sS'block_loop.thisTrialN'
p1140
I0
sg39
F1.3833792153382092
sg34
g753
(S'\x07\xdf\x07\x0b\x10$\x07\r\x13\xa8'
tRp1141
sa(dp1142
S'trial_loop.thisTrialN'
p1143
I15
sg895
S'34-hula_hoops_bbq_beef_redo.png'
p1144
sS'block_loop.thisIndex'
p1145
g889
sg38
S'left'
p1146
sg59
g63
sS'trial_loop.thisN'
p1147
I15
sg33
g937
sg64
g65
sS'trial_loop.thisIndex'
p1148
g60
(g99
S'\x0f\x00\x00\x00'
tRp1149
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1150
I0
sg904
S'36-fig_rolls.png'
p1151
sS'block_loop.thisRepN'
p1152
I0
sg907
g937
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1153
I0
sg909
g944
sg55
g11
sS'block_loop.thisTrial'
p1154
Nsg70
Vn
sS'block_loop.thisTrialN'
p1155
I0
sg39
F1.1833300641919777
sg34
g753
(S'\x07\xdf\x07\x0b\x10$\x0e\x04\x16\xe0'
tRp1156
sa(dp1157
S'trial_loop.thisTrialN'
p1158
I16
sg895
S'25-kitkat.png'
p1159
sS'block_loop.thisIndex'
p1160
g889
sg38
S'right'
p1161
sg59
g63
sS'trial_loop.thisN'
p1162
I16
sg33
S'31-hobnobs.png'
p1163
sg64
g65
sS'trial_loop.thisIndex'
p1164
g60
(g99
S'\x10\x00\x00\x00'
tRp1165
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1166
I0
sg904
S'31-hobnobs.png'
p1167
sS'block_loop.thisRepN'
p1168
I0
sg907
g1163
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1169
I0
sg909
S'25-kitkat.png'
p1170
sg55
g11
sS'block_loop.thisTrial'
p1171
Nsg70
Vn
sS'block_loop.thisTrialN'
p1172
I0
sg39
F2.6331083708610095
sg34
g753
(S'\x07\xdf\x07\x0b\x10$\x14\x07\x85\xc8'
tRp1173
sa(dp1174
S'trial_loop.thisTrialN'
p1175
I17
sg895
S'20-fruit_pastilles.png'
p1176
sS'block_loop.thisIndex'
p1177
g889
sg38
S'left'
p1178
sg59
g63
sS'trial_loop.thisN'
p1179
I17
sg33
S'2-steamed_puddings.png'
p1180
sg64
g65
sS'trial_loop.thisIndex'
p1181
g60
(g99
S'\x11\x00\x00\x00'
tRp1182
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1183
I0
sg904
S'2-steamed_puddings.png'
p1184
sS'block_loop.thisRepN'
p1185
I0
sg907
g1180
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1186
I0
sg909
S'20-fruit_pastilles.png'
p1187
sg55
g11
sS'block_loop.thisTrial'
p1188
Nsg70
Vn
sS'block_loop.thisTrialN'
p1189
I0
sg39
F1.2832722460225341
sg34
g753
(S'\x07\xdf\x07\x0b\x10$\x1c\x02Q\xc0'
tRp1190
sa(dp1191
S'trial_loop.thisTrialN'
p1192
I18
sg895
S'23-crunchie_redo.png'
p1193
sS'block_loop.thisIndex'
p1194
g889
sg38
S'left'
p1195
sg59
g63
sS'trial_loop.thisN'
p1196
I18
sg33
S'23-crunchie_redo.png'
p1197
sg64
g65
sS'trial_loop.thisIndex'
p1198
g60
(g99
S'\x12\x00\x00\x00'
tRp1199
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1200
I0
sg904
S'33-ambrosia_rice.png'
p1201
sS'block_loop.thisRepN'
p1202
I0
sg907
g1197
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1203
I0
sg909
S'33-ambrosia_rice.png'
p1204
sg55
g11
sS'block_loop.thisTrial'
p1205
Nsg70
Vn
sS'block_loop.thisTrialN'
p1206
I0
sg39
F1.366584577030153
sg34
g753
(S'\x07\xdf\x07\x0b\x10$"\x07+\xf0'
tRp1207
sa(dp1208
S'trial_loop.thisTrialN'
p1209
I19
sg895
g1067
sS'block_loop.thisIndex'
p1210
g889
sg38
S'left'
p1211
sg59
g63
sS'trial_loop.thisN'
p1212
I19
sg33
g954
sg64
g65
sS'trial_loop.thisIndex'
p1213
g60
(g99
S'\x13\x00\x00\x00'
tRp1214
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1215
I0
sg904
g1074
sS'block_loop.thisRepN'
p1216
I0
sg907
g954
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1217
I0
sg909
g961
sg55
g11
sS'block_loop.thisTrial'
p1218
Nsg70
Vn
sS'block_loop.thisTrialN'
p1219
I0
sg39
F2.4165656464283529
sg34
g753
(S'\x07\xdf\x07\x0b\x10$(\r:\xb8'
tRp1220
sa(dp1221
S'trial_loop.thisTrialN'
p1222
I20
sg895
S'22-daim.png'
p1223
sS'block_loop.thisIndex'
p1224
g889
sg38
S'right'
p1225
sg59
g63
sS'trial_loop.thisN'
p1226
I20
sg33
g1022
sg64
g65
sS'trial_loop.thisIndex'
p1227
g60
(g99
S'\x14\x00\x00\x00'
tRp1228
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1229
I0
sg904
S'7-olives.png'
p1230
sS'block_loop.thisRepN'
p1231
I0
sg907
g1022
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1232
I0
sg909
g1029
sg55
g11
sS'block_loop.thisTrial'
p1233
Nsg70
Vn
sS'block_loop.thisTrialN'
p1234
I0
sg39
F1.1832875843756483
sg34
g753
(S'\x07\xdf\x07\x0b\x10$0\x04\xed\xb8'
tRp1235
sa(dp1236
S'trial_loop.thisTrialN'
p1237
I21
sg895
S'13-mccoys_steak_crisps.png'
p1238
sS'block_loop.thisIndex'
p1239
g889
sg38
S'left'
p1240
sg59
g63
sS'trial_loop.thisN'
p1241
I21
sg33
g920
sg64
g65
sS'trial_loop.thisIndex'
p1242
g60
(g99
S'\x15\x00\x00\x00'
tRp1243
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1244
I0
sg904
S'3-ellas_strawberries_apples.png'
p1245
sS'block_loop.thisRepN'
p1246
I0
sg907
g926
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1247
I0
sg909
g920
sg55
g11
sS'block_loop.thisTrial'
p1248
Nsg70
Vn
sS'block_loop.thisTrialN'
p1249
I0
sg39
F2.083154100811953
sg34
g753
(S'\x07\xdf\x07\x0b\x10$6\x08\\\xa0'
tRp1250
sa(dp1251
S'trial_loop.thisTrialN'
p1252
I22
sg895
S'2-steamed_puddings.png'
p1253
sS'block_loop.thisIndex'
p1254
g889
sg38
S'left'
p1255
sg59
g63
sS'trial_loop.thisN'
p1256
I22
sg33
g1187
sg64
g65
sS'trial_loop.thisIndex'
p1257
g60
(g99
S'\x16\x00\x00\x00'
tRp1258
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1259
I0
sg904
S'20-fruit_pastilles.png'
p1260
sS'block_loop.thisRepN'
p1261
I0
sg907
g1180
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1262
I0
sg909
g1187
sg55
g11
sS'block_loop.thisTrial'
p1263
Nsg70
Vn
sS'block_loop.thisTrialN'
p1264
I0
sg39
F0.95000296503349091
sg34
g753
(S'\x07\xdf\x07\x0b\x10%\x01\n\x16\x08'
tRp1265
sa(dp1266
S'trial_loop.thisTrialN'
p1267
I23
sg895
S'48-twix.png'
p1268
sS'block_loop.thisIndex'
p1269
g889
sg38
S'left'
p1270
sg59
g63
sS'trial_loop.thisN'
p1271
I23
sg33
S'48-twix.png'
p1272
sg64
g65
sS'trial_loop.thisIndex'
p1273
g60
(g99
S'\x17\x00\x00\x00'
tRp1274
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1275
I0
sg904
S'50-polo.png'
p1276
sS'block_loop.thisRepN'
p1277
I0
sg907
g1272
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1278
I0
sg909
S'50-polo.png'
p1279
sg55
g11
sS'block_loop.thisTrial'
p1280
Nsg70
Vn
sS'block_loop.thisTrialN'
p1281
I0
sg39
F1.3832580480702745
sg34
g753
(S'\x07\xdf\x07\x0b\x10%\x07\t\xb4`'
tRp1282
sa(dp1283
S'trial_loop.thisTrialN'
p1284
I24
sg895
S'1-treacle_cookies.png'
p1285
sS'block_loop.thisIndex'
p1286
g889
sg38
S'left'
p1287
sg59
g63
sS'trial_loop.thisN'
p1288
I24
sg33
S'1-treacle_cookies.png'
p1289
sg64
g65
sS'trial_loop.thisIndex'
p1290
g60
(g99
S'\x18\x00\x00\x00'
tRp1291
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1292
I0
sg904
S'21-nakd_banana_crunch.png'
p1293
sS'block_loop.thisRepN'
p1294
I0
sg907
g1289
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1295
I0
sg909
S'21-nakd_banana_crunch.png'
p1296
sg55
g11
sS'block_loop.thisTrial'
p1297
Nsg70
Vn
sS'block_loop.thisTrialN'
p1298
I0
sg39
F1.2832919178872544
sg34
g753
(S'\x07\xdf\x07\x0b\x10%\x0e\x00\xf6\x18'
tRp1299
sa(dp1300
S'trial_loop.thisTrialN'
p1301
I25
sg895
g967
sS'block_loop.thisIndex'
p1302
g889
sg38
S'right'
p1303
sg59
g63
sS'trial_loop.thisN'
p1304
I25
sg33
g971
sg64
g65
sS'trial_loop.thisIndex'
p1305
g60
(g99
S'\x19\x00\x00\x00'
tRp1306
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1307
I0
sg904
g975
sS'block_loop.thisRepN'
p1308
I0
sg907
g971
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1309
I0
sg909
g978
sg55
g11
sS'block_loop.thisTrial'
p1310
Nsg70
Vn
sS'block_loop.thisTrialN'
p1311
I0
sg39
F1.0670146210431994
sg34
g753
(S'\x07\xdf\x07\x0b\x10%\x14\x05\xd0H'
tRp1312
sa(dp1313
S'trial_loop.thisTrialN'
p1314
I26
sg895
g1176
sS'block_loop.thisIndex'
p1315
g889
sg38
S'right'
p1316
sg59
g63
sS'trial_loop.thisN'
p1317
I26
sg33
g1180
sg64
g65
sS'trial_loop.thisIndex'
p1318
g60
(g99
S'\x1a\x00\x00\x00'
tRp1319
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1320
I0
sg904
g1184
sS'block_loop.thisRepN'
p1321
I0
sg907
g1180
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1322
I0
sg909
g1187
sg55
g11
sS'block_loop.thisTrial'
p1323
Nsg70
Vn
sS'block_loop.thisTrialN'
p1324
I0
sg39
F0.9665943274339952
sg34
g753
(S'\x07\xdf\x07\x0b\x10%\x1a\x07V\xe8'
tRp1325
sa(dp1326
S'trial_loop.thisTrialN'
p1327
I27
sg895
g984
sS'block_loop.thisIndex'
p1328
g889
sg38
S'right'
p1329
sg59
g63
sS'trial_loop.thisN'
p1330
I27
sg33
g988
sg64
g65
sS'trial_loop.thisIndex'
p1331
g60
(g99
S'\x1b\x00\x00\x00'
tRp1332
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1333
I0
sg904
g992
sS'block_loop.thisRepN'
p1334
I0
sg907
g988
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1335
I0
sg909
g995
sg55
g11
sS'block_loop.thisTrial'
p1336
Nsg70
Vn
sS'block_loop.thisTrialN'
p1337
I0
sg39
F1.1331491400815139
sg34
g753
(S'\x07\xdf\x07\x0b\x10% \x07/\xd8'
tRp1338
sa(dp1339
S'trial_loop.thisTrialN'
p1340
I28
sg895
g933
sS'block_loop.thisIndex'
p1341
g889
sg38
S'right'
p1342
sg59
g63
sS'trial_loop.thisN'
p1343
I28
sg33
g937
sg64
g65
sS'trial_loop.thisIndex'
p1344
g60
(g99
S'\x1c\x00\x00\x00'
tRp1345
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1346
I0
sg904
g941
sS'block_loop.thisRepN'
p1347
I0
sg907
g937
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1348
I0
sg909
g944
sg55
g11
sS'block_loop.thisTrial'
p1349
Nsg70
Vn
sS'block_loop.thisTrialN'
p1350
I0
sg39
F0.86654779919990688
sg34
g753
(S'\x07\xdf\x07\x0b\x10%&\t\xa8\xa8'
tRp1351
sa(dp1352
S'trial_loop.thisTrialN'
p1353
I29
sg895
S'16-skips_prawn.png'
p1354
sS'block_loop.thisIndex'
p1355
g889
sg38
S'left'
p1356
sg59
g63
sS'trial_loop.thisN'
p1357
I29
sg33
g988
sg64
g65
sS'trial_loop.thisIndex'
p1358
g60
(g99
S'\x1d\x00\x00\x00'
tRp1359
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1360
I0
sg904
S'42-mrkipling_lemon_slices.png'
p1361
sS'block_loop.thisRepN'
p1362
I0
sg907
g988
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1363
I0
sg909
g995
sg55
g11
sS'block_loop.thisTrial'
p1364
Nsg70
Vn
sS'block_loop.thisTrialN'
p1365
I0
sg39
F0.91651461362562259
sg34
g753
(S'\x07\xdf\x07\x0b\x10%,\x08T\xd0'
tRp1366
sa(dp1367
S'trial_loop.thisTrialN'
p1368
I30
sg895
S'30-spaghetti_hoops.png'
p1369
sS'block_loop.thisIndex'
p1370
g889
sg38
S'left'
p1371
sg59
g63
sS'trial_loop.thisN'
p1372
I30
sg33
g1099
sg64
g65
sS'trial_loop.thisIndex'
p1373
g60
(g99
S'\x1e\x00\x00\x00'
tRp1374
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1375
I0
sg904
S'19-caramello_redo.png'
p1376
sS'block_loop.thisRepN'
p1377
I0
sg907
g1099
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1378
I0
sg909
g1106
sg55
g11
sS'block_loop.thisTrial'
p1379
Nsg70
Vn
sS'block_loop.thisTrialN'
p1380
I0
sg39
F1.5336528537882259
sg34
g753
(S'\x07\xdf\x07\x0b\x10%2\x07v('
tRp1381
sa(dp1382
S'trial_loop.thisTrialN'
p1383
I31
sg895
S'4-corn.png'
p1384
sS'block_loop.thisIndex'
p1385
g889
sg38
S'left'
p1386
sg59
g63
sS'trial_loop.thisN'
p1387
I31
sg33
g1054
sg64
g65
sS'trial_loop.thisIndex'
p1388
g60
(g99
S'\x1f\x00\x00\x00'
tRp1389
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1390
I0
sg904
S'10-bounty_redo.png'
p1391
sS'block_loop.thisRepN'
p1392
I0
sg907
g1054
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1393
I0
sg909
g1061
sg55
g11
sS'block_loop.thisTrial'
p1394
Nsg70
Vn
sS'block_loop.thisTrialN'
p1395
I0
sg39
F1.0666283112877863
sg34
g753
(S'\x07\xdf\x07\x0b\x10%9\x00\xde\xa8'
tRp1396
sa(dp1397
S'trial_loop.thisTrialN'
p1398
I32
sg895
g933
sS'block_loop.thisIndex'
p1399
g889
sg38
S'right'
p1400
sg59
g63
sS'trial_loop.thisN'
p1401
I32
sg33
g937
sg64
g65
sS'trial_loop.thisIndex'
p1402
g60
(g99
S' \x00\x00\x00'
tRp1403
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1404
I0
sg904
g941
sS'block_loop.thisRepN'
p1405
I0
sg907
g937
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1406
I0
sg909
g944
sg55
g11
sS'block_loop.thisTrial'
p1407
Nsg70
Vn
sS'block_loop.thisTrialN'
p1408
I0
sg39
F0.86666925156896468
sg34
g753
(S'\x07\xdf\x07\x0b\x10&\x03\x02eH'
tRp1409
sa(dp1410
S'trial_loop.thisTrialN'
p1411
I33
sg895
g1095
sS'block_loop.thisIndex'
p1412
g889
sg38
S'right'
p1413
sg59
g63
sS'trial_loop.thisN'
p1414
I33
sg33
g1099
sg64
g65
sS'trial_loop.thisIndex'
p1415
g60
(g99
S'!\x00\x00\x00'
tRp1416
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1417
I0
sg904
g1103
sS'block_loop.thisRepN'
p1418
I0
sg907
g1099
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1419
I0
sg909
g1106
sg55
g11
sS'block_loop.thisTrial'
p1420
Nsg70
Vn
sS'block_loop.thisTrialN'
p1421
I0
sg39
F1.6499249618282192
sg34
g753
(S'\x07\xdf\x07\x0b\x10&\t\x00\xcf\x08'
tRp1422
sa(dp1423
S'trial_loop.thisTrialN'
p1424
I34
sg895
g950
sS'block_loop.thisIndex'
p1425
g889
sg38
S'right'
p1426
sg59
g63
sS'trial_loop.thisN'
p1427
I34
sg33
g954
sg64
g65
sS'trial_loop.thisIndex'
p1428
g60
(g99
S'"\x00\x00\x00'
tRp1429
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1430
I0
sg904
g958
sS'block_loop.thisRepN'
p1431
I0
sg907
g954
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1432
I0
sg909
g961
sg55
g11
sS'block_loop.thisTrial'
p1433
Nsg70
Vn
sS'block_loop.thisTrialN'
p1434
I0
sg39
F0.899917549239035
sg34
g753
(S'\x07\xdf\x07\x0b\x10&\x0f\x0bb\x10'
tRp1435
sa(dp1436
S'trial_loop.thisTrialN'
p1437
I35
sg895
g1159
sS'block_loop.thisIndex'
p1438
g889
sg38
S'right'
p1439
sg59
g63
sS'trial_loop.thisN'
p1440
I35
sg33
g1170
sg64
g65
sS'trial_loop.thisIndex'
p1441
g60
(g99
S'#\x00\x00\x00'
tRp1442
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1443
I0
sg904
g1167
sS'block_loop.thisRepN'
p1444
I0
sg907
g1163
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1445
I0
sg909
g1170
sg55
g11
sS'block_loop.thisTrial'
p1446
Nsg70
Vn
sS'block_loop.thisTrialN'
p1447
I0
sg39
F1.0666288814863947
sg34
g753
(S'\x07\xdf\x07\x0b\x10&\x15\nH\xd0'
tRp1448
sa(dp1449
S'trial_loop.thisTrialN'
p1450
I36
sg895
g1268
sS'block_loop.thisIndex'
p1451
g889
sg38
S'left'
p1452
sg59
g63
sS'trial_loop.thisN'
p1453
I36
sg33
g1279
sg64
g65
sS'trial_loop.thisIndex'
p1454
g60
(g99
S'$\x00\x00\x00'
tRp1455
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1456
I0
sg904
g1276
sS'block_loop.thisRepN'
p1457
I0
sg907
g1272
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1458
I0
sg909
g1279
sg55
g11
sS'block_loop.thisTrial'
p1459
Nsg70
Vn
sS'block_loop.thisTrialN'
p1460
I0
sg39
F0.98320393619360402
sg34
g753
(S'\x07\xdf\x07\x0b\x10&\x1b\x0b\xcb\x88'
tRp1461
sa(dp1462
S'trial_loop.thisTrialN'
p1463
I37
sg895
g1238
sS'block_loop.thisIndex'
p1464
g889
sg38
S'left'
p1465
sg59
g63
sS'trial_loop.thisN'
p1466
I37
sg33
g920
sg64
g65
sS'trial_loop.thisIndex'
p1467
g60
(g99
S'%\x00\x00\x00'
tRp1468
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1469
I0
sg904
g1245
sS'block_loop.thisRepN'
p1470
I0
sg907
g926
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1471
I0
sg909
g920
sg55
g11
sS'block_loop.thisTrial'
p1472
Nsg70
Vn
sS'block_loop.thisTrialN'
p1473
I0
sg39
F1.0665427814528812
sg34
g753
(S'\x07\xdf\x07\x0b\x10&!\x0c!x'
tRp1474
sa(dp1475
S'trial_loop.thisTrialN'
p1476
I38
sg895
g896
sS'block_loop.thisIndex'
p1477
g889
sg38
S'left'
p1478
sg59
g63
sS'trial_loop.thisN'
p1479
I38
sg33
g900
sg64
g65
sS'trial_loop.thisIndex'
p1480
g60
(g99
S'&\x00\x00\x00'
tRp1481
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1482
I0
sg904
g905
sS'block_loop.thisRepN'
p1483
I0
sg907
g900
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1484
I0
sg909
g910
sg55
g11
sS'block_loop.thisTrial'
p1485
Nsg70
Vn
sS'block_loop.thisTrialN'
p1486
I0
sg39
F3.4999224529492494
sg34
g753
(S"\x07\xdf\x07\x0b\x10&'\r\xa8\x18"
tRp1487
sa(dp1488
S'trial_loop.thisTrialN'
p1489
I39
sg895
S'38-maltesers.png'
p1490
sS'block_loop.thisIndex'
p1491
g889
sg38
S'left'
p1492
sg59
g63
sS'trial_loop.thisN'
p1493
I39
sg33
S'38-maltesers.png'
p1494
sg64
g65
sS'trial_loop.thisIndex'
p1495
g60
(g99
S"'\x00\x00\x00"
tRp1496
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1497
I0
sg904
S'6-sour_patch_kids.png'
p1498
sS'block_loop.thisRepN'
p1499
I0
sg907
g1494
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1500
I0
sg909
S'6-sour_patch_kids.png'
p1501
sg55
g11
sS'block_loop.thisTrial'
p1502
Nsg70
Vn
sS'block_loop.thisTrialN'
p1503
I0
sg39
F1.1162818014199729
sg34
g753
(S'\x07\xdf\x07\x0b\x10&0\x06\x87\xe0'
tRp1504
sa(dp1505
S'trial_loop.thisTrialN'
p1506
I40
sg895
g1253
sS'block_loop.thisIndex'
p1507
g889
sg38
S'right'
p1508
sg59
g63
sS'trial_loop.thisN'
p1509
I40
sg33
g1180
sg64
g65
sS'trial_loop.thisIndex'
p1510
g60
(g99
S'(\x00\x00\x00'
tRp1511
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1512
I0
sg904
g1260
sS'block_loop.thisRepN'
p1513
I0
sg907
g1180
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1514
I0
sg909
g1187
sg55
g11
sS'block_loop.thisTrial'
p1515
Nsg70
Vn
sS'block_loop.thisTrialN'
p1516
I0
sg39
F1.9833111335901776
sg34
g753
(S'\x07\xdf\x07\x0b\x10&6\x08\xc20'
tRp1517
sa(dp1518
S'trial_loop.thisTrialN'
p1519
I41
sg895
g1384
sS'block_loop.thisIndex'
p1520
g889
sg38
S'left'
p1521
sg59
g63
sS'trial_loop.thisN'
p1522
I41
sg33
g1061
sg64
g65
sS'trial_loop.thisIndex'
p1523
g60
(g99
S')\x00\x00\x00'
tRp1524
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1525
I0
sg904
g1391
sS'block_loop.thisRepN'
p1526
I0
sg907
g1054
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1527
I0
sg909
g1061
sg55
g11
sS'block_loop.thisTrial'
p1528
Nsg70
Vn
sS'block_loop.thisTrialN'
p1529
I0
sg39
F0.8832463589933468
sg34
g753
(S"\x07\xdf\x07\x0b\x10'\x01\t\x10P"
tRp1530
sa(dp1531
S'trial_loop.thisTrialN'
p1532
I42
sg895
g1018
sS'block_loop.thisIndex'
p1533
g889
sg38
S'left'
p1534
sg59
g63
sS'trial_loop.thisN'
p1535
I42
sg33
g1022
sg64
g65
sS'trial_loop.thisIndex'
p1536
g60
(g99
S'*\x00\x00\x00'
tRp1537
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1538
I0
sg904
g1026
sS'block_loop.thisRepN'
p1539
I0
sg907
g1022
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1540
I0
sg909
g1029
sg55
g11
sS'block_loop.thisTrial'
p1541
Nsg70
Vn
sS'block_loop.thisTrialN'
p1542
I0
sg39
F0.84972835724693141
sg34
g753
(S"\x07\xdf\x07\x0b\x10'\x07\x07\xbcx"
tRp1543
sa(dp1544
S'trial_loop.thisTrialN'
p1545
I43
sg895
S'45-chewy_nougat_redo.png'
p1546
sS'block_loop.thisIndex'
p1547
g889
sg38
S'right'
p1548
sg59
g63
sS'trial_loop.thisN'
p1549
I43
sg33
S'41-peanuts_redo.png'
p1550
sg64
g65
sS'trial_loop.thisIndex'
p1551
g60
(g99
S'+\x00\x00\x00'
tRp1552
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1553
I0
sg904
S'41-peanuts_redo.png'
p1554
sS'block_loop.thisRepN'
p1555
I0
sg907
g1550
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1556
I0
sg909
S'45-chewy_nougat_redo.png'
p1557
sg55
g11
sS'block_loop.thisTrial'
p1558
Nsg70
Vn
sS'block_loop.thisTrialN'
p1559
I0
sg39
F1.1498725035271491
sg34
g753
(S"\x07\xdf\x07\x0b\x10'\r\x05\xeb\xa0"
tRp1560
sa(dp1561
S'trial_loop.thisTrialN'
p1562
I44
sg895
g1369
sS'block_loop.thisIndex'
p1563
g889
sg38
S'left'
p1564
sg59
g63
sS'trial_loop.thisN'
p1565
I44
sg33
g1106
sg64
g65
sS'trial_loop.thisIndex'
p1566
g60
(g99
S',\x00\x00\x00'
tRp1567
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1568
I0
sg904
g1376
sS'block_loop.thisRepN'
p1569
I0
sg907
g1099
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1570
I0
sg909
g1106
sg55
g11
sS'block_loop.thisTrial'
p1571
Nsg70
Vn
sS'block_loop.thisTrialN'
p1572
I0
sg39
F1.8999067154618388
sg34
g753
(S"\x07\xdf\x07\x0b\x10'\x13\x08\xa2\xf0"
tRp1573
sa(dp1574
S'trial_loop.thisTrialN'
p1575
I45
sg895
g950
sS'block_loop.thisIndex'
p1576
g889
sg38
S'right'
p1577
sg59
g63
sS'trial_loop.thisN'
p1578
I45
sg33
g954
sg64
g65
sS'trial_loop.thisIndex'
p1579
g60
(g99
S'-\x00\x00\x00'
tRp1580
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1581
I0
sg904
g958
sS'block_loop.thisRepN'
p1582
I0
sg907
g954
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1583
I0
sg909
g961
sg55
g11
sS'block_loop.thisTrial'
p1584
Nsg70
Vn
sS'block_loop.thisTrialN'
p1585
I0
sg39
F0.71665533871419029
sg34
g753
(S"\x07\xdf\x07\x0b\x10'\x1a\x07\xc0`"
tRp1586
sa(dp1587
S'trial_loop.thisTrialN'
p1588
I46
sg895
S'31-hobnobs.png'
p1589
sS'block_loop.thisIndex'
p1590
g889
sg38
S'left'
p1591
sg59
g63
sS'trial_loop.thisN'
p1592
I46
sg33
g1163
sg64
g65
sS'trial_loop.thisIndex'
p1593
g60
(g99
S'.\x00\x00\x00'
tRp1594
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1595
I0
sg904
S'25-kitkat.png'
p1596
sS'block_loop.thisRepN'
p1597
I0
sg907
g1163
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1598
I0
sg909
g1170
sg55
g11
sS'block_loop.thisTrial'
p1599
Nsg70
Vn
sS'block_loop.thisTrialN'
p1600
I0
sg39
F1.6332455036972533
sg34
g753
(S"\x07\xdf\x07\x0b\x10' \x03\xc8\xc0"
tRp1601
sa(dp1602
S'trial_loop.thisTrialN'
p1603
I47
sg895
g933
sS'block_loop.thisIndex'
p1604
g889
sg38
S'right'
p1605
sg59
g63
sS'trial_loop.thisN'
p1606
I47
sg33
g944
sg64
g65
sS'trial_loop.thisIndex'
p1607
g60
(g99
S'/\x00\x00\x00'
tRp1608
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1609
I0
sg904
g941
sS'block_loop.thisRepN'
p1610
I0
sg907
g937
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1611
I0
sg909
g944
sg55
g11
sS'block_loop.thisTrial'
p1612
Nsg70
Vn
sS'block_loop.thisTrialN'
p1613
I0
sg39
F0.86656205417602905
sg34
g753
(S"\x07\xdf\x07\x0b\x10'&\x0e\x1dH"
tRp1614
sa(dp1615
S'trial_loop.thisTrialN'
p1616
I48
sg895
S'49-yorkie.png'
p1617
sS'block_loop.thisIndex'
p1618
g889
sg38
S'left'
p1619
sg59
g63
sS'trial_loop.thisN'
p1620
I48
sg33
S'35-raisins.png'
p1621
sg64
g65
sS'trial_loop.thisIndex'
p1622
g60
(g99
S'0\x00\x00\x00'
tRp1623
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1624
I0
sg904
S'35-raisins.png'
p1625
sS'block_loop.thisRepN'
p1626
I0
sg907
g1621
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1627
I0
sg909
S'49-yorkie.png'
p1628
sg55
g11
sS'block_loop.thisTrial'
p1629
Nsg70
Vn
sS'block_loop.thisTrialN'
p1630
I0
sg39
F1.1666514613643812
sg34
g753
(S"\x07\xdf\x07\x0b\x10',\x0c\x8a\xf0"
tRp1631
sa(dp1632
S'trial_loop.thisTrialN'
p1633
I49
sg895
g1050
sS'block_loop.thisIndex'
p1634
g889
sg38
S'right'
p1635
sg59
g63
sS'trial_loop.thisN'
p1636
I49
sg33
g1054
sg64
g65
sS'trial_loop.thisIndex'
p1637
g60
(g99
S'1\x00\x00\x00'
tRp1638
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1639
I0
sg904
g1058
sS'block_loop.thisRepN'
p1640
I0
sg907
g1054
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1641
I0
sg909
g1061
sg55
g11
sS'block_loop.thisTrial'
p1642
Nsg70
Vn
sS'block_loop.thisTrialN'
p1643
I0
sg39
F0.99991361486900132
sg34
g753
(S"\x07\xdf\x07\x0b\x10'3\x00:\x98"
tRp1644
sa(dp1645
S'trial_loop.thisTrialN'
p1646
I50
sg895
S'33-ambrosia_rice.png'
p1647
sS'block_loop.thisIndex'
p1648
g889
sg38
S'right'
p1649
sg59
g63
sS'trial_loop.thisN'
p1650
I50
sg33
g1197
sg64
g65
sS'trial_loop.thisIndex'
p1651
g60
(g99
S'2\x00\x00\x00'
tRp1652
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1653
I0
sg904
S'23-crunchie_redo.png'
p1654
sS'block_loop.thisRepN'
p1655
I0
sg907
g1197
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1656
I0
sg909
g1204
sg55
g11
sS'block_loop.thisTrial'
p1657
Nsg70
Vn
sS'block_loop.thisTrialN'
p1658
I0
sg39
F1.8669152923939691
sg34
g753
(S"\x07\xdf\x07\x0b\x10'9\x00\xcb "
tRp1659
sa(dp1660
S'trial_loop.thisTrialN'
p1661
I51
sg895
g1384
sS'block_loop.thisIndex'
p1662
g889
sg38
S'left'
p1663
sg59
g63
sS'trial_loop.thisN'
p1664
I51
sg33
g1054
sg64
g65
sS'trial_loop.thisIndex'
p1665
g60
(g99
S'3\x00\x00\x00'
tRp1666
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1667
I0
sg904
g1391
sS'block_loop.thisRepN'
p1668
I0
sg907
g1054
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1669
I0
sg909
g1061
sg55
g11
sS'block_loop.thisTrial'
p1670
Nsg70
Vn
sS'block_loop.thisTrialN'
p1671
I0
sg39
F1.0333084536541719
sg34
g753
(S'\x07\xdf\x07\x0b\x10(\x03\x0ew '
tRp1672
sa(dp1673
S'trial_loop.thisTrialN'
p1674
I52
sg895
S'35-raisins.png'
p1675
sS'block_loop.thisIndex'
p1676
g889
sg38
S'left'
p1677
sg59
g63
sS'trial_loop.thisN'
p1678
I52
sg33
g1621
sg64
g65
sS'trial_loop.thisIndex'
p1679
g60
(g99
S'4\x00\x00\x00'
tRp1680
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1681
I0
sg904
S'49-yorkie.png'
p1682
sS'block_loop.thisRepN'
p1683
I0
sg907
g1621
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1684
I0
sg909
g1628
sg55
g11
sS'block_loop.thisTrial'
p1685
Nsg70
Vn
sS'block_loop.thisTrialN'
p1686
I0
sg39
F1.1333241911452205
sg34
g753
(S'\x07\xdf\x07\x0b\x10(\n\x00>\x80'
tRp1687
sa(dp1688
S'trial_loop.thisTrialN'
p1689
I53
sg895
S'50-polo.png'
p1690
sS'block_loop.thisIndex'
p1691
g889
sg38
S'right'
p1692
sg59
g63
sS'trial_loop.thisN'
p1693
I53
sg33
g1272
sg64
g65
sS'trial_loop.thisIndex'
p1694
g60
(g99
S'5\x00\x00\x00'
tRp1695
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1696
I0
sg904
S'48-twix.png'
p1697
sS'block_loop.thisRepN'
p1698
I0
sg907
g1272
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1699
I0
sg909
g1279
sg55
g11
sS'block_loop.thisTrial'
p1700
Nsg70
Vn
sS'block_loop.thisTrialN'
p1701
I0
sg39
F1.583199431624962
sg34
g753
(S'\x07\xdf\x07\x0b\x10(\x10\x02\xf5\xd0'
tRp1702
sa(dp1703
S'trial_loop.thisTrialN'
p1704
I54
sg895
g1490
sS'block_loop.thisIndex'
p1705
g889
sg38
S'left'
p1706
sg59
g63
sS'trial_loop.thisN'
p1707
I54
sg33
g1501
sg64
g65
sS'trial_loop.thisIndex'
p1708
g60
(g99
S'6\x00\x00\x00'
tRp1709
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1710
I0
sg904
g1498
sS'block_loop.thisRepN'
p1711
I0
sg907
g1494
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1712
I0
sg909
g1501
sg55
g11
sS'block_loop.thisTrial'
p1713
Nsg70
Vn
sS'block_loop.thisTrialN'
p1714
I0
sg39
F0.89957885109470226
sg34
g753
(S'\x07\xdf\x07\x0b\x10(\x16\x0cT@'
tRp1715
sa(dp1716
S'trial_loop.thisTrialN'
p1717
I55
sg895
g1095
sS'block_loop.thisIndex'
p1718
g889
sg38
S'right'
p1719
sg59
g63
sS'trial_loop.thisN'
p1720
I55
sg33
g1106
sg64
g65
sS'trial_loop.thisIndex'
p1721
g60
(g99
S'7\x00\x00\x00'
tRp1722
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1723
I0
sg904
g1103
sS'block_loop.thisRepN'
p1724
I0
sg907
g1099
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1725
I0
sg909
g1106
sg55
g11
sS'block_loop.thisTrial'
p1726
Nsg70
Vn
sS'block_loop.thisTrialN'
p1727
I0
sg39
F2.133297106694954
sg34
g753
(S'\x07\xdf\x07\x0b\x10(\x1c\x0b;\x00'
tRp1728
sa(dp1729
S'trial_loop.thisTrialN'
p1730
I56
sg895
g1589
sS'block_loop.thisIndex'
p1731
g889
sg38
S'left'
p1732
sg59
g63
sS'trial_loop.thisN'
p1733
I56
sg33
g1170
sg64
g65
sS'trial_loop.thisIndex'
p1734
g60
(g99
S'8\x00\x00\x00'
tRp1735
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1736
I0
sg904
g1596
sS'block_loop.thisRepN'
p1737
I0
sg907
g1163
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1738
I0
sg909
g1170
sg55
g11
sS'block_loop.thisTrial'
p1739
Nsg70
Vn
sS'block_loop.thisTrialN'
p1740
I0
sg39
F0.8665948406123789
sg34
g753
(S'\x07\xdf\x07\x0b\x10(#\r\xea\x80'
tRp1741
sa(dp1742
S'trial_loop.thisTrialN'
p1743
I57
sg895
S'21-nakd_banana_crunch.png'
p1744
sS'block_loop.thisIndex'
p1745
g889
sg38
S'right'
p1746
sg59
g63
sS'trial_loop.thisN'
p1747
I57
sg33
g1296
sg64
g65
sS'trial_loop.thisIndex'
p1748
g60
(g99
S'9\x00\x00\x00'
tRp1749
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1750
I0
sg904
S'1-treacle_cookies.png'
p1751
sS'block_loop.thisRepN'
p1752
I0
sg907
g1289
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1753
I0
sg909
g1296
sg55
g11
sS'block_loop.thisTrial'
p1754
Nsg70
Vn
sS'block_loop.thisTrialN'
p1755
I0
sg39
F0.95000809682460385
sg34
g753
(S'\x07\xdf\x07\x0b\x10()\x0cX('
tRp1756
sa(dp1757
S'trial_loop.thisTrialN'
p1758
I58
sg895
g1018
sS'block_loop.thisIndex'
p1759
g889
sg38
S'left'
p1760
sg59
g63
sS'trial_loop.thisN'
p1761
I58
sg33
g1022
sg64
g65
sS'trial_loop.thisIndex'
p1762
g60
(g99
S':\x00\x00\x00'
tRp1763
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1764
I0
sg904
g1026
sS'block_loop.thisRepN'
p1765
I0
sg907
g1022
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1766
I0
sg909
g1029
sg55
g11
sS'block_loop.thisTrial'
p1767
Nsg70
Vn
sS'block_loop.thisTrialN'
p1768
I0
sg39
F0.74992815493897069
sg34
g753
(S'\x07\xdf\x07\x0b\x10(/\x0b\xf6\x80'
tRp1769
sa(dp1770
S'trial_loop.thisTrialN'
p1771
I59
sg895
g1112
sS'block_loop.thisIndex'
p1772
g889
sg38
S'right'
p1773
sg59
g63
sS'trial_loop.thisN'
p1774
I59
sg33
g1011
sg64
g65
sS'trial_loop.thisIndex'
p1775
g60
(g99
S';\x00\x00\x00'
tRp1776
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1777
I0
sg904
g1119
sS'block_loop.thisRepN'
p1778
I0
sg907
g1011
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1779
I0
sg909
g1005
sg55
g11
sS'block_loop.thisTrial'
p1780
Nsg70
Vn
sS'block_loop.thisTrialN'
p1781
I0
sg39
F1.0999766788627312
sg34
g753
(S'\x07\xdf\x07\x0b\x10(5\x08\xb6x'
tRp1782
sa(dp1783
S'trial_loop.thisTrialN'
p1784
I60
sg895
g1253
sS'block_loop.thisIndex'
p1785
g889
sg38
S'left'
p1786
sg59
g63
sS'trial_loop.thisN'
p1787
I60
sg33
g1180
sg64
g65
sS'trial_loop.thisIndex'
p1788
g60
(g99
S'<\x00\x00\x00'
tRp1789
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1790
I0
sg904
g1260
sS'block_loop.thisRepN'
p1791
I0
sg907
g1180
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1792
I0
sg909
g1187
sg55
g11
sS'block_loop.thisTrial'
p1793
Nsg70
Vn
sS'block_loop.thisTrialN'
p1794
I0
sg39
F0.83328952305237181
sg34
g753
(S'\x07\xdf\x07\x0b\x10(;\n\xb60'
tRp1795
sa(dp1796
S'trial_loop.thisTrialN'
p1797
I61
sg895
g950
sS'block_loop.thisIndex'
p1798
g889
sg38
S'right'
p1799
sg59
g63
sS'trial_loop.thisN'
p1800
I61
sg33
g961
sg64
g65
sS'trial_loop.thisIndex'
p1801
g60
(g99
S'=\x00\x00\x00'
tRp1802
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1803
I0
sg904
g958
sS'block_loop.thisRepN'
p1804
I0
sg907
g954
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1805
I0
sg909
g961
sg55
g11
sS'block_loop.thisTrial'
p1806
Nsg70
Vn
sS'block_loop.thisTrialN'
p1807
I0
sg39
F0.61662135486039915
sg34
g753
(S'\x07\xdf\x07\x0b\x10)\x05\x08\xaa\xc0'
tRp1808
sa(dp1809
S'trial_loop.thisTrialN'
p1810
I62
sg895
g1238
sS'block_loop.thisIndex'
p1811
g889
sg38
S'left'
p1812
sg59
g63
sS'trial_loop.thisN'
p1813
I62
sg33
g920
sg64
g65
sS'trial_loop.thisIndex'
p1814
g60
(g99
S'>\x00\x00\x00'
tRp1815
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1816
I0
sg904
g1245
sS'block_loop.thisRepN'
p1817
I0
sg907
g926
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1818
I0
sg909
g920
sg55
g11
sS'block_loop.thisTrial'
p1819
Nsg70
Vn
sS'block_loop.thisTrialN'
p1820
I0
sg39
F0.76656342265414423
sg34
g753
(S'\x07\xdf\x07\x0b\x10)\x0b\x03G\xd8'
tRp1821
sa(dp1822
S'trial_loop.thisTrialN'
p1823
I63
sg895
g1369
sS'block_loop.thisIndex'
p1824
g889
sg38
S'right'
p1825
sg59
g63
sS'trial_loop.thisN'
p1826
I63
sg33
g1099
sg64
g65
sS'trial_loop.thisIndex'
p1827
g60
(g99
S'?\x00\x00\x00'
tRp1828
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1829
I0
sg904
g1376
sS'block_loop.thisRepN'
p1830
I0
sg907
g1099
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1831
I0
sg909
g1106
sg55
g11
sS'block_loop.thisTrial'
p1832
Nsg70
Vn
sS'block_loop.thisTrialN'
p1833
I0
sg39
F0.99995438408950577
sg34
g753
(S'\x07\xdf\x07\x0b\x10)\x11\x00FP'
tRp1834
sa(dp1835
S'trial_loop.thisTrialN'
p1836
I64
sg895
S'44-crunch.png'
p1837
sS'block_loop.thisIndex'
p1838
g889
sg38
S'right'
p1839
sg59
g63
sS'trial_loop.thisN'
p1840
I64
sg33
g900
sg64
g65
sS'trial_loop.thisIndex'
p1841
g60
(g99
S'@\x00\x00\x00'
tRp1842
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1843
I0
sg904
S'26-walkers_smoky_bacon.png'
p1844
sS'block_loop.thisRepN'
p1845
I0
sg907
g900
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1846
I0
sg909
g910
sg55
g11
sS'block_loop.thisTrial'
p1847
Nsg70
Vn
sS'block_loop.thisTrialN'
p1848
I0
sg39
F0.84984097152846516
sg34
g753
(S'\x07\xdf\x07\x0b\x10)\x17\x00\xd6\xd8'
tRp1849
sa(dp1850
S'trial_loop.thisTrialN'
p1851
I65
sg895
g1490
sS'block_loop.thisIndex'
p1852
g889
sg38
S'left'
p1853
sg59
g63
sS'trial_loop.thisN'
p1854
I65
sg33
g1494
sg64
g65
sS'trial_loop.thisIndex'
p1855
g60
(g99
S'A\x00\x00\x00'
tRp1856
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1857
I0
sg904
g1498
sS'block_loop.thisRepN'
p1858
I0
sg907
g1494
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1859
I0
sg909
g1501
sg55
g11
sS'block_loop.thisTrial'
p1860
Nsg70
Vn
sS'block_loop.thisTrialN'
p1861
I0
sg39
F0.93305636872173636
sg34
g753
(S'\x07\xdf\x07\x0b\x10)\x1c\x0eL('
tRp1862
sa(dp1863
S'trial_loop.thisTrialN'
p1864
I66
sg895
g896
sS'block_loop.thisIndex'
p1865
g889
sg38
S'left'
p1866
sg59
g63
sS'trial_loop.thisN'
p1867
I66
sg33
g900
sg64
g65
sS'trial_loop.thisIndex'
p1868
g60
(g99
S'B\x00\x00\x00'
tRp1869
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1870
I0
sg904
g905
sS'block_loop.thisRepN'
p1871
I0
sg907
g900
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1872
I0
sg909
g910
sg55
g11
sS'block_loop.thisTrial'
p1873
Nsg70
Vn
sS'block_loop.thisTrialN'
p1874
I0
sg39
F1.0166543693776475
sg34
g753
(S'\x07\xdf\x07\x0b\x10)"\r\xe6\x98'
tRp1875
sa(dp1876
S'trial_loop.thisTrialN'
p1877
I67
sg895
g1354
sS'block_loop.thisIndex'
p1878
g889
sg38
S'left'
p1879
sg59
g63
sS'trial_loop.thisN'
p1880
I67
sg33
g995
sg64
g65
sS'trial_loop.thisIndex'
p1881
g60
(g99
S'C\x00\x00\x00'
tRp1882
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1883
I0
sg904
g1361
sS'block_loop.thisRepN'
p1884
I0
sg907
g988
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1885
I0
sg909
g995
sg55
g11
sS'block_loop.thisTrial'
p1886
Nsg70
Vn
sS'block_loop.thisTrialN'
p1887
I0
sg39
F1.0668732117119362
sg34
g753
(S'\x07\xdf\x07\x0b\x10)(\x0e{\x08'
tRp1888
sa(dp1889
S'trial_loop.thisTrialN'
p1890
I68
sg895
g1238
sS'block_loop.thisIndex'
p1891
g889
sg38
S'left'
p1892
sg59
g63
sS'trial_loop.thisN'
p1893
I68
sg33
g926
sg64
g65
sS'trial_loop.thisIndex'
p1894
g60
(g99
S'D\x00\x00\x00'
tRp1895
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1896
I0
sg904
g1245
sS'block_loop.thisRepN'
p1897
I0
sg907
g926
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1898
I0
sg909
g920
sg55
g11
sS'block_loop.thisTrial'
p1899
Nsg70
Vn
sS'block_loop.thisTrialN'
p1900
I0
sg39
F0.69986212590447394
sg34
g753
(S'\x07\xdf\x07\x0b\x10)/\x00\xbb\x80'
tRp1901
sa(dp1902
S'trial_loop.thisTrialN'
p1903
I69
sg895
g1690
sS'block_loop.thisIndex'
p1904
g889
sg38
S'right'
p1905
sg59
g63
sS'trial_loop.thisN'
p1906
I69
sg33
g1272
sg64
g65
sS'trial_loop.thisIndex'
p1907
g60
(g99
S'E\x00\x00\x00'
tRp1908
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1909
I0
sg904
g1697
sS'block_loop.thisRepN'
p1910
I0
sg907
g1272
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1911
I0
sg909
g1279
sg55
g11
sS'block_loop.thisTrial'
p1912
Nsg70
Vn
sS'block_loop.thisTrialN'
p1913
I0
sg39
F0.84989998711535009
sg34
g753
(S'\x07\xdf\x07\x0b\x10)4\x0c\n\x08'
tRp1914
sa(dp1915
S'trial_loop.thisTrialN'
p1916
I70
sg895
g1285
sS'block_loop.thisIndex'
p1917
g889
sg38
S'left'
p1918
sg59
g63
sS'trial_loop.thisN'
p1919
I70
sg33
g1296
sg64
g65
sS'trial_loop.thisIndex'
p1920
g60
(g99
S'F\x00\x00\x00'
tRp1921
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1922
I0
sg904
g1293
sS'block_loop.thisRepN'
p1923
I0
sg907
g1289
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1924
I0
sg909
g1296
sg55
g11
sS'block_loop.thisTrial'
p1925
Nsg70
Vn
sS'block_loop.thisTrialN'
p1926
I0
sg39
F1.2165438648335112
sg34
g753
(S'\x07\xdf\x07\x0b\x10):\n90'
tRp1927
sa(dp1928
S'trial_loop.thisTrialN'
p1929
I71
sg895
S'27-hartleys_raspberries_jelly.png'
p1930
sS'block_loop.thisIndex'
p1931
g889
sg38
S'right'
p1932
sg59
g63
sS'trial_loop.thisN'
p1933
I71
sg33
S'51-mars.png'
p1934
sg64
g65
sS'trial_loop.thisIndex'
p1935
g60
(g99
S'G\x00\x00\x00'
tRp1936
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1937
I0
sg904
S'51-mars.png'
p1938
sS'block_loop.thisRepN'
p1939
I0
sg907
S'27-hartleys_raspberries_jelly.png'
p1940
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1941
I0
sg909
g1934
sg55
g11
sS'block_loop.thisTrial'
p1942
Nsg70
Vn
sS'block_loop.thisTrialN'
p1943
I0
sg39
F1.0666422811627854
sg34
g753
(S'\x07\xdf\x07\x0b\x10*\x04\x0e!0'
tRp1944
sa(dp1945
S'trial_loop.thisTrialN'
p1946
I72
sg895
g1253
sS'block_loop.thisIndex'
p1947
g889
sg38
S'left'
p1948
sg59
g63
sS'trial_loop.thisN'
p1949
I72
sg33
g1180
sg64
g65
sS'trial_loop.thisIndex'
p1950
g60
(g99
S'H\x00\x00\x00'
tRp1951
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1952
I0
sg904
g1260
sS'block_loop.thisRepN'
p1953
I0
sg907
g1180
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1954
I0
sg909
g1187
sg55
g11
sS'block_loop.thisTrial'
p1955
Nsg70
Vn
sS'block_loop.thisTrialN'
p1956
I0
sg39
F0.79991720712132519
sg34
g753
(S'\x07\xdf\x07\x0b\x10*\x0b\x00a\xa8'
tRp1957
sa(dp1958
S'trial_loop.thisTrialN'
p1959
I73
sg895
g1647
sS'block_loop.thisIndex'
p1960
g889
sg38
S'right'
p1961
sg59
g63
sS'trial_loop.thisN'
p1962
I73
sg33
g1197
sg64
g65
sS'trial_loop.thisIndex'
p1963
g60
(g99
S'I\x00\x00\x00'
tRp1964
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1965
I0
sg904
g1654
sS'block_loop.thisRepN'
p1966
I0
sg907
g1197
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1967
I0
sg909
g1204
sg55
g11
sS'block_loop.thisTrial'
p1968
Nsg70
Vn
sS'block_loop.thisTrialN'
p1969
I0
sg39
F0.96665277281863382
sg34
g753
(S'\x07\xdf\x07\x0b\x10*\x10\r\x1f`'
tRp1970
sa(dp1971
S'trial_loop.thisTrialN'
p1972
I74
sg895
g1617
sS'block_loop.thisIndex'
p1973
g889
sg38
S'right'
p1974
sg59
g63
sS'trial_loop.thisN'
p1975
I74
sg33
g1621
sg64
g65
sS'trial_loop.thisIndex'
p1976
g60
(g99
S'J\x00\x00\x00'
tRp1977
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1978
I0
sg904
g1625
sS'block_loop.thisRepN'
p1979
I0
sg907
g1621
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1980
I0
sg909
g1628
sg55
g11
sS'block_loop.thisTrial'
p1981
Nsg70
Vn
sS'block_loop.thisTrialN'
p1982
I0
sg39
F1.0332294811087195
sg34
g753
(S'\x07\xdf\x07\x0b\x10*\x16\x0c\xf8P'
tRp1983
sa(dp1984
S'trial_loop.thisTrialN'
p1985
I75
sg895
g1018
sS'block_loop.thisIndex'
p1986
g889
sg38
S'left'
p1987
sg59
g63
sS'trial_loop.thisN'
p1988
I75
sg33
g1029
sg64
g65
sS'trial_loop.thisIndex'
p1989
g60
(g99
S'K\x00\x00\x00'
tRp1990
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p1991
I0
sg904
g1026
sS'block_loop.thisRepN'
p1992
I0
sg907
g1022
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p1993
I0
sg909
g1029
sg55
g11
sS'block_loop.thisTrial'
p1994
Nsg70
Vn
sS'block_loop.thisTrialN'
p1995
I0
sg39
F0.76655800576190813
sg34
g753
(S'\x07\xdf\x07\x0b\x10*\x1c\x0e\x05\xd8'
tRp1996
sa(dp1997
S'trial_loop.thisTrialN'
p1998
I76
sg895
S'18-mms.png'
p1999
sS'block_loop.thisIndex'
p2000
g889
sg38
S'right'
p2001
sg59
g63
sS'trial_loop.thisN'
p2002
I76
sg33
g1138
sg64
g65
sS'trial_loop.thisIndex'
p2003
g60
(g99
S'L\x00\x00\x00'
tRp2004
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2005
I0
sg904
S'43-mrporky_pork_crackles_redo.png'
p2006
sS'block_loop.thisRepN'
p2007
I0
sg907
g1131
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2008
I0
sg909
g1138
sg55
g11
sS'block_loop.thisTrial'
p2009
Nsg70
Vn
sS'block_loop.thisTrialN'
p2010
I0
sg39
F3.0665125609120878
sg34
g753
(S'\x07\xdf\x07\x0b\x10*"\x0b\x04P'
tRp2011
sa(dp2012
S'trial_loop.thisTrialN'
p2013
I77
sg895
g1647
sS'block_loop.thisIndex'
p2014
g889
sg38
S'right'
p2015
sg59
g63
sS'trial_loop.thisN'
p2016
I77
sg33
g1204
sg64
g65
sS'trial_loop.thisIndex'
p2017
g60
(g99
S'M\x00\x00\x00'
tRp2018
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2019
I0
sg904
g1654
sS'block_loop.thisRepN'
p2020
I0
sg907
g1197
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2021
I0
sg909
g1204
sg55
g11
sS'block_loop.thisTrial'
p2022
Nsg70
Vn
sS'block_loop.thisTrialN'
p2023
I0
sg39
F1.116572317754617
sg34
g753
(S'\x07\xdf\x07\x0b\x10**\x0c{P'
tRp2024
sa(dp2025
S'trial_loop.thisTrialN'
p2026
I78
sg895
g1067
sS'block_loop.thisIndex'
p2027
g889
sg38
S'left'
p2028
sg59
g63
sS'trial_loop.thisN'
p2029
I78
sg33
g954
sg64
g65
sS'trial_loop.thisIndex'
p2030
g60
(g99
S'N\x00\x00\x00'
tRp2031
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2032
I0
sg904
g1074
sS'block_loop.thisRepN'
p2033
I0
sg907
g954
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2034
I0
sg909
g961
sg55
g11
sS'block_loop.thisTrial'
p2035
Nsg70
Vn
sS'block_loop.thisTrialN'
p2036
I0
sg39
F0.70030802144538029
sg34
g753
(S'\x07\xdf\x07\x0b\x10*0\x0e\xb9\x88'
tRp2037
sa(dp2038
S'trial_loop.thisTrialN'
p2039
I79
sg895
g1238
sS'block_loop.thisIndex'
p2040
g889
sg38
S'left'
p2041
sg59
g63
sS'trial_loop.thisN'
p2042
I79
sg33
g920
sg64
g65
sS'trial_loop.thisIndex'
p2043
g60
(g99
S'O\x00\x00\x00'
tRp2044
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2045
I0
sg904
g1245
sS'block_loop.thisRepN'
p2046
I0
sg907
g926
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2047
I0
sg909
g920
sg55
g11
sS'block_loop.thisTrial'
p2048
Nsg70
Vn
sS'block_loop.thisTrialN'
p2049
I0
sg39
F0.68320804162794957
sg34
g753
(S'\x07\xdf\x07\x0b\x10*6\n\xc5\xd0'
tRp2050
sa(dp2051
S'trial_loop.thisTrialN'
p2052
I80
sg895
g1369
sS'block_loop.thisIndex'
p2053
g889
sg38
S'right'
p2054
sg59
g63
sS'trial_loop.thisN'
p2055
I80
sg33
g1099
sg64
g65
sS'trial_loop.thisIndex'
p2056
g60
(g99
S'P\x00\x00\x00'
tRp2057
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2058
I0
sg904
g1376
sS'block_loop.thisRepN'
p2059
I0
sg907
g1099
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2060
I0
sg909
g1106
sg55
g11
sS'block_loop.thisTrial'
p2061
Nsg70
Vn
sS'block_loop.thisTrialN'
p2062
I0
sg39
F0.98312040205928497
sg34
g753
(S'\x07\xdf\x07\x0b\x10+\x00\x06U\x18'
tRp2063
sa(dp2064
S'trial_loop.thisTrialN'
p2065
I81
sg895
g1035
sS'block_loop.thisIndex'
p2066
g889
sg38
S'left'
p2067
sg59
g63
sS'trial_loop.thisN'
p2068
I81
sg33
g971
sg64
g65
sS'trial_loop.thisIndex'
p2069
g60
(g99
S'Q\x00\x00\x00'
tRp2070
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2071
I0
sg904
g1042
sS'block_loop.thisRepN'
p2072
I0
sg907
g971
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2073
I0
sg909
g978
sg55
g11
sS'block_loop.thisTrial'
p2074
Nsg70
Vn
sS'block_loop.thisTrialN'
p2075
I0
sg39
F1.0999133867881028
sg34
g753
(S'\x07\xdf\x07\x0b\x10+\x06\x06\xab\x08'
tRp2076
sa(dp2077
S'trial_loop.thisTrialN'
p2078
I82
sg895
g1384
sS'block_loop.thisIndex'
p2079
g889
sg38
S'left'
p2080
sg59
g63
sS'trial_loop.thisN'
p2081
I82
sg33
g1054
sg64
g65
sS'trial_loop.thisIndex'
p2082
g60
(g99
S'R\x00\x00\x00'
tRp2083
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2084
I0
sg904
g1391
sS'block_loop.thisRepN'
p2085
I0
sg907
g1054
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2086
I0
sg909
g1061
sg55
g11
sS'block_loop.thisTrial'
p2087
Nsg70
Vn
sS'block_loop.thisTrialN'
p2088
I0
sg39
F0.88321727885340806
sg34
g753
(S'\x07\xdf\x07\x0b\x10+\x0c\x08\xaa\xc0'
tRp2089
sa(dp2090
S'trial_loop.thisTrialN'
p2091
I83
sg895
g1144
sS'block_loop.thisIndex'
p2092
g889
sg38
S'left'
p2093
sg59
g63
sS'trial_loop.thisN'
p2094
I83
sg33
g937
sg64
g65
sS'trial_loop.thisIndex'
p2095
g60
(g99
S'S\x00\x00\x00'
tRp2096
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2097
I0
sg904
g1151
sS'block_loop.thisRepN'
p2098
I0
sg907
g937
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2099
I0
sg909
g944
sg55
g11
sS'block_loop.thisTrial'
p2100
Nsg70
Vn
sS'block_loop.thisTrialN'
p2101
I0
sg39
F1.2833187172363978
sg34
g753
(S'\x07\xdf\x07\x0b\x10+\x12\x07S\x00'
tRp2102
sa(dp2103
S'trial_loop.thisTrialN'
p2104
I84
sg895
g1999
sS'block_loop.thisIndex'
p2105
g889
sg38
S'left'
p2106
sg59
g63
sS'trial_loop.thisN'
p2107
I84
sg33
g1131
sg64
g65
sS'trial_loop.thisIndex'
p2108
g60
(g99
S'T\x00\x00\x00'
tRp2109
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2110
I0
sg904
g2006
sS'block_loop.thisRepN'
p2111
I0
sg907
g1131
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2112
I0
sg909
g1138
sg55
g11
sS'block_loop.thisTrial'
p2113
Nsg70
Vn
sS'block_loop.thisTrialN'
p2114
I0
sg39
F1.166536281187291
sg34
g753
(S'\x07\xdf\x07\x0b\x10+\x18\x0c-0'
tRp2115
sa(dp2116
S'trial_loop.thisTrialN'
p2117
I85
sg895
g1837
sS'block_loop.thisIndex'
p2118
g889
sg38
S'right'
p2119
sg59
g63
sS'trial_loop.thisN'
p2120
I85
sg33
g910
sg64
g65
sS'trial_loop.thisIndex'
p2121
g60
(g99
S'U\x00\x00\x00'
tRp2122
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2123
I0
sg904
g1844
sS'block_loop.thisRepN'
p2124
I0
sg907
g900
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2125
I0
sg909
g910
sg55
g11
sS'block_loop.thisTrial'
p2126
Nsg70
Vn
sS'block_loop.thisTrialN'
p2127
I0
sg39
F0.9664988191179873
sg34
g753
(S'\x07\xdf\x07\x0b\x10+\x1f\x00\x1bX'
tRp2128
sa(dp2129
S'trial_loop.thisTrialN'
p2130
I86
sg895
g1001
sS'block_loop.thisIndex'
p2131
g889
sg38
S'right'
p2132
sg59
g63
sS'trial_loop.thisN'
p2133
I86
sg33
g1005
sg64
g65
sS'trial_loop.thisIndex'
p2134
g60
(g99
S'V\x00\x00\x00'
tRp2135
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2136
I0
sg904
g1009
sS'block_loop.thisRepN'
p2137
I0
sg907
g1011
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2138
I0
sg909
g1005
sg55
g11
sS'block_loop.thisTrial'
p2139
Nsg70
Vn
sS'block_loop.thisTrialN'
p2140
I0
sg39
F1.0665630235125718
sg34
g753
(S'\x07\xdf\x07\x0b\x10+$\x0f6\x88'
tRp2141
sa(dp2142
S'trial_loop.thisTrialN'
p2143
I87
sg895
g1744
sS'block_loop.thisIndex'
p2144
g889
sg38
S'left'
p2145
sg59
g63
sS'trial_loop.thisN'
p2146
I87
sg33
g1289
sg64
g65
sS'trial_loop.thisIndex'
p2147
g60
(g99
S'W\x00\x00\x00'
tRp2148
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2149
I0
sg904
g1751
sS'block_loop.thisRepN'
p2150
I0
sg907
g1289
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2151
I0
sg909
g1296
sg55
g11
sS'block_loop.thisTrial'
p2152
Nsg70
Vn
sS'block_loop.thisTrialN'
p2153
I0
sg39
F0.8665711773574003
sg34
g753
(S'\x07\xdf\x07\x0b\x10++\x01z\xe8'
tRp2154
sa(dp2155
S'trial_loop.thisTrialN'
p2156
I88
sg895
g1144
sS'block_loop.thisIndex'
p2157
g889
sg38
S'left'
p2158
sg59
g63
sS'trial_loop.thisN'
p2159
I88
sg33
g937
sg64
g65
sS'trial_loop.thisIndex'
p2160
g60
(g99
S'X\x00\x00\x00'
tRp2161
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2162
I0
sg904
g1151
sS'block_loop.thisRepN'
p2163
I0
sg907
g937
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2164
I0
sg909
g944
sg55
g11
sS'block_loop.thisTrial'
p2165
Nsg70
Vn
sS'block_loop.thisTrialN'
p2166
I0
sg39
F1.0170295602511032
sg34
g753
(S'\x07\xdf\x07\x0b\x10+1\x00#('
tRp2167
sa(dp2168
S'trial_loop.thisTrialN'
p2169
I89
sg895
S'6-sour_patch_kids.png'
p2170
sS'block_loop.thisIndex'
p2171
g889
sg38
S'right'
p2172
sg59
g63
sS'trial_loop.thisN'
p2173
I89
sg33
g1494
sg64
g65
sS'trial_loop.thisIndex'
p2174
g60
(g99
S'Y\x00\x00\x00'
tRp2175
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2176
I0
sg904
S'38-maltesers.png'
p2177
sS'block_loop.thisRepN'
p2178
I0
sg907
g1494
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2179
I0
sg909
g1501
sg55
g11
sS'block_loop.thisTrial'
p2180
Nsg70
Vn
sS'block_loop.thisTrialN'
p2181
I0
sg39
F1.0330820846938877
sg34
g753
(S'\x07\xdf\x07\x0b\x10+7\x00\xb3\xb0'
tRp2182
sa(dp2183
S'trial_loop.thisTrialN'
p2184
I90
sg895
g1930
sS'block_loop.thisIndex'
p2185
g889
sg38
S'right'
p2186
sg59
g63
sS'trial_loop.thisN'
p2187
I90
sg33
g1934
sg64
g65
sS'trial_loop.thisIndex'
p2188
g60
(g99
S'Z\x00\x00\x00'
tRp2189
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2190
I0
sg904
g1938
sS'block_loop.thisRepN'
p2191
I0
sg907
g1940
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2192
I0
sg909
g1934
sg55
g11
sS'block_loop.thisTrial'
p2193
Nsg70
Vn
sS'block_loop.thisTrialN'
p2194
I0
sg39
F0.81669331396187772
sg34
g753
(S'\x07\xdf\x07\x0b\x10,\x01\x01\xc18'
tRp2195
sa(dp2196
S'trial_loop.thisTrialN'
p2197
I91
sg895
g1285
sS'block_loop.thisIndex'
p2198
g889
sg38
S'right'
p2199
sg59
g63
sS'trial_loop.thisN'
p2200
I91
sg33
g1289
sg64
g65
sS'trial_loop.thisIndex'
p2201
g60
(g99
S'[\x00\x00\x00'
tRp2202
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2203
I0
sg904
g1293
sS'block_loop.thisRepN'
p2204
I0
sg907
g1289
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2205
I0
sg909
g1296
sg55
g11
sS'block_loop.thisTrial'
p2206
Nsg70
Vn
sS'block_loop.thisTrialN'
p2207
I0
sg39
F2.6498813416110352
sg34
g753
(S'\x07\xdf\x07\x0b\x10,\x06\x0e\xb9\x88'
tRp2208
sa(dp2209
S'trial_loop.thisTrialN'
p2210
I92
sg895
g1617
sS'block_loop.thisIndex'
p2211
g889
sg38
S'right'
p2212
sg59
g63
sS'trial_loop.thisN'
p2213
I92
sg33
g1621
sg64
g65
sS'trial_loop.thisIndex'
p2214
g60
(g99
S'\\\x00\x00\x00'
tRp2215
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2216
I0
sg904
g1625
sS'block_loop.thisRepN'
p2217
I0
sg907
g1621
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2218
I0
sg909
g1628
sg55
g11
sS'block_loop.thisTrial'
p2219
Nsg70
Vn
sS'block_loop.thisTrialN'
p2220
I0
sg39
F0.93334545956167858
sg34
g753
(S'\x07\xdf\x07\x0b\x10,\x0e\n\x02\x80'
tRp2221
sa(dp2222
S'trial_loop.thisTrialN'
p2223
I93
sg895
g1837
sS'block_loop.thisIndex'
p2224
g889
sg38
S'right'
p2225
sg59
g63
sS'trial_loop.thisN'
p2226
I93
sg33
g910
sg64
g65
sS'trial_loop.thisIndex'
p2227
g60
(g99
S']\x00\x00\x00'
tRp2228
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2229
I0
sg904
g1844
sS'block_loop.thisRepN'
p2230
I0
sg907
g900
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2231
I0
sg909
g910
sg55
g11
sS'block_loop.thisTrial'
p2232
Nsg70
Vn
sS'block_loop.thisTrialN'
p2233
I0
sg39
F0.8499963507274515
sg34
g753
(S'\x07\xdf\x07\x0b\x10,\x14\tbX'
tRp2234
sa(dp2235
S'trial_loop.thisTrialN'
p2236
I94
sg895
g1354
sS'block_loop.thisIndex'
p2237
g889
sg38
S'left'
p2238
sg59
g63
sS'trial_loop.thisN'
p2239
I94
sg33
g995
sg64
g65
sS'trial_loop.thisIndex'
p2240
g60
(g99
S'^\x00\x00\x00'
tRp2241
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2242
I0
sg904
g1361
sS'block_loop.thisRepN'
p2243
I0
sg907
g988
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2244
I0
sg909
g995
sg55
g11
sS'block_loop.thisTrial'
p2245
Nsg70
Vn
sS'block_loop.thisTrialN'
p2246
I0
sg39
F1.2497673588513862
sg34
g753
(S'\x07\xdf\x07\x0b\x10,\x1a\x07\x91\x80'
tRp2247
sa(dp2248
S'trial_loop.thisTrialN'
p2249
I95
sg895
g1159
sS'block_loop.thisIndex'
p2250
g889
sg38
S'right'
p2251
sg59
g63
sS'trial_loop.thisN'
p2252
I95
sg33
g1163
sg64
g65
sS'trial_loop.thisIndex'
p2253
g60
(g99
S'_\x00\x00\x00'
tRp2254
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2255
I0
sg904
g1167
sS'block_loop.thisRepN'
p2256
I0
sg907
g1163
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2257
I0
sg909
g1170
sg55
g11
sS'block_loop.thisTrial'
p2258
Nsg70
Vn
sS'block_loop.thisTrialN'
p2259
I0
sg39
F1.1166136571737297
sg34
g753
(S'\x07\xdf\x07\x0b\x10, \x0b\xf2\x98'
tRp2260
sa(dp2261
S'trial_loop.thisTrialN'
p2262
I96
sg895
g1193
sS'block_loop.thisIndex'
p2263
g889
sg38
S'left'
p2264
sg59
g63
sS'trial_loop.thisN'
p2265
I96
sg33
g1197
sg64
g65
sS'trial_loop.thisIndex'
p2266
g60
(g99
S'`\x00\x00\x00'
tRp2267
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2268
I0
sg904
g1201
sS'block_loop.thisRepN'
p2269
I0
sg907
g1197
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2270
I0
sg909
g1204
sg55
g11
sS'block_loop.thisTrial'
p2271
Nsg70
Vn
sS'block_loop.thisTrialN'
p2272
I0
sg39
F0.98322161236501415
sg34
g753
(S'\x07\xdf\x07\x0b\x10,&\x0e,\xe8'
tRp2273
sa(dp2274
S'trial_loop.thisTrialN'
p2275
I97
sg895
S'51-mars.png'
p2276
sS'block_loop.thisIndex'
p2277
g889
sg38
S'left'
p2278
sg59
g63
sS'trial_loop.thisN'
p2279
I97
sg33
g1940
sg64
g65
sS'trial_loop.thisIndex'
p2280
g60
(g99
S'a\x00\x00\x00'
tRp2281
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2282
I0
sg904
S'27-hartleys_raspberries_jelly.png'
p2283
sS'block_loop.thisRepN'
p2284
I0
sg907
g1940
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2285
I0
sg909
g1934
sg55
g11
sS'block_loop.thisTrial'
p2286
Nsg70
Vn
sS'block_loop.thisTrialN'
p2287
I0
sg39
F1.0665846910742403
sg34
g753
(S'\x07\xdf\x07\x0b\x10,,\x0e\x82\xd8'
tRp2288
sa(dp2289
S'trial_loop.thisTrialN'
p2290
I98
sg895
g1690
sS'block_loop.thisIndex'
p2291
g889
sg38
S'right'
p2292
sg59
g63
sS'trial_loop.thisN'
p2293
I98
sg33
g1272
sg64
g65
sS'trial_loop.thisIndex'
p2294
g60
(g99
S'b\x00\x00\x00'
tRp2295
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2296
I0
sg904
g1697
sS'block_loop.thisRepN'
p2297
I0
sg907
g1272
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2298
I0
sg909
g1279
sg55
g11
sS'block_loop.thisTrial'
p2299
Nsg70
Vn
sS'block_loop.thisTrialN'
p2300
I0
sg39
F0.85003940074238926
sg34
g753
(S'\x07\xdf\x07\x0b\x10,3\x00\xc78'
tRp2301
sa(dp2302
S'trial_loop.thisTrialN'
p2303
I99
sg895
g1223
sS'block_loop.thisIndex'
p2304
g889
sg38
S'right'
p2305
sg59
g63
sS'trial_loop.thisN'
p2306
I99
sg33
g1022
sg64
g65
sS'trial_loop.thisIndex'
p2307
g60
(g99
S'c\x00\x00\x00'
tRp2308
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2309
I0
sg904
g1230
sS'block_loop.thisRepN'
p2310
I0
sg907
g1022
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2311
I0
sg909
g1029
sg55
g11
sS'block_loop.thisTrial'
p2312
Nsg70
Vn
sS'block_loop.thisTrialN'
p2313
I0
sg39
F0.79989354386634659
sg34
g753
(S'\x07\xdf\x07\x0b\x10,8\x0e8\xa0'
tRp2314
sa(dp2315
S'trial_loop.thisTrialN'
p2316
I100
sg895
g1050
sS'block_loop.thisIndex'
p2317
g889
sg38
S'right'
p2318
sg59
g63
sS'trial_loop.thisN'
p2319
I100
sg33
g1054
sg64
g65
sS'trial_loop.thisIndex'
p2320
g60
(g99
S'd\x00\x00\x00'
tRp2321
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2322
I0
sg904
g1058
sS'block_loop.thisRepN'
p2323
I0
sg907
g1054
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2324
I0
sg909
g1061
sg55
g11
sS'block_loop.thisTrial'
p2325
Nsg70
Vn
sS'block_loop.thisTrialN'
p2326
I0
sg39
F1.3664753839439072
sg34
g753
(S'\x07\xdf\x07\x0b\x10-\x02\x0b\xb00'
tRp2327
sa(dp2328
S'trial_loop.thisTrialN'
p2329
I101
sg895
g1127
sS'block_loop.thisIndex'
p2330
g889
sg38
S'left'
p2331
sg59
g63
sS'trial_loop.thisN'
p2332
I101
sg33
g1138
sg64
g65
sS'trial_loop.thisIndex'
p2333
g60
(g99
S'e\x00\x00\x00'
tRp2334
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2335
I0
sg904
g1135
sS'block_loop.thisRepN'
p2336
I0
sg907
g1131
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2337
I0
sg909
g1138
sg55
g11
sS'block_loop.thisTrial'
p2338
Nsg70
Vn
sS'block_loop.thisTrialN'
p2339
I0
sg39
F1.3999089962562721
sg34
g753
(S'\x07\xdf\x07\x0b\x10-\t\x02x\xd0'
tRp2340
sa(dp2341
S'trial_loop.thisTrialN'
p2342
I102
sg895
g1589
sS'block_loop.thisIndex'
p2343
g889
sg38
S'left'
p2344
sg59
g63
sS'trial_loop.thisN'
p2345
I102
sg33
g1163
sg64
g65
sS'trial_loop.thisIndex'
p2346
g60
(g99
S'f\x00\x00\x00'
tRp2347
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2348
I0
sg904
g1596
sS'block_loop.thisRepN'
p2349
I0
sg907
g1163
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2350
I0
sg909
g1170
sg55
g11
sS'block_loop.thisTrial'
p2351
Nsg70
Vn
sS'block_loop.thisTrialN'
p2352
I0
sg39
F0.73332538856266183
sg34
g753
(S'\x07\xdf\x07\x0b\x10-\x0f\t;H'
tRp2353
sa(dp2354
S'trial_loop.thisTrialN'
p2355
I103
sg895
g896
sS'block_loop.thisIndex'
p2356
g889
sg38
S'left'
p2357
sg59
g63
sS'trial_loop.thisN'
p2358
I103
sg33
g900
sg64
g65
sS'trial_loop.thisIndex'
p2359
g60
(g99
S'g\x00\x00\x00'
tRp2360
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2361
I0
sg904
g905
sS'block_loop.thisRepN'
p2362
I0
sg907
g900
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2363
I0
sg909
g910
sg55
g11
sS'block_loop.thisTrial'
p2364
Nsg70
Vn
sS'block_loop.thisTrialN'
p2365
I0
sg39
F1.6833143837247917
sg34
g753
(S'\x07\xdf\x07\x0b\x10-\x15\x05\x82('
tRp2366
sa(dp2367
S'trial_loop.thisTrialN'
p2368
I104
sg895
g1001
sS'block_loop.thisIndex'
p2369
g889
sg38
S'right'
p2370
sg59
g63
sS'trial_loop.thisN'
p2371
I104
sg33
g1011
sg64
g65
sS'trial_loop.thisIndex'
p2372
g60
(g99
S'h\x00\x00\x00'
tRp2373
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2374
I0
sg904
g1009
sS'block_loop.thisRepN'
p2375
I0
sg907
g1011
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2376
I0
sg909
g1005
sg55
g11
sS'block_loop.thisTrial'
p2377
Nsg70
Vn
sS'block_loop.thisTrialN'
p2378
I0
sg39
F1.8499213695722574
sg34
g753
(S'\x07\xdf\x07\x0b\x10-\x1c\x01L\x08'
tRp2379
sa(dp2380
S'trial_loop.thisTrialN'
p2381
I105
sg895
g1176
sS'block_loop.thisIndex'
p2382
g889
sg38
S'right'
p2383
sg59
g63
sS'trial_loop.thisN'
p2384
I105
sg33
g1180
sg64
g65
sS'trial_loop.thisIndex'
p2385
g60
(g99
S'i\x00\x00\x00'
tRp2386
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2387
I0
sg904
g1184
sS'block_loop.thisRepN'
p2388
I0
sg907
g1180
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2389
I0
sg909
g1187
sg55
g11
sS'block_loop.thisTrial'
p2390
Nsg70
Vn
sS'block_loop.thisTrialN'
p2391
I0
sg39
F0.81652054369624238
sg34
g753
(S'\x07\xdf\x07\x0b\x10-"\x0e\xb9\x88'
tRp2392
sa(dp2393
S'trial_loop.thisTrialN'
p2394
I106
sg895
g1354
sS'block_loop.thisIndex'
p2395
g889
sg38
S'left'
p2396
sg59
g63
sS'trial_loop.thisN'
p2397
I106
sg33
g988
sg64
g65
sS'trial_loop.thisIndex'
p2398
g60
(g99
S'j\x00\x00\x00'
tRp2399
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2400
I0
sg904
g1361
sS'block_loop.thisRepN'
p2401
I0
sg907
g988
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2402
I0
sg909
g995
sg55
g11
sS'block_loop.thisTrial'
p2403
Nsg70
Vn
sS'block_loop.thisTrialN'
p2404
I0
sg39
F0.79979404416008038
sg34
g753
(S'\x07\xdf\x07\x0b\x10-(\x0co\x98'
tRp2405
sa(dp2406
S'trial_loop.thisTrialN'
p2407
I107
sg895
g1112
sS'block_loop.thisIndex'
p2408
g889
sg38
S'left'
p2409
sg59
g63
sS'trial_loop.thisN'
p2410
I107
sg33
g1005
sg64
g65
sS'trial_loop.thisIndex'
p2411
g60
(g99
S'k\x00\x00\x00'
tRp2412
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2413
I0
sg904
g1119
sS'block_loop.thisRepN'
p2414
I0
sg907
g1011
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2415
I0
sg909
g1005
sg55
g11
sS'block_loop.thisTrial'
p2416
Nsg70
Vn
sS'block_loop.thisTrialN'
p2417
I0
sg39
F0.78307153601053869
sg34
g753
(S'\x07\xdf\x07\x0b\x10-.\t\xe7('
tRp2418
sa(dp2419
S'trial_loop.thisTrialN'
p2420
I108
sg895
g984
sS'block_loop.thisIndex'
p2421
g889
sg38
S'left'
p2422
sg59
g63
sS'trial_loop.thisN'
p2423
I108
sg33
g988
sg64
g65
sS'trial_loop.thisIndex'
p2424
g60
(g99
S'l\x00\x00\x00'
tRp2425
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2426
I0
sg904
g992
sS'block_loop.thisRepN'
p2427
I0
sg907
g988
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2428
I0
sg909
g995
sg55
g11
sS'block_loop.thisTrial'
p2429
Nsg70
Vn
sS'block_loop.thisTrialN'
p2430
I0
sg39
F3.1664855334856838
sg34
g753
(S'\x07\xdf\x07\x0b\x10-4\x07$ '
tRp2431
sa(dp2432
S'trial_loop.thisTrialN'
p2433
I109
sg895
g1159
sS'block_loop.thisIndex'
p2434
g889
sg38
S'right'
p2435
sg59
g63
sS'trial_loop.thisN'
p2436
I109
sg33
g1163
sg64
g65
sS'trial_loop.thisIndex'
p2437
g60
(g99
S'm\x00\x00\x00'
tRp2438
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2439
I0
sg904
g1167
sS'block_loop.thisRepN'
p2440
I0
sg907
g1163
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2441
I0
sg909
g1170
sg55
g11
sS'block_loop.thisTrial'
p2442
Nsg70
Vn
sS'block_loop.thisTrialN'
p2443
I0
sg39
F0.65004926518304273
sg34
g753
(S'\x07\xdf\x07\x0b\x10.\x00\nD\xe8'
tRp2444
sa(dp2445
S'trial_loop.thisTrialN'
p2446
I110
sg895
S'41-peanuts_redo.png'
p2447
sS'block_loop.thisIndex'
p2448
g889
sg38
S'left'
p2449
sg59
g63
sS'trial_loop.thisN'
p2450
I110
sg33
g1550
sg64
g65
sS'trial_loop.thisIndex'
p2451
g60
(g99
S'n\x00\x00\x00'
tRp2452
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2453
I0
sg904
S'45-chewy_nougat_redo.png'
p2454
sS'block_loop.thisRepN'
p2455
I0
sg907
g1550
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2456
I0
sg909
g1557
sg55
g11
sS'block_loop.thisTrial'
p2457
Nsg70
Vn
sS'block_loop.thisTrialN'
p2458
I0
sg39
F1.0167407545086462
sg34
g753
(S'\x07\xdf\x07\x0b\x10.\x06\x05_\x00'
tRp2459
sa(dp2460
S'trial_loop.thisTrialN'
p2461
I111
sg895
g1193
sS'block_loop.thisIndex'
p2462
g889
sg38
S'left'
p2463
sg59
g63
sS'trial_loop.thisN'
p2464
I111
sg33
g1197
sg64
g65
sS'trial_loop.thisIndex'
p2465
g60
(g99
S'o\x00\x00\x00'
tRp2466
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2467
I0
sg904
g1201
sS'block_loop.thisRepN'
p2468
I0
sg907
g1197
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2469
I0
sg909
g1204
sg55
g11
sS'block_loop.thisTrial'
p2470
Nsg70
Vn
sS'block_loop.thisTrialN'
p2471
I0
sg39
F1.5165297809217009
sg34
g753
(S'\x07\xdf\x07\x0b\x10.\x0c\x06.\x08'
tRp2472
sa(dp2473
S'trial_loop.thisTrialN'
p2474
I112
sg895
g2276
sS'block_loop.thisIndex'
p2475
g889
sg38
S'left'
p2476
sg59
g63
sS'trial_loop.thisN'
p2477
I112
sg33
g1934
sg64
g65
sS'trial_loop.thisIndex'
p2478
g60
(g99
S'p\x00\x00\x00'
tRp2479
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2480
I0
sg904
g2283
sS'block_loop.thisRepN'
p2481
I0
sg907
g1940
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2482
I0
sg909
g1934
sg55
g11
sS'block_loop.thisTrial'
p2483
Nsg70
Vn
sS'block_loop.thisTrialN'
p2484
I0
sg39
F0.7666458163948846
sg34
g753
(S'\x07\xdf\x07\x0b\x10.\x12\x0e\x9aH'
tRp2485
sa(dp2486
S'trial_loop.thisTrialN'
p2487
I113
sg895
g2170
sS'block_loop.thisIndex'
p2488
g889
sg38
S'right'
p2489
sg59
g63
sS'trial_loop.thisN'
p2490
I113
sg33
g1494
sg64
g65
sS'trial_loop.thisIndex'
p2491
g60
(g99
S'q\x00\x00\x00'
tRp2492
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2493
I0
sg904
g2177
sS'block_loop.thisRepN'
p2494
I0
sg907
g1494
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2495
I0
sg909
g1501
sg55
g11
sS'block_loop.thisTrial'
p2496
Nsg70
Vn
sS'block_loop.thisTrialN'
p2497
I0
sg39
F0.8829618297459092
sg34
g753
(S'\x07\xdf\x07\x0b\x10.\x18\x0bZ@'
tRp2498
sa(dp2499
S'trial_loop.thisTrialN'
p2500
I114
sg895
g1001
sS'block_loop.thisIndex'
p2501
g889
sg38
S'right'
p2502
sg59
g63
sS'trial_loop.thisN'
p2503
I114
sg33
g1011
sg64
g65
sS'trial_loop.thisIndex'
p2504
g60
(g99
S'r\x00\x00\x00'
tRp2505
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2506
I0
sg904
g1009
sS'block_loop.thisRepN'
p2507
I0
sg907
g1011
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2508
I0
sg909
g1005
sg55
g11
sS'block_loop.thisTrial'
p2509
Nsg70
Vn
sS'block_loop.thisTrialN'
p2510
I0
sg39
F1.1666520315629896
sg34
g753
(S'\x07\xdf\x07\x0b\x10.\x1e\nA\x00'
tRp2511
sa(dp2512
S'trial_loop.thisTrialN'
p2513
I115
sg895
g1144
sS'block_loop.thisIndex'
p2514
g889
sg38
S'left'
p2515
sg59
g63
sS'trial_loop.thisN'
p2516
I115
sg33
g944
sg64
g65
sS'trial_loop.thisIndex'
p2517
g60
(g99
S's\x00\x00\x00'
tRp2518
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2519
I0
sg904
g1151
sS'block_loop.thisRepN'
p2520
I0
sg907
g937
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2521
I0
sg909
g944
sg55
g11
sS'block_loop.thisTrial'
p2522
Nsg70
Vn
sS'block_loop.thisTrialN'
p2523
I0
sg39
F0.73320764249001513
sg34
g753
(S'\x07\xdf\x07\x0b\x10.$\r6\xd0'
tRp2524
sa(dp2525
S'trial_loop.thisTrialN'
p2526
I116
sg895
g967
sS'block_loop.thisIndex'
p2527
g889
sg38
S'right'
p2528
sg59
g63
sS'trial_loop.thisN'
p2529
I116
sg33
g971
sg64
g65
sS'trial_loop.thisIndex'
p2530
g60
(g99
S't\x00\x00\x00'
tRp2531
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2532
I0
sg904
g975
sS'block_loop.thisRepN'
p2533
I0
sg907
g971
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2534
I0
sg909
g978
sg55
g11
sS'block_loop.thisTrial'
p2535
Nsg70
Vn
sS'block_loop.thisTrialN'
p2536
I0
sg39
F0.76666491805735859
sg34
g753
(S'\x07\xdf\x07\x0b\x10.*\t\xbc0'
tRp2537
sa(dp2538
S'trial_loop.thisTrialN'
p2539
I117
sg895
g1268
sS'block_loop.thisIndex'
p2540
g889
sg38
S'left'
p2541
sg59
g63
sS'trial_loop.thisN'
p2542
I117
sg33
g1272
sg64
g65
sS'trial_loop.thisIndex'
p2543
g60
(g99
S'u\x00\x00\x00'
tRp2544
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2545
I0
sg904
g1276
sS'block_loop.thisRepN'
p2546
I0
sg907
g1272
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2547
I0
sg909
g1279
sg55
g11
sS'block_loop.thisTrial'
p2548
Nsg70
Vn
sS'block_loop.thisTrialN'
p2549
I0
sg39
F0.74990620228345506
sg34
g753
(S'\x07\xdf\x07\x0b\x10.0\x06\xba\xa8'
tRp2550
sa(dp2551
S'trial_loop.thisTrialN'
p2552
I118
sg895
g984
sS'block_loop.thisIndex'
p2553
g889
sg38
S'right'
p2554
sg59
g63
sS'trial_loop.thisN'
p2555
I118
sg33
g988
sg64
g65
sS'trial_loop.thisIndex'
p2556
g60
(g99
S'v\x00\x00\x00'
tRp2557
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2558
I0
sg904
g992
sS'block_loop.thisRepN'
p2559
I0
sg907
g988
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2560
I0
sg909
g995
sg55
g11
sS'block_loop.thisTrial'
p2561
Nsg70
Vn
sS'block_loop.thisTrialN'
p2562
I0
sg39
F1.4664597604933078
sg34
g753
(S'\x07\xdf\x07\x0b\x10.6\x03@\x08'
tRp2563
sa(dp2564
S'trial_loop.thisTrialN'
p2565
I119
sg895
g1617
sS'block_loop.thisIndex'
p2566
g889
sg38
S'right'
p2567
sg59
g63
sS'trial_loop.thisN'
p2568
I119
sg33
g1621
sg64
g65
sS'trial_loop.thisIndex'
p2569
g60
(g99
S'w\x00\x00\x00'
tRp2570
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2571
I0
sg904
g1625
sS'block_loop.thisRepN'
p2572
I0
sg907
g1621
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2573
I0
sg909
g1628
sg55
g11
sS'block_loop.thisTrial'
p2574
Nsg70
Vn
sS'block_loop.thisTrialN'
p2575
I0
sg39
F0.91656051463723998
sg34
g753
(S'\x07\xdf\x07\x0b\x10/\x00\n\xf4\xb0'
tRp2576
sa(dp2577
S'trial_loop.thisTrialN'
p2578
I120
sg895
g2170
sS'block_loop.thisIndex'
p2579
g889
sg38
S'right'
p2580
sg59
g63
sS'trial_loop.thisN'
p2581
I120
sg33
g1494
sg64
g65
sS'trial_loop.thisIndex'
p2582
g60
(g99
S'x\x00\x00\x00'
tRp2583
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2584
I0
sg904
g2177
sS'block_loop.thisRepN'
p2585
I0
sg907
g1494
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2586
I0
sg909
g1501
sg55
g11
sS'block_loop.thisTrial'
p2587
Nsg70
Vn
sS'block_loop.thisTrialN'
p2588
I0
sg39
F0.71641585517863859
sg34
g753
(S'\x07\xdf\x07\x0b\x10/\x06\n\x19\xf0'
tRp2589
sa(dp2590
S'trial_loop.thisTrialN'
p2591
I121
sg895
g1050
sS'block_loop.thisIndex'
p2592
g889
sg38
S'right'
p2593
sg59
g63
sS'trial_loop.thisN'
p2594
I121
sg33
g1054
sg64
g65
sS'trial_loop.thisIndex'
p2595
g60
(g99
S'y\x00\x00\x00'
tRp2596
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2597
I0
sg904
g1058
sS'block_loop.thisRepN'
p2598
I0
sg907
g1054
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2599
I0
sg909
g1061
sg55
g11
sS'block_loop.thisTrial'
p2600
Nsg70
Vn
sS'block_loop.thisTrialN'
p2601
I0
sg39
F0.88323409972144873
sg34
g753
(S'\x07\xdf\x07\x0b\x10/\x0c\x06`\xd0'
tRp2602
sa(dp2603
S'trial_loop.thisTrialN'
p2604
I122
sg895
g984
sS'block_loop.thisIndex'
p2605
g889
sg38
S'right'
p2606
sg59
g63
sS'trial_loop.thisN'
p2607
I122
sg33
g988
sg64
g65
sS'trial_loop.thisIndex'
p2608
g60
(g99
S'z\x00\x00\x00'
tRp2609
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2610
I0
sg904
g992
sS'block_loop.thisRepN'
p2611
I0
sg907
g988
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2612
I0
sg909
g995
sg55
g11
sS'block_loop.thisTrial'
p2613
Nsg70
Vn
sS'block_loop.thisTrialN'
p2614
I0
sg39
F0.86645143558780546
sg34
g753
(S'\x07\xdf\x07\x0b\x10/\x12\x05\t\x10'
tRp2615
sa(dp2616
S'trial_loop.thisTrialN'
p2617
I123
sg895
g1127
sS'block_loop.thisIndex'
p2618
g889
sg38
S'right'
p2619
sg59
g63
sS'trial_loop.thisN'
p2620
I123
sg33
g1131
sg64
g65
sS'trial_loop.thisIndex'
p2621
g60
(g99
S'{\x00\x00\x00'
tRp2622
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2623
I0
sg904
g1135
sS'block_loop.thisRepN'
p2624
I0
sg907
g1131
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2625
I0
sg909
g1138
sg55
g11
sS'block_loop.thisTrial'
p2626
Nsg70
Vn
sS'block_loop.thisTrialN'
p2627
I0
sg39
F1.1499021538693341
sg34
g753
(S'\x07\xdf\x07\x0b\x10/\x18\x03v\xb8'
tRp2628
sa(dp2629
S'trial_loop.thisTrialN'
p2630
I124
sg895
g1223
sS'block_loop.thisIndex'
p2631
g889
sg38
S'right'
p2632
sg59
g63
sS'trial_loop.thisN'
p2633
I124
sg33
g1022
sg64
g65
sS'trial_loop.thisIndex'
p2634
g60
(g99
S'|\x00\x00\x00'
tRp2635
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2636
I0
sg904
g1230
sS'block_loop.thisRepN'
p2637
I0
sg907
g1022
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2638
I0
sg909
g1029
sg55
g11
sS'block_loop.thisTrial'
p2639
Nsg70
Vn
sS'block_loop.thisTrialN'
p2640
I0
sg39
F0.90030499938802677
sg34
g753
(S'\x07\xdf\x07\x0b\x10/\x1e\x06h\xa0'
tRp2641
sa(dp2642
S'trial_loop.thisTrialN'
p2643
I125
sg895
g1617
sS'block_loop.thisIndex'
p2644
g889
sg38
S'right'
p2645
sg59
g63
sS'trial_loop.thisN'
p2646
I125
sg33
g1621
sg64
g65
sS'trial_loop.thisIndex'
p2647
g60
(g99
S'}\x00\x00\x00'
tRp2648
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2649
I0
sg904
g1625
sS'block_loop.thisRepN'
p2650
I0
sg907
g1621
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2651
I0
sg909
g1628
sg55
g11
sS'block_loop.thisTrial'
p2652
Nsg70
Vn
sS'block_loop.thisTrialN'
p2653
I0
sg39
F0.71668071256499388
sg34
g753
(S'\x07\xdf\x07\x0b\x10/$\x05O`'
tRp2654
sa(dp2655
S'trial_loop.thisTrialN'
p2656
I126
sg895
g967
sS'block_loop.thisIndex'
p2657
g889
sg38
S'right'
p2658
sg59
g63
sS'trial_loop.thisN'
p2659
I126
sg33
g971
sg64
g65
sS'trial_loop.thisIndex'
p2660
g60
(g99
S'~\x00\x00\x00'
tRp2661
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2662
I0
sg904
g975
sS'block_loop.thisRepN'
p2663
I0
sg907
g971
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2664
I0
sg909
g978
sg55
g11
sS'block_loop.thisTrial'
p2665
Nsg70
Vn
sS'block_loop.thisTrialN'
p2666
I0
sg39
F0.73330286570489989
sg34
g753
(S'\x07\xdf\x07\x0b\x10/*\x01\x9a('
tRp2667
sa(dp2668
S'trial_loop.thisTrialN'
p2669
I127
sg895
g1050
sS'block_loop.thisIndex'
p2670
g889
sg38
S'right'
p2671
sg59
g63
sS'trial_loop.thisN'
p2672
I127
sg33
g1054
sg64
g65
sS'trial_loop.thisIndex'
p2673
g60
(g99
S'\x7f\x00\x00\x00'
tRp2674
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2675
I0
sg904
g1058
sS'block_loop.thisRepN'
p2676
I0
sg907
g1054
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2677
I0
sg909
g1061
sg55
g11
sS'block_loop.thisTrial'
p2678
Nsg70
Vn
sS'block_loop.thisTrialN'
p2679
I0
sg39
F0.61657801974433823
sg34
g753
(S'\x07\xdf\x07\x0b\x10//\r#H'
tRp2680
sa(dp2681
S'trial_loop.thisTrialN'
p2682
I128
sg895
g1546
sS'block_loop.thisIndex'
p2683
g889
sg38
S'right'
p2684
sg59
g63
sS'trial_loop.thisN'
p2685
I128
sg33
g1550
sg64
g65
sS'trial_loop.thisIndex'
p2686
g60
(g99
S'\x80\x00\x00\x00'
tRp2687
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2688
I0
sg904
g1554
sS'block_loop.thisRepN'
p2689
I0
sg907
g1550
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2690
I0
sg909
g1557
sg55
g11
sS'block_loop.thisTrial'
p2691
Nsg70
Vn
sS'block_loop.thisTrialN'
p2692
I0
sg39
F0.7998895524724503
sg34
g753
(S'\x07\xdf\x07\x0b\x10/5\x07\xfe\xe0'
tRp2693
sa(dp2694
S'trial_loop.thisTrialN'
p2695
I129
sg895
g1035
sS'block_loop.thisIndex'
p2696
g889
sg38
S'left'
p2697
sg59
g63
sS'trial_loop.thisN'
p2698
I129
sg33
g971
sg64
g65
sS'trial_loop.thisIndex'
p2699
g60
(g99
S'\x81\x00\x00\x00'
tRp2700
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2701
I0
sg904
g1042
sS'block_loop.thisRepN'
p2702
I0
sg907
g971
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2703
I0
sg909
g978
sg55
g11
sS'block_loop.thisTrial'
p2704
Nsg70
Vn
sS'block_loop.thisTrialN'
p2705
I0
sg39
F0.73334876671651728
sg34
g753
(S'\x07\xdf\x07\x0b\x10/;\x05vp'
tRp2706
sa(dp2707
S'trial_loop.thisTrialN'
p2708
I130
sg895
g1999
sS'block_loop.thisIndex'
p2709
g889
sg38
S'right'
p2710
sg59
g63
sS'trial_loop.thisN'
p2711
I130
sg33
g1131
sg64
g65
sS'trial_loop.thisIndex'
p2712
g60
(g99
S'\x82\x00\x00\x00'
tRp2713
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2714
I0
sg904
g2006
sS'block_loop.thisRepN'
p2715
I0
sg907
g1131
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2716
I0
sg909
g1138
sg55
g11
sS'block_loop.thisTrial'
p2717
Nsg70
Vn
sS'block_loop.thisTrialN'
p2718
I0
sg39
F4.4496927768341266
sg34
g753
(S'\x07\xdf\x07\x0b\x100\x05\x01\xc18'
tRp2719
sa(dp2720
S'trial_loop.thisTrialN'
p2721
I131
sg895
g1285
sS'block_loop.thisIndex'
p2722
g889
sg38
S'left'
p2723
sg59
g63
sS'trial_loop.thisN'
p2724
I131
sg33
g1289
sg64
g65
sS'trial_loop.thisIndex'
p2725
g60
(g99
S'\x83\x00\x00\x00'
tRp2726
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2727
I0
sg904
g1293
sS'block_loop.thisRepN'
p2728
I0
sg907
g1289
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2729
I0
sg909
g1296
sg55
g11
sS'block_loop.thisTrial'
p2730
Nsg70
Vn
sS'block_loop.thisTrialN'
p2731
I0
sg39
F1.6999499365374504
sg34
g753
(S"\x07\xdf\x07\x0b\x100\x0e\t'\xc0"
tRp2732
sa(dp2733
S'trial_loop.thisTrialN'
p2734
I132
sg895
g1690
sS'block_loop.thisIndex'
p2735
g889
sg38
S'right'
p2736
sg59
g63
sS'trial_loop.thisN'
p2737
I132
sg33
g1272
sg64
g65
sS'trial_loop.thisIndex'
p2738
g60
(g99
S'\x84\x00\x00\x00'
tRp2739
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2740
I0
sg904
g1697
sS'block_loop.thisRepN'
p2741
I0
sg907
g1272
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2742
I0
sg909
g1279
sg55
g11
sS'block_loop.thisTrial'
p2743
Nsg70
Vn
sS'block_loop.thisTrialN'
p2744
I0
sg39
F0.76665037798375124
sg34
g753
(S'\x07\xdf\x07\x0b\x100\x15\x05,8'
tRp2745
sa(dp2746
S'trial_loop.thisTrialN'
p2747
I133
sg895
g896
sS'block_loop.thisIndex'
p2748
g889
sg38
S'left'
p2749
sg59
g63
sS'trial_loop.thisN'
p2750
I133
sg33
g910
sg64
g65
sS'trial_loop.thisIndex'
p2751
g60
(g99
S'\x85\x00\x00\x00'
tRp2752
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2753
I0
sg904
g905
sS'block_loop.thisRepN'
p2754
I0
sg907
g900
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2755
I0
sg909
g910
sg55
g11
sS'block_loop.thisTrial'
p2756
Nsg70
Vn
sS'block_loop.thisTrialN'
p2757
I0
sg39
F0.81666851030968246
sg34
g753
(S'\x07\xdf\x07\x0b\x100\x1b\x01\xf0\x18'
tRp2758
sa(dp2759
S'trial_loop.thisTrialN'
p2760
I134
sg895
g1112
sS'block_loop.thisIndex'
p2761
g889
sg38
S'left'
p2762
sg59
g63
sS'trial_loop.thisN'
p2763
I134
sg33
g1011
sg64
g65
sS'trial_loop.thisIndex'
p2764
g60
(g99
S'\x86\x00\x00\x00'
tRp2765
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2766
I0
sg904
g1119
sS'block_loop.thisRepN'
p2767
I0
sg907
g1011
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2768
I0
sg909
g1005
sg55
g11
sS'block_loop.thisTrial'
p2769
Nsg70
Vn
sS'block_loop.thisTrialN'
p2770
I0
sg39
F0.86654865449963836
sg34
g753
(S'\x07\xdf\x07\x0b\x100 \x0e\xe8h'
tRp2771
sa(dp2772
S'trial_loop.thisTrialN'
p2773
I135
sg895
g1193
sS'block_loop.thisIndex'
p2774
g889
sg38
S'left'
p2775
sg59
g63
sS'trial_loop.thisN'
p2776
I135
sg33
g1197
sg64
g65
sS'trial_loop.thisIndex'
p2777
g60
(g99
S'\x87\x00\x00\x00'
tRp2778
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2779
I0
sg904
g1201
sS'block_loop.thisRepN'
p2780
I0
sg907
g1197
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2781
I0
sg909
g1204
sg55
g11
sS'block_loop.thisTrial'
p2782
Nsg70
Vn
sS'block_loop.thisTrialN'
p2783
I0
sg39
F0.91665972924602102
sg34
g753
(S'\x07\xdf\x07\x0b\x100&\r\x90\xa8'
tRp2784
sa(dp2785
S'trial_loop.thisTrialN'
p2786
I136
sg895
g2170
sS'block_loop.thisIndex'
p2787
g889
sg38
S'right'
p2788
sg59
g63
sS'trial_loop.thisN'
p2789
I136
sg33
g1501
sg64
g65
sS'trial_loop.thisIndex'
p2790
g60
(g99
S'\x88\x00\x00\x00'
tRp2791
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2792
I0
sg904
g2177
sS'block_loop.thisRepN'
p2793
I0
sg907
g1494
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2794
I0
sg909
g1501
sg55
g11
sS'block_loop.thisTrial'
p2795
Nsg70
Vn
sS'block_loop.thisTrialN'
p2796
I0
sg39
F0.81615191010860144
sg34
g753
(S'\x07\xdf\x07\x0b\x100,\x0c\xb5\xe8'
tRp2797
sa(dp2798
S'trial_loop.thisTrialN'
p2799
I137
sg895
g933
sS'block_loop.thisIndex'
p2800
g889
sg38
S'right'
p2801
sg59
g63
sS'trial_loop.thisN'
p2802
I137
sg33
g937
sg64
g65
sS'trial_loop.thisIndex'
p2803
g60
(g99
S'\x89\x00\x00\x00'
tRp2804
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2805
I0
sg904
g941
sS'block_loop.thisRepN'
p2806
I0
sg907
g937
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2807
I0
sg909
g944
sg55
g11
sS'block_loop.thisTrial'
p2808
Nsg70
Vn
sS'block_loop.thisTrialN'
p2809
I0
sg39
F0.66677433922450291
sg34
g753
(S'\x07\xdf\x07\x0b\x1002\nk\xf8'
tRp2810
sa(dp2811
S'trial_loop.thisTrialN'
p2812
I138
sg895
g1253
sS'block_loop.thisIndex'
p2813
g889
sg38
S'left'
p2814
sg59
g63
sS'trial_loop.thisN'
p2815
I138
sg33
g1187
sg64
g65
sS'trial_loop.thisIndex'
p2816
g60
(g99
S'\x8a\x00\x00\x00'
tRp2817
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2818
I0
sg904
g1260
sS'block_loop.thisRepN'
p2819
I0
sg907
g1180
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2820
I0
sg909
g1187
sg55
g11
sS'block_loop.thisTrial'
p2821
Nsg70
Vn
sS'block_loop.thisTrialN'
p2822
I0
sg39
F0.73322617395388079
sg34
g753
(S'\x07\xdf\x07\x0b\x1008\x05\xc0\xa8'
tRp2823
sa(dp2824
S'trial_loop.thisTrialN'
p2825
I139
sg895
g1589
sS'block_loop.thisIndex'
p2826
g889
sg38
S'left'
p2827
sg59
g63
sS'trial_loop.thisN'
p2828
I139
sg33
g1163
sg64
g65
sS'trial_loop.thisIndex'
p2829
g60
(g99
S'\x8b\x00\x00\x00'
tRp2830
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2831
I0
sg904
g1596
sS'block_loop.thisRepN'
p2832
I0
sg907
g1163
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2833
I0
sg909
g1170
sg55
g11
sS'block_loop.thisTrial'
p2834
Nsg70
Vn
sS'block_loop.thisTrialN'
p2835
I0
sg39
F0.73318084314450971
sg34
g753
(S'\x07\xdf\x07\x0b\x101\x02\x02F\x08'
tRp2836
sa(dp2837
S'trial_loop.thisTrialN'
p2838
I140
sg895
g1546
sS'block_loop.thisIndex'
p2839
g889
sg38
S'right'
p2840
sg59
g63
sS'trial_loop.thisN'
p2841
I140
sg33
g1550
sg64
g65
sS'trial_loop.thisIndex'
p2842
g60
(g99
S'\x8c\x00\x00\x00'
tRp2843
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2844
I0
sg904
g1554
sS'block_loop.thisRepN'
p2845
I0
sg907
g1550
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2846
I0
sg909
g1557
sg55
g11
sS'block_loop.thisTrial'
p2847
Nsg70
Vn
sS'block_loop.thisTrialN'
p2848
I0
sg39
F0.70003717696818057
sg34
g753
(S'\x07\xdf\x07\x0b\x101\x07\x0e\r\xa8'
tRp2849
sa(dp2850
S'trial_loop.thisTrialN'
p2851
I141
sg895
g1144
sS'block_loop.thisIndex'
p2852
g889
sg38
S'left'
p2853
sg59
g63
sS'trial_loop.thisN'
p2854
I141
sg33
g937
sg64
g65
sS'trial_loop.thisIndex'
p2855
g60
(g99
S'\x8d\x00\x00\x00'
tRp2856
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2857
I0
sg904
g1151
sS'block_loop.thisRepN'
p2858
I0
sg907
g937
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2859
I0
sg909
g944
sg55
g11
sS'block_loop.thisTrial'
p2860
Nsg70
Vn
sS'block_loop.thisTrialN'
p2861
I0
sg39
F0.66666457593964878
sg34
g753
(S'\x07\xdf\x07\x0b\x101\r\t\xdbp'
tRp2862
sa(dp2863
S'trial_loop.thisTrialN'
p2864
I142
sg895
g1837
sS'block_loop.thisIndex'
p2865
g889
sg38
S'right'
p2866
sg59
g63
sS'trial_loop.thisN'
p2867
I142
sg33
g900
sg64
g65
sS'trial_loop.thisIndex'
p2868
g60
(g99
S'\x8e\x00\x00\x00'
tRp2869
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2870
I0
sg904
g1844
sS'block_loop.thisRepN'
p2871
I0
sg907
g900
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2872
I0
sg909
g910
sg55
g11
sS'block_loop.thisTrial'
p2873
Nsg70
Vn
sS'block_loop.thisTrialN'
p2874
I0
sg39
F0.8999064303607156
sg34
g753
(S'\x07\xdf\x07\x0b\x101\x13\x05j\xb8'
tRp2875
sa(dp2876
S'trial_loop.thisTrialN'
p2877
I143
sg895
g1159
sS'block_loop.thisIndex'
p2878
g889
sg38
S'right'
p2879
sg59
g63
sS'trial_loop.thisN'
p2880
I143
sg33
g1170
sg64
g65
sS'trial_loop.thisIndex'
p2881
g60
(g99
S'\x8f\x00\x00\x00'
tRp2882
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2883
I0
sg904
g1167
sS'block_loop.thisRepN'
p2884
I0
sg907
g1163
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2885
I0
sg909
g1170
sg55
g11
sS'block_loop.thisTrial'
p2886
Nsg70
Vn
sS'block_loop.thisTrialN'
p2887
I0
sg39
F0.61653896111965878
sg34
g753
(S'\x07\xdf\x07\x0b\x101\x19\x04Qx'
tRp2888
sa(dp2889
S'trial_loop.thisTrialN'
p2890
I144
sg895
g2447
sS'block_loop.thisIndex'
p2891
g889
sg38
S'left'
p2892
sg59
g63
sS'trial_loop.thisN'
p2893
I144
sg33
g1550
sg64
g65
sS'trial_loop.thisIndex'
p2894
g60
(g99
S'\x90\x00\x00\x00'
tRp2895
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2896
I0
sg904
g2454
sS'block_loop.thisRepN'
p2897
I0
sg907
g1550
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2898
I0
sg909
g1557
sg55
g11
sS'block_loop.thisTrial'
p2899
Nsg70
Vn
sS'block_loop.thisTrialN'
p2900
I0
sg39
F0.78333097651193384
sg34
g753
(S'\x07\xdf\x07\x0b\x101\x1e\x0e4\xb8'
tRp2901
sa(dp2902
S'trial_loop.thisTrialN'
p2903
I145
sg895
g1675
sS'block_loop.thisIndex'
p2904
g889
sg38
S'left'
p2905
sg59
g63
sS'trial_loop.thisN'
p2906
I145
sg33
g1621
sg64
g65
sS'trial_loop.thisIndex'
p2907
g60
(g99
S'\x91\x00\x00\x00'
tRp2908
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2909
I0
sg904
g1682
sS'block_loop.thisRepN'
p2910
I0
sg907
g1621
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2911
I0
sg909
g1628
sg55
g11
sS'block_loop.thisTrial'
p2912
Nsg70
Vn
sS'block_loop.thisTrialN'
p2913
I0
sg39
F0.68325137674764846
sg34
g753
(S'\x07\xdf\x07\x0b\x101$\x0bm\xc8'
tRp2914
sa(dp2915
S'trial_loop.thisTrialN'
p2916
I146
sg895
g1744
sS'block_loop.thisIndex'
p2917
g889
sg38
S'right'
p2918
sg59
g63
sS'trial_loop.thisN'
p2919
I146
sg33
g1289
sg64
g65
sS'trial_loop.thisIndex'
p2920
g60
(g99
S'\x92\x00\x00\x00'
tRp2921
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2922
I0
sg904
g1751
sS'block_loop.thisRepN'
p2923
I0
sg907
g1289
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2924
I0
sg909
g1296
sg55
g11
sS'block_loop.thisTrial'
p2925
Nsg70
Vn
sS'block_loop.thisTrialN'
p2926
I0
sg39
F0.84988915333451587
sg34
g753
(S'\x07\xdf\x07\x0b\x101*\x07\x00\xf8'
tRp2927
sa(dp2928
S'trial_loop.thisTrialN'
p2929
I147
sg895
g916
sS'block_loop.thisIndex'
p2930
g889
sg38
S'right'
p2931
sg59
g63
sS'trial_loop.thisN'
p2932
I147
sg33
g926
sg64
g65
sS'trial_loop.thisIndex'
p2933
g60
(g99
S'\x93\x00\x00\x00'
tRp2934
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2935
I0
sg904
g924
sS'block_loop.thisRepN'
p2936
I0
sg907
g926
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2937
I0
sg909
g920
sg55
g11
sS'block_loop.thisTrial'
p2938
Nsg70
Vn
sS'block_loop.thisTrialN'
p2939
I0
sg39
F0.7503643570926215
sg34
g753
(S'\x07\xdf\x07\x0b\x1010\x05n\xa0'
tRp2940
sa(dp2941
S'trial_loop.thisTrialN'
p2942
I148
sg895
g2447
sS'block_loop.thisIndex'
p2943
g889
sg38
S'left'
p2944
sg59
g63
sS'trial_loop.thisN'
p2945
I148
sg33
g1557
sg64
g65
sS'trial_loop.thisIndex'
p2946
g60
(g99
S'\x94\x00\x00\x00'
tRp2947
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2948
I0
sg904
g2454
sS'block_loop.thisRepN'
p2949
I0
sg907
g1550
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2950
I0
sg909
g1557
sg55
g11
sS'block_loop.thisTrial'
p2951
Nsg70
Vn
sS'block_loop.thisTrialN'
p2952
I0
sg39
F0.73326722827550839
sg34
g753
(S'\x07\xdf\x07\x0b\x1016\x01\xf4\x00'
tRp2953
sa(dp2954
S'trial_loop.thisTrialN'
p2955
I149
sg895
g1018
sS'block_loop.thisIndex'
p2956
g889
sg38
S'left'
p2957
sg59
g63
sS'trial_loop.thisN'
p2958
I149
sg33
g1022
sg64
g65
sS'trial_loop.thisIndex'
p2959
g60
(g99
S'\x95\x00\x00\x00'
tRp2960
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2961
I0
sg904
g1026
sS'block_loop.thisRepN'
p2962
I0
sg907
g1022
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2963
I0
sg909
g1029
sg55
g11
sS'block_loop.thisTrial'
p2964
Nsg70
Vn
sS'block_loop.thisTrialN'
p2965
I0
sg39
F0.71667215958223096
sg34
g753
(S'\x07\xdf\x07\x0b\x101;\r\xbb\xa0'
tRp2966
sa(dp2967
S'trial_loop.thisTrialN'
p2968
I150
sg895
g1067
sS'block_loop.thisIndex'
p2969
g889
sg38
S'left'
p2970
sg59
g63
sS'trial_loop.thisN'
p2971
I150
sg33
g954
sg64
g65
sS'trial_loop.thisIndex'
p2972
g60
(g99
S'\x96\x00\x00\x00'
tRp2973
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2974
I0
sg904
g1074
sS'block_loop.thisRepN'
p2975
I0
sg907
g954
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2976
I0
sg909
g961
sg55
g11
sS'block_loop.thisTrial'
p2977
Nsg70
Vn
sS'block_loop.thisTrialN'
p2978
I0
sg39
F0.61667923004642944
sg34
g753
(S'\x07\xdf\x07\x0b\x102\x05\n\x02\x80'
tRp2979
sa(dp2980
S'trial_loop.thisTrialN'
p2981
I151
sg895
g1546
sS'block_loop.thisIndex'
p2982
g889
sg38
S'right'
p2983
sg59
g63
sS'trial_loop.thisN'
p2984
I151
sg33
g1550
sg64
g65
sS'trial_loop.thisIndex'
p2985
g60
(g99
S'\x97\x00\x00\x00'
tRp2986
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p2987
I0
sg904
g1554
sS'block_loop.thisRepN'
p2988
I0
sg907
g1550
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p2989
I0
sg909
g1557
sg55
g11
sS'block_loop.thisTrial'
p2990
Nsg70
Vn
sS'block_loop.thisTrialN'
p2991
I0
sg39
F1.0498878418766253
sg34
g753
(S'\x07\xdf\x07\x0b\x102\x0b\x04\xa3\x80'
tRp2992
sa(dp2993
S'trial_loop.thisTrialN'
p2994
I152
sg895
g1112
sS'block_loop.thisIndex'
p2995
g889
sg38
S'left'
p2996
sg59
g63
sS'trial_loop.thisN'
p2997
I152
sg33
g1011
sg64
g65
sS'trial_loop.thisIndex'
p2998
g60
(g99
S'\x98\x00\x00\x00'
tRp2999
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3000
I0
sg904
g1119
sS'block_loop.thisRepN'
p3001
I0
sg907
g1011
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3002
I0
sg909
g1005
sg55
g11
sS'block_loop.thisTrial'
p3003
Nsg70
Vn
sS'block_loop.thisTrialN'
p3004
I0
sg39
F0.74996065627783537
sg34
g753
(S'\x07\xdf\x07\x0b\x102\x11\x05\xeb\xa0'
tRp3005
sa(dp3006
S'trial_loop.thisTrialN'
p3007
I153
sg895
g1268
sS'block_loop.thisIndex'
p3008
g889
sg38
S'left'
p3009
sg59
g63
sS'trial_loop.thisN'
p3010
I153
sg33
g1279
sg64
g65
sS'trial_loop.thisIndex'
p3011
g60
(g99
S'\x99\x00\x00\x00'
tRp3012
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3013
I0
sg904
g1276
sS'block_loop.thisRepN'
p3014
I0
sg907
g1272
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3015
I0
sg909
g1279
sg55
g11
sS'block_loop.thisTrial'
p3016
Nsg70
Vn
sS'block_loop.thisTrialN'
p3017
I0
sg39
F0.85035243993843324
sg34
g753
(S'\x07\xdf\x07\x0b\x102\x17\x02q\x00'
tRp3018
sa(dp3019
S'trial_loop.thisTrialN'
p3020
I154
sg895
g1930
sS'block_loop.thisIndex'
p3021
g889
sg38
S'right'
p3022
sg59
g63
sS'trial_loop.thisN'
p3023
I154
sg33
g1940
sg64
g65
sS'trial_loop.thisIndex'
p3024
g60
(g99
S'\x9a\x00\x00\x00'
tRp3025
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3026
I0
sg904
g1938
sS'block_loop.thisRepN'
p3027
I0
sg907
g1940
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3028
I0
sg909
g1934
sg55
g11
sS'block_loop.thisTrial'
p3029
Nsg70
Vn
sS'block_loop.thisTrialN'
p3030
I0
sg39
F0.71655526880931575
sg34
g753
(S'\x07\xdf\x07\x0b\x102\x1d\x00\xda\xc0'
tRp3031
sa(dp3032
S'trial_loop.thisTrialN'
p3033
I155
sg895
g1690
sS'block_loop.thisIndex'
p3034
g889
sg38
S'right'
p3035
sg59
g63
sS'trial_loop.thisN'
p3036
I155
sg33
g1272
sg64
g65
sS'trial_loop.thisIndex'
p3037
g60
(g99
S'\x9b\x00\x00\x00'
tRp3038
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3039
I0
sg904
g1697
sS'block_loop.thisRepN'
p3040
I0
sg907
g1272
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3041
I0
sg909
g1279
sg55
g11
sS'block_loop.thisTrial'
p3042
Nsg70
Vn
sS'block_loop.thisTrialN'
p3043
I0
sg39
F0.64988248200461385
sg34
g753
(S'\x07\xdf\x07\x0b\x102"\x0c)H'
tRp3044
sa(dp3045
S'trial_loop.thisTrialN'
p3046
I156
sg895
g1223
sS'block_loop.thisIndex'
p3047
g889
sg38
S'right'
p3048
sg59
g63
sS'trial_loop.thisN'
p3049
I156
sg33
g1022
sg64
g65
sS'trial_loop.thisIndex'
p3050
g60
(g99
S'\x9c\x00\x00\x00'
tRp3051
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3052
I0
sg904
g1230
sS'block_loop.thisRepN'
p3053
I0
sg907
g1022
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3054
I0
sg909
g1029
sg55
g11
sS'block_loop.thisTrial'
p3055
Nsg70
Vn
sS'block_loop.thisTrialN'
p3056
I0
sg39
F0.88325092058585142
sg34
g753
(S'\x07\xdf\x07\x0b\x102(\x07C`'
tRp3057
sa(dp3058
S'trial_loop.thisTrialN'
p3059
I157
sg895
g2276
sS'block_loop.thisIndex'
p3060
g889
sg38
S'left'
p3061
sg59
g63
sS'trial_loop.thisN'
p3062
I157
sg33
g1940
sg64
g65
sS'trial_loop.thisIndex'
p3063
g60
(g99
S'\x9d\x00\x00\x00'
tRp3064
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3065
I0
sg904
g2283
sS'block_loop.thisRepN'
p3066
I0
sg907
g1940
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3067
I0
sg909
g1934
sg55
g11
sS'block_loop.thisTrial'
p3068
Nsg70
Vn
sS'block_loop.thisTrialN'
p3069
I0
sg39
F0.79985990213026525
sg34
g753
(S'\x07\xdf\x07\x0b\x102.\x06* '
tRp3070
sa(dp3071
S'trial_loop.thisTrialN'
p3072
I158
sg895
g1999
sS'block_loop.thisIndex'
p3073
g889
sg38
S'right'
p3074
sg59
g63
sS'trial_loop.thisN'
p3075
I158
sg33
g1138
sg64
g65
sS'trial_loop.thisIndex'
p3076
g60
(g99
S'\x9e\x00\x00\x00'
tRp3077
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3078
I0
sg904
g2006
sS'block_loop.thisRepN'
p3079
I0
sg907
g1131
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3080
I0
sg909
g1138
sg55
g11
sS'block_loop.thisTrial'
p3081
Nsg70
Vn
sS'block_loop.thisTrialN'
p3082
I0
sg39
F0.91653514078643639
sg34
g753
(S'\x07\xdf\x07\x0b\x1024\x03\xa1\xb0'
tRp3083
sa(dp3084
S'trial_loop.thisTrialN'
p3085
I159
sg895
g1744
sS'block_loop.thisIndex'
p3086
g889
sg38
S'right'
p3087
sg59
g63
sS'trial_loop.thisN'
p3088
I159
sg33
g1289
sg64
g65
sS'trial_loop.thisIndex'
p3089
g60
(g99
S'\x9f\x00\x00\x00'
tRp3090
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3091
I0
sg904
g1751
sS'block_loop.thisRepN'
p3092
I0
sg907
g1289
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3093
I0
sg909
g1296
sg55
g11
sS'block_loop.thisTrial'
p3094
Nsg70
Vn
sS'block_loop.thisTrialN'
p3095
I0
sg39
F1.0166207276452042
sg34
g753
(S'\x07\xdf\x07\x0b\x102:\x02\xc6\xf0'
tRp3096
sa(dp3097
S'trial_loop.thisTrialN'
p3098
I160
sg895
g1035
sS'block_loop.thisIndex'
p3099
g889
sg38
S'left'
p3100
sg59
g63
sS'trial_loop.thisN'
p3101
I160
sg33
g971
sg64
g65
sS'trial_loop.thisIndex'
p3102
g60
(g99
S'\xa0\x00\x00\x00'
tRp3103
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3104
I0
sg904
g1042
sS'block_loop.thisRepN'
p3105
I0
sg907
g971
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3106
I0
sg909
g978
sg55
g11
sS'block_loop.thisTrial'
p3107
Nsg70
Vn
sS'block_loop.thisTrialN'
p3108
I0
sg39
F0.96658520425262395
sg34
g753
(S'\x07\xdf\x07\x0b\x103\x04\x03\x92\x10'
tRp3109
sa(dp3110
S'trial_loop.thisTrialN'
p3111
I161
sg895
g1384
sS'block_loop.thisIndex'
p3112
g889
sg38
S'left'
p3113
sg59
g63
sS'trial_loop.thisN'
p3114
I161
sg33
g1054
sg64
g65
sS'trial_loop.thisIndex'
p3115
g60
(g99
S'\xa1\x00\x00\x00'
tRp3116
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3117
I0
sg904
g1391
sS'block_loop.thisRepN'
p3118
I0
sg907
g1054
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3119
I0
sg909
g1061
sg55
g11
sS'block_loop.thisTrial'
p3120
Nsg70
Vn
sS'block_loop.thisTrialN'
p3121
I0
sg39
F0.86665471149535733
sg34
g753
(S'\x07\xdf\x07\x0b\x103\n\x03\xa9\x80'
tRp3122
sa(dp3123
S'trial_loop.thisTrialN'
p3124
I162
sg895
g1546
sS'block_loop.thisIndex'
p3125
g889
sg38
S'right'
p3126
sg59
g63
sS'trial_loop.thisN'
p3127
I162
sg33
g1557
sg64
g65
sS'trial_loop.thisIndex'
p3128
g60
(g99
S'\xa2\x00\x00\x00'
tRp3129
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3130
I0
sg904
g1554
sS'block_loop.thisRepN'
p3131
I0
sg907
g1550
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3132
I0
sg909
g1557
sg55
g11
sS'block_loop.thisTrial'
p3133
Nsg70
Vn
sS'block_loop.thisTrialN'
p3134
I0
sg39
F0.6833206559131213
sg34
g753
(S'\x07\xdf\x07\x0b\x103\x10\x02\x17('
tRp3135
sa(dp3136
S'trial_loop.thisTrialN'
p3137
I163
sg895
g1647
sS'block_loop.thisIndex'
p3138
g889
sg38
S'right'
p3139
sg59
g63
sS'trial_loop.thisN'
p3140
I163
sg33
g1197
sg64
g65
sS'trial_loop.thisIndex'
p3141
g60
(g99
S'\xa3\x00\x00\x00'
tRp3142
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3143
I0
sg904
g1654
sS'block_loop.thisRepN'
p3144
I0
sg907
g1197
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3145
I0
sg909
g1204
sg55
g11
sS'block_loop.thisTrial'
p3146
Nsg70
Vn
sS'block_loop.thisTrialN'
p3147
I0
sg39
F1.016585660410783
sg34
g753
(S'\x07\xdf\x07\x0b\x103\x15\x0c\xec\x98'
tRp3148
sa(dp3149
S'trial_loop.thisTrialN'
p3150
I164
sg895
g2170
sS'block_loop.thisIndex'
p3151
g889
sg38
S'right'
p3152
sg59
g63
sS'trial_loop.thisN'
p3153
I164
sg33
g1494
sg64
g65
sS'trial_loop.thisIndex'
p3154
g60
(g99
S'\xa4\x00\x00\x00'
tRp3155
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3156
I0
sg904
g2177
sS'block_loop.thisRepN'
p3157
I0
sg907
g1494
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3158
I0
sg909
g1501
sg55
g11
sS'block_loop.thisTrial'
p3159
Nsg70
Vn
sS'block_loop.thisTrialN'
p3160
I0
sg39
F1.3463390950018947
sg34
g753
(S'\x07\xdf\x07\x0b\x103\x1b\r\xbb\xa0'
tRp3161
sa(dp3162
S'trial_loop.thisTrialN'
p3163
I165
sg895
g2447
sS'block_loop.thisIndex'
p3164
g889
sg38
S'left'
p3165
sg59
g63
sS'trial_loop.thisN'
p3166
I165
sg33
g1550
sg64
g65
sS'trial_loop.thisIndex'
p3167
g60
(g99
S'\xa5\x00\x00\x00'
tRp3168
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3169
I0
sg904
g2454
sS'block_loop.thisRepN'
p3170
I0
sg907
g1550
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3171
I0
sg909
g1557
sg55
g11
sS'block_loop.thisTrial'
p3172
Nsg70
Vn
sS'block_loop.thisTrialN'
p3173
I0
sg39
F0.91653884707920952
sg34
g753
(S'\x07\xdf\x07\x0b\x103"\x06.\x08'
tRp3174
sa(dp3175
S'trial_loop.thisTrialN'
p3176
I166
sg895
g1223
sS'block_loop.thisIndex'
p3177
g889
sg38
S'right'
p3178
sg59
g63
sS'trial_loop.thisN'
p3179
I166
sg33
g1022
sg64
g65
sS'trial_loop.thisIndex'
p3180
g60
(g99
S'\xa6\x00\x00\x00'
tRp3181
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3182
I0
sg904
g1230
sS'block_loop.thisRepN'
p3183
I0
sg907
g1022
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3184
I0
sg909
g1029
sg55
g11
sS'block_loop.thisTrial'
p3185
Nsg70
Vn
sS'block_loop.thisTrialN'
p3186
I0
sg39
F0.66664775506797014
sg34
g753
(S'\x07\xdf\x07\x0b\x103(\x05O`'
tRp3187
sa(dp3188
S'trial_loop.thisTrialN'
p3189
I167
sg895
g1095
sS'block_loop.thisIndex'
p3190
g889
sg38
S'left'
p3191
sg59
g63
sS'trial_loop.thisN'
p3192
I167
sg33
g1099
sg64
g65
sS'trial_loop.thisIndex'
p3193
g60
(g99
S'\xa7\x00\x00\x00'
tRp3194
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3195
I0
sg904
g1103
sS'block_loop.thisRepN'
p3196
I0
sg907
g1099
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3197
I0
sg909
g1106
sg55
g11
sS'block_loop.thisTrial'
p3198
Nsg70
Vn
sS'block_loop.thisTrialN'
p3199
I0
sg39
F1.5332177920281538
sg34
g753
(S'\x07\xdf\x07\x0b\x103.\x00\xa4\x10'
tRp3200
sa(dp3201
S'trial_loop.thisTrialN'
p3202
I168
sg895
g1675
sS'block_loop.thisIndex'
p3203
g889
sg38
S'left'
p3204
sg59
g63
sS'trial_loop.thisN'
p3205
I168
sg33
g1621
sg64
g65
sS'trial_loop.thisIndex'
p3206
g60
(g99
S'\xa8\x00\x00\x00'
tRp3207
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3208
I0
sg904
g1682
sS'block_loop.thisRepN'
p3209
I0
sg907
g1621
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3210
I0
sg909
g1628
sg55
g11
sS'block_loop.thisTrial'
p3211
Nsg70
Vn
sS'block_loop.thisTrialN'
p3212
I0
sg39
F0.63323609541475889
sg34
g753
(S'\x07\xdf\x07\x0b\x1034\tN\xd0'
tRp3213
sa(dp3214
S'trial_loop.thisTrialN'
p3215
I169
sg895
g1268
sS'block_loop.thisIndex'
p3216
g889
sg38
S'left'
p3217
sg59
g63
sS'trial_loop.thisN'
p3218
I169
sg33
g1279
sg64
g65
sS'trial_loop.thisIndex'
p3219
g60
(g99
S'\xa9\x00\x00\x00'
tRp3220
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3221
I0
sg904
g1276
sS'block_loop.thisRepN'
p3222
I0
sg907
g1272
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3223
I0
sg909
g1279
sg55
g11
sS'block_loop.thisTrial'
p3224
Nsg70
Vn
sS'block_loop.thisTrialN'
p3225
I0
sg39
F0.63321670865116175
sg34
g753
(S'\x07\xdf\x07\x0b\x103:\x04h\xe8'
tRp3226
sa(dp3227
S'trial_loop.thisTrialN'
p3228
I170
sg895
g2447
sS'block_loop.thisIndex'
p3229
g889
sg38
S'left'
p3230
sg59
g63
sS'trial_loop.thisN'
p3231
I170
sg33
g1550
sg64
g65
sS'trial_loop.thisIndex'
p3232
g60
(g99
S'\xaa\x00\x00\x00'
tRp3233
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3234
I0
sg904
g2454
sS'block_loop.thisRepN'
p3235
I0
sg907
g1550
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3236
I0
sg909
g1557
sg55
g11
sS'block_loop.thisTrial'
p3237
Nsg70
Vn
sS'block_loop.thisTrialN'
p3238
I0
sg39
F0.73322816965082893
sg34
g753
(S'\x07\xdf\x07\x0b\x104\x03\x0e\x82\xd8'
tRp3239
sa(dp3240
S'trial_loop.thisTrialN'
p3241
I171
sg895
g1095
sS'block_loop.thisIndex'
p3242
g889
sg38
S'left'
p3243
sg59
g63
sS'trial_loop.thisN'
p3244
I171
sg33
g1099
sg64
g65
sS'trial_loop.thisIndex'
p3245
g60
(g99
S'\xab\x00\x00\x00'
tRp3246
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3247
I0
sg904
g1103
sS'block_loop.thisRepN'
p3248
I0
sg907
g1099
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3249
I0
sg909
g1106
sg55
g11
sS'block_loop.thisTrial'
p3250
Nsg70
Vn
sS'block_loop.thisTrialN'
p3251
I0
sg39
F1.3833167785596743
sg34
g753
(S'\x07\xdf\x07\x0b\x104\t\n\xcd\xa0'
tRp3252
sa(dp3253
S'trial_loop.thisTrialN'
p3254
I172
sg895
g916
sS'block_loop.thisIndex'
p3255
g889
sg38
S'right'
p3256
sg59
g63
sS'trial_loop.thisN'
p3257
I172
sg33
g926
sg64
g65
sS'trial_loop.thisIndex'
p3258
g60
(g99
S'\xac\x00\x00\x00'
tRp3259
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3260
I0
sg904
g924
sS'block_loop.thisRepN'
p3261
I0
sg907
g926
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3262
I0
sg909
g920
sg55
g11
sS'block_loop.thisTrial'
p3263
Nsg70
Vn
sS'block_loop.thisTrialN'
p3264
I0
sg39
F0.64996544594396255
sg34
g753
(S'\x07\xdf\x07\x0b\x104\x10\x02\x0fX'
tRp3265
sa(dp3266
S'trial_loop.thisTrialN'
p3267
I173
sg895
g1354
sS'block_loop.thisIndex'
p3268
g889
sg38
S'left'
p3269
sg59
g63
sS'trial_loop.thisN'
p3270
I173
sg33
g988
sg64
g65
sS'trial_loop.thisIndex'
p3271
g60
(g99
S'\xad\x00\x00\x00'
tRp3272
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3273
I0
sg904
g1361
sS'block_loop.thisRepN'
p3274
I0
sg907
g988
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3275
I0
sg909
g995
sg55
g11
sS'block_loop.thisTrial'
p3276
Nsg70
Vn
sS'block_loop.thisTrialN'
p3277
I0
sg39
F0.69974609043129021
sg34
g753
(S'\x07\xdf\x07\x0b\x104\x15\x0cg\xc8'
tRp3278
sa(dp3279
S'trial_loop.thisTrialN'
p3280
I174
sg895
g1067
sS'block_loop.thisIndex'
p3281
g889
sg38
S'left'
p3282
sg59
g63
sS'trial_loop.thisN'
p3283
I174
sg33
g954
sg64
g65
sS'trial_loop.thisIndex'
p3284
g60
(g99
S'\xae\x00\x00\x00'
tRp3285
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3286
I0
sg904
g1074
sS'block_loop.thisRepN'
p3287
I0
sg907
g954
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3288
I0
sg909
g961
sg55
g11
sS'block_loop.thisTrial'
p3289
Nsg70
Vn
sS'block_loop.thisTrialN'
p3290
I0
sg39
F0.63325063548472826
sg34
g753
(S'\x07\xdf\x07\x0b\x104\x1b\x08t\x10'
tRp3291
sa(dp3292
S'trial_loop.thisTrialN'
p3293
I175
sg895
g1999
sS'block_loop.thisIndex'
p3294
g889
sg38
S'right'
p3295
sg59
g63
sS'trial_loop.thisN'
p3296
I175
sg33
g1131
sg64
g65
sS'trial_loop.thisIndex'
p3297
g60
(g99
S'\xaf\x00\x00\x00'
tRp3298
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3299
I0
sg904
g2006
sS'block_loop.thisRepN'
p3300
I0
sg907
g1131
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3301
I0
sg909
g1138
sg55
g11
sS'block_loop.thisTrial'
p3302
Nsg70
Vn
sS'block_loop.thisTrialN'
p3303
I0
sg39
F1.8833430077065714
sg34
g753
(S'\x07\xdf\x07\x0b\x104!\x03O\xa8'
tRp3304
sa(dp3305
S'trial_loop.thisTrialN'
p3306
I176
sg895
g1490
sS'block_loop.thisIndex'
p3307
g889
sg38
S'left'
p3308
sg59
g63
sS'trial_loop.thisN'
p3309
I176
sg33
g1494
sg64
g65
sS'trial_loop.thisIndex'
p3310
g60
(g99
S'\xb0\x00\x00\x00'
tRp3311
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3312
I0
sg904
g1498
sS'block_loop.thisRepN'
p3313
I0
sg907
g1494
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3314
I0
sg909
g1501
sg55
g11
sS'block_loop.thisTrial'
p3315
Nsg70
Vn
sS'block_loop.thisTrialN'
p3316
I0
sg39
F0.84959749659901718
sg34
g753
(S'\x07\xdf\x07\x0b\x104(\x01\xf4\x00'
tRp3317
sa(dp3318
S'trial_loop.thisTrialN'
p3319
I177
sg895
g1176
sS'block_loop.thisIndex'
p3320
g889
sg38
S'right'
p3321
sg59
g63
sS'trial_loop.thisN'
p3322
I177
sg33
g1180
sg64
g65
sS'trial_loop.thisIndex'
p3323
g60
(g99
S'\xb1\x00\x00\x00'
tRp3324
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3325
I0
sg904
g1184
sS'block_loop.thisRepN'
p3326
I0
sg907
g1180
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3327
I0
sg909
g1187
sg55
g11
sS'block_loop.thisTrial'
p3328
Nsg70
Vn
sS'block_loop.thisTrialN'
p3329
I0
sg39
F0.66658104179805377
sg34
g753
(S'\x07\xdf\x07\x0b\x104.\x00#('
tRp3330
sa(dp3331
S'trial_loop.thisTrialN'
p3332
I178
sg895
g1285
sS'block_loop.thisIndex'
p3333
g889
sg38
S'left'
p3334
sg59
g63
sS'trial_loop.thisN'
p3335
I178
sg33
g1296
sg64
g65
sS'trial_loop.thisIndex'
p3336
g60
(g99
S'\xb2\x00\x00\x00'
tRp3337
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3338
I0
sg904
g1293
sS'block_loop.thisRepN'
p3339
I0
sg907
g1289
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3340
I0
sg909
g1296
sg55
g11
sS'block_loop.thisTrial'
p3341
Nsg70
Vn
sS'block_loop.thisTrialN'
p3342
I0
sg39
F0.79987529749996611
sg34
g753
(S'\x07\xdf\x07\x0b\x1043\n\xf8\x98'
tRp3343
sa(dp3344
S'trial_loop.thisTrialN'
p3345
I179
sg895
g1930
sS'block_loop.thisIndex'
p3346
g889
sg38
S'right'
p3347
sg59
g63
sS'trial_loop.thisN'
p3348
I179
sg33
g1934
sg64
g65
sS'trial_loop.thisIndex'
p3349
g60
(g99
S'\xb3\x00\x00\x00'
tRp3350
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3351
I0
sg904
g1938
sS'block_loop.thisRepN'
p3352
I0
sg907
g1940
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3353
I0
sg909
g1934
sg55
g11
sS'block_loop.thisTrial'
p3354
Nsg70
Vn
sS'block_loop.thisTrialN'
p3355
I0
sg39
F1.6332859878202726
sg34
g753
(S'\x07\xdf\x07\x0b\x1049\x08p('
tRp3356
sa(dp3357
S'trial_loop.thisTrialN'
p3358
I180
sg895
g1193
sS'block_loop.thisIndex'
p3359
g889
sg38
S'left'
p3360
sg59
g63
sS'trial_loop.thisN'
p3361
I180
sg33
g1197
sg64
g65
sS'trial_loop.thisIndex'
p3362
g60
(g99
S'\xb4\x00\x00\x00'
tRp3363
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3364
I0
sg904
g1201
sS'block_loop.thisRepN'
p3365
I0
sg907
g1197
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3366
I0
sg909
g1204
sg55
g11
sS'block_loop.thisTrial'
p3367
Nsg70
Vn
sS'block_loop.thisTrialN'
p3368
I0
sg39
F0.63334386300630285
sg34
g753
(S'\x07\xdf\x07\x0b\x105\x04\x03C\xf0'
tRp3369
sa(dp3370
S'trial_loop.thisTrialN'
p3371
I181
sg895
g2276
sS'block_loop.thisIndex'
p3372
g889
sg38
S'left'
p3373
sg59
g63
sS'trial_loop.thisN'
p3374
I181
sg33
g1934
sg64
g65
sS'trial_loop.thisIndex'
p3375
g60
(g99
S'\xb5\x00\x00\x00'
tRp3376
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3377
I0
sg904
g2283
sS'block_loop.thisRepN'
p3378
I0
sg907
g1940
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3379
I0
sg909
g1934
sg55
g11
sS'block_loop.thisTrial'
p3380
Nsg70
Vn
sS'block_loop.thisTrialN'
p3381
I0
sg39
F0.95037815590694663
sg34
g753
(S'\x07\xdf\x07\x0b\x105\t\ra\xc8'
tRp3382
sa(dp3383
S'trial_loop.thisTrialN'
p3384
I182
sg895
g916
sS'block_loop.thisIndex'
p3385
g889
sg38
S'right'
p3386
sg59
g63
sS'trial_loop.thisN'
p3387
I182
sg33
g926
sg64
g65
sS'trial_loop.thisIndex'
p3388
g60
(g99
S'\xb6\x00\x00\x00'
tRp3389
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3390
I0
sg904
g924
sS'block_loop.thisRepN'
p3391
I0
sg907
g926
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3392
I0
sg909
g920
sg55
g11
sS'block_loop.thisTrial'
p3393
Nsg70
Vn
sS'block_loop.thisTrialN'
p3394
I0
sg39
F0.59999464012798853
sg34
g753
(S'\x07\xdf\x07\x0b\x105\x0f\r:\xb8'
tRp3395
sa(dp3396
S'trial_loop.thisTrialN'
p3397
I183
sg895
g1675
sS'block_loop.thisIndex'
p3398
g889
sg38
S'left'
p3399
sg59
g63
sS'trial_loop.thisN'
p3400
I183
sg33
g1628
sg64
g65
sS'trial_loop.thisIndex'
p3401
g60
(g99
S'\xb7\x00\x00\x00'
tRp3402
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3403
I0
sg904
g1682
sS'block_loop.thisRepN'
p3404
I0
sg907
g1621
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3405
I0
sg909
g1628
sg55
g11
sS'block_loop.thisTrial'
p3406
Nsg70
Vn
sS'block_loop.thisTrialN'
p3407
I0
sg39
F0.66654682986336411
sg34
g753
(S'\x07\xdf\x07\x0b\x105\x15\x07\x9d8'
tRp3408
sa(dp3409
S'trial_loop.thisTrialN'
p3410
I184
sg895
g1369
sS'block_loop.thisIndex'
p3411
g889
sg38
S'left'
p3412
sg59
g63
sS'trial_loop.thisN'
p3413
I184
sg33
g1106
sg64
g65
sS'trial_loop.thisIndex'
p3414
g60
(g99
S'\xb8\x00\x00\x00'
tRp3415
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3416
I0
sg904
g1376
sS'block_loop.thisRepN'
p3417
I0
sg907
g1099
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3418
I0
sg909
g1106
sg55
g11
sS'block_loop.thisTrial'
p3419
Nsg70
Vn
sS'block_loop.thisTrialN'
p3420
I0
sg39
F1.2665588610616396
sg34
g753
(S'\x07\xdf\x07\x0b\x105\x1b\x02\xf1\xe8'
tRp3421
sa(dp3422
S'trial_loop.thisTrialN'
p3423
I185
sg895
g1675
sS'block_loop.thisIndex'
p3424
g889
sg38
S'left'
p3425
sg59
g63
sS'trial_loop.thisN'
p3426
I185
sg33
g1628
sg64
g65
sS'trial_loop.thisIndex'
p3427
g60
(g99
S'\xb9\x00\x00\x00'
tRp3428
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3429
I0
sg904
g1682
sS'block_loop.thisRepN'
p3430
I0
sg907
g1621
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3431
I0
sg909
g1628
sg55
g11
sS'block_loop.thisTrial'
p3432
Nsg70
Vn
sS'block_loop.thisTrialN'
p3433
I0
sg39
F0.63331079146882985
sg34
g753
(S'\x07\xdf\x07\x0b\x105!\x07\x8d\x98'
tRp3434
sa(dp3435
S'trial_loop.thisTrialN'
p3436
I186
sg895
g1035
sS'block_loop.thisIndex'
p3437
g889
sg38
S'left'
p3438
sg59
g63
sS'trial_loop.thisN'
p3439
I186
sg33
g971
sg64
g65
sS'trial_loop.thisIndex'
p3440
g60
(g99
S'\xba\x00\x00\x00'
tRp3441
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3442
I0
sg904
g1042
sS'block_loop.thisRepN'
p3443
I0
sg907
g971
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3444
I0
sg909
g978
sg55
g11
sS'block_loop.thisTrial'
p3445
Nsg70
Vn
sS'block_loop.thisTrialN'
p3446
I0
sg39
F0.7831787334071123
sg34
g753
(S"\x07\xdf\x07\x0b\x105'\x02i0"
tRp3447
sa(dp3448
S'trial_loop.thisTrialN'
p3449
I187
sg895
g1589
sS'block_loop.thisIndex'
p3450
g889
sg38
S'left'
p3451
sg59
g63
sS'trial_loop.thisN'
p3452
I187
sg33
g1170
sg64
g65
sS'trial_loop.thisIndex'
p3453
g60
(g99
S'\xbb\x00\x00\x00'
tRp3454
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3455
I0
sg904
g1596
sS'block_loop.thisRepN'
p3456
I0
sg907
g1163
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3457
I0
sg909
g1170
sg55
g11
sS'block_loop.thisTrial'
p3458
Nsg70
Vn
sS'block_loop.thisTrialN'
p3459
I0
sg39
F0.75017020437007886
sg34
g753
(S'\x07\xdf\x07\x0b\x105,\x0e\xe8h'
tRp3460
sa(dp3461
S'trial_loop.thisTrialN'
p3462
I188
sg895
g1127
sS'block_loop.thisIndex'
p3463
g889
sg38
S'left'
p3464
sg59
g63
sS'trial_loop.thisN'
p3465
I188
sg33
g1131
sg64
g65
sS'trial_loop.thisIndex'
p3466
g60
(g99
S'\xbc\x00\x00\x00'
tRp3467
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3468
I0
sg904
g1135
sS'block_loop.thisRepN'
p3469
I0
sg907
g1131
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3470
I0
sg909
g1138
sg55
g11
sS'block_loop.thisTrial'
p3471
Nsg70
Vn
sS'block_loop.thisTrialN'
p3472
I0
sg39
F0.73336644288428943
sg34
g753
(S'\x07\xdf\x07\x0b\x1052\x0b\xacH'
tRp3473
sa(dp3474
S'trial_loop.thisTrialN'
p3475
I189
sg895
g1930
sS'block_loop.thisIndex'
p3476
g889
sg38
S'right'
p3477
sg59
g63
sS'trial_loop.thisN'
p3478
I189
sg33
g1934
sg64
g65
sS'trial_loop.thisIndex'
p3479
g60
(g99
S'\xbd\x00\x00\x00'
tRp3480
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3481
I0
sg904
g1938
sS'block_loop.thisRepN'
p3482
I0
sg907
g1940
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3483
I0
sg909
g1934
sg55
g11
sS'block_loop.thisTrial'
p3484
Nsg70
Vn
sS'block_loop.thisTrialN'
p3485
I0
sg39
F0.8666059594906983
sg34
g753
(S'\x07\xdf\x07\x0b\x1058\x081\xa8'
tRp3486
sa(dp3487
S'trial_loop.thisTrialN'
p3488
I190
sg895
g916
sS'block_loop.thisIndex'
p3489
g889
sg38
S'right'
p3490
sg59
g63
sS'trial_loop.thisN'
p3491
I190
sg33
g926
sg64
g65
sS'trial_loop.thisIndex'
p3492
g60
(g99
S'\xbe\x00\x00\x00'
tRp3493
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3494
I0
sg904
g924
sS'block_loop.thisRepN'
p3495
I0
sg907
g926
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3496
I0
sg909
g920
sg55
g11
sS'block_loop.thisTrial'
p3497
Nsg70
Vn
sS'block_loop.thisTrialN'
p3498
I0
sg39
F0.68322343699765042
sg34
g753
(S'\x07\xdf\x07\x0b\x106\x02\x06\x9fP'
tRp3499
sa(dp3500
S'trial_loop.thisTrialN'
p3501
I191
sg895
g950
sS'block_loop.thisIndex'
p3502
g889
sg38
S'right'
p3503
sg59
g63
sS'trial_loop.thisN'
p3504
I191
sg33
g954
sg64
g65
sS'trial_loop.thisIndex'
p3505
g60
(g99
S'\xbf\x00\x00\x00'
tRp3506
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3507
I0
sg904
g958
sS'block_loop.thisRepN'
p3508
I0
sg907
g954
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3509
I0
sg909
g961
sg55
g11
sS'block_loop.thisTrial'
p3510
Nsg70
Vn
sS'block_loop.thisTrialN'
p3511
I0
sg39
F0.58324761343101272
sg34
g753
(S'\x07\xdf\x07\x0b\x106\x08\x02\xe60'
tRp3512
sa(dp3513
S'trial_loop.thisTrialN'
p3514
I192
sg895
g1744
sS'block_loop.thisIndex'
p3515
g889
sg38
S'right'
p3516
sg59
g63
sS'trial_loop.thisN'
p3517
I192
sg33
g1296
sg64
g65
sS'trial_loop.thisIndex'
p3518
g60
(g99
S'\xc0\x00\x00\x00'
tRp3519
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3520
I0
sg904
g1751
sS'block_loop.thisRepN'
p3521
I0
sg907
g1289
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3522
I0
sg909
g1296
sg55
g11
sS'block_loop.thisTrial'
p3523
Nsg70
Vn
sS'block_loop.thisTrialN'
p3524
I0
sg39
F0.86652328065247275
sg34
g753
(S'\x07\xdf\x07\x0b\x106\r\x0c\r\xf0'
tRp3525
sa(dp3526
S'trial_loop.thisTrialN'
p3527
I193
sg895
g1837
sS'block_loop.thisIndex'
p3528
g889
sg38
S'right'
p3529
sg59
g63
sS'trial_loop.thisN'
p3530
I193
sg33
g900
sg64
g65
sS'trial_loop.thisIndex'
p3531
g60
(g99
S'\xc1\x00\x00\x00'
tRp3532
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3533
I0
sg904
g1844
sS'block_loop.thisRepN'
p3534
I0
sg907
g900
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3535
I0
sg909
g910
sg55
g11
sS'block_loop.thisTrial'
p3536
Nsg70
Vn
sS'block_loop.thisTrialN'
p3537
I0
sg39
F0.85038494127729791
sg34
g753
(S'\x07\xdf\x07\x0b\x106\x13\n\xba\x18'
tRp3538
sa(dp3539
S'trial_loop.thisTrialN'
p3540
I194
sg895
g1127
sS'block_loop.thisIndex'
p3541
g889
sg38
S'left'
p3542
sg59
g63
sS'trial_loop.thisN'
p3543
I194
sg33
g1131
sg64
g65
sS'trial_loop.thisIndex'
p3544
g60
(g99
S'\xc2\x00\x00\x00'
tRp3545
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3546
I0
sg904
g1135
sS'block_loop.thisRepN'
p3547
I0
sg907
g1131
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3548
I0
sg909
g1138
sg55
g11
sS'block_loop.thisTrial'
p3549
Nsg70
Vn
sS'block_loop.thisTrialN'
p3550
I0
sg39
F0.66664404877883499
sg34
g753
(S'\x07\xdf\x07\x0b\x106\x19\x08\xe9@'
tRp3551
sa(dp3552
S'trial_loop.thisTrialN'
p3553
I195
sg895
g1647
sS'block_loop.thisIndex'
p3554
g889
sg38
S'right'
p3555
sg59
g63
sS'trial_loop.thisN'
p3556
I195
sg33
g1204
sg64
g65
sS'trial_loop.thisIndex'
p3557
g60
(g99
S'\xc3\x00\x00\x00'
tRp3558
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3559
I0
sg904
g1654
sS'block_loop.thisRepN'
p3560
I0
sg907
g1197
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3561
I0
sg909
g1204
sg55
g11
sS'block_loop.thisTrial'
p3562
Nsg70
Vn
sS'block_loop.thisTrialN'
p3563
I0
sg39
F0.78322634501455468
sg34
g753
(S'\x07\xdf\x07\x0b\x106\x1f\x04=\xf0'
tRp3564
sa(dp3565
S'trial_loop.thisTrialN'
p3566
I196
sg895
g1490
sS'block_loop.thisIndex'
p3567
g889
sg38
S'left'
p3568
sg59
g63
sS'trial_loop.thisN'
p3569
I196
sg33
g1494
sg64
g65
sS'trial_loop.thisIndex'
p3570
g60
(g99
S'\xc4\x00\x00\x00'
tRp3571
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3572
I0
sg904
g1498
sS'block_loop.thisRepN'
p3573
I0
sg907
g1494
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3574
I0
sg909
g1501
sg55
g11
sS'block_loop.thisTrial'
p3575
Nsg70
Vn
sS'block_loop.thisTrialN'
p3576
I0
sg39
F0.66625830922203022
sg34
g753
(S'\x07\xdf\x07\x0b\x106%\x01z\xe8'
tRp3577
sa(dp3578
S'trial_loop.thisTrialN'
p3579
I197
sg895
g967
sS'block_loop.thisIndex'
p3580
g889
sg38
S'right'
p3581
sg59
g63
sS'trial_loop.thisN'
p3582
I197
sg33
g971
sg64
g65
sS'trial_loop.thisIndex'
p3583
g60
(g99
S'\xc5\x00\x00\x00'
tRp3584
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3585
I0
sg904
g975
sS'block_loop.thisRepN'
p3586
I0
sg907
g971
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3587
I0
sg909
g978
sg55
g11
sS'block_loop.thisTrial'
p3588
Nsg70
Vn
sS'block_loop.thisTrialN'
p3589
I0
sg39
F0.69993482626887271
sg34
g753
(S'\x07\xdf\x07\x0b\x106*\x0c\x11\xd8'
tRp3590
sa(dp3591
S'trial_loop.thisTrialN'
p3592
I198
sg895
g1176
sS'block_loop.thisIndex'
p3593
g889
sg38
S'right'
p3594
sg59
g63
sS'trial_loop.thisN'
p3595
I198
sg33
g1180
sg64
g65
sS'trial_loop.thisIndex'
p3596
g60
(g99
S'\xc6\x00\x00\x00'
tRp3597
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3598
I0
sg904
g1184
sS'block_loop.thisRepN'
p3599
I0
sg907
g1180
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3600
I0
sg909
g1187
sg55
g11
sS'block_loop.thisTrial'
p3601
Nsg70
Vn
sS'block_loop.thisTrialN'
p3602
I0
sg39
F0.81663258777916781
sg34
g753
(S'\x07\xdf\x07\x0b\x1060\x08\x1e '
tRp3603
sa(dp3604
S'trial_loop.thisTrialN'
p3605
I199
sg895
g2276
sS'block_loop.thisIndex'
p3606
g889
sg38
S'left'
p3607
sg59
g63
sS'trial_loop.thisN'
p3608
I199
sg33
g1940
sg64
g65
sS'trial_loop.thisIndex'
p3609
g60
(g99
S'\xc7\x00\x00\x00'
tRp3610
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3611
I0
sg904
g2283
sS'block_loop.thisRepN'
p3612
I0
sg907
g1940
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3613
I0
sg909
g1934
sg55
g11
sS'block_loop.thisTrial'
p3614
Nsg70
Vn
sS'block_loop.thisTrialN'
p3615
I0
sg39
F1.033649432592938
sg34
g753
(S'\x07\xdf\x07\x0b\x1066\x05\xd40'
tRp3616
sa(dp3617
S'block_loop.thisRepN'
p3618
I0
sg55
g11
sg41
F141.63051909767091
sg56
g57
sS'block_loop.thisIndex'
p3619
g889
sg58
Vy
sg59
g63
sS'block_loop.thisN'
p3620
I0
sg40
S'space'
p3621
sg64
g65
sS'block_loop.thisTrial'
p3622
Nsg66
g67
sg68
g69
sS'block_loop.thisTrialN'
p3623
I0
sg70
Vn
sa(dp3624
S'block_loop.thisRepN'
p3625
I1
sg56
g57
sS'block_loop.thisIndex'
p3626
g60
(g99
S'\x00\x00\x00\x00'
tRp3627
sg58
Vy
sg59
g63
sS'block_loop.thisN'
p3628
I1
sg37
Nsg55
g11
sg64
g65
sS'block_loop.thisTrial'
p3629
Nsg66
g67
sg68
g69
sS'block_loop.thisTrialN'
p3630
I0
sg70
Vn
sa(dp3631
S'trial_loop.thisTrialN'
p3632
I0
sS'img_left'
p3633
S'44-crunch.png'
p3634
sS'block_loop.thisIndex'
p3635
g3627
sg38
S'right'
p3636
sg59
g63
sS'trial_loop.thisN'
p3637
I0
sg33
S'26-walkers_smoky_bacon.png'
p3638
sg64
g65
sS'trial_loop.thisIndex'
p3639
g60
(g99
S'\x00\x00\x00\x00'
tRp3640
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3641
I0
sS'img_right'
p3642
S'26-walkers_smoky_bacon.png'
p3643
sS'block_loop.thisRepN'
p3644
I1
sS'img_correct'
p3645
g3638
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3646
I1
sS'img_wrong'
p3647
S'44-crunch.png'
p3648
sg55
g11
sS'block_loop.thisTrial'
p3649
Nsg70
Vn
sS'block_loop.thisTrialN'
p3650
I0
sg39
F0.76653519780666102
sg34
g753
(S'\x07\xdf\x07\x0b\x10;\x1c\x0bF\xb8'
tRp3651
sa(dp3652
S'trial_loop.thisTrialN'
p3653
I1
sg3633
S'35-raisins.png'
p3654
sS'block_loop.thisIndex'
p3655
g3627
sg38
S'left'
p3656
sg59
g63
sS'trial_loop.thisN'
p3657
I1
sg33
S'35-raisins.png'
p3658
sg64
g65
sS'trial_loop.thisIndex'
p3659
g60
(g99
S'\x01\x00\x00\x00'
tRp3660
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3661
I0
sg3642
S'49-yorkie.png'
p3662
sS'block_loop.thisRepN'
p3663
I1
sg3645
g3658
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3664
I1
sg3647
S'49-yorkie.png'
p3665
sg55
g11
sS'block_loop.thisTrial'
p3666
Nsg70
Vn
sS'block_loop.thisTrialN'
p3667
I0
sg39
F0.78318015890181414
sg34
g753
(S'\x07\xdf\x07\x0b\x10;"\x08\n\x98'
tRp3668
sa(dp3669
S'trial_loop.thisTrialN'
p3670
I2
sg3633
S'38-maltesers.png'
p3671
sS'block_loop.thisIndex'
p3672
g3627
sg38
S'left'
p3673
sg59
g63
sS'trial_loop.thisN'
p3674
I2
sg33
S'38-maltesers.png'
p3675
sg64
g65
sS'trial_loop.thisIndex'
p3676
g60
(g99
S'\x02\x00\x00\x00'
tRp3677
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3678
I0
sg3642
S'6-sour_patch_kids.png'
p3679
sS'block_loop.thisRepN'
p3680
I1
sg3645
g3675
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3681
I1
sg3647
S'6-sour_patch_kids.png'
p3682
sg55
g11
sS'block_loop.thisTrial'
p3683
Nsg70
Vn
sS'block_loop.thisTrialN'
p3684
I0
sg39
F0.63305505726748379
sg34
g753
(S'\x07\xdf\x07\x0b\x10;(\x05G\x90'
tRp3685
sa(dp3686
S'trial_loop.thisTrialN'
p3687
I3
sg3633
S'17-jacobs_mini_cheddars_redo.png'
p3688
sS'block_loop.thisIndex'
p3689
g3627
sg38
S'left'
p3690
sg59
g63
sS'trial_loop.thisN'
p3691
I3
sg33
S'17-jacobs_mini_cheddars_redo.png'
p3692
sg64
g65
sS'trial_loop.thisIndex'
p3693
g60
(g99
S'\x03\x00\x00\x00'
tRp3694
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3695
I0
sg3642
S'8-liquorice_catherine_wheels.png'
p3696
sS'block_loop.thisRepN'
p3697
I1
sg3645
g3692
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3698
I1
sg3647
S'8-liquorice_catherine_wheels.png'
p3699
sg55
g11
sS'block_loop.thisTrial'
p3700
Nsg70
Vn
sS'block_loop.thisTrialN'
p3701
I0
sg39
F0.76658223921913304
sg34
g753
(S'\x07\xdf\x07\x0b\x10;.\x00#('
tRp3702
sa(dp3703
S'trial_loop.thisTrialN'
p3704
I4
sg3633
S'18-mms.png'
p3705
sS'block_loop.thisIndex'
p3706
g3627
sg38
S'left'
p3707
sg59
g63
sS'trial_loop.thisN'
p3708
I4
sg33
S'43-mrporky_pork_crackles_redo.png'
p3709
sg64
g65
sS'trial_loop.thisIndex'
p3710
g60
(g99
S'\x04\x00\x00\x00'
tRp3711
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3712
I0
sg3642
S'43-mrporky_pork_crackles_redo.png'
p3713
sS'block_loop.thisRepN'
p3714
I1
sg3645
g3709
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3715
I1
sg3647
S'18-mms.png'
p3716
sg55
g11
sS'block_loop.thisTrial'
p3717
Nsg70
Vn
sS'block_loop.thisTrialN'
p3718
I0
sg39
F0.54987558260108926
sg34
g753
(S'\x07\xdf\x07\x0b\x10;3\x0cc\xe0'
tRp3719
sa(dp3720
S'trial_loop.thisTrialN'
p3721
I5
sg3633
S'2-steamed_puddings.png'
p3722
sS'block_loop.thisIndex'
p3723
g3627
sg38
S'left'
p3724
sg59
g63
sS'trial_loop.thisN'
p3725
I5
sg33
S'2-steamed_puddings.png'
p3726
sg64
g65
sS'trial_loop.thisIndex'
p3727
g60
(g99
S'\x05\x00\x00\x00'
tRp3728
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3729
I0
sg3642
S'20-fruit_pastilles.png'
p3730
sS'block_loop.thisRepN'
p3731
I1
sg3645
g3726
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3732
I1
sg3647
S'20-fruit_pastilles.png'
p3733
sg55
g11
sS'block_loop.thisTrial'
p3734
Nsg70
Vn
sS'block_loop.thisTrialN'
p3735
I0
sg39
F0.61676960657496238
sg34
g753
(S'\x07\xdf\x07\x0b\x10;9\x06\x0e\xc8'
tRp3736
sa(dp3737
S'trial_loop.thisTrialN'
p3738
I6
sg3633
S'8-liquorice_catherine_wheels.png'
p3739
sS'block_loop.thisIndex'
p3740
g3627
sg38
S'right'
p3741
sg59
g63
sS'trial_loop.thisN'
p3742
I6
sg33
g3692
sg64
g65
sS'trial_loop.thisIndex'
p3743
g60
(g99
S'\x06\x00\x00\x00'
tRp3744
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3745
I0
sg3642
S'17-jacobs_mini_cheddars_redo.png'
p3746
sS'block_loop.thisRepN'
p3747
I1
sg3645
g3692
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3748
I1
sg3647
g3699
sg55
g11
sS'block_loop.thisTrial'
p3749
Nsg70
Vn
sS'block_loop.thisTrialN'
p3750
I0
sg39
F0.68323256017902168
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x00\x03\x00\xab\xe0'
tRp3751
sa(dp3752
S'trial_loop.thisTrialN'
p3753
I7
sg3633
g3671
sS'block_loop.thisIndex'
p3754
g3627
sg38
S'left'
p3755
sg59
g63
sS'trial_loop.thisN'
p3756
I7
sg33
g3675
sg64
g65
sS'trial_loop.thisIndex'
p3757
g60
(g99
S'\x07\x00\x00\x00'
tRp3758
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3759
I0
sg3642
g3679
sS'block_loop.thisRepN'
p3760
I1
sg3645
g3675
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3761
I1
sg3647
g3682
sg55
g11
sS'block_loop.thisTrial'
p3762
Nsg70
Vn
sS'block_loop.thisTrialN'
p3763
I0
sg39
F0.6829280739693786
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x00\x08\x0b}h'
tRp3764
sa(dp3765
S'trial_loop.thisTrialN'
p3766
I8
sg3633
S'5-pineapple.png'
p3767
sS'block_loop.thisIndex'
p3768
g3627
sg38
S'right'
p3769
sg59
g63
sS'trial_loop.thisN'
p3770
I8
sg33
S'5-pineapple.png'
p3771
sg64
g65
sS'trial_loop.thisIndex'
p3772
g60
(g99
S'\x08\x00\x00\x00'
tRp3773
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3774
I0
sg3642
S'40-sardines.png'
p3775
sS'block_loop.thisRepN'
p3776
I1
sg3645
S'40-sardines.png'
p3777
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3778
I1
sg3647
g3771
sg55
g11
sS'block_loop.thisTrial'
p3779
Nsg70
Vn
sS'block_loop.thisTrialN'
p3780
I0
sg39
F0.74990050029373378
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x00\x0e\x07O\x18'
tRp3781
sa(dp3782
S'trial_loop.thisTrialN'
p3783
I9
sg3633
S'30-spaghetti_hoops.png'
p3784
sS'block_loop.thisIndex'
p3785
g3627
sg38
S'left'
p3786
sg59
g63
sS'trial_loop.thisN'
p3787
I9
sg33
S'30-spaghetti_hoops.png'
p3788
sg64
g65
sS'trial_loop.thisIndex'
p3789
g60
(g99
S'\t\x00\x00\x00'
tRp3790
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3791
I0
sg3642
S'19-caramello_redo.png'
p3792
sS'block_loop.thisRepN'
p3793
I1
sg3645
g3788
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3794
I1
sg3647
S'19-caramello_redo.png'
p3795
sg55
g11
sS'block_loop.thisTrial'
p3796
Nsg70
Vn
sS'block_loop.thisTrialN'
p3797
I0
sg39
F1.3331809001610964
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x00\x14\x04\x0f\x10'
tRp3798
sa(dp3799
S'trial_loop.thisTrialN'
p3800
I10
sg3633
S'33-ambrosia_rice.png'
p3801
sS'block_loop.thisIndex'
p3802
g3627
sg38
S'right'
p3803
sg59
g63
sS'trial_loop.thisN'
p3804
I10
sg33
S'23-crunchie_redo.png'
p3805
sg64
g65
sS'trial_loop.thisIndex'
p3806
g60
(g99
S'\n\x00\x00\x00'
tRp3807
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3808
I0
sg3642
S'23-crunchie_redo.png'
p3809
sS'block_loop.thisRepN'
p3810
I1
sg3645
g3805
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3811
I1
sg3647
S'33-ambrosia_rice.png'
p3812
sg55
g11
sS'block_loop.thisTrial'
p3813
Nsg70
Vn
sS'block_loop.thisTrialN'
p3814
I0
sg39
F0.66656365073140478
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x00\x1a\t\xa0\xd8'
tRp3815
sa(dp3816
S'trial_loop.thisTrialN'
p3817
I11
sg3633
S'49-yorkie.png'
p3818
sS'block_loop.thisIndex'
p3819
g3627
sg38
S'right'
p3820
sg59
g63
sS'trial_loop.thisN'
p3821
I11
sg33
g3658
sg64
g65
sS'trial_loop.thisIndex'
p3822
g60
(g99
S'\x0b\x00\x00\x00'
tRp3823
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3824
I0
sg3642
S'35-raisins.png'
p3825
sS'block_loop.thisRepN'
p3826
I1
sg3645
g3658
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3827
I1
sg3647
g3665
sg55
g11
sS'block_loop.thisTrial'
p3828
Nsg70
Vn
sS'block_loop.thisTrialN'
p3829
I0
sg39
F0.78335321426857263
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x00 \x04\xf5\x88'
tRp3830
sa(dp3831
S'trial_loop.thisTrialN'
p3832
I12
sg3633
S'13-mccoys_steak_crisps.png'
p3833
sS'block_loop.thisIndex'
p3834
g3627
sg38
S'left'
p3835
sg59
g63
sS'trial_loop.thisN'
p3836
I12
sg33
S'3-ellas_strawberries_apples.png'
p3837
sg64
g65
sS'trial_loop.thisIndex'
p3838
g60
(g99
S'\x0c\x00\x00\x00'
tRp3839
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3840
I0
sg3642
S'3-ellas_strawberries_apples.png'
p3841
sS'block_loop.thisRepN'
p3842
I1
sg3645
g3837
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3843
I1
sg3647
S'13-mccoys_steak_crisps.png'
p3844
sg55
g11
sS'block_loop.thisTrial'
p3845
Nsg70
Vn
sS'block_loop.thisTrialN'
p3846
I0
sg39
F0.69987809147278313
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x00&\x022\x80'
tRp3847
sa(dp3848
S'trial_loop.thisTrialN'
p3849
I13
sg3633
S'21-nakd_banana_crunch.png'
p3850
sS'block_loop.thisIndex'
p3851
g3627
sg38
S'right'
p3852
sg59
g63
sS'trial_loop.thisN'
p3853
I13
sg33
S'1-treacle_cookies.png'
p3854
sg64
g65
sS'trial_loop.thisIndex'
p3855
g60
(g99
S'\r\x00\x00\x00'
tRp3856
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3857
I0
sg3642
S'1-treacle_cookies.png'
p3858
sS'block_loop.thisRepN'
p3859
I1
sg3645
g3854
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3860
I1
sg3647
S'21-nakd_banana_crunch.png'
p3861
sg55
g11
sS'block_loop.thisTrial'
p3862
Nsg70
Vn
sS'block_loop.thisTrialN'
p3863
I0
sg39
F1.2165321757529455
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x00+\r\x81\x08'
tRp3864
sa(dp3865
S'trial_loop.thisTrialN'
p3866
I14
sg3633
S'27-hartleys_raspberries_jelly.png'
p3867
sS'block_loop.thisIndex'
p3868
g3627
sg38
S'right'
p3869
sg59
g63
sS'trial_loop.thisN'
p3870
I14
sg33
S'27-hartleys_raspberries_jelly.png'
p3871
sg64
g65
sS'trial_loop.thisIndex'
p3872
g60
(g99
S'\x0e\x00\x00\x00'
tRp3873
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3874
I0
sg3642
S'51-mars.png'
p3875
sS'block_loop.thisRepN'
p3876
I1
sg3645
g3871
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3877
I1
sg3647
S'51-mars.png'
p3878
sg55
g11
sS'block_loop.thisTrial'
p3879
Nsg70
Vn
sS'block_loop.thisTrialN'
p3880
I0
sg39
F0.74983977410738589
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x002\x01\xe8H'
tRp3881
sa(dp3882
S'trial_loop.thisTrialN'
p3883
I15
sg3633
S'48-twix.png'
p3884
sS'block_loop.thisIndex'
p3885
g3627
sg38
S'left'
p3886
sg59
g63
sS'trial_loop.thisN'
p3887
I15
sg33
S'48-twix.png'
p3888
sg64
g65
sS'trial_loop.thisIndex'
p3889
g60
(g99
S'\x0f\x00\x00\x00'
tRp3890
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3891
I0
sg3642
S'50-polo.png'
p3892
sS'block_loop.thisRepN'
p3893
I1
sg3645
g3888
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3894
I1
sg3647
S'50-polo.png'
p3895
sg55
g11
sS'block_loop.thisTrial'
p3896
Nsg70
Vn
sS'block_loop.thisTrialN'
p3897
I0
sg39
F0.71659774862928316
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x007\r\xea\x80'
tRp3898
sa(dp3899
S'trial_loop.thisTrialN'
p3900
I16
sg3633
S'23-crunchie_redo.png'
p3901
sS'block_loop.thisIndex'
p3902
g3627
sg38
S'left'
p3903
sg59
g63
sS'trial_loop.thisN'
p3904
I16
sg33
g3812
sg64
g65
sS'trial_loop.thisIndex'
p3905
g60
(g99
S'\x10\x00\x00\x00'
tRp3906
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3907
I0
sg3642
S'33-ambrosia_rice.png'
p3908
sS'block_loop.thisRepN'
p3909
I1
sg3645
g3805
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3910
I1
sg3647
g3812
sg55
g11
sS'block_loop.thisTrial'
p3911
Nsg70
Vn
sS'block_loop.thisTrialN'
p3912
I0
sg39
F1.0499736568090157
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x01\x01\t\xf6\xc8'
tRp3913
sa(dp3914
S'trial_loop.thisTrialN'
p3915
I17
sg3633
S'43-mrporky_pork_crackles_redo.png'
p3916
sS'block_loop.thisIndex'
p3917
g3627
sg38
S'left'
p3918
sg59
g63
sS'trial_loop.thisN'
p3919
I17
sg33
g3709
sg64
g65
sS'trial_loop.thisIndex'
p3920
g60
(g99
S'\x11\x00\x00\x00'
tRp3921
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3922
I0
sg3642
S'18-mms.png'
p3923
sS'block_loop.thisRepN'
p3924
I1
sg3645
g3709
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3925
I1
sg3647
g3716
sg55
g11
sS'block_loop.thisTrial'
p3926
Nsg70
Vn
sS'block_loop.thisTrialN'
p3927
I0
sg39
F0.71691791530611226
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x01\x07\x0b>\xe8'
tRp3928
sa(dp3929
S'trial_loop.thisTrialN'
p3930
I18
sg3633
S'26-walkers_smoky_bacon.png'
p3931
sS'block_loop.thisIndex'
p3932
g3627
sg38
S'left'
p3933
sg59
g63
sS'trial_loop.thisN'
p3934
I18
sg33
g3638
sg64
g65
sS'trial_loop.thisIndex'
p3935
g60
(g99
S'\x12\x00\x00\x00'
tRp3936
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3937
I0
sg3642
S'44-crunch.png'
p3938
sS'block_loop.thisRepN'
p3939
I1
sg3645
g3638
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3940
I1
sg3647
g3648
sg55
g11
sS'block_loop.thisTrial'
p3941
Nsg70
Vn
sS'block_loop.thisTrialN'
p3942
I0
sg39
F1.0499271855987899
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x01\r\x07\x85\xc8'
tRp3943
sa(dp3944
S'trial_loop.thisTrialN'
p3945
I19
sg3633
S'36-fig_rolls.png'
p3946
sS'block_loop.thisIndex'
p3947
g3627
sg38
S'right'
p3948
sg59
g63
sS'trial_loop.thisN'
p3949
I19
sg33
S'36-fig_rolls.png'
p3950
sg64
g65
sS'trial_loop.thisIndex'
p3951
g60
(g99
S'\x13\x00\x00\x00'
tRp3952
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3953
I0
sg3642
S'34-hula_hoops_bbq_beef_redo.png'
p3954
sS'block_loop.thisRepN'
p3955
I1
sg3645
S'34-hula_hoops_bbq_beef_redo.png'
p3956
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3957
I1
sg3647
g3950
sg55
g11
sS'block_loop.thisTrial'
p3958
Nsg70
Vn
sS'block_loop.thisTrialN'
p3959
I0
sg39
F0.66658873948472319
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x01\x13\x08\xcd\xe8'
tRp3960
sa(dp3961
S'trial_loop.thisTrialN'
p3962
I20
sg3633
g3767
sS'block_loop.thisIndex'
p3963
g3627
sg38
S'right'
p3964
sg59
g63
sS'trial_loop.thisN'
p3965
I20
sg33
g3777
sg64
g65
sS'trial_loop.thisIndex'
p3966
g60
(g99
S'\x14\x00\x00\x00'
tRp3967
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3968
I0
sg3642
g3775
sS'block_loop.thisRepN'
p3969
I1
sg3645
g3777
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3970
I1
sg3647
g3771
sg55
g11
sS'block_loop.thisTrial'
p3971
Nsg70
Vn
sS'block_loop.thisTrialN'
p3972
I0
sg39
F0.74971290485336795
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x01\x19\x04&\x80'
tRp3973
sa(dp3974
S'trial_loop.thisTrialN'
p3975
I21
sg3633
S'34-hula_hoops_bbq_beef_redo.png'
p3976
sS'block_loop.thisIndex'
p3977
g3627
sg38
S'left'
p3978
sg59
g63
sS'trial_loop.thisN'
p3979
I21
sg33
g3956
sg64
g65
sS'trial_loop.thisIndex'
p3980
g60
(g99
S'\x15\x00\x00\x00'
tRp3981
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3982
I0
sg3642
S'36-fig_rolls.png'
p3983
sS'block_loop.thisRepN'
p3984
I1
sg3645
g3956
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3985
I1
sg3647
g3950
sg55
g11
sS'block_loop.thisTrial'
p3986
Nsg70
Vn
sS'block_loop.thisTrialN'
p3987
I0
sg39
F1.4331926462582487
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x01\x1f\x00\xe6x'
tRp3988
sa(dp3989
S'trial_loop.thisTrialN'
p3990
I22
sg3633
g3784
sS'block_loop.thisIndex'
p3991
g3627
sg38
S'left'
p3992
sg59
g63
sS'trial_loop.thisN'
p3993
I22
sg33
g3795
sg64
g65
sS'trial_loop.thisIndex'
p3994
g60
(g99
S'\x16\x00\x00\x00'
tRp3995
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p3996
I0
sg3642
g3792
sS'block_loop.thisRepN'
p3997
I1
sg3645
g3788
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p3998
I1
sg3647
g3795
sg55
g11
sS'block_loop.thisTrial'
p3999
Nsg70
Vn
sS'block_loop.thisTrialN'
p4000
I0
sg39
F1.2833326871077588
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x01%\x08"\x08'
tRp4001
sa(dp4002
S'trial_loop.thisTrialN'
p4003
I23
sg3633
S'10-bounty_redo.png'
p4004
sS'block_loop.thisIndex'
p4005
g3627
sg38
S'right'
p4006
sg59
g63
sS'trial_loop.thisN'
p4007
I23
sg33
S'4-corn.png'
p4008
sg64
g65
sS'trial_loop.thisIndex'
p4009
g60
(g99
S'\x17\x00\x00\x00'
tRp4010
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4011
I0
sg3642
S'4-corn.png'
p4012
sS'block_loop.thisRepN'
p4013
I1
sg3645
g4008
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4014
I1
sg3647
S'10-bounty_redo.png'
p4015
sg55
g11
sS'block_loop.thisTrial'
p4016
Nsg70
Vn
sS'block_loop.thisTrialN'
p4017
I0
sg39
F0.6331987473895424
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x01+\x0c\xfc8'
tRp4018
sa(dp4019
S'trial_loop.thisTrialN'
p4020
I24
sg3633
g3818
sS'block_loop.thisIndex'
p4021
g3627
sg38
S'right'
p4022
sg59
g63
sS'trial_loop.thisN'
p4023
I24
sg33
g3658
sg64
g65
sS'trial_loop.thisIndex'
p4024
g60
(g99
S'\x18\x00\x00\x00'
tRp4025
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4026
I0
sg3642
g3825
sS'block_loop.thisRepN'
p4027
I1
sg3645
g3658
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4028
I1
sg3647
g3665
sg55
g11
sS'block_loop.thisTrial'
p4029
Nsg70
Vn
sS'block_loop.thisTrialN'
p4030
I0
sg39
F0.84990996559645282
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x011\x07\xd7\xd0'
tRp4031
sa(dp4032
S'trial_loop.thisTrialN'
p4033
I25
sg3633
g3767
sS'block_loop.thisIndex'
p4034
g3627
sg38
S'right'
p4035
sg59
g63
sS'trial_loop.thisN'
p4036
I25
sg33
g3777
sg64
g65
sS'trial_loop.thisIndex'
p4037
g60
(g99
S'\x19\x00\x00\x00'
tRp4038
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4039
I0
sg3642
g3775
sS'block_loop.thisRepN'
p4040
I1
sg3645
g3777
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4041
I1
sg3647
g3771
sg55
g11
sS'block_loop.thisTrial'
p4042
Nsg70
Vn
sS'block_loop.thisTrialN'
p4043
I0
sg39
F0.69988379346614238
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x017\x06\x06\xf8'
tRp4044
sa(dp4045
S'trial_loop.thisTrialN'
p4046
I26
sg3633
g3833
sS'block_loop.thisIndex'
p4047
g3627
sg38
S'right'
p4048
sg59
g63
sS'trial_loop.thisN'
p4049
I26
sg33
g3837
sg64
g65
sS'trial_loop.thisIndex'
p4050
g60
(g99
S'\x1a\x00\x00\x00'
tRp4051
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4052
I0
sg3642
g3841
sS'block_loop.thisRepN'
p4053
I1
sg3645
g3837
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4054
I1
sg3647
g3844
sg55
g11
sS'block_loop.thisTrial'
p4055
Nsg70
Vn
sS'block_loop.thisTrialN'
p4056
I0
sg39
F0.9666741552791791
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x02\x01\x01\xd4\xc0'
tRp4057
sa(dp4058
S'trial_loop.thisTrialN'
p4059
I27
sg3633
g3818
sS'block_loop.thisIndex'
p4060
g3627
sg38
S'right'
p4061
sg59
g63
sS'trial_loop.thisN'
p4062
I27
sg33
g3658
sg64
g65
sS'trial_loop.thisIndex'
p4063
g60
(g99
S'\x1b\x00\x00\x00'
tRp4064
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4065
I0
sg3642
g3825
sS'block_loop.thisRepN'
p4066
I1
sg3645
g3658
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4067
I1
sg3647
g3665
sg55
g11
sS'block_loop.thisTrial'
p4068
Nsg70
Vn
sS'block_loop.thisTrialN'
p4069
I0
sg39
F0.6165948406123789
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x02\x07\x01\xec0'
tRp4070
sa(dp4071
S'trial_loop.thisTrialN'
p4072
I28
sg3633
g3916
sS'block_loop.thisIndex'
p4073
g3627
sg38
S'left'
p4074
sg59
g63
sS'trial_loop.thisN'
p4075
I28
sg33
g3709
sg64
g65
sS'trial_loop.thisIndex'
p4076
g60
(g99
S'\x1c\x00\x00\x00'
tRp4077
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4078
I0
sg3642
g3923
sS'block_loop.thisRepN'
p4079
I1
sg3645
g3709
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4080
I1
sg3647
g3716
sg55
g11
sS'block_loop.thisTrial'
p4081
Nsg70
Vn
sS'block_loop.thisTrialN'
p4082
I0
sg39
F0.78378513993084198
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x02\x0c\x0b\xcfp'
tRp4083
sa(dp4084
S'trial_loop.thisTrialN'
p4085
I29
sg3633
S'42-mrkipling_lemon_slices.png'
p4086
sS'block_loop.thisIndex'
p4087
g3627
sg38
S'right'
p4088
sg59
g63
sS'trial_loop.thisN'
p4089
I29
sg33
S'16-skips_prawn.png'
p4090
sg64
g65
sS'trial_loop.thisIndex'
p4091
g60
(g99
S'\x1d\x00\x00\x00'
tRp4092
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4093
I0
sg3642
S'16-skips_prawn.png'
p4094
sS'block_loop.thisRepN'
p4095
I1
sg3645
g4090
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4096
I1
sg3647
S'42-mrkipling_lemon_slices.png'
p4097
sg55
g11
sS'block_loop.thisTrial'
p4098
Nsg70
Vn
sS'block_loop.thisTrialN'
p4099
I0
sg39
F0.79992861109712976
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x02\x12\t\x08\x80'
tRp4100
sa(dp4101
S'trial_loop.thisTrialN'
p4102
I30
sg3633
S'51-mars.png'
p4103
sS'block_loop.thisIndex'
p4104
g3627
sg38
S'left'
p4105
sg59
g63
sS'trial_loop.thisN'
p4106
I30
sg33
g3871
sg64
g65
sS'trial_loop.thisIndex'
p4107
g60
(g99
S'\x1e\x00\x00\x00'
tRp4108
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4109
I0
sg3642
S'27-hartleys_raspberries_jelly.png'
p4110
sS'block_loop.thisRepN'
p4111
I1
sg3645
g3871
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4112
I1
sg3647
g3878
sg55
g11
sS'block_loop.thisTrial'
p4113
Nsg70
Vn
sS'block_loop.thisTrialN'
p4114
I0
sg39
F1.0332004009651428
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x02\x18\x06\x83\xf8'
tRp4115
sa(dp4116
S'trial_loop.thisTrialN'
p4117
I31
sg3633
S'45-chewy_nougat_redo.png'
p4118
sS'block_loop.thisIndex'
p4119
g3627
sg38
S'right'
p4120
sg59
g63
sS'trial_loop.thisN'
p4121
I31
sg33
S'41-peanuts_redo.png'
p4122
sg64
g65
sS'trial_loop.thisIndex'
p4123
g60
(g99
S'\x1f\x00\x00\x00'
tRp4124
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4125
I0
sg3642
S'41-peanuts_redo.png'
p4126
sS'block_loop.thisRepN'
p4127
I1
sg3645
g4122
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4128
I1
sg3647
S'45-chewy_nougat_redo.png'
p4129
sg55
g11
sS'block_loop.thisTrial'
p4130
Nsg70
Vn
sS'block_loop.thisTrialN'
p4131
I0
sg39
F0.61656975186269847
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x02\x1e\x07\x8d\x98'
tRp4132
sa(dp4133
S'trial_loop.thisTrialN'
p4134
I32
sg3633
g3976
sS'block_loop.thisIndex'
p4135
g3627
sg38
S'left'
p4136
sg59
g63
sS'trial_loop.thisN'
p4137
I32
sg33
g3950
sg64
g65
sS'trial_loop.thisIndex'
p4138
g60
(g99
S' \x00\x00\x00'
tRp4139
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4140
I0
sg3642
g3983
sS'block_loop.thisRepN'
p4141
I1
sg3645
g3956
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4142
I1
sg3647
g3950
sg55
g11
sS'block_loop.thisTrial'
p4143
Nsg70
Vn
sS'block_loop.thisTrialN'
p4144
I0
sg39
F0.8832187043481099
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x02$\x02*\xb0'
tRp4145
sa(dp4146
S'trial_loop.thisTrialN'
p4147
I33
sg3633
S'40-sardines.png'
p4148
sS'block_loop.thisIndex'
p4149
g3627
sg38
S'left'
p4150
sg59
g63
sS'trial_loop.thisN'
p4151
I33
sg33
g3777
sg64
g65
sS'trial_loop.thisIndex'
p4152
g60
(g99
S'!\x00\x00\x00'
tRp4153
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4154
I0
sg3642
S'5-pineapple.png'
p4155
sS'block_loop.thisRepN'
p4156
I1
sg3645
g3777
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4157
I1
sg3647
g3771
sg55
g11
sS'block_loop.thisTrial'
p4158
Nsg70
Vn
sS'block_loop.thisTrialN'
p4159
I0
sg39
F0.73321419977946789
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x02*\x00\xd6\xd8'
tRp4160
sa(dp4161
S'trial_loop.thisTrialN'
p4162
I34
sg3633
S'25-kitkat.png'
p4163
sS'block_loop.thisIndex'
p4164
g3627
sg38
S'right'
p4165
sg59
g63
sS'trial_loop.thisN'
p4166
I34
sg33
S'31-hobnobs.png'
p4167
sg64
g65
sS'trial_loop.thisIndex'
p4168
g60
(g99
S'"\x00\x00\x00'
tRp4169
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4170
I0
sg3642
S'31-hobnobs.png'
p4171
sS'block_loop.thisRepN'
p4172
I1
sg3645
g4167
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4173
I1
sg3647
S'25-kitkat.png'
p4174
sg55
g11
sS'block_loop.thisTrial'
p4175
Nsg70
Vn
sS'block_loop.thisTrialN'
p4176
I0
sg39
F0.81703600349646877
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x02/\x0c\x9ex'
tRp4177
sa(dp4178
S'trial_loop.thisTrialN'
p4179
I35
sg3633
g3901
sS'block_loop.thisIndex'
p4180
g3627
sg38
S'left'
p4181
sg59
g63
sS'trial_loop.thisN'
p4182
I35
sg33
g3805
sg64
g65
sS'trial_loop.thisIndex'
p4183
g60
(g99
S'#\x00\x00\x00'
tRp4184
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4185
I0
sg3642
g3908
sS'block_loop.thisRepN'
p4186
I1
sg3645
g3805
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4187
I1
sg3647
g3812
sg55
g11
sS'block_loop.thisTrial'
p4188
Nsg70
Vn
sS'block_loop.thisTrialN'
p4189
I0
sg39
F4.1998216417850927
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x025\nT\x88'
tRp4190
sa(dp4191
S'trial_loop.thisTrialN'
p4192
I36
sg3633
S'50-polo.png'
p4193
sS'block_loop.thisIndex'
p4194
g3627
sg38
S'right'
p4195
sg59
g63
sS'trial_loop.thisN'
p4196
I36
sg33
g3888
sg64
g65
sS'trial_loop.thisIndex'
p4197
g60
(g99
S'$\x00\x00\x00'
tRp4198
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4199
I0
sg3642
S'48-twix.png'
p4200
sS'block_loop.thisRepN'
p4201
I1
sg3645
g3888
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4202
I1
sg3647
g3895
sg55
g11
sS'block_loop.thisTrial'
p4203
Nsg70
Vn
sS'block_loop.thisTrialN'
p4204
I0
sg39
F0.86655321609214297
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x03\x02\r\xea\x80'
tRp4205
sa(dp4206
S'trial_loop.thisTrialN'
p4207
I37
sg3633
g3634
sS'block_loop.thisIndex'
p4208
g3627
sg38
S'right'
p4209
sg59
g63
sS'trial_loop.thisN'
p4210
I37
sg33
g3648
sg64
g65
sS'trial_loop.thisIndex'
p4211
g60
(g99
S'%\x00\x00\x00'
tRp4212
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4213
I0
sg3642
g3643
sS'block_loop.thisRepN'
p4214
I1
sg3645
g3638
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4215
I1
sg3647
g3648
sg55
g11
sS'block_loop.thisTrial'
p4216
Nsg70
Vn
sS'block_loop.thisTrialN'
p4217
I0
sg39
F0.74988054333152832
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x03\x08\x0cX('
tRp4218
sa(dp4219
S'trial_loop.thisTrialN'
p4220
I38
sg3633
g3901
sS'block_loop.thisIndex'
p4221
g3627
sg38
S'left'
p4222
sg59
g63
sS'trial_loop.thisN'
p4223
I38
sg33
g3805
sg64
g65
sS'trial_loop.thisIndex'
p4224
g60
(g99
S'&\x00\x00\x00'
tRp4225
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4226
I0
sg3642
g3908
sS'block_loop.thisRepN'
p4227
I1
sg3645
g3805
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4228
I1
sg3647
g3812
sg55
g11
sS'block_loop.thisTrial'
p4229
Nsg70
Vn
sS'block_loop.thisTrialN'
p4230
I0
sg39
F0.71652533336600754
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x03\x0e\t\x1c\x08'
tRp4231
sa(dp4232
S'trial_loop.thisTrialN'
p4233
I39
sg3633
S'22-daim.png'
p4234
sS'block_loop.thisIndex'
p4235
g3627
sg38
S'right'
p4236
sg59
g63
sS'trial_loop.thisN'
p4237
I39
sg33
S'7-olives.png'
p4238
sg64
g65
sS'trial_loop.thisIndex'
p4239
g60
(g99
S"'\x00\x00\x00"
tRp4240
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4241
I0
sg3642
S'7-olives.png'
p4242
sS'block_loop.thisRepN'
p4243
I1
sg3645
g4238
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4244
I1
sg3647
S'22-daim.png'
p4245
sg55
g11
sS'block_loop.thisTrial'
p4246
Nsg70
Vn
sS'block_loop.thisTrialN'
p4247
I0
sg39
F0.83315467101056129
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x03\x14\x05$h'
tRp4248
sa(dp4249
S'trial_loop.thisTrialN'
p4250
I40
sg3633
g4004
sS'block_loop.thisIndex'
p4251
g3627
sg38
S'right'
p4252
sg59
g63
sS'trial_loop.thisN'
p4253
I40
sg33
g4008
sg64
g65
sS'trial_loop.thisIndex'
p4254
g60
(g99
S'(\x00\x00\x00'
tRp4255
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4256
I0
sg3642
g4012
sS'block_loop.thisRepN'
p4257
I1
sg3645
g4008
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4258
I1
sg3647
g4015
sg55
g11
sS'block_loop.thisTrial'
p4259
Nsg70
Vn
sS'block_loop.thisTrialN'
p4260
I0
sg39
F0.69988892525725532
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x03\x1a\x03\x18\xf8'
tRp4261
sa(dp4262
S'trial_loop.thisTrialN'
p4263
I41
sg3633
g4086
sS'block_loop.thisIndex'
p4264
g3627
sg38
S'right'
p4265
sg59
g63
sS'trial_loop.thisN'
p4266
I41
sg33
g4090
sg64
g65
sS'trial_loop.thisIndex'
p4267
g60
(g99
S')\x00\x00\x00'
tRp4268
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4269
I0
sg3642
g4094
sS'block_loop.thisRepN'
p4270
I1
sg3645
g4090
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4271
I1
sg3647
g4097
sg55
g11
sS'block_loop.thisTrial'
p4272
Nsg70
Vn
sS'block_loop.thisTrialN'
p4273
I0
sg39
F0.86643832101617591
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x03\x1f\x0eg\x80'
tRp4274
sa(dp4275
S'trial_loop.thisTrialN'
p4276
I42
sg3633
g3634
sS'block_loop.thisIndex'
p4277
g3627
sg38
S'right'
p4278
sg59
g63
sS'trial_loop.thisN'
p4279
I42
sg33
g3638
sg64
g65
sS'trial_loop.thisIndex'
p4280
g60
(g99
S'*\x00\x00\x00'
tRp4281
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4282
I0
sg3642
g3643
sS'block_loop.thisRepN'
p4283
I1
sg3645
g3638
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4284
I1
sg3647
g3648
sg55
g11
sS'block_loop.thisTrial'
p4285
Nsg70
Vn
sS'block_loop.thisTrialN'
p4286
I0
sg39
F0.64993693600263214
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x03%\x0c\xd5('
tRp4287
sa(dp4288
S'trial_loop.thisTrialN'
p4289
I43
sg3633
S'46-pistachios.png'
p4290
sS'block_loop.thisIndex'
p4291
g3627
sg38
S'left'
p4292
sg59
g63
sS'trial_loop.thisN'
p4293
I43
sg33
S'46-pistachios.png'
p4294
sg64
g65
sS'trial_loop.thisIndex'
p4295
g60
(g99
S'+\x00\x00\x00'
tRp4296
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4297
I0
sg3642
S'29-beans.png'
p4298
sS'block_loop.thisRepN'
p4299
I1
sg3645
g4294
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4300
I1
sg3647
S'29-beans.png'
p4301
sg55
g11
sS'block_loop.thisTrial'
p4302
Nsg70
Vn
sS'block_loop.thisTrialN'
p4303
I0
sg39
F0.66661354313691845
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x03+\x07\xebX'
tRp4304
sa(dp4305
S'trial_loop.thisTrialN'
p4306
I44
sg3633
S'4-corn.png'
p4307
sS'block_loop.thisIndex'
p4308
g3627
sg38
S'left'
p4309
sg59
g63
sS'trial_loop.thisN'
p4310
I44
sg33
g4015
sg64
g65
sS'trial_loop.thisIndex'
p4311
g60
(g99
S',\x00\x00\x00'
tRp4312
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4313
I0
sg3642
S'10-bounty_redo.png'
p4314
sS'block_loop.thisRepN'
p4315
I1
sg3645
g4008
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4316
I1
sg3647
g4015
sg55
g11
sS'block_loop.thisTrial'
p4317
Nsg70
Vn
sS'block_loop.thisTrialN'
p4318
I0
sg39
F0.81660920962167438
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x031\x03~\x88'
tRp4319
sa(dp4320
S'trial_loop.thisTrialN'
p4321
I45
sg3633
g3654
sS'block_loop.thisIndex'
p4322
g3627
sg38
S'left'
p4323
sg59
g63
sS'trial_loop.thisN'
p4324
I45
sg33
g3658
sg64
g65
sS'trial_loop.thisIndex'
p4325
g60
(g99
S'-\x00\x00\x00'
tRp4326
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4327
I0
sg3642
g3662
sS'block_loop.thisRepN'
p4328
I1
sg3645
g3658
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4329
I1
sg3647
g3665
sg55
g11
sS'block_loop.thisTrial'
p4330
Nsg70
Vn
sS'block_loop.thisTrialN'
p4331
I0
sg39
F0.78331244504806818
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x037\x014\x98'
tRp4332
sa(dp4333
S'trial_loop.thisTrialN'
p4334
I46
sg3633
S'29-beans.png'
p4335
sS'block_loop.thisIndex'
p4336
g3627
sg38
S'right'
p4337
sg59
g63
sS'trial_loop.thisN'
p4338
I46
sg33
g4294
sg64
g65
sS'trial_loop.thisIndex'
p4339
g60
(g99
S'.\x00\x00\x00'
tRp4340
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4341
I0
sg3642
S'46-pistachios.png'
p4342
sS'block_loop.thisRepN'
p4343
I1
sg3645
g4294
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4344
I1
sg3647
g4301
sg55
g11
sS'block_loop.thisTrial'
p4345
Nsg70
Vn
sS'block_loop.thisTrialN'
p4346
I0
sg39
F0.59999264443467837
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x04\x00\r\xaf\xe8'
tRp4347
sa(dp4348
S'trial_loop.thisTrialN'
p4349
I47
sg3633
g4193
sS'block_loop.thisIndex'
p4350
g3627
sg38
S'right'
p4351
sg59
g63
sS'trial_loop.thisN'
p4352
I47
sg33
g3888
sg64
g65
sS'trial_loop.thisIndex'
p4353
g60
(g99
S'/\x00\x00\x00'
tRp4354
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4355
I0
sg3642
g4200
sS'block_loop.thisRepN'
p4356
I1
sg3645
g3888
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4357
I1
sg3647
g3895
sg55
g11
sS'block_loop.thisTrial'
p4358
Nsg70
Vn
sS'block_loop.thisTrialN'
p4359
I0
sg39
F1.1999259881813487
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x04\x06\x08\x12h'
tRp4360
sa(dp4361
S'trial_loop.thisTrialN'
p4362
I48
sg3633
S'19-caramello_redo.png'
p4363
sS'block_loop.thisIndex'
p4364
g3627
sg38
S'right'
p4365
sg59
g63
sS'trial_loop.thisN'
p4366
I48
sg33
g3788
sg64
g65
sS'trial_loop.thisIndex'
p4367
g60
(g99
S'0\x00\x00\x00'
tRp4368
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4369
I0
sg3642
S'30-spaghetti_hoops.png'
p4370
sS'block_loop.thisRepN'
p4371
I1
sg3645
g3788
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4372
I1
sg3647
g3795
sg55
g11
sS'block_loop.thisTrial'
p4373
Nsg70
Vn
sS'block_loop.thisTrialN'
p4374
I0
sg39
F0.98317457095254213
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x04\x0c\x0b}h'
tRp4375
sa(dp4376
S'trial_loop.thisTrialN'
p4377
I49
sg3633
S'20-fruit_pastilles.png'
p4378
sS'block_loop.thisIndex'
p4379
g3627
sg38
S'right'
p4380
sg59
g63
sS'trial_loop.thisN'
p4381
I49
sg33
g3726
sg64
g65
sS'trial_loop.thisIndex'
p4382
g60
(g99
S'1\x00\x00\x00'
tRp4383
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4384
I0
sg3642
S'2-steamed_puddings.png'
p4385
sS'block_loop.thisRepN'
p4386
I1
sg3645
g3726
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4387
I1
sg3647
g3733
sg55
g11
sS'block_loop.thisTrial'
p4388
Nsg70
Vn
sS'block_loop.thisTrialN'
p4389
I0
sg39
F0.71653075025824364
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x04\x12\x0b\xd3X'
tRp4390
sa(dp4391
S'trial_loop.thisTrialN'
p4392
I50
sg3633
g4335
sS'block_loop.thisIndex'
p4393
g3627
sg38
S'right'
p4394
sg59
g63
sS'trial_loop.thisN'
p4395
I50
sg33
g4294
sg64
g65
sS'trial_loop.thisIndex'
p4396
g60
(g99
S'2\x00\x00\x00'
tRp4397
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4398
I0
sg3642
g4342
sS'block_loop.thisRepN'
p4399
I1
sg3645
g4294
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4400
I1
sg3647
g4301
sg55
g11
sS'block_loop.thisTrial'
p4401
Nsg70
Vn
sS'block_loop.thisTrialN'
p4402
I0
sg39
F0.68333434068335919
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x04\x18\x08\x1a8'
tRp4403
sa(dp4404
S'trial_loop.thisTrialN'
p4405
I51
sg3633
S'31-hobnobs.png'
p4406
sS'block_loop.thisIndex'
p4407
g3627
sg38
S'left'
p4408
sg59
g63
sS'trial_loop.thisN'
p4409
I51
sg33
g4167
sg64
g65
sS'trial_loop.thisIndex'
p4410
g60
(g99
S'3\x00\x00\x00'
tRp4411
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4412
I0
sg3642
S'25-kitkat.png'
p4413
sS'block_loop.thisRepN'
p4414
I1
sg3645
g4167
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4415
I1
sg3647
g4174
sg55
g11
sS'block_loop.thisTrial'
p4416
Nsg70
Vn
sS'block_loop.thisTrialN'
p4417
I0
sg39
F0.80029125759756425
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x04\x1e\x03\xadh'
tRp4418
sa(dp4419
S'trial_loop.thisTrialN'
p4420
I52
sg3633
g3739
sS'block_loop.thisIndex'
p4421
g3627
sg38
S'right'
p4422
sg59
g63
sS'trial_loop.thisN'
p4423
I52
sg33
g3692
sg64
g65
sS'trial_loop.thisIndex'
p4424
g60
(g99
S'4\x00\x00\x00'
tRp4425
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4426
I0
sg3642
g3746
sS'block_loop.thisRepN'
p4427
I1
sg3645
g3692
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4428
I1
sg3647
g3699
sg55
g11
sS'block_loop.thisTrial'
p4429
Nsg70
Vn
sS'block_loop.thisTrialN'
p4430
I0
sg39
F0.74997690694726771
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x04$\x01$\xf8'
tRp4431
sa(dp4432
S'trial_loop.thisTrialN'
p4433
I53
sg3633
g3884
sS'block_loop.thisIndex'
p4434
g3627
sg38
S'left'
p4435
sg59
g63
sS'trial_loop.thisN'
p4436
I53
sg33
g3895
sg64
g65
sS'trial_loop.thisIndex'
p4437
g60
(g99
S'5\x00\x00\x00'
tRp4438
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4439
I0
sg3642
g3892
sS'block_loop.thisRepN'
p4440
I1
sg3645
g3888
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4441
I1
sg3647
g3895
sg55
g11
sS'block_loop.thisTrial'
p4442
Nsg70
Vn
sS'block_loop.thisTrialN'
p4443
I0
sg39
F0.76659877498605056
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x04)\r+\x18'
tRp4444
sa(dp4445
S'trial_loop.thisTrialN'
p4446
I54
sg3633
S'41-peanuts_redo.png'
p4447
sS'block_loop.thisIndex'
p4448
g3627
sg38
S'left'
p4449
sg59
g63
sS'trial_loop.thisN'
p4450
I54
sg33
g4129
sg64
g65
sS'trial_loop.thisIndex'
p4451
g60
(g99
S'6\x00\x00\x00'
tRp4452
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4453
I0
sg3642
S'45-chewy_nougat_redo.png'
p4454
sS'block_loop.thisRepN'
p4455
I1
sg3645
g4122
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4456
I1
sg3647
g4129
sg55
g11
sS'block_loop.thisTrial'
p4457
Nsg70
Vn
sS'block_loop.thisTrialN'
p4458
I0
sg39
F0.7332601007874473
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x04/\n)\x90'
tRp4459
sa(dp4460
S'trial_loop.thisTrialN'
p4461
I55
sg3633
g3688
sS'block_loop.thisIndex'
p4462
g3627
sg38
S'left'
p4463
sg59
g63
sS'trial_loop.thisN'
p4464
I55
sg33
g3692
sg64
g65
sS'trial_loop.thisIndex'
p4465
g60
(g99
S'7\x00\x00\x00'
tRp4466
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4467
I0
sg3642
g3696
sS'block_loop.thisRepN'
p4468
I1
sg3645
g3692
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4469
I1
sg3647
g3699
sg55
g11
sS'block_loop.thisTrial'
p4470
Nsg70
Vn
sS'block_loop.thisTrialN'
p4471
I0
sg39
F0.74987569664153853
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x045\x06tX'
tRp4472
sa(dp4473
S'trial_loop.thisTrialN'
p4474
I56
sg3633
S'16-skips_prawn.png'
p4475
sS'block_loop.thisIndex'
p4476
g3627
sg38
S'left'
p4477
sg59
g63
sS'trial_loop.thisN'
p4478
I56
sg33
g4090
sg64
g65
sS'trial_loop.thisIndex'
p4479
g60
(g99
S'8\x00\x00\x00'
tRp4480
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4481
I0
sg3642
S'42-mrkipling_lemon_slices.png'
p4482
sS'block_loop.thisRepN'
p4483
I1
sg3645
g4090
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4484
I1
sg3647
g4097
sg55
g11
sS'block_loop.thisTrial'
p4485
Nsg70
Vn
sS'block_loop.thisTrialN'
p4486
I0
sg39
F0.66645730863820063
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x04;\x034P'
tRp4487
sa(dp4488
S'trial_loop.thisTrialN'
p4489
I57
sg3633
S'6-sour_patch_kids.png'
p4490
sS'block_loop.thisIndex'
p4491
g3627
sg38
S'right'
p4492
sg59
g63
sS'trial_loop.thisN'
p4493
I57
sg33
g3675
sg64
g65
sS'trial_loop.thisIndex'
p4494
g60
(g99
S'9\x00\x00\x00'
tRp4495
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4496
I0
sg3642
S'38-maltesers.png'
p4497
sS'block_loop.thisRepN'
p4498
I1
sg3645
g3675
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4499
I1
sg3647
g3682
sg55
g11
sS'block_loop.thisTrial'
p4500
Nsg70
Vn
sS'block_loop.thisTrialN'
p4501
I0
sg39
F0.76676641346057295
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x05\x04\r\xcb@'
tRp4502
sa(dp4503
S'trial_loop.thisTrialN'
p4504
I58
sg3633
g4234
sS'block_loop.thisIndex'
p4505
g3627
sg38
S'right'
p4506
sg59
g63
sS'trial_loop.thisN'
p4507
I58
sg33
g4238
sg64
g65
sS'trial_loop.thisIndex'
p4508
g60
(g99
S':\x00\x00\x00'
tRp4509
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4510
I0
sg3642
g4242
sS'block_loop.thisRepN'
p4511
I1
sg3645
g4238
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4512
I1
sg3647
g4245
sg55
g11
sS'block_loop.thisTrial'
p4513
Nsg70
Vn
sS'block_loop.thisTrialN'
p4514
I0
sg39
F0.68331894531365833
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x05\n\n\xcd\xa0'
tRp4515
sa(dp4516
S'trial_loop.thisTrialN'
p4517
I59
sg3633
g3931
sS'block_loop.thisIndex'
p4518
g3627
sg38
S'left'
p4519
sg59
g63
sS'trial_loop.thisN'
p4520
I59
sg33
g3638
sg64
g65
sS'trial_loop.thisIndex'
p4521
g60
(g99
S';\x00\x00\x00'
tRp4522
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4523
I0
sg3642
g3938
sS'block_loop.thisRepN'
p4524
I1
sg3645
g3638
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4525
I1
sg3647
g3648
sg55
g11
sS'block_loop.thisTrial'
p4526
Nsg70
Vn
sS'block_loop.thisTrialN'
p4527
I0
sg39
F1.1666189600255166
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x05\x10\x06\\\xe8'
tRp4528
sa(dp4529
S'trial_loop.thisTrialN'
p4530
I60
sg3633
g4004
sS'block_loop.thisIndex'
p4531
g3627
sg38
S'right'
p4532
sg59
g63
sS'trial_loop.thisN'
p4533
I60
sg33
g4008
sg64
g65
sS'trial_loop.thisIndex'
p4534
g60
(g99
S'<\x00\x00\x00'
tRp4535
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4536
I0
sg3642
g4012
sS'block_loop.thisRepN'
p4537
I1
sg3645
g4008
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4538
I1
sg3647
g4015
sg55
g11
sS'block_loop.thisTrial'
p4539
Nsg70
Vn
sS'block_loop.thisTrialN'
p4540
I0
sg39
F0.76662357863460784
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x05\x16\t\x8dP'
tRp4541
sa(dp4542
S'trial_loop.thisTrialN'
p4543
I61
sg3633
g3976
sS'block_loop.thisIndex'
p4544
g3627
sg38
S'left'
p4545
sg59
g63
sS'trial_loop.thisN'
p4546
I61
sg33
g3956
sg64
g65
sS'trial_loop.thisIndex'
p4547
g60
(g99
S'=\x00\x00\x00'
tRp4548
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4549
I0
sg3642
g3983
sS'block_loop.thisRepN'
p4550
I1
sg3645
g3956
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4551
I1
sg3647
g3950
sg55
g11
sS'block_loop.thisTrial'
p4552
Nsg70
Vn
sS'block_loop.thisTrialN'
p4553
I0
sg39
F0.93322229660043376
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x05\x1c\x06\x8b\xc8'
tRp4554
sa(dp4555
S'trial_loop.thisTrialN'
p4556
I62
sg3633
S'1-treacle_cookies.png'
p4557
sS'block_loop.thisIndex'
p4558
g3627
sg38
S'left'
p4559
sg59
g63
sS'trial_loop.thisN'
p4560
I62
sg33
g3854
sg64
g65
sS'trial_loop.thisIndex'
p4561
g60
(g99
S'>\x00\x00\x00'
tRp4562
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4563
I0
sg3642
S'21-nakd_banana_crunch.png'
p4564
sS'block_loop.thisRepN'
p4565
I1
sg3645
g3854
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4566
I1
sg3647
g3861
sg55
g11
sS'block_loop.thisTrial'
p4567
Nsg70
Vn
sS'block_loop.thisTrialN'
p4568
I0
sg39
F0.71656524729041848
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x05"\x05\xeb\xa0'
tRp4569
sa(dp4570
S'trial_loop.thisTrialN'
p4571
I63
sg3633
g4004
sS'block_loop.thisIndex'
p4572
g3627
sg38
S'right'
p4573
sg59
g63
sS'trial_loop.thisN'
p4574
I63
sg33
g4008
sg64
g65
sS'trial_loop.thisIndex'
p4575
g60
(g99
S'?\x00\x00\x00'
tRp4576
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4577
I0
sg3642
g4012
sS'block_loop.thisRepN'
p4578
I1
sg3645
g4008
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4579
I1
sg3647
g4015
sg55
g11
sS'block_loop.thisTrial'
p4580
Nsg70
Vn
sS'block_loop.thisTrialN'
p4581
I0
sg39
F0.66665117626325809
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x05(\x026h'
tRp4582
sa(dp4583
S'trial_loop.thisTrialN'
p4584
I64
sg3633
g4086
sS'block_loop.thisIndex'
p4585
g3627
sg38
S'right'
p4586
sg59
g63
sS'trial_loop.thisN'
p4587
I64
sg33
g4090
sg64
g65
sS'trial_loop.thisIndex'
p4588
g60
(g99
S'@\x00\x00\x00'
tRp4589
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4590
I0
sg3642
g4094
sS'block_loop.thisRepN'
p4591
I1
sg3645
g4090
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4592
I1
sg3647
g4097
sg55
g11
sS'block_loop.thisTrial'
p4593
Nsg70
Vn
sS'block_loop.thisTrialN'
p4594
I0
sg39
F0.84986663047675393
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x05-\x0c\xcdX'
tRp4595
sa(dp4596
S'trial_loop.thisTrialN'
p4597
I65
sg3633
g3916
sS'block_loop.thisIndex'
p4598
g3627
sg38
S'left'
p4599
sg59
g63
sS'trial_loop.thisN'
p4600
I65
sg33
g3716
sg64
g65
sS'trial_loop.thisIndex'
p4601
g60
(g99
S'A\x00\x00\x00'
tRp4602
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4603
I0
sg3642
g3923
sS'block_loop.thisRepN'
p4604
I1
sg3645
g3709
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4605
I1
sg3647
g3716
sg55
g11
sS'block_loop.thisTrial'
p4606
Nsg70
Vn
sS'block_loop.thisTrialN'
p4607
I0
sg39
F0.79995484024766483
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x053\n\xfc\x80'
tRp4608
sa(dp4609
S'trial_loop.thisTrialN'
p4610
I66
sg3633
g4475
sS'block_loop.thisIndex'
p4611
g3627
sg38
S'left'
p4612
sg59
g63
sS'trial_loop.thisN'
p4613
I66
sg33
g4090
sg64
g65
sS'trial_loop.thisIndex'
p4614
g60
(g99
S'B\x00\x00\x00'
tRp4615
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4616
I0
sg3642
g4482
sS'block_loop.thisRepN'
p4617
I1
sg3645
g4090
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4618
I1
sg3647
g4097
sg55
g11
sS'block_loop.thisTrial'
p4619
Nsg70
Vn
sS'block_loop.thisTrialN'
p4620
I0
sg39
F0.68320290983683662
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x059\x08t\x10'
tRp4621
sa(dp4622
S'trial_loop.thisTrialN'
p4623
I67
sg3633
g3946
sS'block_loop.thisIndex'
p4624
g3627
sg38
S'right'
p4625
sg59
g63
sS'trial_loop.thisN'
p4626
I67
sg33
g3956
sg64
g65
sS'trial_loop.thisIndex'
p4627
g60
(g99
S'C\x00\x00\x00'
tRp4628
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4629
I0
sg3642
g3954
sS'block_loop.thisRepN'
p4630
I1
sg3645
g3956
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4631
I1
sg3647
g3950
sg55
g11
sS'block_loop.thisTrial'
p4632
Nsg70
Vn
sS'block_loop.thisTrialN'
p4633
I0
sg39
F0.59989171923007234
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x06\x03\x04E\xc0'
tRp4634
sa(dp4635
S'trial_loop.thisTrialN'
p4636
I68
sg3633
S'7-olives.png'
p4637
sS'block_loop.thisIndex'
p4638
g3627
sg38
S'left'
p4639
sg59
g63
sS'trial_loop.thisN'
p4640
I68
sg33
g4238
sg64
g65
sS'trial_loop.thisIndex'
p4641
g60
(g99
S'D\x00\x00\x00'
tRp4642
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4643
I0
sg3642
S'22-daim.png'
p4644
sS'block_loop.thisRepN'
p4645
I1
sg3645
g4238
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4646
I1
sg3647
g4245
sg55
g11
sS'block_loop.thisTrial'
p4647
Nsg70
Vn
sS'block_loop.thisTrialN'
p4648
I0
sg39
F0.5999253609625157
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x06\x08\r\xe6\x98'
tRp4649
sa(dp4650
S'trial_loop.thisTrialN'
p4651
I69
sg3633
g4363
sS'block_loop.thisIndex'
p4652
g3627
sg38
S'right'
p4653
sg59
g63
sS'trial_loop.thisN'
p4654
I69
sg33
g3788
sg64
g65
sS'trial_loop.thisIndex'
p4655
g60
(g99
S'E\x00\x00\x00'
tRp4656
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4657
I0
sg3642
g4370
sS'block_loop.thisRepN'
p4658
I1
sg3645
g3788
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4659
I1
sg3647
g3795
sg55
g11
sS'block_loop.thisTrial'
p4660
Nsg70
Vn
sS'block_loop.thisTrialN'
p4661
I0
sg39
F0.94999213125265669
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x06\x0e\x08I\x18'
tRp4662
sa(dp4663
S'trial_loop.thisTrialN'
p4664
I70
sg3633
g3722
sS'block_loop.thisIndex'
p4665
g3627
sg38
S'left'
p4666
sg59
g63
sS'trial_loop.thisN'
p4667
I70
sg33
g3726
sg64
g65
sS'trial_loop.thisIndex'
p4668
g60
(g99
S'F\x00\x00\x00'
tRp4669
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4670
I0
sg3642
g3730
sS'block_loop.thisRepN'
p4671
I1
sg3645
g3726
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4672
I1
sg3647
g3733
sg55
g11
sS'block_loop.thisTrial'
p4673
Nsg70
Vn
sS'block_loop.thisTrialN'
p4674
I0
sg39
F0.59992450566642219
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x06\x14\x07\xe7p'
tRp4675
sa(dp4676
S'trial_loop.thisTrialN'
p4677
I71
sg3633
g3705
sS'block_loop.thisIndex'
p4678
g3627
sg38
S'right'
p4679
sg59
g63
sS'trial_loop.thisN'
p4680
I71
sg33
g3716
sg64
g65
sS'trial_loop.thisIndex'
p4681
g60
(g99
S'G\x00\x00\x00'
tRp4682
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4683
I0
sg3642
g3713
sS'block_loop.thisRepN'
p4684
I1
sg3645
g3709
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4685
I1
sg3647
g3716
sg55
g11
sS'block_loop.thisTrial'
p4686
Nsg70
Vn
sS'block_loop.thisTrialN'
p4687
I0
sg39
F1.033244306279812
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x06\x1a\x02\x84\x88'
tRp4688
sa(dp4689
S'trial_loop.thisTrialN'
p4690
I72
sg3633
g3946
sS'block_loop.thisIndex'
p4691
g3627
sg38
S'right'
p4692
sg59
g63
sS'trial_loop.thisN'
p4693
I72
sg33
g3950
sg64
g65
sS'trial_loop.thisIndex'
p4694
g60
(g99
S'H\x00\x00\x00'
tRp4695
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4696
I0
sg3642
g3954
sS'block_loop.thisRepN'
p4697
I1
sg3645
g3956
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4698
I1
sg3647
g3950
sg55
g11
sS'block_loop.thisTrial'
p4699
Nsg70
Vn
sS'block_loop.thisTrialN'
p4700
I0
sg39
F0.63322526163392467
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x06 \x03S\x90'
tRp4701
sa(dp4702
S'trial_loop.thisTrialN'
p4703
I73
sg3633
g4378
sS'block_loop.thisIndex'
p4704
g3627
sg38
S'right'
p4705
sg59
g63
sS'trial_loop.thisN'
p4706
I73
sg33
g3726
sg64
g65
sS'trial_loop.thisIndex'
p4707
g60
(g99
S'I\x00\x00\x00'
tRp4708
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4709
I0
sg3642
g4385
sS'block_loop.thisRepN'
p4710
I1
sg3645
g3726
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4711
I1
sg3647
g3733
sg55
g11
sS'block_loop.thisTrial'
p4712
Nsg70
Vn
sS'block_loop.thisTrialN'
p4713
I0
sg39
F0.5498918332705216
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x06%\r\xac\x00'
tRp4714
sa(dp4715
S'trial_loop.thisTrialN'
p4716
I74
sg3633
g3946
sS'block_loop.thisIndex'
p4717
g3627
sg38
S'right'
p4718
sg59
g63
sS'trial_loop.thisN'
p4719
I74
sg33
g3950
sg64
g65
sS'trial_loop.thisIndex'
p4720
g60
(g99
S'J\x00\x00\x00'
tRp4721
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4722
I0
sg3642
g3954
sS'block_loop.thisRepN'
p4723
I1
sg3645
g3956
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4724
I1
sg3647
g3950
sg55
g11
sS'block_loop.thisTrial'
p4725
Nsg70
Vn
sS'block_loop.thisTrialN'
p4726
I0
sg39
F0.9333269281014509
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x06+\x07V\xe8'
tRp4727
sa(dp4728
S'trial_loop.thisTrialN'
p4729
I75
sg3633
g3705
sS'block_loop.thisIndex'
p4730
g3627
sg38
S'right'
p4731
sg59
g63
sS'trial_loop.thisN'
p4732
I75
sg33
g3709
sg64
g65
sS'trial_loop.thisIndex'
p4733
g60
(g99
S'K\x00\x00\x00'
tRp4734
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4735
I0
sg3642
g3713
sS'block_loop.thisRepN'
p4736
I1
sg3645
g3709
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4737
I1
sg3647
g3716
sg55
g11
sS'block_loop.thisTrial'
p4738
Nsg70
Vn
sS'block_loop.thisTrialN'
p4739
I0
sg39
F0.86704415734129725
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x061\x06\xb6\xc0'
tRp4740
sa(dp4741
S'trial_loop.thisTrialN'
p4742
I76
sg3633
g3671
sS'block_loop.thisIndex'
p4743
g3627
sg38
S'left'
p4744
sg59
g63
sS'trial_loop.thisN'
p4745
I76
sg33
g3675
sg64
g65
sS'trial_loop.thisIndex'
p4746
g60
(g99
S'L\x00\x00\x00'
tRp4747
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4748
I0
sg3642
g3679
sS'block_loop.thisRepN'
p4749
I1
sg3645
g3675
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4750
I1
sg3647
g3682
sg55
g11
sS'block_loop.thisTrial'
p4751
Nsg70
Vn
sS'block_loop.thisTrialN'
p4752
I0
sg39
F0.84982329536433099
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x067\x05$h'
tRp4753
sa(dp4754
S'trial_loop.thisTrialN'
p4755
I77
sg3633
g3850
sS'block_loop.thisIndex'
p4756
g3627
sg38
S'right'
p4757
sg59
g63
sS'trial_loop.thisN'
p4758
I77
sg33
g3854
sg64
g65
sS'trial_loop.thisIndex'
p4759
g60
(g99
S'M\x00\x00\x00'
tRp4760
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4761
I0
sg3642
g3858
sS'block_loop.thisRepN'
p4762
I1
sg3645
g3854
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4763
I1
sg3647
g3861
sg55
g11
sS'block_loop.thisTrial'
p4764
Nsg70
Vn
sS'block_loop.thisTrialN'
p4765
I0
sg39
F0.68336541652388405
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x07\x01\x03S\x90'
tRp4766
sa(dp4767
S'trial_loop.thisTrialN'
p4768
I78
sg3633
g4148
sS'block_loop.thisIndex'
p4769
g3627
sg38
S'left'
p4770
sg59
g63
sS'trial_loop.thisN'
p4771
I78
sg33
g3777
sg64
g65
sS'trial_loop.thisIndex'
p4772
g60
(g99
S'N\x00\x00\x00'
tRp4773
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4774
I0
sg3642
g4155
sS'block_loop.thisRepN'
p4775
I1
sg3645
g3777
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4776
I1
sg3647
g3771
sg55
g11
sS'block_loop.thisTrial'
p4777
Nsg70
Vn
sS'block_loop.thisTrialN'
p4778
I0
sg39
F0.69998357826989377
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x07\x06\x0ec\x98'
tRp4779
sa(dp4780
S'trial_loop.thisTrialN'
p4781
I79
sg3633
g4103
sS'block_loop.thisIndex'
p4782
g3627
sg38
S'left'
p4783
sg59
g63
sS'trial_loop.thisN'
p4784
I79
sg33
g3871
sg64
g65
sS'trial_loop.thisIndex'
p4785
g60
(g99
S'O\x00\x00\x00'
tRp4786
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4787
I0
sg3642
g4110
sS'block_loop.thisRepN'
p4788
I1
sg3645
g3871
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4789
I1
sg3647
g3878
sg55
g11
sS'block_loop.thisTrial'
p4790
Nsg70
Vn
sS'block_loop.thisTrialN'
p4791
I0
sg39
F0.86639812199064181
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x07\x0c\n5H'
tRp4792
sa(dp4793
S'trial_loop.thisTrialN'
p4794
I80
sg3633
g4637
sS'block_loop.thisIndex'
p4795
g3627
sg38
S'left'
p4796
sg59
g63
sS'trial_loop.thisN'
p4797
I80
sg33
g4238
sg64
g65
sS'trial_loop.thisIndex'
p4798
g60
(g99
S'P\x00\x00\x00'
tRp4799
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4800
I0
sg3642
g4644
sS'block_loop.thisRepN'
p4801
I1
sg3645
g4238
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4802
I1
sg3647
g4245
sg55
g11
sS'block_loop.thisTrial'
p4803
Nsg70
Vn
sS'block_loop.thisTrialN'
p4804
I0
sg39
F0.64997827542174491
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x07\x12\x08\xdd\x88'
tRp4805
sa(dp4806
S'trial_loop.thisTrialN'
p4807
I81
sg3633
g4163
sS'block_loop.thisIndex'
p4808
g3627
sg38
S'right'
p4809
sg59
g63
sS'trial_loop.thisN'
p4810
I81
sg33
g4167
sg64
g65
sS'trial_loop.thisIndex'
p4811
g60
(g99
S'Q\x00\x00\x00'
tRp4812
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4813
I0
sg3642
g4171
sS'block_loop.thisRepN'
p4814
I1
sg3645
g4167
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4815
I1
sg3647
g4174
sg55
g11
sS'block_loop.thisTrial'
p4816
Nsg70
Vn
sS'block_loop.thisTrialN'
p4817
I0
sg39
F0.66660071366277407
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x07\x18\x03\xf3\xb8'
tRp4818
sa(dp4819
S'trial_loop.thisTrialN'
p4820
I82
sg3633
g4363
sS'block_loop.thisIndex'
p4821
g3627
sg38
S'right'
p4822
sg59
g63
sS'trial_loop.thisN'
p4823
I82
sg33
g3788
sg64
g65
sS'trial_loop.thisIndex'
p4824
g60
(g99
S'R\x00\x00\x00'
tRp4825
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4826
I0
sg3642
g4370
sS'block_loop.thisRepN'
p4827
I1
sg3645
g3788
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4828
I1
sg3647
g3795
sg55
g11
sS'block_loop.thisTrial'
p4829
Nsg70
Vn
sS'block_loop.thisTrialN'
p4830
I0
sg39
F0.81652624568232568
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x07\x1d\x0e\x8a\xa8'
tRp4831
sa(dp4832
S'trial_loop.thisTrialN'
p4833
I83
sg3633
g3901
sS'block_loop.thisIndex'
p4834
g3627
sg38
S'left'
p4835
sg59
g63
sS'trial_loop.thisN'
p4836
I83
sg33
g3805
sg64
g65
sS'trial_loop.thisIndex'
p4837
g60
(g99
S'S\x00\x00\x00'
tRp4838
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4839
I0
sg3642
g3908
sS'block_loop.thisRepN'
p4840
I1
sg3645
g3805
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4841
I1
sg3647
g3812
sg55
g11
sS'block_loop.thisTrial'
p4842
Nsg70
Vn
sS'block_loop.thisTrialN'
p4843
I0
sg39
F0.71652390786766773
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x07#\x0c@\xb8'
tRp4844
sa(dp4845
S'trial_loop.thisTrialN'
p4846
I84
sg3633
g4193
sS'block_loop.thisIndex'
p4847
g3627
sg38
S'right'
p4848
sg59
g63
sS'trial_loop.thisN'
p4849
I84
sg33
g3888
sg64
g65
sS'trial_loop.thisIndex'
p4850
g60
(g99
S'T\x00\x00\x00'
tRp4851
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4852
I0
sg3642
g4200
sS'block_loop.thisRepN'
p4853
I1
sg3645
g3888
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4854
I1
sg3647
g3895
sg55
g11
sS'block_loop.thisTrial'
p4855
Nsg70
Vn
sS'block_loop.thisTrialN'
p4856
I0
sg39
F0.66663777659050538
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x07)\x08\x8b\x80'
tRp4857
sa(dp4858
S'trial_loop.thisTrialN'
p4859
I85
sg3633
g3850
sS'block_loop.thisIndex'
p4860
g3627
sg38
S'right'
p4861
sg59
g63
sS'trial_loop.thisN'
p4862
I85
sg33
g3854
sg64
g65
sS'trial_loop.thisIndex'
p4863
g60
(g99
S'U\x00\x00\x00'
tRp4864
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4865
I0
sg3642
g3858
sS'block_loop.thisRepN'
p4866
I1
sg3645
g3854
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4867
I1
sg3647
g3861
sg55
g11
sS'block_loop.thisTrial'
p4868
Nsg70
Vn
sS'block_loop.thisTrialN'
p4869
I0
sg39
F0.58328809755403199
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x07/\x03\xe00'
tRp4870
sa(dp4871
S'trial_loop.thisTrialN'
p4872
I86
sg3633
g4447
sS'block_loop.thisIndex'
p4873
g3627
sg38
S'left'
p4874
sg59
g63
sS'trial_loop.thisN'
p4875
I86
sg33
g4122
sg64
g65
sS'trial_loop.thisIndex'
p4876
g60
(g99
S'V\x00\x00\x00'
tRp4877
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4878
I0
sg3642
g4454
sS'block_loop.thisRepN'
p4879
I1
sg3645
g4122
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4880
I1
sg3647
g4129
sg55
g11
sS'block_loop.thisTrial'
p4881
Nsg70
Vn
sS'block_loop.thisTrialN'
p4882
I0
sg39
F0.79989012267469661
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x074\rFp'
tRp4883
sa(dp4884
S'trial_loop.thisTrialN'
p4885
I87
sg3633
g4307
sS'block_loop.thisIndex'
p4886
g3627
sg38
S'left'
p4887
sg59
g63
sS'trial_loop.thisN'
p4888
I87
sg33
g4008
sg64
g65
sS'trial_loop.thisIndex'
p4889
g60
(g99
S'W\x00\x00\x00'
tRp4890
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4891
I0
sg3642
g4314
sS'block_loop.thisRepN'
p4892
I1
sg3645
g4008
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4893
I1
sg3647
g4015
sg55
g11
sS'block_loop.thisTrial'
p4894
Nsg70
Vn
sS'block_loop.thisTrialN'
p4895
I0
sg39
F0.68333377048475086
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x07:\n\xbe\x00'
tRp4896
sa(dp4897
S'trial_loop.thisTrialN'
p4898
I88
sg3633
S'3-ellas_strawberries_apples.png'
p4899
sS'block_loop.thisIndex'
p4900
g3627
sg38
S'left'
p4901
sg59
g63
sS'trial_loop.thisN'
p4902
I88
sg33
g3837
sg64
g65
sS'trial_loop.thisIndex'
p4903
g60
(g99
S'X\x00\x00\x00'
tRp4904
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4905
I0
sg3642
S'13-mccoys_steak_crisps.png'
p4906
sS'block_loop.thisRepN'
p4907
I1
sg3645
g3837
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4908
I1
sg3647
g3844
sg55
g11
sS'block_loop.thisTrial'
p4909
Nsg70
Vn
sS'block_loop.thisTrialN'
p4910
I0
sg39
F1.0833151820006606
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x08\x04\x06\x8b\xc8'
tRp4911
sa(dp4912
S'trial_loop.thisTrialN'
p4913
I89
sg3633
g3654
sS'block_loop.thisIndex'
p4914
g3627
sg38
S'left'
p4915
sg59
g63
sS'trial_loop.thisN'
p4916
I89
sg33
g3658
sg64
g65
sS'trial_loop.thisIndex'
p4917
g60
(g99
S'Y\x00\x00\x00'
tRp4918
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4919
I0
sg3642
g3662
sS'block_loop.thisRepN'
p4920
I1
sg3645
g3658
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4921
I1
sg3647
g3665
sg55
g11
sS'block_loop.thisTrial'
p4922
Nsg70
Vn
sS'block_loop.thisTrialN'
p4923
I0
sg39
F0.69990004413193674
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x08\n\x08P\xe8'
tRp4924
sa(dp4925
S'trial_loop.thisTrialN'
p4926
I90
sg3633
g4363
sS'block_loop.thisIndex'
p4927
g3627
sg38
S'right'
p4928
sg59
g63
sS'trial_loop.thisN'
p4929
I90
sg33
g3795
sg64
g65
sS'trial_loop.thisIndex'
p4930
g60
(g99
S'Z\x00\x00\x00'
tRp4931
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4932
I0
sg3642
g4370
sS'block_loop.thisRepN'
p4933
I1
sg3645
g3788
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4934
I1
sg3647
g3795
sg55
g11
sS'block_loop.thisTrial'
p4935
Nsg70
Vn
sS'block_loop.thisTrialN'
p4936
I0
sg39
F0.8665948406123789
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x08\x10\x04\x1e\xb0'
tRp4937
sa(dp4938
S'trial_loop.thisTrialN'
p4939
I91
sg3633
g3867
sS'block_loop.thisIndex'
p4940
g3627
sg38
S'left'
p4941
sg59
g63
sS'trial_loop.thisN'
p4942
I91
sg33
g3871
sg64
g65
sS'trial_loop.thisIndex'
p4943
g60
(g99
S'[\x00\x00\x00'
tRp4944
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4945
I0
sg3642
g3875
sS'block_loop.thisRepN'
p4946
I1
sg3645
g3871
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4947
I1
sg3647
g3878
sg55
g11
sS'block_loop.thisTrial'
p4948
Nsg70
Vn
sS'block_loop.thisTrialN'
p4949
I0
sg39
F0.73307022455628612
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x08\x16\x02\x8cX'
tRp4950
sa(dp4951
S'trial_loop.thisTrialN'
p4952
I92
sg3633
g4234
sS'block_loop.thisIndex'
p4953
g3627
sg38
S'right'
p4954
sg59
g63
sS'trial_loop.thisN'
p4955
I92
sg33
g4245
sg64
g65
sS'trial_loop.thisIndex'
p4956
g60
(g99
S'\\\x00\x00\x00'
tRp4957
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4958
I0
sg3642
g4242
sS'block_loop.thisRepN'
p4959
I1
sg3645
g4238
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4960
I1
sg3647
g4245
sg55
g11
sS'block_loop.thisTrial'
p4961
Nsg70
Vn
sS'block_loop.thisTrialN'
p4962
I0
sg39
F0.63324607389586163
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x08\x1b\x0eS\xf8'
tRp4963
sa(dp4964
S'trial_loop.thisTrialN'
p4965
I93
sg3633
g4378
sS'block_loop.thisIndex'
p4966
g3627
sg38
S'right'
p4967
sg59
g63
sS'trial_loop.thisN'
p4968
I93
sg33
g3726
sg64
g65
sS'trial_loop.thisIndex'
p4969
g60
(g99
S']\x00\x00\x00'
tRp4970
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4971
I0
sg3642
g4385
sS'block_loop.thisRepN'
p4972
I1
sg3645
g3726
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4973
I1
sg3647
g3733
sg55
g11
sS'block_loop.thisTrial'
p4974
Nsg70
Vn
sS'block_loop.thisTrialN'
p4975
I0
sg39
F0.64999652178812539
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x08!\t+\xa8'
tRp4976
sa(dp4977
S'trial_loop.thisTrialN'
p4978
I94
sg3633
g4899
sS'block_loop.thisIndex'
p4979
g3627
sg38
S'left'
p4980
sg59
g63
sS'trial_loop.thisN'
p4981
I94
sg33
g3837
sg64
g65
sS'trial_loop.thisIndex'
p4982
g60
(g99
S'^\x00\x00\x00'
tRp4983
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4984
I0
sg3642
g4906
sS'block_loop.thisRepN'
p4985
I1
sg3645
g3837
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4986
I1
sg3647
g3844
sg55
g11
sS'block_loop.thisTrial'
p4987
Nsg70
Vn
sS'block_loop.thisTrialN'
p4988
I0
sg39
F0.91658987988193985
sg34
g753
(S"\x07\xdf\x07\x0b\x11\x08'\x04\x80X"
tRp4989
sa(dp4990
S'trial_loop.thisTrialN'
p4991
I95
sg3633
g4475
sS'block_loop.thisIndex'
p4992
g3627
sg38
S'left'
p4993
sg59
g63
sS'trial_loop.thisN'
p4994
I95
sg33
g4090
sg64
g65
sS'trial_loop.thisIndex'
p4995
g60
(g99
S'_\x00\x00\x00'
tRp4996
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p4997
I0
sg3642
g4482
sS'block_loop.thisRepN'
p4998
I1
sg3645
g4090
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p4999
I1
sg3647
g4097
sg55
g11
sS'block_loop.thisTrial'
p5000
Nsg70
Vn
sS'block_loop.thisTrialN'
p5001
I0
sg39
F0.71650965289882151
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x08-\x03\xa5\x98'
tRp5002
sa(dp5003
S'trial_loop.thisTrialN'
p5004
I96
sg3633
g4118
sS'block_loop.thisIndex'
p5005
g3627
sg38
S'right'
p5006
sg59
g63
sS'trial_loop.thisN'
p5007
I96
sg33
g4122
sg64
g65
sS'trial_loop.thisIndex'
p5008
g60
(g99
S'`\x00\x00\x00'
tRp5009
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5010
I0
sg3642
g4126
sS'block_loop.thisRepN'
p5011
I1
sg3645
g4122
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5012
I1
sg3647
g4129
sg55
g11
sS'block_loop.thisTrial'
p5013
Nsg70
Vn
sS'block_loop.thisTrialN'
p5014
I0
sg39
F0.68329927345257602
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x082\x0f.\xb8'
tRp5015
sa(dp5016
S'trial_loop.thisTrialN'
p5017
I97
sg3633
g4406
sS'block_loop.thisIndex'
p5018
g3627
sg38
S'left'
p5019
sg59
g63
sS'trial_loop.thisN'
p5020
I97
sg33
g4167
sg64
g65
sS'trial_loop.thisIndex'
p5021
g60
(g99
S'a\x00\x00\x00'
tRp5022
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5023
I0
sg3642
g4413
sS'block_loop.thisRepN'
p5024
I1
sg3645
g4167
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5025
I1
sg3647
g4174
sg55
g11
sS'block_loop.thisTrial'
p5026
Nsg70
Vn
sS'block_loop.thisTrialN'
p5027
I0
sg39
F0.59998523184549413
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x088\n\xc1\xe8'
tRp5028
sa(dp5029
S'trial_loop.thisTrialN'
p5030
I98
sg3633
g4447
sS'block_loop.thisIndex'
p5031
g3627
sg38
S'left'
p5032
sg59
g63
sS'trial_loop.thisN'
p5033
I98
sg33
g4122
sg64
g65
sS'trial_loop.thisIndex'
p5034
g60
(g99
S'b\x00\x00\x00'
tRp5035
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5036
I0
sg3642
g4454
sS'block_loop.thisRepN'
p5037
I1
sg3645
g4122
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5038
I1
sg3647
g4129
sg55
g11
sS'block_loop.thisTrial'
p5039
Nsg70
Vn
sS'block_loop.thisTrialN'
p5040
I0
sg39
F0.61657716444824473
sg34
g753
(S'\x07\xdf\x07\x0b\x11\t\x02\x05$h'
tRp5041
sa(dp5042
S'trial_loop.thisTrialN'
p5043
I99
sg3633
g3671
sS'block_loop.thisIndex'
p5044
g3627
sg38
S'left'
p5045
sg59
g63
sS'trial_loop.thisN'
p5046
I99
sg33
g3682
sg64
g65
sS'trial_loop.thisIndex'
p5047
g60
(g99
S'c\x00\x00\x00'
tRp5048
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5049
I0
sg3642
g3679
sS'block_loop.thisRepN'
p5050
I1
sg3645
g3675
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5051
I1
sg3647
g3682
sg55
g11
sS'block_loop.thisTrial'
p5052
Nsg70
Vn
sS'block_loop.thisTrialN'
p5053
I0
sg39
F0.63301713904002099
sg34
g753
(S'\x07\xdf\x07\x0b\x11\t\x07\x0f\x03\xc0'
tRp5054
sa(dp5055
S'trial_loop.thisTrialN'
p5056
I100
sg3633
g3739
sS'block_loop.thisIndex'
p5057
g3627
sg38
S'right'
p5058
sg59
g63
sS'trial_loop.thisN'
p5059
I100
sg33
g3692
sg64
g65
sS'trial_loop.thisIndex'
p5060
g60
(g99
S'd\x00\x00\x00'
tRp5061
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5062
I0
sg3642
g3746
sS'block_loop.thisRepN'
p5063
I1
sg3645
g3692
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5064
I1
sg3647
g3699
sg55
g11
sS'block_loop.thisTrial'
p5065
Nsg70
Vn
sS'block_loop.thisTrialN'
p5066
I0
sg39
F0.76655458457025816
sg34
g753
(S'\x07\xdf\x07\x0b\x11\t\r\n\x19\xf0'
tRp5067
sa(dp5068
S'trial_loop.thisTrialN'
p5069
I101
sg3633
g4004
sS'block_loop.thisIndex'
p5070
g3627
sg38
S'right'
p5071
sg59
g63
sS'trial_loop.thisN'
p5072
I101
sg33
g4008
sg64
g65
sS'trial_loop.thisIndex'
p5073
g60
(g99
S'e\x00\x00\x00'
tRp5074
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5075
I0
sg3642
g4012
sS'block_loop.thisRepN'
p5076
I1
sg3645
g4008
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5077
I1
sg3647
g4015
sg55
g11
sS'block_loop.thisTrial'
p5078
Nsg70
Vn
sS'block_loop.thisTrialN'
p5079
I0
sg39
F0.6331237662343483
sg34
g753
(S'\x07\xdf\x07\x0b\x11\t\x13\x06\xdd\xd0'
tRp5080
sa(dp5081
S'trial_loop.thisTrialN'
p5082
I102
sg3633
g4086
sS'block_loop.thisIndex'
p5083
g3627
sg38
S'right'
p5084
sg59
g63
sS'trial_loop.thisN'
p5085
I102
sg33
g4090
sg64
g65
sS'trial_loop.thisIndex'
p5086
g60
(g99
S'f\x00\x00\x00'
tRp5087
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5088
I0
sg3642
g4094
sS'block_loop.thisRepN'
p5089
I1
sg3645
g4090
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5090
I1
sg3647
g4097
sg55
g11
sS'block_loop.thisTrial'
p5091
Nsg70
Vn
sS'block_loop.thisTrialN'
p5092
I0
sg39
F0.86656775616575032
sg34
g753
(S'\x07\xdf\x07\x0b\x11\t\x19\x01\xf4\x00'
tRp5093
sa(dp5094
S'trial_loop.thisTrialN'
p5095
I103
sg3633
g4290
sS'block_loop.thisIndex'
p5096
g3627
sg38
S'left'
p5097
sg59
g63
sS'trial_loop.thisN'
p5098
I103
sg33
g4294
sg64
g65
sS'trial_loop.thisIndex'
p5099
g60
(g99
S'g\x00\x00\x00'
tRp5100
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5101
I0
sg3642
g4298
sS'block_loop.thisRepN'
p5102
I1
sg3645
g4294
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5103
I1
sg3647
g4301
sg55
g11
sS'block_loop.thisTrial'
p5104
Nsg70
Vn
sS'block_loop.thisTrialN'
p5105
I0
sg39
F0.64992980851457105
sg34
g753
(S'\x07\xdf\x07\x0b\x11\t\x1f\x00a\xa8'
tRp5106
sa(dp5107
S'trial_loop.thisTrialN'
p5108
I104
sg3633
g3705
sS'block_loop.thisIndex'
p5109
g3627
sg38
S'right'
p5110
sg59
g63
sS'trial_loop.thisN'
p5111
I104
sg33
g3709
sg64
g65
sS'trial_loop.thisIndex'
p5112
g60
(g99
S'h\x00\x00\x00'
tRp5113
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5114
I0
sg3642
g3713
sS'block_loop.thisRepN'
p5115
I1
sg3645
g3709
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5116
I1
sg3647
g3716
sg55
g11
sS'block_loop.thisTrial'
p5117
Nsg70
Vn
sS'block_loop.thisTrialN'
p5118
I0
sg39
F0.96670694171552896
sg34
g753
(S'\x07\xdf\x07\x0b\x11\t$\n\xbe\x00'
tRp5119
sa(dp5120
S'trial_loop.thisTrialN'
p5121
I105
sg3633
g4490
sS'block_loop.thisIndex'
p5122
g3627
sg38
S'right'
p5123
sg59
g63
sS'trial_loop.thisN'
p5124
I105
sg33
g3682
sg64
g65
sS'trial_loop.thisIndex'
p5125
g60
(g99
S'i\x00\x00\x00'
tRp5126
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5127
I0
sg3642
g4497
sS'block_loop.thisRepN'
p5128
I1
sg3645
g3675
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5129
I1
sg3647
g3682
sg55
g11
sS'block_loop.thisTrial'
p5130
Nsg70
Vn
sS'block_loop.thisTrialN'
p5131
I0
sg39
F0.93306834289978724
sg34
g753
(S'\x07\xdf\x07\x0b\x11\t*\n\xd5p'
tRp5132
sa(dp5133
S'trial_loop.thisTrialN'
p5134
I106
sg3633
g4163
sS'block_loop.thisIndex'
p5135
g3627
sg38
S'right'
p5136
sg59
g63
sS'trial_loop.thisN'
p5137
I106
sg33
g4167
sg64
g65
sS'trial_loop.thisIndex'
p5138
g60
(g99
S'j\x00\x00\x00'
tRp5139
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5140
I0
sg3642
g4171
sS'block_loop.thisRepN'
p5141
I1
sg3645
g4167
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5142
I1
sg3647
g4174
sg55
g11
sS'block_loop.thisTrial'
p5143
Nsg70
Vn
sS'block_loop.thisTrialN'
p5144
I0
sg39
F0.63322241064088303
sg34
g753
(S'\x07\xdf\x07\x0b\x11\t0\n5H'
tRp5145
sa(dp5146
S'trial_loop.thisTrialN'
p5147
I107
sg3633
g3784
sS'block_loop.thisIndex'
p5148
g3627
sg38
S'left'
p5149
sg59
g63
sS'trial_loop.thisN'
p5150
I107
sg33
g3795
sg64
g65
sS'trial_loop.thisIndex'
p5151
g60
(g99
S'k\x00\x00\x00'
tRp5152
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5153
I0
sg3642
g3792
sS'block_loop.thisRepN'
p5154
I1
sg3645
g3788
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5155
I1
sg3647
g3795
sg55
g11
sS'block_loop.thisTrial'
p5156
Nsg70
Vn
sS'block_loop.thisTrialN'
p5157
I0
sg39
F0.79986531902250135
sg34
g753
(S'\x07\xdf\x07\x0b\x11\t6\x05\x10\xe0'
tRp5158
sa(dp5159
S'trial_loop.thisTrialN'
p5160
I108
sg3633
g3739
sS'block_loop.thisIndex'
p5161
g3627
sg38
S'right'
p5162
sg59
g63
sS'trial_loop.thisN'
p5163
I108
sg33
g3692
sg64
g65
sS'trial_loop.thisIndex'
p5164
g60
(g99
S'l\x00\x00\x00'
tRp5165
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5166
I0
sg3642
g3746
sS'block_loop.thisRepN'
p5167
I1
sg3645
g3692
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5168
I1
sg3647
g3699
sg55
g11
sS'block_loop.thisTrial'
p5169
Nsg70
Vn
sS'block_loop.thisTrialN'
p5170
I0
sg39
F0.66666457593601081
sg34
g753
(S'\x07\xdf\x07\x0b\x11\n\x00\x02\x88p'
tRp5171
sa(dp5172
S'trial_loop.thisTrialN'
p5173
I109
sg3633
g3976
sS'block_loop.thisIndex'
p5174
g3627
sg38
S'left'
p5175
sg59
g63
sS'trial_loop.thisN'
p5176
I109
sg33
g3956
sg64
g65
sS'trial_loop.thisIndex'
p5177
g60
(g99
S'm\x00\x00\x00'
tRp5178
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5179
I0
sg3642
g3983
sS'block_loop.thisRepN'
p5180
I1
sg3645
g3956
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5181
I1
sg3647
g3950
sg55
g11
sS'block_loop.thisTrial'
p5182
Nsg70
Vn
sS'block_loop.thisTrialN'
p5183
I0
sg39
F1.1332563374744495
sg34
g753
(S'\x07\xdf\x07\x0b\x11\n\x05\r]\xe0'
tRp5184
sa(dp5185
S'trial_loop.thisTrialN'
p5186
I110
sg3633
g4637
sS'block_loop.thisIndex'
p5187
g3627
sg38
S'left'
p5188
sg59
g63
sS'trial_loop.thisN'
p5189
I110
sg33
g4238
sg64
g65
sS'trial_loop.thisIndex'
p5190
g60
(g99
S'n\x00\x00\x00'
tRp5191
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5192
I0
sg3642
g4644
sS'block_loop.thisRepN'
p5193
I1
sg3645
g4238
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5194
I1
sg3647
g4245
sg55
g11
sS'block_loop.thisTrial'
p5195
Nsg70
Vn
sS'block_loop.thisTrialN'
p5196
I0
sg39
F0.78330417716279044
sg34
g753
(S'\x07\xdf\x07\x0b\x11\n\x0c\x00\x94p'
tRp5197
sa(dp5198
S'trial_loop.thisTrialN'
p5199
I111
sg3633
g3671
sS'block_loop.thisIndex'
p5200
g3627
sg38
S'left'
p5201
sg59
g63
sS'trial_loop.thisN'
p5202
I111
sg33
g3675
sg64
g65
sS'trial_loop.thisIndex'
p5203
g60
(g99
S'o\x00\x00\x00'
tRp5204
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5205
I0
sg3642
g3679
sS'block_loop.thisRepN'
p5206
I1
sg3645
g3675
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5207
I1
sg3647
g3682
sg55
g11
sS'block_loop.thisTrial'
p5208
Nsg70
Vn
sS'block_loop.thisTrialN'
p5209
I0
sg39
F0.65012510163796833
sg34
g753
(S'\x07\xdf\x07\x0b\x11\n\x11\r\x0f\xc0'
tRp5210
sa(dp5211
S'trial_loop.thisTrialN'
p5212
I112
sg3633
g3801
sS'block_loop.thisIndex'
p5213
g3627
sg38
S'right'
p5214
sg59
g63
sS'trial_loop.thisN'
p5215
I112
sg33
g3805
sg64
g65
sS'trial_loop.thisIndex'
p5216
g60
(g99
S'p\x00\x00\x00'
tRp5217
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5218
I0
sg3642
g3809
sS'block_loop.thisRepN'
p5219
I1
sg3645
g3805
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5220
I1
sg3647
g3812
sg55
g11
sS'block_loop.thisTrial'
p5221
Nsg70
Vn
sS'block_loop.thisTrialN'
p5222
I0
sg39
F0.73324385011801496
sg34
g753
(S'\x07\xdf\x07\x0b\x11\n\x17\x08)\xd8'
tRp5223
sa(dp5224
S'trial_loop.thisTrialN'
p5225
I113
sg3633
g4148
sS'block_loop.thisIndex'
p5226
g3627
sg38
S'left'
p5227
sg59
g63
sS'trial_loop.thisN'
p5228
I113
sg33
g3777
sg64
g65
sS'trial_loop.thisIndex'
p5229
g60
(g99
S'q\x00\x00\x00'
tRp5230
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5231
I0
sg3642
g4155
sS'block_loop.thisRepN'
p5232
I1
sg3645
g3777
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5233
I1
sg3647
g3771
sg55
g11
sS'block_loop.thisTrial'
p5234
Nsg70
Vn
sS'block_loop.thisTrialN'
p5235
I0
sg39
F0.6666400573849387
sg34
g753
(S'\x07\xdf\x07\x0b\x11\n\x1d\x04\xaf8'
tRp5236
sa(dp5237
S'trial_loop.thisTrialN'
p5238
I114
sg3633
g4475
sS'block_loop.thisIndex'
p5239
g3627
sg38
S'left'
p5240
sg59
g63
sS'trial_loop.thisN'
p5241
I114
sg33
g4097
sg64
g65
sS'trial_loop.thisIndex'
p5242
g60
(g99
S'r\x00\x00\x00'
tRp5243
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5244
I0
sg3642
g4482
sS'block_loop.thisRepN'
p5245
I1
sg3645
g4090
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5246
I1
sg3647
g4097
sg55
g11
sS'block_loop.thisTrial'
p5247
Nsg70
Vn
sS'block_loop.thisTrialN'
p5248
I0
sg39
F0.69989605274167843
sg34
g753
(S'\x07\xdf\x07\x0b\x11\n#\x00\x03\xe8'
tRp5249
sa(dp5250
S'trial_loop.thisTrialN'
p5251
I115
sg3633
g3722
sS'block_loop.thisIndex'
p5252
g3627
sg38
S'left'
p5253
sg59
g63
sS'trial_loop.thisN'
p5254
I115
sg33
g3726
sg64
g65
sS'trial_loop.thisIndex'
p5255
g60
(g99
S's\x00\x00\x00'
tRp5256
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5257
I0
sg3642
g3730
sS'block_loop.thisRepN'
p5258
I1
sg3645
g3726
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5259
I1
sg3647
g3733
sg55
g11
sS'block_loop.thisTrial'
p5260
Nsg70
Vn
sS'block_loop.thisTrialN'
p5261
I0
sg39
F0.68323427077848464
sg34
g753
(S'\x07\xdf\x07\x0b\x11\n(\x0bRp'
tRp5262
sa(dp5263
S'trial_loop.thisTrialN'
p5264
I116
sg3633
g4103
sS'block_loop.thisIndex'
p5265
g3627
sg38
S'right'
p5266
sg59
g63
sS'trial_loop.thisN'
p5267
I116
sg33
g3871
sg64
g65
sS'trial_loop.thisIndex'
p5268
g60
(g99
S't\x00\x00\x00'
tRp5269
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5270
I0
sg3642
g4110
sS'block_loop.thisRepN'
p5271
I1
sg3645
g3871
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5272
I1
sg3647
g3878
sg55
g11
sS'block_loop.thisTrial'
p5273
Nsg70
Vn
sS'block_loop.thisTrialN'
p5274
I0
sg39
F1.0499822097954166
sg34
g753
(S'\x07\xdf\x07\x0b\x11\n.\x06\xe1\xb8'
tRp5275
sa(dp5276
S'trial_loop.thisTrialN'
p5277
I117
sg3633
g4637
sS'block_loop.thisIndex'
p5278
g3627
sg38
S'left'
p5279
sg59
g63
sS'trial_loop.thisN'
p5280
I117
sg33
g4245
sg64
g65
sS'trial_loop.thisIndex'
p5281
g60
(g99
S'u\x00\x00\x00'
tRp5282
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5283
I0
sg3642
g4644
sS'block_loop.thisRepN'
p5284
I1
sg3645
g4238
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5285
I1
sg3647
g4245
sg55
g11
sS'block_loop.thisTrial'
p5286
Nsg70
Vn
sS'block_loop.thisTrialN'
p5287
I0
sg39
F0.70035962444308097
sg34
g753
(S'\x07\xdf\x07\x0b\x11\n4\x08)\xd8'
tRp5288
sa(dp5289
S'trial_loop.thisTrialN'
p5290
I118
sg3633
g4899
sS'block_loop.thisIndex'
p5291
g3627
sg38
S'left'
p5292
sg59
g63
sS'trial_loop.thisN'
p5293
I118
sg33
g3837
sg64
g65
sS'trial_loop.thisIndex'
p5294
g60
(g99
S'v\x00\x00\x00'
tRp5295
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5296
I0
sg3642
g4906
sS'block_loop.thisRepN'
p5297
I1
sg3645
g3837
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5298
I1
sg3647
g3844
sg55
g11
sS'block_loop.thisTrial'
p5299
Nsg70
Vn
sS'block_loop.thisTrialN'
p5300
I0
sg39
F0.63332618684216868
sg34
g753
(S'\x07\xdf\x07\x0b\x11\n:\x046 '
tRp5301
sa(dp5302
S'trial_loop.thisTrialN'
p5303
I119
sg3633
g4335
sS'block_loop.thisIndex'
p5304
g3627
sg38
S'right'
p5305
sg59
g63
sS'trial_loop.thisN'
p5306
I119
sg33
g4301
sg64
g65
sS'trial_loop.thisIndex'
p5307
g60
(g99
S'w\x00\x00\x00'
tRp5308
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5309
I0
sg3642
g4342
sS'block_loop.thisRepN'
p5310
I1
sg3645
g4294
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5311
I1
sg3647
g4301
sg55
g11
sS'block_loop.thisTrial'
p5312
Nsg70
Vn
sS'block_loop.thisTrialN'
p5313
I0
sg39
F0.61666212408454157
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x0b\x03\x0eS\xf8'
tRp5314
sa(dp5315
S'trial_loop.thisTrialN'
p5316
I120
sg3633
g4103
sS'block_loop.thisIndex'
p5317
g3627
sg38
S'right'
p5318
sg59
g63
sS'trial_loop.thisN'
p5319
I120
sg33
g3871
sg64
g65
sS'trial_loop.thisIndex'
p5320
g60
(g99
S'x\x00\x00\x00'
tRp5321
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5322
I0
sg3642
g4110
sS'block_loop.thisRepN'
p5323
I1
sg3645
g3871
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5324
I1
sg3647
g3878
sg55
g11
sS'block_loop.thisTrial'
p5325
Nsg70
Vn
sS'block_loop.thisTrialN'
p5326
I0
sg39
F0.74998774072446395
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x0b\t\x08\xf1\x10'
tRp5327
sa(dp5328
S'trial_loop.thisTrialN'
p5329
I121
sg3633
g3722
sS'block_loop.thisIndex'
p5330
g3627
sg38
S'left'
p5331
sg59
g63
sS'trial_loop.thisN'
p5332
I121
sg33
g3733
sg64
g65
sS'trial_loop.thisIndex'
p5333
g60
(g99
S'y\x00\x00\x00'
tRp5334
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5335
I0
sg3642
g3730
sS'block_loop.thisRepN'
p5336
I1
sg3645
g3726
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5337
I1
sg3647
g3733
sg55
g11
sS'block_loop.thisTrial'
p5338
Nsg70
Vn
sS'block_loop.thisTrialN'
p5339
I0
sg39
F0.61653924621714395
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x0b\x0f\x05\xb4\xf0'
tRp5340
sa(dp5341
S'trial_loop.thisTrialN'
p5342
I122
sg3633
g4490
sS'block_loop.thisIndex'
p5343
g3627
sg38
S'right'
p5344
sg59
g63
sS'trial_loop.thisN'
p5345
I122
sg33
g3682
sg64
g65
sS'trial_loop.thisIndex'
p5346
g60
(g99
S'z\x00\x00\x00'
tRp5347
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5348
I0
sg3642
g4497
sS'block_loop.thisRepN'
p5349
I1
sg3645
g3675
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5350
I1
sg3647
g3682
sg55
g11
sS'block_loop.thisTrial'
p5351
Nsg70
Vn
sS'block_loop.thisTrialN'
p5352
I0
sg39
F0.73306081627379172
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x0b\x15\x00R\x08'
tRp5353
sa(dp5354
S'trial_loop.thisTrialN'
p5355
I123
sg3633
g4378
sS'block_loop.thisIndex'
p5356
g3627
sg38
S'right'
p5357
sg59
g63
sS'trial_loop.thisN'
p5358
I123
sg33
g3726
sg64
g65
sS'trial_loop.thisIndex'
p5359
g60
(g99
S'{\x00\x00\x00'
tRp5360
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5361
I0
sg3642
g4385
sS'block_loop.thisRepN'
p5362
I1
sg3645
g3726
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5363
I1
sg3647
g3733
sg55
g11
sS'block_loop.thisTrial'
p5364
Nsg70
Vn
sS'block_loop.thisTrialN'
p5365
I0
sg39
F0.55034656688803807
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x0b\x1a\x0c\x19\xa8'
tRp5366
sa(dp5367
S'trial_loop.thisTrialN'
p5368
I124
sg3633
g4163
sS'block_loop.thisIndex'
p5369
g3627
sg38
S'right'
p5370
sg59
g63
sS'trial_loop.thisN'
p5371
I124
sg33
g4167
sg64
g65
sS'trial_loop.thisIndex'
p5372
g60
(g99
S'|\x00\x00\x00'
tRp5373
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5374
I0
sg3642
g4171
sS'block_loop.thisRepN'
p5375
I1
sg3645
g4167
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5376
I1
sg3647
g4174
sg55
g11
sS'block_loop.thisTrial'
p5377
Nsg70
Vn
sS'block_loop.thisTrialN'
p5378
I0
sg39
F0.69993625176357455
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x0b \x05\xc4\x90'
tRp5379
sa(dp5380
S'trial_loop.thisTrialN'
p5381
I125
sg3633
g4335
sS'block_loop.thisIndex'
p5382
g3627
sg38
S'right'
p5383
sg59
g63
sS'trial_loop.thisN'
p5384
I125
sg33
g4294
sg64
g65
sS'trial_loop.thisIndex'
p5385
g60
(g99
S'}\x00\x00\x00'
tRp5386
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5387
I0
sg3642
g4342
sS'block_loop.thisRepN'
p5388
I1
sg3645
g4294
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5389
I1
sg3647
g4301
sg55
g11
sS'block_loop.thisTrial'
p5390
Nsg70
Vn
sS'block_loop.thisTrialN'
p5391
I0
sg39
F0.55050394178397255
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x0b&\x01\x92X'
tRp5392
sa(dp5393
S'trial_loop.thisTrialN'
p5394
I126
sg3633
g4086
sS'block_loop.thisIndex'
p5395
g3627
sg38
S'right'
p5396
sg59
g63
sS'trial_loop.thisN'
p5397
I126
sg33
g4090
sg64
g65
sS'trial_loop.thisIndex'
p5398
g60
(g99
S'~\x00\x00\x00'
tRp5399
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5400
I0
sg3642
g4094
sS'block_loop.thisRepN'
p5401
I1
sg3645
g4090
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5402
I1
sg3647
g4097
sg55
g11
sS'block_loop.thisTrial'
p5403
Nsg70
Vn
sS'block_loop.thisTrialN'
p5404
I0
sg39
F0.71638677503506187
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x0b+\x0c)H'
tRp5405
sa(dp5406
S'trial_loop.thisTrialN'
p5407
I127
sg3633
g3801
sS'block_loop.thisIndex'
p5408
g3627
sg38
S'right'
p5409
sg59
g63
sS'trial_loop.thisN'
p5410
I127
sg33
g3805
sg64
g65
sS'trial_loop.thisIndex'
p5411
g60
(g99
S'\x7f\x00\x00\x00'
tRp5412
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5413
I0
sg3642
g3809
sS'block_loop.thisRepN'
p5414
I1
sg3645
g3805
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5415
I1
sg3647
g3812
sg55
g11
sS'block_loop.thisTrial'
p5416
Nsg70
Vn
sS'block_loop.thisTrialN'
p5417
I0
sg39
F0.63322326594061451
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x0b1\x085\x90'
tRp5418
sa(dp5419
S'trial_loop.thisTrialN'
p5420
I128
sg3633
g3931
sS'block_loop.thisIndex'
p5421
g3627
sg38
S'left'
p5422
sg59
g63
sS'trial_loop.thisN'
p5423
I128
sg33
g3638
sg64
g65
sS'trial_loop.thisIndex'
p5424
g60
(g99
S'\x80\x00\x00\x00'
tRp5425
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5426
I0
sg3642
g3938
sS'block_loop.thisRepN'
p5427
I1
sg3645
g3638
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5428
I1
sg3647
g3648
sg55
g11
sS'block_loop.thisTrial'
p5429
Nsg70
Vn
sS'block_loop.thisTrialN'
p5430
I0
sg39
F1.1832285687887634
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x0b7\x03\x11('
tRp5431
sa(dp5432
S'trial_loop.thisTrialN'
p5433
I129
sg3633
g3688
sS'block_loop.thisIndex'
p5434
g3627
sg38
S'left'
p5435
sg59
g63
sS'trial_loop.thisN'
p5436
I129
sg33
g3699
sg64
g65
sS'trial_loop.thisIndex'
p5437
g60
(g99
S'\x81\x00\x00\x00'
tRp5438
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5439
I0
sg3642
g3696
sS'block_loop.thisRepN'
p5440
I1
sg3645
g3692
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5441
I1
sg3647
g3699
sg55
g11
sS'block_loop.thisTrial'
p5442
Nsg70
Vn
sS'block_loop.thisTrialN'
p5443
I0
sg39
F0.83332487538427813
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x0c\x01\x06|('
tRp5444
sa(dp5445
S'trial_loop.thisTrialN'
p5446
I130
sg3633
g3867
sS'block_loop.thisIndex'
p5447
g3627
sg38
S'left'
p5448
sg59
g63
sS'trial_loop.thisN'
p5449
I130
sg33
g3871
sg64
g65
sS'trial_loop.thisIndex'
p5450
g60
(g99
S'\x82\x00\x00\x00'
tRp5451
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5452
I0
sg3642
g3875
sS'block_loop.thisRepN'
p5453
I1
sg3645
g3871
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5454
I1
sg3647
g3878
sg55
g11
sS'block_loop.thisTrial'
p5455
Nsg70
Vn
sS'block_loop.thisTrialN'
p5456
I0
sg39
F0.69989662294028676
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x0c\x07\x04p\xb8'
tRp5457
sa(dp5458
S'trial_loop.thisTrialN'
p5459
I131
sg3633
g4447
sS'block_loop.thisIndex'
p5460
g3627
sg38
S'left'
p5461
sg59
g63
sS'trial_loop.thisN'
p5462
I131
sg33
g4122
sg64
g65
sS'trial_loop.thisIndex'
p5463
g60
(g99
S'\x83\x00\x00\x00'
tRp5464
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5465
I0
sg3642
g4454
sS'block_loop.thisRepN'
p5466
I1
sg3645
g4122
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5467
I1
sg3647
g4129
sg55
g11
sS'block_loop.thisTrial'
p5468
Nsg70
Vn
sS'block_loop.thisTrialN'
p5469
I0
sg39
F0.71655526880931575
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x0c\r\x00>\x80'
tRp5470
sa(dp5471
S'trial_loop.thisTrialN'
p5472
I132
sg3633
g3688
sS'block_loop.thisIndex'
p5473
g3627
sg38
S'left'
p5474
sg59
g63
sS'trial_loop.thisN'
p5475
I132
sg33
g3692
sg64
g65
sS'trial_loop.thisIndex'
p5476
g60
(g99
S'\x84\x00\x00\x00'
tRp5477
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5478
I0
sg3642
g3696
sS'block_loop.thisRepN'
p5479
I1
sg3645
g3692
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5480
I1
sg3647
g3699
sg55
g11
sS'block_loop.thisTrial'
p5481
Nsg70
Vn
sS'block_loop.thisTrialN'
p5482
I0
sg39
F0.69998272297380026
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x0c\x12\x0b\xc7\xa0'
tRp5483
sa(dp5484
S'trial_loop.thisTrialN'
p5485
I133
sg3633
g4899
sS'block_loop.thisIndex'
p5486
g3627
sg38
S'left'
p5487
sg59
g63
sS'trial_loop.thisN'
p5488
I133
sg33
g3844
sg64
g65
sS'trial_loop.thisIndex'
p5489
g60
(g99
S'\x85\x00\x00\x00'
tRp5490
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5491
I0
sg3642
g4906
sS'block_loop.thisRepN'
p5492
I1
sg3645
g3837
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5493
I1
sg3647
g3844
sg55
g11
sS'block_loop.thisTrial'
p5494
Nsg70
Vn
sS'block_loop.thisTrialN'
p5495
I0
sg39
F0.71660915260508773
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x0c\x18\x07\x95h'
tRp5496
sa(dp5497
S'trial_loop.thisTrialN'
p5498
I134
sg3633
g4557
sS'block_loop.thisIndex'
p5499
g3627
sg38
S'left'
p5500
sg59
g63
sS'trial_loop.thisN'
p5501
I134
sg33
g3854
sg64
g65
sS'trial_loop.thisIndex'
p5502
g60
(g99
S'\x86\x00\x00\x00'
tRp5503
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5504
I0
sg3642
g4564
sS'block_loop.thisRepN'
p5505
I1
sg3645
g3854
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5506
I1
sg3647
g3861
sg55
g11
sS'block_loop.thisTrial'
p5507
Nsg70
Vn
sS'block_loop.thisTrialN'
p5508
I0
sg39
F0.69989861863359693
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x0c\x1e\x03\xe00'
tRp5509
sa(dp5510
S'trial_loop.thisTrialN'
p5511
I135
sg3633
g3931
sS'block_loop.thisIndex'
p5512
g3627
sg38
S'left'
p5513
sg59
g63
sS'trial_loop.thisN'
p5514
I135
sg33
g3648
sg64
g65
sS'trial_loop.thisIndex'
p5515
g60
(g99
S'\x87\x00\x00\x00'
tRp5516
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5517
I0
sg3642
g3938
sS'block_loop.thisRepN'
p5518
I1
sg3645
g3638
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5519
I1
sg3647
g3648
sg55
g11
sS'block_loop.thisTrial'
p5520
Nsg70
Vn
sS'block_loop.thisTrialN'
p5521
I0
sg39
F0.65001134695557994
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x0c#\x0f.\xb8'
tRp5522
sa(dp5523
S'trial_loop.thisTrialN'
p5524
I136
sg3633
g3784
sS'block_loop.thisIndex'
p5525
g3627
sg38
S'left'
p5526
sg59
g63
sS'trial_loop.thisN'
p5527
I136
sg33
g3788
sg64
g65
sS'trial_loop.thisIndex'
p5528
g60
(g99
S'\x88\x00\x00\x00'
tRp5529
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5530
I0
sg3642
g3792
sS'block_loop.thisRepN'
p5531
I1
sg3645
g3788
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5532
I1
sg3647
g3795
sg55
g11
sS'block_loop.thisTrial'
p5533
Nsg70
Vn
sS'block_loop.thisTrialN'
p5534
I0
sg39
F1.2832160814323288
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x0c)\nD\xe8'
tRp5535
sa(dp5536
S'trial_loop.thisTrialN'
p5537
I137
sg3633
g4637
sS'block_loop.thisIndex'
p5538
g3627
sg38
S'left'
p5539
sg59
g63
sS'trial_loop.thisN'
p5540
I137
sg33
g4238
sg64
g65
sS'trial_loop.thisIndex'
p5541
g60
(g99
S'\x89\x00\x00\x00'
tRp5542
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5543
I0
sg3642
g4644
sS'block_loop.thisRepN'
p5544
I1
sg3645
g4238
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5545
I1
sg3647
g4245
sg55
g11
sS'block_loop.thisTrial'
p5546
Nsg70
Vn
sS'block_loop.thisTrialN'
p5547
I0
sg39
F0.64995717806232278
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x0c/\x0f\x1f\x18'
tRp5548
sa(dp5549
S'trial_loop.thisTrialN'
p5550
I138
sg3633
g3901
sS'block_loop.thisIndex'
p5551
g3627
sg38
S'left'
p5552
sg59
g63
sS'trial_loop.thisN'
p5553
I138
sg33
g3805
sg64
g65
sS'trial_loop.thisIndex'
p5554
g60
(g99
S'\x8a\x00\x00\x00'
tRp5555
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5556
I0
sg3642
g3908
sS'block_loop.thisRepN'
p5557
I1
sg3645
g3805
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5558
I1
sg3647
g3812
sg55
g11
sS'block_loop.thisTrial'
p5559
Nsg70
Vn
sS'block_loop.thisTrialN'
p5560
I0
sg39
F0.66660898154441384
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x0c5\n90'
tRp5561
sa(dp5562
S'trial_loop.thisTrialN'
p5563
I139
sg3633
g4234
sS'block_loop.thisIndex'
p5564
g3627
sg38
S'right'
p5565
sg59
g63
sS'trial_loop.thisN'
p5566
I139
sg33
g4238
sg64
g65
sS'trial_loop.thisIndex'
p5567
g60
(g99
S'\x8b\x00\x00\x00'
tRp5568
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5569
I0
sg3642
g4242
sS'block_loop.thisRepN'
p5570
I1
sg3645
g4238
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5571
I1
sg3647
g4245
sg55
g11
sS'block_loop.thisTrial'
p5572
Nsg70
Vn
sS'block_loop.thisTrialN'
p5573
I0
sg39
F0.61667694925199612
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x0c;\x05\x8d\xe0'
tRp5574
sa(dp5575
S'trial_loop.thisTrialN'
p5576
I140
sg3633
g3688
sS'block_loop.thisIndex'
p5577
g3627
sg38
S'left'
p5578
sg59
g63
sS'trial_loop.thisN'
p5579
I140
sg33
g3692
sg64
g65
sS'trial_loop.thisIndex'
p5580
g60
(g99
S'\x8c\x00\x00\x00'
tRp5581
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5582
I0
sg3642
g3696
sS'block_loop.thisRepN'
p5583
I1
sg3645
g3692
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5584
I1
sg3647
g3699
sg55
g11
sS'block_loop.thisTrial'
p5585
Nsg70
Vn
sS'block_loop.thisTrialN'
p5586
I0
sg39
F0.76654517628776375
sg34
g753
(S'\x07\xdf\x07\x0b\x11\r\x05\x00e\x90'
tRp5587
sa(dp5588
S'trial_loop.thisTrialN'
p5589
I141
sg3633
g4335
sS'block_loop.thisIndex'
p5590
g3627
sg38
S'right'
p5591
sg59
g63
sS'trial_loop.thisN'
p5592
I141
sg33
g4294
sg64
g65
sS'trial_loop.thisIndex'
p5593
g60
(g99
S'\x8d\x00\x00\x00'
tRp5594
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5595
I0
sg3642
g4342
sS'block_loop.thisRepN'
p5596
I1
sg3645
g4294
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5597
I1
sg3647
g4301
sg55
g11
sS'block_loop.thisTrial'
p5598
Nsg70
Vn
sS'block_loop.thisTrialN'
p5599
I0
sg39
F0.61665841778813046
sg34
g753
(S'\x07\xdf\x07\x0b\x11\r\n\x0ck\xb0'
tRp5600
sa(dp5601
S'trial_loop.thisTrialN'
p5602
I142
sg3633
g3867
sS'block_loop.thisIndex'
p5603
g3627
sg38
S'left'
p5604
sg59
g63
sS'trial_loop.thisN'
p5605
I142
sg33
g3871
sg64
g65
sS'trial_loop.thisIndex'
p5606
g60
(g99
S'\x8e\x00\x00\x00'
tRp5607
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5608
I0
sg3642
g3875
sS'block_loop.thisRepN'
p5609
I1
sg3645
g3871
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5610
I1
sg3647
g3878
sg55
g11
sS'block_loop.thisTrial'
p5611
Nsg70
Vn
sS'block_loop.thisTrialN'
p5612
I0
sg39
F0.79990637334049097
sg34
g753
(S'\x07\xdf\x07\x0b\x11\r\x10\x07GH'
tRp5613
sa(dp5614
S'trial_loop.thisTrialN'
p5615
I143
sg3633
g3634
sS'block_loop.thisIndex'
p5616
g3627
sg38
S'right'
p5617
sg59
g63
sS'trial_loop.thisN'
p5618
I143
sg33
g3638
sg64
g65
sS'trial_loop.thisIndex'
p5619
g60
(g99
S'\x8f\x00\x00\x00'
tRp5620
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5621
I0
sg3642
g3643
sS'block_loop.thisRepN'
p5622
I1
sg3645
g3638
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5623
I1
sg3647
g3648
sg55
g11
sS'block_loop.thisTrial'
p5624
Nsg70
Vn
sS'block_loop.thisTrialN'
p5625
I0
sg39
F0.79992718560242793
sg34
g753
(S'\x07\xdf\x07\x0b\x11\r\x16\x04\xbe\xd8'
tRp5626
sa(dp5627
S'trial_loop.thisTrialN'
p5628
I144
sg3633
g3884
sS'block_loop.thisIndex'
p5629
g3627
sg38
S'left'
p5630
sg59
g63
sS'trial_loop.thisN'
p5631
I144
sg33
g3895
sg64
g65
sS'trial_loop.thisIndex'
p5632
g60
(g99
S'\x90\x00\x00\x00'
tRp5633
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5634
I0
sg3642
g3892
sS'block_loop.thisRepN'
p5635
I1
sg3645
g3888
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5636
I1
sg3647
g3895
sg55
g11
sS'block_loop.thisTrial'
p5637
Nsg70
Vn
sS'block_loop.thisTrialN'
p5638
I0
sg39
F1.3666561369936971
sg34
g753
(S'\x07\xdf\x07\x0b\x11\r\x1c\x01\xfb\xd0'
tRp5639
sa(dp5640
S'trial_loop.thisTrialN'
p5641
I145
sg3633
g3916
sS'block_loop.thisIndex'
p5642
g3627
sg38
S'left'
p5643
sg59
g63
sS'trial_loop.thisN'
p5644
I145
sg33
g3716
sg64
g65
sS'trial_loop.thisIndex'
p5645
g60
(g99
S'\x91\x00\x00\x00'
tRp5646
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5647
I0
sg3642
g3923
sS'block_loop.thisRepN'
p5648
I1
sg3645
g3709
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5649
I1
sg3647
g3716
sg55
g11
sS'block_loop.thisTrial'
p5650
Nsg70
Vn
sS'block_loop.thisTrialN'
p5651
I0
sg39
F0.66669166038627736
sg34
g753
(S'\x07\xdf\x07\x0b\x11\r"\x08E0'
tRp5652
sa(dp5653
S'trial_loop.thisTrialN'
p5654
I146
sg3633
g4290
sS'block_loop.thisIndex'
p5655
g3627
sg38
S'left'
p5656
sg59
g63
sS'trial_loop.thisN'
p5657
I146
sg33
g4301
sg64
g65
sS'trial_loop.thisIndex'
p5658
g60
(g99
S'\x92\x00\x00\x00'
tRp5659
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5660
I0
sg3642
g4298
sS'block_loop.thisRepN'
p5661
I1
sg3645
g4294
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5662
I1
sg3647
g4301
sg55
g11
sS'block_loop.thisTrial'
p5663
Nsg70
Vn
sS'block_loop.thisTrialN'
p5664
I0
sg39
F0.53331273014555336
sg34
g753
(S'\x07\xdf\x07\x0b\x11\r(\x03\x99\xe0'
tRp5665
sa(dp5666
S'trial_loop.thisTrialN'
p5667
I147
sg3633
g4193
sS'block_loop.thisIndex'
p5668
g3627
sg38
S'right'
p5669
sg59
g63
sS'trial_loop.thisN'
p5670
I147
sg33
g3888
sg64
g65
sS'trial_loop.thisIndex'
p5671
g60
(g99
S'\x93\x00\x00\x00'
tRp5672
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5673
I0
sg3642
g4200
sS'block_loop.thisRepN'
p5674
I1
sg3645
g3888
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5675
I1
sg3647
g3895
sg55
g11
sS'block_loop.thisTrial'
p5676
Nsg70
Vn
sS'block_loop.thisTrialN'
p5677
I0
sg39
F0.61658771312431782
sg34
g753
(S'\x07\xdf\x07\x0b\x11\r-\x0cH\x88'
tRp5678
sa(dp5679
S'trial_loop.thisTrialN'
p5680
I148
sg3633
g4148
sS'block_loop.thisIndex'
p5681
g3627
sg38
S'left'
p5682
sg59
g63
sS'trial_loop.thisN'
p5683
I148
sg33
g3777
sg64
g65
sS'trial_loop.thisIndex'
p5684
g60
(g99
S'\x94\x00\x00\x00'
tRp5685
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5686
I0
sg3642
g4155
sS'block_loop.thisRepN'
p5687
I1
sg3645
g3777
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5688
I1
sg3647
g3771
sg55
g11
sS'block_loop.thisTrial'
p5689
Nsg70
Vn
sS'block_loop.thisTrialN'
p5690
I0
sg39
F0.61659027901987429
sg34
g753
(S'\x07\xdf\x07\x0b\x11\r3\x06\xe5\xa0'
tRp5691
sa(dp5692
S'trial_loop.thisTrialN'
p5693
I149
sg3633
g3976
sS'block_loop.thisIndex'
p5694
g3627
sg38
S'left'
p5695
sg59
g63
sS'trial_loop.thisN'
p5696
I149
sg33
g3956
sg64
g65
sS'trial_loop.thisIndex'
p5697
g60
(g99
S'\x95\x00\x00\x00'
tRp5698
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5699
I0
sg3642
g3983
sS'block_loop.thisRepN'
p5700
I1
sg3645
g3956
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5701
I1
sg3647
g3950
sg55
g11
sS'block_loop.thisTrial'
p5702
Nsg70
Vn
sS'block_loop.thisTrialN'
p5703
I0
sg39
F0.98319965970586054
sg34
g753
(S'\x07\xdf\x07\x0b\x11\r9\x01\x82\xb8'
tRp5704
sa(dp5705
S'trial_loop.thisTrialN'
p5706
I150
sg3633
g4447
sS'block_loop.thisIndex'
p5707
g3627
sg38
S'left'
p5708
sg59
g63
sS'trial_loop.thisN'
p5709
I150
sg33
g4122
sg64
g65
sS'trial_loop.thisIndex'
p5710
g60
(g99
S'\x96\x00\x00\x00'
tRp5711
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5712
I0
sg3642
g4454
sS'block_loop.thisRepN'
p5713
I1
sg3645
g4122
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5714
I1
sg3647
g4129
sg55
g11
sS'block_loop.thisTrial'
p5715
Nsg70
Vn
sS'block_loop.thisTrialN'
p5716
I0
sg39
F0.7665976345888339
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x0e\x03\x01\xd8\xa8'
tRp5717
sa(dp5718
S'trial_loop.thisTrialN'
p5719
I151
sg3633
g3654
sS'block_loop.thisIndex'
p5720
g3627
sg38
S'left'
p5721
sg59
g63
sS'trial_loop.thisN'
p5722
I151
sg33
g3658
sg64
g65
sS'trial_loop.thisIndex'
p5723
g60
(g99
S'\x97\x00\x00\x00'
tRp5724
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5725
I0
sg3642
g3662
sS'block_loop.thisRepN'
p5726
I1
sg3645
g3658
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5727
I1
sg3647
g3665
sg55
g11
sS'block_loop.thisTrial'
p5728
Nsg70
Vn
sS'block_loop.thisTrialN'
p5729
I0
sg39
F0.6998860742605757
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x0e\x08\x0e\x19`'
tRp5730
sa(dp5731
S'trial_loop.thisTrialN'
p5732
I152
sg3633
g4163
sS'block_loop.thisIndex'
p5733
g3627
sg38
S'right'
p5734
sg59
g63
sS'trial_loop.thisN'
p5735
I152
sg33
g4167
sg64
g65
sS'trial_loop.thisIndex'
p5736
g60
(g99
S'\x98\x00\x00\x00'
tRp5737
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5738
I0
sg3642
g4171
sS'block_loop.thisRepN'
p5739
I1
sg3645
g4167
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5740
I1
sg3647
g4174
sg55
g11
sS'block_loop.thisTrial'
p5741
Nsg70
Vn
sS'block_loop.thisTrialN'
p5742
I0
sg39
F0.70003746206930373
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x0e\x0e\t\xe7('
tRp5743
sa(dp5744
S'trial_loop.thisTrialN'
p5745
I153
sg3633
g3833
sS'block_loop.thisIndex'
p5746
g3627
sg38
S'right'
p5747
sg59
g63
sS'trial_loop.thisN'
p5748
I153
sg33
g3837
sg64
g65
sS'trial_loop.thisIndex'
p5749
g60
(g99
S'\x99\x00\x00\x00'
tRp5750
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5751
I0
sg3642
g3841
sS'block_loop.thisRepN'
p5752
I1
sg3645
g3837
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5753
I1
sg3647
g3844
sg55
g11
sS'block_loop.thisTrial'
p5754
Nsg70
Vn
sS'block_loop.thisTrialN'
p5755
I0
sg39
F0.75039087134427973
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x0e\x14\x05\xf3p'
tRp5756
sa(dp5757
S'trial_loop.thisTrialN'
p5758
I154
sg3633
g3767
sS'block_loop.thisIndex'
p5759
g3627
sg38
S'right'
p5760
sg59
g63
sS'trial_loop.thisN'
p5761
I154
sg33
g3777
sg64
g65
sS'trial_loop.thisIndex'
p5762
g60
(g99
S'\x9a\x00\x00\x00'
tRp5763
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5764
I0
sg3642
g3775
sS'block_loop.thisRepN'
p5765
I1
sg3645
g3777
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5766
I1
sg3647
g3771
sg55
g11
sS'block_loop.thisTrial'
p5767
Nsg70
Vn
sS'block_loop.thisTrialN'
p5768
I0
sg39
F0.8999942409900541
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x0e\x1a\x02\xb7P'
tRp5769
sa(dp5770
S'trial_loop.thisTrialN'
p5771
I155
sg3633
g3801
sS'block_loop.thisIndex'
p5772
g3627
sg38
S'right'
p5773
sg59
g63
sS'trial_loop.thisN'
p5774
I155
sg33
g3805
sg64
g65
sS'trial_loop.thisIndex'
p5775
g60
(g99
S'\x9b\x00\x00\x00'
tRp5776
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5777
I0
sg3642
g3809
sS'block_loop.thisRepN'
p5778
I1
sg3645
g3805
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5779
I1
sg3647
g3812
sg55
g11
sS'block_loop.thisTrial'
p5780
Nsg70
Vn
sS'block_loop.thisTrialN'
p5781
I0
sg39
F0.63319960268563591
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x0e \x01\x9e\x10'
tRp5782
sa(dp5783
S'trial_loop.thisTrialN'
p5784
I156
sg3633
g3739
sS'block_loop.thisIndex'
p5785
g3627
sg38
S'right'
p5786
sg59
g63
sS'trial_loop.thisN'
p5787
I156
sg33
g3692
sg64
g65
sS'trial_loop.thisIndex'
p5788
g60
(g99
S'\x9c\x00\x00\x00'
tRp5789
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5790
I0
sg3642
g3746
sS'block_loop.thisRepN'
p5791
I1
sg3645
g3692
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5792
I1
sg3647
g3699
sg55
g11
sS'block_loop.thisTrial'
p5793
Nsg70
Vn
sS'block_loop.thisTrialN'
p5794
I0
sg39
F0.68322799859015504
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x0e%\x0b\xbb\xe8'
tRp5795
sa(dp5796
S'trial_loop.thisTrialN'
p5797
I157
sg3633
g4118
sS'block_loop.thisIndex'
p5798
g3627
sg38
S'right'
p5799
sg59
g63
sS'trial_loop.thisN'
p5800
I157
sg33
g4122
sg64
g65
sS'trial_loop.thisIndex'
p5801
g60
(g99
S'\x9d\x00\x00\x00'
tRp5802
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5803
I0
sg3642
g4126
sS'block_loop.thisRepN'
p5804
I1
sg3645
g4122
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5805
I1
sg3647
g4129
sg55
g11
sS'block_loop.thisTrial'
p5806
Nsg70
Vn
sS'block_loop.thisTrialN'
p5807
I0
sg39
F0.69999013555934653
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x0e+\x07\x89\xb0'
tRp5808
sa(dp5809
S'trial_loop.thisTrialN'
p5810
I158
sg3633
g4193
sS'block_loop.thisIndex'
p5811
g3627
sg38
S'right'
p5812
sg59
g63
sS'trial_loop.thisN'
p5813
I158
sg33
g3888
sg64
g65
sS'trial_loop.thisIndex'
p5814
g60
(g99
S'\x9e\x00\x00\x00'
tRp5815
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5816
I0
sg3642
g4200
sS'block_loop.thisRepN'
p5817
I1
sg3645
g3888
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5818
I1
sg3647
g3895
sg55
g11
sS'block_loop.thisTrial'
p5819
Nsg70
Vn
sS'block_loop.thisTrialN'
p5820
I0
sg39
F0.71659860392537666
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x0e1\x03Wx'
tRp5821
sa(dp5822
S'trial_loop.thisTrialN'
p5823
I159
sg3633
g3654
sS'block_loop.thisIndex'
p5824
g3627
sg38
S'left'
p5825
sg59
g63
sS'trial_loop.thisN'
p5826
I159
sg33
g3658
sg64
g65
sS'trial_loop.thisIndex'
p5827
g60
(g99
S'\x9f\x00\x00\x00'
tRp5828
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5829
I0
sg3642
g3662
sS'block_loop.thisRepN'
p5830
I1
sg3645
g3658
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5831
I1
sg3647
g3665
sg55
g11
sS'block_loop.thisTrial'
p5832
Nsg70
Vn
sS'block_loop.thisTrialN'
p5833
I0
sg39
F0.66660926664553699
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x0e6\x0e\xe0\x98'
tRp5834
sa(dp5835
S'trial_loop.thisTrialN'
p5836
I160
sg3633
g3884
sS'block_loop.thisIndex'
p5837
g3627
sg38
S'left'
p5838
sg59
g63
sS'trial_loop.thisN'
p5839
I160
sg33
g3895
sg64
g65
sS'trial_loop.thisIndex'
p5840
g60
(g99
S'\xa0\x00\x00\x00'
tRp5841
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5842
I0
sg3642
g3892
sS'block_loop.thisRepN'
p5843
I1
sg3645
g3888
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5844
I1
sg3647
g3895
sg55
g11
sS'block_loop.thisTrial'
p5845
Nsg70
Vn
sS'block_loop.thisTrialN'
p5846
I0
sg39
F0.56656245331760147
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x0f\x00\n5H'
tRp5847
sa(dp5848
S'trial_loop.thisTrialN'
p5849
I161
sg3633
g4234
sS'block_loop.thisIndex'
p5850
g3627
sg38
S'right'
p5851
sg59
g63
sS'trial_loop.thisN'
p5852
I161
sg33
g4238
sg64
g65
sS'trial_loop.thisIndex'
p5853
g60
(g99
S'\xa1\x00\x00\x00'
tRp5854
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5855
I0
sg3642
g4242
sS'block_loop.thisRepN'
p5856
I1
sg3645
g4238
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5857
I1
sg3647
g4245
sg55
g11
sS'block_loop.thisTrial'
p5858
Nsg70
Vn
sS'block_loop.thisTrialN'
p5859
I0
sg39
F0.68324111316542258
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x0f\x06\x04\x1e\xb0'
tRp5860
sa(dp5861
S'trial_loop.thisTrialN'
p5862
I162
sg3633
g4406
sS'block_loop.thisIndex'
p5863
g3627
sg38
S'left'
p5864
sg59
g63
sS'trial_loop.thisN'
p5865
I162
sg33
g4167
sg64
g65
sS'trial_loop.thisIndex'
p5866
g60
(g99
S'\xa2\x00\x00\x00'
tRp5867
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5868
I0
sg3642
g4413
sS'block_loop.thisRepN'
p5869
I1
sg3645
g4167
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5870
I1
sg3647
g4174
sg55
g11
sS'block_loop.thisTrial'
p5871
Nsg70
Vn
sS'block_loop.thisTrialN'
p5872
I0
sg39
F0.64988333730434533
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x0f\x0b\x0e\xf08'
tRp5873
sa(dp5874
S'trial_loop.thisTrialN'
p5875
I163
sg3633
g3767
sS'block_loop.thisIndex'
p5876
g3627
sg38
S'right'
p5877
sg59
g63
sS'trial_loop.thisN'
p5878
I163
sg33
g3777
sg64
g65
sS'trial_loop.thisIndex'
p5879
g60
(g99
S'\xa3\x00\x00\x00'
tRp5880
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5881
I0
sg3642
g3775
sS'block_loop.thisRepN'
p5882
I1
sg3645
g3777
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5883
I1
sg3647
g3771
sg55
g11
sS'block_loop.thisTrial'
p5884
Nsg70
Vn
sS'block_loop.thisTrialN'
p5885
I0
sg39
F0.6998986186372349
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x0f\x11\nD\xe8'
tRp5886
sa(dp5887
S'trial_loop.thisTrialN'
p5888
I164
sg3633
g4307
sS'block_loop.thisIndex'
p5889
g3627
sg38
S'left'
p5890
sg59
g63
sS'trial_loop.thisN'
p5891
I164
sg33
g4008
sg64
g65
sS'trial_loop.thisIndex'
p5892
g60
(g99
S'\xa4\x00\x00\x00'
tRp5893
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5894
I0
sg3642
g4314
sS'block_loop.thisRepN'
p5895
I1
sg3645
g4008
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5896
I1
sg3647
g4015
sg55
g11
sS'block_loop.thisTrial'
p5897
Nsg70
Vn
sS'block_loop.thisTrialN'
p5898
I0
sg39
F0.6998718192880915
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x0f\x17\x06\x16\x98'
tRp5899
sa(dp5900
S'trial_loop.thisTrialN'
p5901
I165
sg3633
g3850
sS'block_loop.thisIndex'
p5902
g3627
sg38
S'right'
p5903
sg59
g63
sS'trial_loop.thisN'
p5904
I165
sg33
g3854
sg64
g65
sS'trial_loop.thisIndex'
p5905
g60
(g99
S'\xa5\x00\x00\x00'
tRp5906
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5907
I0
sg3642
g3858
sS'block_loop.thisRepN'
p5908
I1
sg3645
g3854
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5909
I1
sg3647
g3861
sg55
g11
sS'block_loop.thisTrial'
p5910
Nsg70
Vn
sS'block_loop.thisTrialN'
p5911
I0
sg39
F0.71705305244540796
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x0f\x1d\x02\x1e\xf8'
tRp5912
sa(dp5913
S'trial_loop.thisTrialN'
p5914
I166
sg3633
g4490
sS'block_loop.thisIndex'
p5915
g3627
sg38
S'right'
p5916
sg59
g63
sS'trial_loop.thisN'
p5917
I166
sg33
g3675
sg64
g65
sS'trial_loop.thisIndex'
p5918
g60
(g99
S'\xa6\x00\x00\x00'
tRp5919
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5920
I0
sg3642
g4497
sS'block_loop.thisRepN'
p5921
I1
sg3645
g3675
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5922
I1
sg3647
g3682
sg55
g11
sS'block_loop.thisTrial'
p5923
Nsg70
Vn
sS'block_loop.thisTrialN'
p5924
I0
sg39
F0.71626731836659019
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x0f"\rm\x80'
tRp5925
sa(dp5926
S'trial_loop.thisTrialN'
p5927
I167
sg3633
g3867
sS'block_loop.thisIndex'
p5928
g3627
sg38
S'left'
p5929
sg59
g63
sS'trial_loop.thisN'
p5930
I167
sg33
g3871
sg64
g65
sS'trial_loop.thisIndex'
p5931
g60
(g99
S'\xa7\x00\x00\x00'
tRp5932
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5933
I0
sg3642
g3875
sS'block_loop.thisRepN'
p5934
I1
sg3645
g3871
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5935
I1
sg3647
g3878
sg55
g11
sS'block_loop.thisTrial'
p5936
Nsg70
Vn
sS'block_loop.thisTrialN'
p5937
I0
sg39
F0.61664074162399629
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x0f(\t\xb8H'
tRp5938
sa(dp5939
S'trial_loop.thisTrialN'
p5940
I168
sg3633
g4557
sS'block_loop.thisIndex'
p5941
g3627
sg38
S'left'
p5942
sg59
g63
sS'trial_loop.thisN'
p5943
I168
sg33
g3861
sg64
g65
sS'trial_loop.thisIndex'
p5944
g60
(g99
S'\xa8\x00\x00\x00'
tRp5945
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5946
I0
sg3642
g4564
sS'block_loop.thisRepN'
p5947
I1
sg3645
g3854
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5948
I1
sg3647
g3861
sg55
g11
sS'block_loop.thisTrial'
p5949
Nsg70
Vn
sS'block_loop.thisTrialN'
p5950
I0
sg39
F0.63320844076588401
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x0f.\x04U`'
tRp5951
sa(dp5952
S'trial_loop.thisTrialN'
p5953
I169
sg3633
g3818
sS'block_loop.thisIndex'
p5954
g3627
sg38
S'right'
p5955
sg59
g63
sS'trial_loop.thisN'
p5956
I169
sg33
g3658
sg64
g65
sS'trial_loop.thisIndex'
p5957
g60
(g99
S'\xa9\x00\x00\x00'
tRp5958
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5959
I0
sg3642
g3825
sS'block_loop.thisRepN'
p5960
I1
sg3645
g3658
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5961
I1
sg3647
g3665
sg55
g11
sS'block_loop.thisTrial'
p5962
Nsg70
Vn
sS'block_loop.thisTrialN'
p5963
I0
sg39
F0.69998785476491321
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x0f3\x0es8'
tRp5964
sa(dp5965
S'trial_loop.thisTrialN'
p5966
I170
sg3633
g3634
sS'block_loop.thisIndex'
p5967
g3627
sg38
S'right'
p5968
sg59
g63
sS'trial_loop.thisN'
p5969
I170
sg33
g3638
sg64
g65
sS'trial_loop.thisIndex'
p5970
g60
(g99
S'\xaa\x00\x00\x00'
tRp5971
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5972
I0
sg3642
g3643
sS'block_loop.thisRepN'
p5973
I1
sg3645
g3638
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5974
I1
sg3647
g3648
sg55
g11
sS'block_loop.thisTrial'
p5975
Nsg70
Vn
sS'block_loop.thisTrialN'
p5976
I0
sg39
F0.70000895212433534
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x0f9\n{\x98'
tRp5977
sa(dp5978
S'trial_loop.thisTrialN'
p5979
I171
sg3633
g3884
sS'block_loop.thisIndex'
p5980
g3627
sg38
S'left'
p5981
sg59
g63
sS'trial_loop.thisN'
p5982
I171
sg33
g3895
sg64
g65
sS'trial_loop.thisIndex'
p5983
g60
(g99
S'\xab\x00\x00\x00'
tRp5984
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5985
I0
sg3642
g3892
sS'block_loop.thisRepN'
p5986
I1
sg3645
g3888
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p5987
I1
sg3647
g3895
sg55
g11
sS'block_loop.thisTrial'
p5988
Nsg70
Vn
sS'block_loop.thisTrialN'
p5989
I0
sg39
F0.76675016279114061
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x10\x03\x06MH'
tRp5990
sa(dp5991
S'trial_loop.thisTrialN'
p5992
I172
sg3633
g3916
sS'block_loop.thisIndex'
p5993
g3627
sg38
S'left'
p5994
sg59
g63
sS'trial_loop.thisN'
p5995
I172
sg33
g3709
sg64
g65
sS'trial_loop.thisIndex'
p5996
g60
(g99
S'\xac\x00\x00\x00'
tRp5997
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p5998
I0
sg3642
g3923
sS'block_loop.thisRepN'
p5999
I1
sg3645
g3709
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6000
I1
sg3647
g3716
sg55
g11
sS'block_loop.thisTrial'
p6001
Nsg70
Vn
sS'block_loop.thisTrialN'
p6002
I0
sg39
F0.69989747823638027
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x10\t\x03K\xc0'
tRp6003
sa(dp6004
S'trial_loop.thisTrialN'
p6005
I173
sg3633
g3850
sS'block_loop.thisIndex'
p6006
g3627
sg38
S'right'
p6007
sg59
g63
sS'trial_loop.thisN'
p6008
I173
sg33
g3854
sg64
g65
sS'trial_loop.thisIndex'
p6009
g60
(g99
S'\xad\x00\x00\x00'
tRp6010
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6011
I0
sg3642
g3858
sS'block_loop.thisRepN'
p6012
I1
sg3645
g3854
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6013
I1
sg3647
g3861
sg55
g11
sS'block_loop.thisTrial'
p6014
Nsg70
Vn
sS'block_loop.thisTrialN'
p6015
I0
sg39
F0.64997599462731159
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x10\x0e\x0e\x9aH'
tRp6016
sa(dp6017
S'trial_loop.thisTrialN'
p6018
I174
sg3633
g4103
sS'block_loop.thisIndex'
p6019
g3627
sg38
S'right'
p6020
sg59
g63
sS'trial_loop.thisN'
p6021
I174
sg33
g3871
sg64
g65
sS'trial_loop.thisIndex'
p6022
g60
(g99
S'\xae\x00\x00\x00'
tRp6023
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6024
I0
sg3642
g4110
sS'block_loop.thisRepN'
p6025
I1
sg3645
g3871
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6026
I1
sg3647
g3878
sg55
g11
sS'block_loop.thisTrial'
p6027
Nsg70
Vn
sS'block_loop.thisTrialN'
p6028
I0
sg39
F0.73324898190912791
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x10\x14\t\xb0x'
tRp6029
sa(dp6030
S'trial_loop.thisTrialN'
p6031
I175
sg3633
g3818
sS'block_loop.thisIndex'
p6032
g3627
sg38
S'right'
p6033
sg59
g63
sS'trial_loop.thisN'
p6034
I175
sg33
g3658
sg64
g65
sS'trial_loop.thisIndex'
p6035
g60
(g99
S'\xaf\x00\x00\x00'
tRp6036
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6037
I0
sg3642
g3825
sS'block_loop.thisRepN'
p6038
I1
sg3645
g3658
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6039
I1
sg3647
g3665
sg55
g11
sS'block_loop.thisTrial'
p6040
Nsg70
Vn
sS'block_loop.thisTrialN'
p6041
I0
sg39
F0.68325935953180306
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x10\x1a\x065\xd8'
tRp6042
sa(dp6043
S'trial_loop.thisTrialN'
p6044
I176
sg3633
g3833
sS'block_loop.thisIndex'
p6045
g3627
sg38
S'right'
p6046
sg59
g63
sS'trial_loop.thisN'
p6047
I176
sg33
g3837
sg64
g65
sS'trial_loop.thisIndex'
p6048
g60
(g99
S'\xb0\x00\x00\x00'
tRp6049
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6050
I0
sg3642
g3841
sS'block_loop.thisRepN'
p6051
I1
sg3645
g3837
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6052
I1
sg3647
g3844
sg55
g11
sS'block_loop.thisTrial'
p6053
Nsg70
Vn
sS'block_loop.thisTrialN'
p6054
I0
sg39
F0.71661770558785065
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x10 \x01\xc9\x08'
tRp6055
sa(dp6056
S'trial_loop.thisTrialN'
p6057
I177
sg3633
g4307
sS'block_loop.thisIndex'
p6058
g3627
sg38
S'left'
p6059
sg59
g63
sS'trial_loop.thisN'
p6060
I177
sg33
g4008
sg64
g65
sS'trial_loop.thisIndex'
p6061
g60
(g99
S'\xb1\x00\x00\x00'
tRp6062
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6063
I0
sg3642
g4314
sS'block_loop.thisRepN'
p6064
I1
sg3645
g4008
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6065
I1
sg3647
g4015
sg55
g11
sS'block_loop.thisTrial'
p6066
Nsg70
Vn
sS'block_loop.thisTrialN'
p6067
I0
sg39
F0.66668823919098941
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x10%\rR('
tRp6068
sa(dp6069
S'trial_loop.thisTrialN'
p6070
I178
sg3633
g3833
sS'block_loop.thisIndex'
p6071
g3627
sg38
S'right'
p6072
sg59
g63
sS'trial_loop.thisN'
p6073
I178
sg33
g3844
sg64
g65
sS'trial_loop.thisIndex'
p6074
g60
(g99
S'\xb2\x00\x00\x00'
tRp6075
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6076
I0
sg3642
g3841
sS'block_loop.thisRepN'
p6077
I1
sg3645
g3837
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6078
I1
sg3647
g3844
sg55
g11
sS'block_loop.thisTrial'
p6079
Nsg70
Vn
sS'block_loop.thisTrialN'
p6080
I0
sg39
F0.6499238214273646
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x10+\x08\xa6\xd8'
tRp6081
sa(dp6082
S'trial_loop.thisTrialN'
p6083
I179
sg3633
g3784
sS'block_loop.thisIndex'
p6084
g3627
sg38
S'left'
p6085
sg59
g63
sS'trial_loop.thisN'
p6086
I179
sg33
g3788
sg64
g65
sS'trial_loop.thisIndex'
p6087
g60
(g99
S'\xb3\x00\x00\x00'
tRp6088
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6089
I0
sg3642
g3792
sS'block_loop.thisRepN'
p6090
I1
sg3645
g3788
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6091
I1
sg3647
g3795
sg55
g11
sS'block_loop.thisTrial'
p6092
Nsg70
Vn
sS'block_loop.thisTrialN'
p6093
I0
sg39
F1.3331794746627565
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x101\x03\xc0\xf0'
tRp6094
sa(dp6095
S'trial_loop.thisTrialN'
p6096
I180
sg3633
g4290
sS'block_loop.thisIndex'
p6097
g3627
sg38
S'left'
p6098
sg59
g63
sS'trial_loop.thisN'
p6099
I180
sg33
g4294
sg64
g65
sS'trial_loop.thisIndex'
p6100
g60
(g99
S'\xb4\x00\x00\x00'
tRp6101
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6102
I0
sg3642
g4298
sS'block_loop.thisRepN'
p6103
I1
sg3645
g4294
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6104
I1
sg3647
g4301
sg55
g11
sS'block_loop.thisTrial'
p6105
Nsg70
Vn
sS'block_loop.thisTrialN'
p6106
I0
sg39
F0.5832091250049416
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x107\t\x8dP'
tRp6107
sa(dp6108
S'trial_loop.thisTrialN'
p6109
I181
sg3633
g4406
sS'block_loop.thisIndex'
p6110
g3627
sg38
S'left'
p6111
sg59
g63
sS'trial_loop.thisN'
p6112
I181
sg33
g4174
sg64
g65
sS'trial_loop.thisIndex'
p6113
g60
(g99
S'\xb5\x00\x00\x00'
tRp6114
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6115
I0
sg3642
g4413
sS'block_loop.thisRepN'
p6116
I1
sg3645
g4167
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6117
I1
sg3647
g4174
sg55
g11
sS'block_loop.thisTrial'
p6118
Nsg70
Vn
sS'block_loop.thisTrialN'
p6119
I0
sg39
F0.66655253185308538
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x11\x01\x03\xb1P'
tRp6120
sa(dp6121
S'trial_loop.thisTrialN'
p6122
I182
sg3633
g4378
sS'block_loop.thisIndex'
p6123
g3627
sg38
S'right'
p6124
sg59
g63
sS'trial_loop.thisN'
p6125
I182
sg33
g3733
sg64
g65
sS'trial_loop.thisIndex'
p6126
g60
(g99
S'\xb6\x00\x00\x00'
tRp6127
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6128
I0
sg3642
g4385
sS'block_loop.thisRepN'
p6129
I1
sg3645
g3726
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6130
I1
sg3647
g3733
sg55
g11
sS'block_loop.thisTrial'
p6131
Nsg70
Vn
sS'block_loop.thisTrialN'
p6132
I0
sg39
F0.54999418396982946
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x11\x06\x0eH@'
tRp6133
sa(dp6134
S'trial_loop.thisTrialN'
p6135
I183
sg3633
g4557
sS'block_loop.thisIndex'
p6136
g3627
sg38
S'left'
p6137
sg59
g63
sS'trial_loop.thisN'
p6138
I183
sg33
g3854
sg64
g65
sS'trial_loop.thisIndex'
p6139
g60
(g99
S'\xb7\x00\x00\x00'
tRp6140
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6141
I0
sg3642
g4564
sS'block_loop.thisRepN'
p6142
I1
sg3645
g3854
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6143
I1
sg3647
g3861
sg55
g11
sS'block_loop.thisTrial'
p6144
Nsg70
Vn
sS'block_loop.thisTrialN'
p6145
I0
sg39
F0.5837091894391051
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x11\x0c\x07\xf3('
tRp6146
sa(dp6147
S'trial_loop.thisTrialN'
p6148
I184
sg3633
g3931
sS'block_loop.thisIndex'
p6149
g3627
sg38
S'left'
p6150
sg59
g63
sS'trial_loop.thisN'
p6151
I184
sg33
g3648
sg64
g65
sS'trial_loop.thisIndex'
p6152
g60
(g99
S'\xb8\x00\x00\x00'
tRp6153
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6154
I0
sg3642
g3938
sS'block_loop.thisRepN'
p6155
I1
sg3645
g3638
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6156
I1
sg3647
g3648
sg55
g11
sS'block_loop.thisTrial'
p6157
Nsg70
Vn
sS'block_loop.thisTrialN'
p6158
I0
sg39
F0.73328889582990087
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x11\x12\x02\x17('
tRp6159
sa(dp6160
S'trial_loop.thisTrialN'
p6161
I185
sg3633
g4118
sS'block_loop.thisIndex'
p6162
g3627
sg38
S'right'
p6163
sg59
g63
sS'trial_loop.thisN'
p6164
I185
sg33
g4122
sg64
g65
sS'trial_loop.thisIndex'
p6165
g60
(g99
S'\xb9\x00\x00\x00'
tRp6166
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6167
I0
sg3642
g4126
sS'block_loop.thisRepN'
p6168
I1
sg3645
g4122
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6169
I1
sg3647
g4129
sg55
g11
sS'block_loop.thisTrial'
p6170
Nsg70
Vn
sS'block_loop.thisTrialN'
p6171
I0
sg39
F0.64991897473737481
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x11\x17\r\xde\xc8'
tRp6172
sa(dp6173
S'trial_loop.thisTrialN'
p6174
I186
sg3633
g4307
sS'block_loop.thisIndex'
p6175
g3627
sg38
S'left'
p6176
sg59
g63
sS'trial_loop.thisN'
p6177
I186
sg33
g4008
sg64
g65
sS'trial_loop.thisIndex'
p6178
g60
(g99
S'\xba\x00\x00\x00'
tRp6179
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6180
I0
sg3642
g4314
sS'block_loop.thisRepN'
p6181
I1
sg3645
g4008
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6182
I1
sg3647
g4015
sg55
g11
sS'block_loop.thisTrial'
p6183
Nsg70
Vn
sS'block_loop.thisTrialN'
p6184
I0
sg39
F0.58321710779273417
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x11\x1d\x08\xf4\xf8'
tRp6185
sa(dp6186
S'trial_loop.thisTrialN'
p6187
I187
sg3633
g4899
sS'block_loop.thisIndex'
p6188
g3627
sg38
S'left'
p6189
sg59
g63
sS'trial_loop.thisN'
p6190
I187
sg33
g3837
sg64
g65
sS'trial_loop.thisIndex'
p6191
g60
(g99
S'\xbb\x00\x00\x00'
tRp6192
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6193
I0
sg3642
g4906
sS'block_loop.thisRepN'
p6194
I1
sg3645
g3837
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6195
I1
sg3647
g3844
sg55
g11
sS'block_loop.thisTrial'
p6196
Nsg70
Vn
sS'block_loop.thisTrialN'
p6197
I0
sg39
F0.73334163923209417
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x11#\x03\x18\xf8'
tRp6198
sa(dp6199
S'trial_loop.thisTrialN'
p6200
I188
sg3633
g4290
sS'block_loop.thisIndex'
p6201
g3627
sg38
S'left'
p6202
sg59
g63
sS'trial_loop.thisN'
p6203
I188
sg33
g4294
sg64
g65
sS'trial_loop.thisIndex'
p6204
g60
(g99
S'\xbc\x00\x00\x00'
tRp6205
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6206
I0
sg3642
g4298
sS'block_loop.thisRepN'
p6207
I1
sg3645
g4294
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6208
I1
sg3647
g4301
sg55
g11
sS'block_loop.thisTrial'
p6209
Nsg70
Vn
sS'block_loop.thisTrialN'
p6210
I0
sg39
F0.56659181855866336
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x11(\x0e\xe0\x98'
tRp6211
sa(dp6212
S'trial_loop.thisTrialN'
p6213
I189
sg3633
g4490
sS'block_loop.thisIndex'
p6214
g3627
sg38
S'right'
p6215
sg59
g63
sS'trial_loop.thisN'
p6216
I189
sg33
g3682
sg64
g65
sS'trial_loop.thisIndex'
p6217
g60
(g99
S'\xbd\x00\x00\x00'
tRp6218
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6219
I0
sg3642
g4497
sS'block_loop.thisRepN'
p6220
I1
sg3645
g3675
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6221
I1
sg3647
g3682
sg55
g11
sS'block_loop.thisTrial'
p6222
Nsg70
Vn
sS'block_loop.thisTrialN'
p6223
I0
sg39
F0.71612049215036677
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x11.\x08\x8b\x80'
tRp6224
sa(dp6225
S'trial_loop.thisTrialN'
p6226
I190
sg3633
g4406
sS'block_loop.thisIndex'
p6227
g3627
sg38
S'left'
p6228
sg59
g63
sS'trial_loop.thisN'
p6229
I190
sg33
g4167
sg64
g65
sS'trial_loop.thisIndex'
p6230
g60
(g99
S'\xbe\x00\x00\x00'
tRp6231
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6232
I0
sg3642
g4413
sS'block_loop.thisRepN'
p6233
I1
sg3645
g4167
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6234
I1
sg3647
g4174
sg55
g11
sS'block_loop.thisTrial'
p6235
Nsg70
Vn
sS'block_loop.thisTrialN'
p6236
I0
sg39
F0.60002257987798657
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x114\x04\xd2`'
tRp6237
sa(dp6238
S'trial_loop.thisTrialN'
p6239
I191
sg3633
g4363
sS'block_loop.thisIndex'
p6240
g3627
sg38
S'right'
p6241
sg59
g63
sS'trial_loop.thisN'
p6242
I191
sg33
g3788
sg64
g65
sS'trial_loop.thisIndex'
p6243
g60
(g99
S'\xbf\x00\x00\x00'
tRp6244
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6245
I0
sg3642
g4370
sS'block_loop.thisRepN'
p6246
I1
sg3645
g3788
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6247
I1
sg3647
g3795
sg55
g11
sS'block_loop.thisTrial'
p6248
Nsg70
Vn
sS'block_loop.thisTrialN'
p6249
I0
sg39
F0.81659980134281795
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x119\x0ew '
tRp6250
sa(dp6251
S'trial_loop.thisTrialN'
p6252
I192
sg3633
g3801
sS'block_loop.thisIndex'
p6253
g3627
sg38
S'right'
p6254
sg59
g63
sS'trial_loop.thisN'
p6255
I192
sg33
g3805
sg64
g65
sS'trial_loop.thisIndex'
p6256
g60
(g99
S'\xc0\x00\x00\x00'
tRp6257
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6258
I0
sg3642
g3809
sS'block_loop.thisRepN'
p6259
I1
sg3645
g3805
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6260
I1
sg3647
g3812
sg55
g11
sS'block_loop.thisTrial'
p6261
Nsg70
Vn
sS'block_loop.thisTrialN'
p6262
I0
sg39
F0.73323159084247891
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x12\x03\x0c-0'
tRp6263
sa(dp6264
S'trial_loop.thisTrialN'
p6265
I193
sg3633
g3705
sS'block_loop.thisIndex'
p6266
g3627
sg38
S'right'
p6267
sg59
g63
sS'trial_loop.thisN'
p6268
I193
sg33
g3709
sg64
g65
sS'trial_loop.thisIndex'
p6269
g60
(g99
S'\xc1\x00\x00\x00'
tRp6270
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6271
I0
sg3642
g3713
sS'block_loop.thisRepN'
p6272
I1
sg3645
g3709
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6273
I1
sg3647
g3716
sg55
g11
sS'block_loop.thisTrial'
p6274
Nsg70
Vn
sS'block_loop.thisTrialN'
p6275
I0
sg39
F0.70001094782128348
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x12\t\x08\xb2\x90'
tRp6276
sa(dp6277
S'trial_loop.thisTrialN'
p6278
I194
sg3633
g4475
sS'block_loop.thisIndex'
p6279
g3627
sg38
S'left'
p6280
sg59
g63
sS'trial_loop.thisN'
p6281
I194
sg33
g4090
sg64
g65
sS'trial_loop.thisIndex'
p6282
g60
(g99
S'\xc2\x00\x00\x00'
tRp6283
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6284
I0
sg3642
g4482
sS'block_loop.thisRepN'
p6285
I1
sg3645
g4090
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6286
I1
sg3647
g4097
sg55
g11
sS'block_loop.thisTrial'
p6287
Nsg70
Vn
sS'block_loop.thisTrialN'
p6288
I0
sg39
F0.79972989678208251
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x12\x0f\x04\x80X'
tRp6289
sa(dp6290
S'trial_loop.thisTrialN'
p6291
I195
sg3633
g4148
sS'block_loop.thisIndex'
p6292
g3627
sg38
S'left'
p6293
sg59
g63
sS'trial_loop.thisN'
p6294
I195
sg33
g3771
sg64
g65
sS'trial_loop.thisIndex'
p6295
g60
(g99
S'\xc3\x00\x00\x00'
tRp6296
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6297
I0
sg3642
g4155
sS'block_loop.thisRepN'
p6298
I1
sg3645
g3777
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6299
I1
sg3647
g3771
sg55
g11
sS'block_loop.thisTrial'
p6300
Nsg70
Vn
sS'block_loop.thisTrialN'
p6301
I0
sg39
F0.66669679217375233
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x12\x15\x01\xfb\xd0'
tRp6302
sa(dp6303
S'trial_loop.thisTrialN'
p6304
I196
sg3633
g3722
sS'block_loop.thisIndex'
p6305
g3627
sg38
S'left'
p6306
sg59
g63
sS'trial_loop.thisN'
p6307
I196
sg33
g3726
sg64
g65
sS'trial_loop.thisIndex'
p6308
g60
(g99
S'\xc4\x00\x00\x00'
tRp6309
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6310
I0
sg3642
g3730
sS'block_loop.thisRepN'
p6311
I1
sg3645
g3726
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6312
I1
sg3647
g3733
sg55
g11
sS'block_loop.thisTrial'
p6313
Nsg70
Vn
sS'block_loop.thisTrialN'
p6314
I0
sg39
F0.56654107085705618
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x12\x1a\x0c\xcdX'
tRp6315
sa(dp6316
S'trial_loop.thisTrialN'
p6317
I197
sg3633
g4118
sS'block_loop.thisIndex'
p6318
g3627
sg38
S'right'
p6319
sg59
g63
sS'trial_loop.thisN'
p6320
I197
sg33
g4122
sg64
g65
sS'trial_loop.thisIndex'
p6321
g60
(g99
S'\xc5\x00\x00\x00'
tRp6322
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6323
I0
sg3642
g4126
sS'block_loop.thisRepN'
p6324
I1
sg3645
g4122
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6325
I1
sg3647
g4129
sg55
g11
sS'block_loop.thisTrial'
p6326
Nsg70
Vn
sS'block_loop.thisTrialN'
p6327
I0
sg39
F0.64996601614620886
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x12 \x06\xb6\xc0'
tRp6328
sa(dp6329
S'trial_loop.thisTrialN'
p6330
I198
sg3633
g4557
sS'block_loop.thisIndex'
p6331
g3627
sg38
S'left'
p6332
sg59
g63
sS'trial_loop.thisN'
p6333
I198
sg33
g3854
sg64
g65
sS'trial_loop.thisIndex'
p6334
g60
(g99
S'\xc6\x00\x00\x00'
tRp6335
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6336
I0
sg3642
g4564
sS'block_loop.thisRepN'
p6337
I1
sg3645
g3854
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6338
I1
sg3647
g3861
sg55
g11
sS'block_loop.thisTrial'
p6339
Nsg70
Vn
sS'block_loop.thisTrialN'
p6340
I0
sg39
F1.0999823808524525
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x12&\x01\xcc\xf0'
tRp6341
sa(dp6342
S'trial_loop.thisTrialN'
p6343
I199
sg3633
g3946
sS'block_loop.thisIndex'
p6344
g3627
sg38
S'right'
p6345
sg59
g63
sS'trial_loop.thisN'
p6346
I199
sg33
g3950
sg64
g65
sS'trial_loop.thisIndex'
p6347
g60
(g99
S'\xc7\x00\x00\x00'
tRp6348
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6349
I0
sg3642
g3954
sS'block_loop.thisRepN'
p6350
I1
sg3645
g3956
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6351
I1
sg3647
g3950
sg55
g11
sS'block_loop.thisTrial'
p6352
Nsg70
Vn
sS'block_loop.thisTrialN'
p6353
I0
sg39
F0.5832270862738369
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x12,\x03\xcc\xa8'
tRp6354
sa(dp6355
S'block_loop.thisRepN'
p6356
I1
sg55
g11
sg41
F194.24597496598653
sg56
g57
sS'block_loop.thisIndex'
p6357
g3627
sg58
Vy
sg59
g63
sS'block_loop.thisN'
p6358
I1
sg40
S'space'
p6359
sg64
g65
sS'block_loop.thisTrial'
p6360
Nsg66
g67
sg68
g69
sS'block_loop.thisTrialN'
p6361
I0
sg70
Vn
sa(dp6362
S'block_loop.thisRepN'
p6363
I2
sg56
g57
sS'block_loop.thisIndex'
p6364
g60
(g99
S'\x00\x00\x00\x00'
tRp6365
sg58
Vy
sg59
g63
sS'block_loop.thisN'
p6366
I2
sg37
Nsg55
g11
sg64
g65
sS'block_loop.thisTrial'
p6367
Nsg66
g67
sg68
g69
sS'block_loop.thisTrialN'
p6368
I0
sg70
Vn
sa(dp6369
S'trial_loop.thisTrialN'
p6370
I0
sS'img_left'
p6371
S'44-crunch.png'
p6372
sS'block_loop.thisIndex'
p6373
g6365
sg38
S'right'
p6374
sg59
g63
sS'trial_loop.thisN'
p6375
I0
sg33
S'26-walkers_smoky_bacon.png'
p6376
sg64
g65
sS'trial_loop.thisIndex'
p6377
g60
(g99
S'\x00\x00\x00\x00'
tRp6378
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6379
I0
sS'img_right'
p6380
S'26-walkers_smoky_bacon.png'
p6381
sS'block_loop.thisRepN'
p6382
I2
sS'img_correct'
p6383
g6376
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6384
I2
sS'img_wrong'
p6385
S'44-crunch.png'
p6386
sg55
g11
sS'block_loop.thisTrial'
p6387
Nsg70
Vn
sS'block_loop.thisTrialN'
p6388
I0
sg39
F0.79983310278112185
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x17\x02\x01\xc9\x08'
tRp6389
sa(dp6390
S'trial_loop.thisTrialN'
p6391
I1
sg6371
S'6-sour_patch_kids.png'
p6392
sS'block_loop.thisIndex'
p6393
g6365
sg38
S'right'
p6394
sg59
g63
sS'trial_loop.thisN'
p6395
I1
sg33
S'38-maltesers.png'
p6396
sg64
g65
sS'trial_loop.thisIndex'
p6397
g60
(g99
S'\x01\x00\x00\x00'
tRp6398
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6399
I0
sg6380
S'38-maltesers.png'
p6400
sS'block_loop.thisRepN'
p6401
I2
sg6383
g6396
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6402
I2
sg6385
S'6-sour_patch_kids.png'
p6403
sg55
g11
sS'block_loop.thisTrial'
p6404
Nsg70
Vn
sS'block_loop.thisTrialN'
p6405
I0
sg39
F0.66638974006855278
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x17\x07\x0e\x86\xc0'
tRp6406
sa(dp6407
S'trial_loop.thisTrialN'
p6408
I2
sg6371
S'22-daim.png'
p6409
sS'block_loop.thisIndex'
p6410
g6365
sg38
S'right'
p6411
sg59
g63
sS'trial_loop.thisN'
p6412
I2
sg33
S'7-olives.png'
p6413
sg64
g65
sS'trial_loop.thisIndex'
p6414
g60
(g99
S'\x02\x00\x00\x00'
tRp6415
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6416
I0
sg6380
S'7-olives.png'
p6417
sS'block_loop.thisRepN'
p6418
I2
sg6383
g6413
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6419
I2
sg6385
S'22-daim.png'
p6420
sg55
g11
sS'block_loop.thisTrial'
p6421
Nsg70
Vn
sS'block_loop.thisTrialN'
p6422
I0
sg39
F0.53339398348907707
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x17\r\t\xdbp'
tRp6423
sa(dp6424
S'trial_loop.thisTrialN'
p6425
I3
sg6371
S'33-ambrosia_rice.png'
p6426
sS'block_loop.thisIndex'
p6427
g6365
sg38
S'right'
p6428
sg59
g63
sS'trial_loop.thisN'
p6429
I3
sg33
S'23-crunchie_redo.png'
p6430
sg64
g65
sS'trial_loop.thisIndex'
p6431
g60
(g99
S'\x03\x00\x00\x00'
tRp6432
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6433
I0
sg6380
S'23-crunchie_redo.png'
p6434
sS'block_loop.thisRepN'
p6435
I2
sg6383
g6430
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6436
I2
sg6385
S'33-ambrosia_rice.png'
p6437
sg55
g11
sS'block_loop.thisTrial'
p6438
Nsg70
Vn
sS'block_loop.thisTrialN'
p6439
I0
sg39
F0.63317508413092582
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x17\x13\x03G\xd8'
tRp6440
sa(dp6441
S'trial_loop.thisTrialN'
p6442
I4
sg6371
S'36-fig_rolls.png'
p6443
sS'block_loop.thisIndex'
p6444
g6365
sg38
S'right'
p6445
sg59
g63
sS'trial_loop.thisN'
p6446
I4
sg33
S'34-hula_hoops_bbq_beef_redo.png'
p6447
sg64
g65
sS'trial_loop.thisIndex'
p6448
g60
(g99
S'\x04\x00\x00\x00'
tRp6449
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6450
I0
sg6380
S'34-hula_hoops_bbq_beef_redo.png'
p6451
sS'block_loop.thisRepN'
p6452
I2
sg6383
g6447
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6453
I2
sg6385
S'36-fig_rolls.png'
p6454
sg55
g11
sS'block_loop.thisTrial'
p6455
Nsg70
Vn
sS'block_loop.thisTrialN'
p6456
I0
sg39
F0.69991686499997741
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x17\x18\re\xb0'
tRp6457
sa(dp6458
S'trial_loop.thisTrialN'
p6459
I5
sg6371
S'10-bounty_redo.png'
p6460
sS'block_loop.thisIndex'
p6461
g6365
sg38
S'right'
p6462
sg59
g63
sS'trial_loop.thisN'
p6463
I5
sg33
S'4-corn.png'
p6464
sg64
g65
sS'trial_loop.thisIndex'
p6465
g60
(g99
S'\x05\x00\x00\x00'
tRp6466
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6467
I0
sg6380
S'4-corn.png'
p6468
sS'block_loop.thisRepN'
p6469
I2
sg6383
g6464
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6470
I2
sg6385
S'10-bounty_redo.png'
p6471
sg55
g11
sS'block_loop.thisTrial'
p6472
Nsg70
Vn
sS'block_loop.thisTrialN'
p6473
I0
sg39
F0.64974563427313115
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x17\x1e\tq\xf8'
tRp6474
sa(dp6475
S'trial_loop.thisTrialN'
p6476
I6
sg6371
S'27-hartleys_raspberries_jelly.png'
p6477
sS'block_loop.thisIndex'
p6478
g6365
sg38
S'left'
p6479
sg59
g63
sS'trial_loop.thisN'
p6480
I6
sg33
S'51-mars.png'
p6481
sg64
g65
sS'trial_loop.thisIndex'
p6482
g60
(g99
S'\x06\x00\x00\x00'
tRp6483
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6484
I0
sg6380
S'51-mars.png'
p6485
sS'block_loop.thisRepN'
p6486
I2
sg6383
S'27-hartleys_raspberries_jelly.png'
p6487
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6488
I2
sg6385
g6481
sg55
g11
sS'block_loop.thisTrial'
p6489
Nsg70
Vn
sS'block_loop.thisTrialN'
p6490
I0
sg39
F0.73321391467834474
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x17$\x04\x88('
tRp6491
sa(dp6492
S'trial_loop.thisTrialN'
p6493
I7
sg6371
S'3-ellas_strawberries_apples.png'
p6494
sS'block_loop.thisIndex'
p6495
g6365
sg38
S'left'
p6496
sg59
g63
sS'trial_loop.thisN'
p6497
I7
sg33
S'3-ellas_strawberries_apples.png'
p6498
sg64
g65
sS'trial_loop.thisIndex'
p6499
g60
(g99
S'\x07\x00\x00\x00'
tRp6500
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6501
I0
sg6380
S'13-mccoys_steak_crisps.png'
p6502
sS'block_loop.thisRepN'
p6503
I2
sg6383
g6498
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6504
I2
sg6385
S'13-mccoys_steak_crisps.png'
p6505
sg55
g11
sS'block_loop.thisTrial'
p6506
Nsg70
Vn
sS'block_loop.thisTrialN'
p6507
I0
sg39
F0.73323501203412889
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x17*\x01\r\x88'
tRp6508
sa(dp6509
S'trial_loop.thisTrialN'
p6510
I8
sg6371
S'34-hula_hoops_bbq_beef_redo.png'
p6511
sS'block_loop.thisIndex'
p6512
g6365
sg38
S'left'
p6513
sg59
g63
sS'trial_loop.thisN'
p6514
I8
sg33
g6447
sg64
g65
sS'trial_loop.thisIndex'
p6515
g60
(g99
S'\x08\x00\x00\x00'
tRp6516
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6517
I0
sg6380
S'36-fig_rolls.png'
p6518
sS'block_loop.thisRepN'
p6519
I2
sg6383
g6447
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6520
I2
sg6385
g6454
sg55
g11
sS'block_loop.thisTrial'
p6521
Nsg70
Vn
sS'block_loop.thisTrialN'
p6522
I0
sg39
F0.64992980851457105
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x17/\x0c\x96\xa8'
tRp6523
sa(dp6524
S'trial_loop.thisTrialN'
p6525
I9
sg6371
S'50-polo.png'
p6526
sS'block_loop.thisIndex'
p6527
g6365
sg38
S'right'
p6528
sg59
g63
sS'trial_loop.thisN'
p6529
I9
sg33
S'50-polo.png'
p6530
sg64
g65
sS'trial_loop.thisIndex'
p6531
g60
(g99
S'\t\x00\x00\x00'
tRp6532
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6533
I0
sg6380
S'48-twix.png'
p6534
sS'block_loop.thisRepN'
p6535
I2
sg6383
S'48-twix.png'
p6536
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6537
I2
sg6385
g6530
sg55
g11
sS'block_loop.thisTrial'
p6538
Nsg70
Vn
sS'block_loop.thisTrialN'
p6539
I0
sg39
F0.73332966505404329
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x175\x07\xebX'
tRp6540
sa(dp6541
S'trial_loop.thisTrialN'
p6542
I10
sg6371
S'8-liquorice_catherine_wheels.png'
p6543
sS'block_loop.thisIndex'
p6544
g6365
sg38
S'right'
p6545
sg59
g63
sS'trial_loop.thisN'
p6546
I10
sg33
S'17-jacobs_mini_cheddars_redo.png'
p6547
sg64
g65
sS'trial_loop.thisIndex'
p6548
g60
(g99
S'\n\x00\x00\x00'
tRp6549
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6550
I0
sg6380
S'17-jacobs_mini_cheddars_redo.png'
p6551
sS'block_loop.thisRepN'
p6552
I2
sg6383
g6547
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6553
I2
sg6385
S'8-liquorice_catherine_wheels.png'
p6554
sg55
g11
sS'block_loop.thisTrial'
p6555
Nsg70
Vn
sS'block_loop.thisTrialN'
p6556
I0
sg39
F0.66651176263258094
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x17;\x046 '
tRp6557
sa(dp6558
S'trial_loop.thisTrialN'
p6559
I11
sg6371
S'42-mrkipling_lemon_slices.png'
p6560
sS'block_loop.thisIndex'
p6561
g6365
sg38
S'right'
p6562
sg59
g63
sS'trial_loop.thisN'
p6563
I11
sg33
S'16-skips_prawn.png'
p6564
sg64
g65
sS'trial_loop.thisIndex'
p6565
g60
(g99
S'\x0b\x00\x00\x00'
tRp6566
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6567
I0
sg6380
S'16-skips_prawn.png'
p6568
sS'block_loop.thisRepN'
p6569
I2
sg6383
g6564
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6570
I2
sg6385
S'42-mrkipling_lemon_slices.png'
p6571
sg55
g11
sS'block_loop.thisTrial'
p6572
Nsg70
Vn
sS'block_loop.thisTrialN'
p6573
I0
sg39
F0.79984194086500793
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x18\x04\x0f\x07\xa8'
tRp6574
sa(dp6575
S'trial_loop.thisTrialN'
p6576
I12
sg6371
S'35-raisins.png'
p6577
sS'block_loop.thisIndex'
p6578
g6365
sg38
S'left'
p6579
sg59
g63
sS'trial_loop.thisN'
p6580
I12
sg33
S'35-raisins.png'
p6581
sg64
g65
sS'trial_loop.thisIndex'
p6582
g60
(g99
S'\x0c\x00\x00\x00'
tRp6583
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6584
I0
sg6380
S'49-yorkie.png'
p6585
sS'block_loop.thisRepN'
p6586
I2
sg6383
g6581
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6587
I2
sg6385
S'49-yorkie.png'
p6588
sg55
g11
sS'block_loop.thisTrial'
p6589
Nsg70
Vn
sS'block_loop.thisTrialN'
p6590
I0
sg39
F0.64990785585905542
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x18\n\x0c\x83 '
tRp6591
sa(dp6592
S'trial_loop.thisTrialN'
p6593
I13
sg6371
S'16-skips_prawn.png'
p6594
sS'block_loop.thisIndex'
p6595
g6365
sg38
S'left'
p6596
sg59
g63
sS'trial_loop.thisN'
p6597
I13
sg33
g6564
sg64
g65
sS'trial_loop.thisIndex'
p6598
g60
(g99
S'\r\x00\x00\x00'
tRp6599
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6600
I0
sg6380
S'42-mrkipling_lemon_slices.png'
p6601
sS'block_loop.thisRepN'
p6602
I2
sg6383
g6564
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6603
I2
sg6385
g6571
sg55
g11
sS'block_loop.thisTrial'
p6604
Nsg70
Vn
sS'block_loop.thisTrialN'
p6605
I0
sg39
F0.96644236943029682
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x18\x10\x07\x99P'
tRp6606
sa(dp6607
S'trial_loop.thisTrialN'
p6608
I14
sg6371
S'45-chewy_nougat_redo.png'
p6609
sS'block_loop.thisIndex'
p6610
g6365
sg38
S'right'
p6611
sg59
g63
sS'trial_loop.thisN'
p6612
I14
sg33
S'41-peanuts_redo.png'
p6613
sg64
g65
sS'trial_loop.thisIndex'
p6614
g60
(g99
S'\x0e\x00\x00\x00'
tRp6615
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6616
I0
sg6380
S'41-peanuts_redo.png'
p6617
sS'block_loop.thisRepN'
p6618
I2
sg6383
g6613
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6619
I2
sg6385
S'45-chewy_nougat_redo.png'
p6620
sg55
g11
sS'block_loop.thisTrial'
p6621
Nsg70
Vn
sS'block_loop.thisTrialN'
p6622
I0
sg39
F0.59989114902782603
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x18\x16\x07\xb0\xc0'
tRp6623
sa(dp6624
S'trial_loop.thisTrialN'
p6625
I15
sg6371
g6594
sS'block_loop.thisIndex'
p6626
g6365
sg38
S'left'
p6627
sg59
g63
sS'trial_loop.thisN'
p6628
I15
sg33
g6564
sg64
g65
sS'trial_loop.thisIndex'
p6629
g60
(g99
S'\x0f\x00\x00\x00'
tRp6630
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6631
I0
sg6380
g6601
sS'block_loop.thisRepN'
p6632
I2
sg6383
g6564
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6633
I2
sg6385
g6571
sg55
g11
sS'block_loop.thisTrial'
p6634
Nsg70
Vn
sS'block_loop.thisTrialN'
p6635
I0
sg39
F0.68310797172307502
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x18\x1c\x02\x13@'
tRp6636
sa(dp6637
S'trial_loop.thisTrialN'
p6638
I16
sg6371
g6409
sS'block_loop.thisIndex'
p6639
g6365
sg38
S'right'
p6640
sg59
g63
sS'trial_loop.thisN'
p6641
I16
sg33
g6413
sg64
g65
sS'trial_loop.thisIndex'
p6642
g60
(g99
S'\x10\x00\x00\x00'
tRp6643
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6644
I0
sg6380
g6417
sS'block_loop.thisRepN'
p6645
I2
sg6383
g6413
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6646
I2
sg6385
g6420
sg55
g11
sS'block_loop.thisTrial'
p6647
Nsg70
Vn
sS'block_loop.thisTrialN'
p6648
I0
sg39
F0.64985539756162325
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x18!\x0c\xe8\xb0'
tRp6649
sa(dp6650
S'trial_loop.thisTrialN'
p6651
I17
sg6371
S'5-pineapple.png'
p6652
sS'block_loop.thisIndex'
p6653
g6365
sg38
S'right'
p6654
sg59
g63
sS'trial_loop.thisN'
p6655
I17
sg33
S'40-sardines.png'
p6656
sg64
g65
sS'trial_loop.thisIndex'
p6657
g60
(g99
S'\x11\x00\x00\x00'
tRp6658
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6659
I0
sg6380
S'40-sardines.png'
p6660
sS'block_loop.thisRepN'
p6661
I2
sg6383
g6656
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6662
I2
sg6385
S'5-pineapple.png'
p6663
sg55
g11
sS'block_loop.thisTrial'
p6664
Nsg70
Vn
sS'block_loop.thisTrialN'
p6665
I0
sg39
F0.75032330277463188
sg34
g753
(S"\x07\xdf\x07\x0b\x11\x18'\x07\xfe\xe0"
tRp6666
sa(dp6667
S'trial_loop.thisTrialN'
p6668
I18
sg6371
g6577
sS'block_loop.thisIndex'
p6669
g6365
sg38
S'left'
p6670
sg59
g63
sS'trial_loop.thisN'
p6671
I18
sg33
g6581
sg64
g65
sS'trial_loop.thisIndex'
p6672
g60
(g99
S'\x12\x00\x00\x00'
tRp6673
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6674
I0
sg6380
g6585
sS'block_loop.thisRepN'
p6675
I2
sg6383
g6581
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6676
I2
sg6385
g6588
sg55
g11
sS'block_loop.thisTrial'
p6677
Nsg70
Vn
sS'block_loop.thisTrialN'
p6678
I0
sg39
F0.58320684421050828
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x18-\x04\xc2\xc0'
tRp6679
sa(dp6680
S'trial_loop.thisTrialN'
p6681
I19
sg6371
S'30-spaghetti_hoops.png'
p6682
sS'block_loop.thisIndex'
p6683
g6365
sg38
S'left'
p6684
sg59
g63
sS'trial_loop.thisN'
p6685
I19
sg33
S'30-spaghetti_hoops.png'
p6686
sg64
g65
sS'trial_loop.thisIndex'
p6687
g60
(g99
S'\x13\x00\x00\x00'
tRp6688
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6689
I0
sg6380
S'19-caramello_redo.png'
p6690
sS'block_loop.thisRepN'
p6691
I2
sg6383
g6686
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6692
I2
sg6385
S'19-caramello_redo.png'
p6693
sg55
g11
sS'block_loop.thisTrial'
p6694
Nsg70
Vn
sS'block_loop.thisTrialN'
p6695
I0
sg39
F1.0832478985284979
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x182\x0e)\x00'
tRp6696
sa(dp6697
S'trial_loop.thisTrialN'
p6698
I20
sg6371
S'43-mrporky_pork_crackles_redo.png'
p6699
sS'block_loop.thisIndex'
p6700
g6365
sg38
S'left'
p6701
sg59
g63
sS'trial_loop.thisN'
p6702
I20
sg33
S'43-mrporky_pork_crackles_redo.png'
p6703
sg64
g65
sS'trial_loop.thisIndex'
p6704
g60
(g99
S'\x14\x00\x00\x00'
tRp6705
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6706
I0
sg6380
S'18-mms.png'
p6707
sS'block_loop.thisRepN'
p6708
I2
sg6383
g6703
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6709
I2
sg6385
S'18-mms.png'
p6710
sg55
g11
sS'block_loop.thisTrial'
p6711
Nsg70
Vn
sS'block_loop.thisTrialN'
p6712
I0
sg39
F0.69998215277519193
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x189\x00\xa7\xf8'
tRp6713
sa(dp6714
S'trial_loop.thisTrialN'
p6715
I21
sg6371
S'2-steamed_puddings.png'
p6716
sS'block_loop.thisIndex'
p6717
g6365
sg38
S'left'
p6718
sg59
g63
sS'trial_loop.thisN'
p6719
I21
sg33
S'2-steamed_puddings.png'
p6720
sg64
g65
sS'trial_loop.thisIndex'
p6721
g60
(g99
S'\x15\x00\x00\x00'
tRp6722
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6723
I0
sg6380
S'20-fruit_pastilles.png'
p6724
sS'block_loop.thisRepN'
p6725
I2
sg6383
g6720
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6726
I2
sg6385
S'20-fruit_pastilles.png'
p6727
sg55
g11
sS'block_loop.thisTrial'
p6728
Nsg70
Vn
sS'block_loop.thisTrialN'
p6729
I0
sg39
F0.58323364355965168
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x19\x02\x0b\xf6\x80'
tRp6730
sa(dp6731
S'trial_loop.thisTrialN'
p6732
I22
sg6371
S'41-peanuts_redo.png'
p6733
sS'block_loop.thisIndex'
p6734
g6365
sg38
S'left'
p6735
sg59
g63
sS'trial_loop.thisN'
p6736
I22
sg33
g6613
sg64
g65
sS'trial_loop.thisIndex'
p6737
g60
(g99
S'\x16\x00\x00\x00'
tRp6738
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6739
I0
sg6380
S'45-chewy_nougat_redo.png'
p6740
sS'block_loop.thisRepN'
p6741
I2
sg6383
g6613
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6742
I2
sg6385
g6620
sg55
g11
sS'block_loop.thisTrial'
p6743
Nsg70
Vn
sS'block_loop.thisTrialN'
p6744
I0
sg39
F0.69989576764419326
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x19\x08\x06\x1a\x80'
tRp6745
sa(dp6746
S'trial_loop.thisTrialN'
p6747
I23
sg6371
S'13-mccoys_steak_crisps.png'
p6748
sS'block_loop.thisIndex'
p6749
g6365
sg38
S'right'
p6750
sg59
g63
sS'trial_loop.thisN'
p6751
I23
sg33
g6498
sg64
g65
sS'trial_loop.thisIndex'
p6752
g60
(g99
S'\x17\x00\x00\x00'
tRp6753
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6754
I0
sg6380
S'3-ellas_strawberries_apples.png'
p6755
sS'block_loop.thisRepN'
p6756
I2
sg6383
g6498
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6757
I2
sg6385
g6505
sg55
g11
sS'block_loop.thisTrial'
p6758
Nsg70
Vn
sS'block_loop.thisTrialN'
p6759
I0
sg39
F0.73332909485543496
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x19\x0e\x01\xe8H'
tRp6760
sa(dp6761
S'trial_loop.thisTrialN'
p6762
I24
sg6371
S'40-sardines.png'
p6763
sS'block_loop.thisIndex'
p6764
g6365
sg38
S'left'
p6765
sg59
g63
sS'trial_loop.thisN'
p6766
I24
sg33
g6656
sg64
g65
sS'trial_loop.thisIndex'
p6767
g60
(g99
S'\x18\x00\x00\x00'
tRp6768
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6769
I0
sg6380
S'5-pineapple.png'
p6770
sS'block_loop.thisRepN'
p6771
I2
sg6383
g6656
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6772
I2
sg6385
g6663
sg55
g11
sS'block_loop.thisTrial'
p6773
Nsg70
Vn
sS'block_loop.thisTrialN'
p6774
I0
sg39
F0.59987090697177337
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x19\x13\r\xaf\xe8'
tRp6775
sa(dp6776
S'trial_loop.thisTrialN'
p6777
I25
sg6371
S'21-nakd_banana_crunch.png'
p6778
sS'block_loop.thisIndex'
p6779
g6365
sg38
S'right'
p6780
sg59
g63
sS'trial_loop.thisN'
p6781
I25
sg33
S'1-treacle_cookies.png'
p6782
sg64
g65
sS'trial_loop.thisIndex'
p6783
g60
(g99
S'\x19\x00\x00\x00'
tRp6784
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6785
I0
sg6380
S'1-treacle_cookies.png'
p6786
sS'block_loop.thisRepN'
p6787
I2
sg6383
g6782
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6788
I2
sg6385
S'21-nakd_banana_crunch.png'
p6789
sg55
g11
sS'block_loop.thisTrial'
p6790
Nsg70
Vn
sS'block_loop.thisTrialN'
p6791
I0
sg39
F0.68330811153646209
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x19\x19\x08\x0e\x80'
tRp6792
sa(dp6793
S'trial_loop.thisTrialN'
p6794
I26
sg6371
g6699
sS'block_loop.thisIndex'
p6795
g6365
sg38
S'left'
p6796
sg59
g63
sS'trial_loop.thisN'
p6797
I26
sg33
g6703
sg64
g65
sS'trial_loop.thisIndex'
p6798
g60
(g99
S'\x1a\x00\x00\x00'
tRp6799
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6800
I0
sg6380
g6707
sS'block_loop.thisRepN'
p6801
I2
sg6383
g6703
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6802
I2
sg6385
g6710
sg55
g11
sS'block_loop.thisTrial'
p6803
Nsg70
Vn
sS'block_loop.thisTrialN'
p6804
I0
sg39
F0.54990722864022246
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x19\x1f\x03\xe00'
tRp6805
sa(dp6806
S'trial_loop.thisTrialN'
p6807
I27
sg6371
S'38-maltesers.png'
p6808
sS'block_loop.thisIndex'
p6809
g6365
sg38
S'left'
p6810
sg59
g63
sS'trial_loop.thisN'
p6811
I27
sg33
g6396
sg64
g65
sS'trial_loop.thisIndex'
p6812
g60
(g99
S'\x1b\x00\x00\x00'
tRp6813
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6814
I0
sg6380
S'6-sour_patch_kids.png'
p6815
sS'block_loop.thisRepN'
p6816
I2
sg6383
g6396
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6817
I2
sg6385
g6403
sg55
g11
sS'block_loop.thisTrial'
p6818
Nsg70
Vn
sS'block_loop.thisTrialN'
p6819
I0
sg39
F0.63306902713884483
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x19$\x0c\x8e\xd8'
tRp6820
sa(dp6821
S'trial_loop.thisTrialN'
p6822
I28
sg6371
S'1-treacle_cookies.png'
p6823
sS'block_loop.thisIndex'
p6824
g6365
sg38
S'left'
p6825
sg59
g63
sS'trial_loop.thisN'
p6826
I28
sg33
g6782
sg64
g65
sS'trial_loop.thisIndex'
p6827
g60
(g99
S'\x1c\x00\x00\x00'
tRp6828
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6829
I0
sg6380
S'21-nakd_banana_crunch.png'
p6830
sS'block_loop.thisRepN'
p6831
I2
sg6383
g6782
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6832
I2
sg6385
g6789
sg55
g11
sS'block_loop.thisTrial'
p6833
Nsg70
Vn
sS'block_loop.thisTrialN'
p6834
I0
sg39
F0.59996869607857661
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x19*\x07\xa5\x08'
tRp6835
sa(dp6836
S'trial_loop.thisTrialN'
p6837
I29
sg6371
g6682
sS'block_loop.thisIndex'
p6838
g6365
sg38
S'left'
p6839
sg59
g63
sS'trial_loop.thisN'
p6840
I29
sg33
g6686
sg64
g65
sS'trial_loop.thisIndex'
p6841
g60
(g99
S'\x1d\x00\x00\x00'
tRp6842
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6843
I0
sg6380
g6690
sS'block_loop.thisRepN'
p6844
I2
sg6383
g6686
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6845
I2
sg6385
g6693
sg55
g11
sS'block_loop.thisTrial'
p6846
Nsg70
Vn
sS'block_loop.thisTrialN'
p6847
I0
sg39
F0.58373513348851702
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x190\x02\x07\x88'
tRp6848
sa(dp6849
S'trial_loop.thisTrialN'
p6850
I30
sg6371
g6392
sS'block_loop.thisIndex'
p6851
g6365
sg38
S'right'
p6852
sg59
g63
sS'trial_loop.thisN'
p6853
I30
sg33
g6403
sg64
g65
sS'trial_loop.thisIndex'
p6854
g60
(g99
S'\x1e\x00\x00\x00'
tRp6855
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6856
I0
sg6380
g6400
sS'block_loop.thisRepN'
p6857
I2
sg6383
g6396
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6858
I2
sg6385
g6403
sg55
g11
sS'block_loop.thisTrial'
p6859
Nsg70
Vn
sS'block_loop.thisTrialN'
p6860
I0
sg39
F0.66629366155757452
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x195\x0bm\xc8'
tRp6861
sa(dp6862
S'trial_loop.thisTrialN'
p6863
I31
sg6371
g6477
sS'block_loop.thisIndex'
p6864
g6365
sg38
S'left'
p6865
sg59
g63
sS'trial_loop.thisN'
p6866
I31
sg33
g6487
sg64
g65
sS'trial_loop.thisIndex'
p6867
g60
(g99
S'\x1f\x00\x00\x00'
tRp6868
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6869
I0
sg6380
g6485
sS'block_loop.thisRepN'
p6870
I2
sg6383
g6487
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6871
I2
sg6385
g6481
sg55
g11
sS'block_loop.thisTrial'
p6872
Nsg70
Vn
sS'block_loop.thisTrialN'
p6873
I0
sg39
F0.59991823347809259
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x19;\x06\xc2x'
tRp6874
sa(dp6875
S'trial_loop.thisTrialN'
p6876
I32
sg6371
S'49-yorkie.png'
p6877
sS'block_loop.thisIndex'
p6878
g6365
sg38
S'right'
p6879
sg59
g63
sS'trial_loop.thisN'
p6880
I32
sg33
g6581
sg64
g65
sS'trial_loop.thisIndex'
p6881
g60
(g99
S' \x00\x00\x00'
tRp6882
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6883
I0
sg6380
S'35-raisins.png'
p6884
sS'block_loop.thisRepN'
p6885
I2
sg6383
g6581
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6886
I2
sg6385
g6588
sg55
g11
sS'block_loop.thisTrial'
p6887
Nsg70
Vn
sS'block_loop.thisTrialN'
p6888
I0
sg39
F0.69986896829504985
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1a\x05\x01$\xf8'
tRp6889
sa(dp6890
S'trial_loop.thisTrialN'
p6891
I33
sg6371
g6392
sS'block_loop.thisIndex'
p6892
g6365
sg38
S'right'
p6893
sg59
g63
sS'trial_loop.thisN'
p6894
I33
sg33
g6403
sg64
g65
sS'trial_loop.thisIndex'
p6895
g60
(g99
S'!\x00\x00\x00'
tRp6896
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6897
I0
sg6380
g6400
sS'block_loop.thisRepN'
p6898
I2
sg6383
g6396
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6899
I2
sg6385
g6403
sg55
g11
sS'block_loop.thisTrial'
p6900
Nsg70
Vn
sS'block_loop.thisTrialN'
p6901
I0
sg39
F0.76629058248363435
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1a\n\x0co\x98'
tRp6902
sa(dp6903
S'trial_loop.thisTrialN'
p6904
I34
sg6371
S'29-beans.png'
p6905
sS'block_loop.thisIndex'
p6906
g6365
sg38
S'right'
p6907
sg59
g63
sS'trial_loop.thisN'
p6908
I34
sg33
S'29-beans.png'
p6909
sg64
g65
sS'trial_loop.thisIndex'
p6910
g60
(g99
S'"\x00\x00\x00'
tRp6911
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6912
I0
sg6380
S'46-pistachios.png'
p6913
sS'block_loop.thisRepN'
p6914
I2
sg6383
S'46-pistachios.png'
p6915
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6916
I2
sg6385
g6909
sg55
g11
sS'block_loop.thisTrial'
p6917
Nsg70
Vn
sS'block_loop.thisTrialN'
p6918
I0
sg39
F0.68323084958683467
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1a\x10\tq\xf8'
tRp6919
sa(dp6920
S'trial_loop.thisTrialN'
p6921
I35
sg6371
S'26-walkers_smoky_bacon.png'
p6922
sS'block_loop.thisIndex'
p6923
g6365
sg38
S'left'
p6924
sg59
g63
sS'trial_loop.thisN'
p6925
I35
sg33
g6376
sg64
g65
sS'trial_loop.thisIndex'
p6926
g60
(g99
S'#\x00\x00\x00'
tRp6927
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6928
I0
sg6380
S'44-crunch.png'
p6929
sS'block_loop.thisRepN'
p6930
I2
sg6383
g6376
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6931
I2
sg6385
g6386
sg55
g11
sS'block_loop.thisTrial'
p6932
Nsg70
Vn
sS'block_loop.thisTrialN'
p6933
I0
sg39
F0.66670220906598843
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1a\x16\x05\x01@'
tRp6934
sa(dp6935
S'trial_loop.thisTrialN'
p6936
I36
sg6371
S'18-mms.png'
p6937
sS'block_loop.thisIndex'
p6938
g6365
sg38
S'right'
p6939
sg59
g63
sS'trial_loop.thisN'
p6940
I36
sg33
g6703
sg64
g65
sS'trial_loop.thisIndex'
p6941
g60
(g99
S'$\x00\x00\x00'
tRp6942
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6943
I0
sg6380
S'43-mrporky_pork_crackles_redo.png'
p6944
sS'block_loop.thisRepN'
p6945
I2
sg6383
g6703
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6946
I2
sg6385
g6710
sg55
g11
sS'block_loop.thisTrial'
p6947
Nsg70
Vn
sS'block_loop.thisTrialN'
p6948
I0
sg39
F1.0332237791189982
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1a\x1c\x00\x94p'
tRp6949
sa(dp6950
S'trial_loop.thisTrialN'
p6951
I37
sg6371
S'51-mars.png'
p6952
sS'block_loop.thisIndex'
p6953
g6365
sg38
S'right'
p6954
sg59
g63
sS'trial_loop.thisN'
p6955
I37
sg33
g6487
sg64
g65
sS'trial_loop.thisIndex'
p6956
g60
(g99
S'%\x00\x00\x00'
tRp6957
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6958
I0
sg6380
S'27-hartleys_raspberries_jelly.png'
p6959
sS'block_loop.thisRepN'
p6960
I2
sg6383
g6487
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6961
I2
sg6385
g6481
sg55
g11
sS'block_loop.thisTrial'
p6962
Nsg70
Vn
sS'block_loop.thisTrialN'
p6963
I0
sg39
F0.71667301488196244
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1a"\x01cx'
tRp6964
sa(dp6965
S'trial_loop.thisTrialN'
p6966
I38
sg6371
S'19-caramello_redo.png'
p6967
sS'block_loop.thisIndex'
p6968
g6365
sg38
S'right'
p6969
sg59
g63
sS'trial_loop.thisN'
p6970
I38
sg33
g6686
sg64
g65
sS'trial_loop.thisIndex'
p6971
g60
(g99
S'&\x00\x00\x00'
tRp6972
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6973
I0
sg6380
S'30-spaghetti_hoops.png'
p6974
sS'block_loop.thisRepN'
p6975
I2
sg6383
g6686
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6976
I2
sg6385
g6693
sg55
g11
sS'block_loop.thisTrial'
p6977
Nsg70
Vn
sS'block_loop.thisTrialN'
p6978
I0
sg39
F0.91646643182320986
sg34
g753
(S"\x07\xdf\x07\x0b\x11\x1a'\x0c\xec\x98"
tRp6979
sa(dp6980
S'trial_loop.thisTrialN'
p6981
I39
sg6371
S'4-corn.png'
p6982
sS'block_loop.thisIndex'
p6983
g6365
sg38
S'left'
p6984
sg59
g63
sS'trial_loop.thisN'
p6985
I39
sg33
g6471
sg64
g65
sS'trial_loop.thisIndex'
p6986
g60
(g99
S"'\x00\x00\x00"
tRp6987
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p6988
I0
sg6380
S'10-bounty_redo.png'
p6989
sS'block_loop.thisRepN'
p6990
I2
sg6383
g6464
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p6991
I2
sg6385
g6471
sg55
g11
sS'block_loop.thisTrial'
p6992
Nsg70
Vn
sS'block_loop.thisTrialN'
p6993
I0
sg39
F0.69995364283022354
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1a-\x0c\x11\xd8'
tRp6994
sa(dp6995
S'trial_loop.thisTrialN'
p6996
I40
sg6371
S'31-hobnobs.png'
p6997
sS'block_loop.thisIndex'
p6998
g6365
sg38
S'left'
p6999
sg59
g63
sS'trial_loop.thisN'
p7000
I40
sg33
S'31-hobnobs.png'
p7001
sg64
g65
sS'trial_loop.thisIndex'
p7002
g60
(g99
S'(\x00\x00\x00'
tRp7003
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7004
I0
sg6380
S'25-kitkat.png'
p7005
sS'block_loop.thisRepN'
p7006
I2
sg6383
g7001
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7007
I2
sg6385
S'25-kitkat.png'
p7008
sg55
g11
sS'block_loop.thisTrial'
p7009
Nsg70
Vn
sS'block_loop.thisTrialN'
p7010
I0
sg39
F0.61663560983652133
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1a3\x08\x1a8'
tRp7011
sa(dp7012
S'trial_loop.thisTrialN'
p7013
I41
sg6371
g6808
sS'block_loop.thisIndex'
p7014
g6365
sg38
S'left'
p7015
sg59
g63
sS'trial_loop.thisN'
p7016
I41
sg33
g6396
sg64
g65
sS'trial_loop.thisIndex'
p7017
g60
(g99
S')\x00\x00\x00'
tRp7018
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7019
I0
sg6380
g6815
sS'block_loop.thisRepN'
p7020
I2
sg6383
g6396
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7021
I2
sg6385
g6403
sg55
g11
sS'block_loop.thisTrial'
p7022
Nsg70
Vn
sS'block_loop.thisTrialN'
p7023
I0
sg39
F0.66642623279767577
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1a9\x02\xbb8'
tRp7024
sa(dp7025
S'trial_loop.thisTrialN'
p7026
I42
sg6371
g6997
sS'block_loop.thisIndex'
p7027
g6365
sg38
S'left'
p7028
sg59
g63
sS'trial_loop.thisN'
p7029
I42
sg33
g7001
sg64
g65
sS'trial_loop.thisIndex'
p7030
g60
(g99
S'*\x00\x00\x00'
tRp7031
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7032
I0
sg6380
g7005
sS'block_loop.thisRepN'
p7033
I2
sg6383
g7001
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7034
I2
sg6385
g7008
sg55
g11
sS'block_loop.thisTrial'
p7035
Nsg70
Vn
sS'block_loop.thisTrialN'
p7036
I0
sg39
F0.5833662148033909
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1b\x02\rR('
tRp7037
sa(dp7038
S'trial_loop.thisTrialN'
p7039
I43
sg6371
g6823
sS'block_loop.thisIndex'
p7040
g6365
sg38
S'left'
p7041
sg59
g63
sS'trial_loop.thisN'
p7042
I43
sg33
g6782
sg64
g65
sS'trial_loop.thisIndex'
p7043
g60
(g99
S'+\x00\x00\x00'
tRp7044
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7045
I0
sg6380
g6830
sS'block_loop.thisRepN'
p7046
I2
sg6383
g6782
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7047
I2
sg6385
g6789
sg55
g11
sS'block_loop.thisTrial'
p7048
Nsg70
Vn
sS'block_loop.thisTrialN'
p7049
I0
sg39
F0.63320587487396551
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1b\x08\x07v('
tRp7050
sa(dp7051
S'trial_loop.thisTrialN'
p7052
I44
sg6371
g6937
sS'block_loop.thisIndex'
p7053
g6365
sg38
S'right'
p7054
sg59
g63
sS'trial_loop.thisN'
p7055
I44
sg33
g6703
sg64
g65
sS'trial_loop.thisIndex'
p7056
g60
(g99
S',\x00\x00\x00'
tRp7057
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7058
I0
sg6380
g6944
sS'block_loop.thisRepN'
p7059
I2
sg6383
g6703
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7060
I2
sg6385
g6710
sg55
g11
sS'block_loop.thisTrial'
p7061
Nsg70
Vn
sS'block_loop.thisTrialN'
p7062
I0
sg39
F0.78323831918896758
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1b\x0e\x02\x8cX'
tRp7063
sa(dp7064
S'trial_loop.thisTrialN'
p7065
I45
sg6371
S'48-twix.png'
p7066
sS'block_loop.thisIndex'
p7067
g6365
sg38
S'left'
p7068
sg59
g63
sS'trial_loop.thisN'
p7069
I45
sg33
g6536
sg64
g65
sS'trial_loop.thisIndex'
p7070
g60
(g99
S'-\x00\x00\x00'
tRp7071
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7072
I0
sg6380
S'50-polo.png'
p7073
sS'block_loop.thisRepN'
p7074
I2
sg6383
g6536
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7075
I2
sg6385
g6530
sg55
g11
sS'block_loop.thisTrial'
p7076
Nsg70
Vn
sS'block_loop.thisTrialN'
p7077
I0
sg39
F0.93325394263956696
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1b\x13\x0f\x0b\x90'
tRp7078
sa(dp7079
S'trial_loop.thisTrialN'
p7080
I46
sg6371
g6763
sS'block_loop.thisIndex'
p7081
g6365
sg38
S'left'
p7082
sg59
g63
sS'trial_loop.thisN'
p7083
I46
sg33
g6656
sg64
g65
sS'trial_loop.thisIndex'
p7084
g60
(g99
S'.\x00\x00\x00'
tRp7085
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7086
I0
sg6380
g6770
sS'block_loop.thisRepN'
p7087
I2
sg6383
g6656
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7088
I2
sg6385
g6663
sg55
g11
sS'block_loop.thisTrial'
p7089
Nsg70
Vn
sS'block_loop.thisTrialN'
p7090
I0
sg39
F0.66666258024270064
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1b\x19\x0ekh'
tRp7091
sa(dp7092
S'trial_loop.thisTrialN'
p7093
I47
sg6371
g6922
sS'block_loop.thisIndex'
p7094
g6365
sg38
S'left'
p7095
sg59
g63
sS'trial_loop.thisN'
p7096
I47
sg33
g6376
sg64
g65
sS'trial_loop.thisIndex'
p7097
g60
(g99
S'/\x00\x00\x00'
tRp7098
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7099
I0
sg6380
g6929
sS'block_loop.thisRepN'
p7100
I2
sg6383
g6376
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7101
I2
sg6385
g6386
sg55
g11
sS'block_loop.thisTrial'
p7102
Nsg70
Vn
sS'block_loop.thisTrialN'
p7103
I0
sg39
F0.71668242316081887
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1b\x1f\t\xc0\x18'
tRp7104
sa(dp7105
S'trial_loop.thisTrialN'
p7106
I48
sg6371
g6748
sS'block_loop.thisIndex'
p7107
g6365
sg38
S'right'
p7108
sg59
g63
sS'trial_loop.thisN'
p7109
I48
sg33
g6498
sg64
g65
sS'trial_loop.thisIndex'
p7110
g60
(g99
S'0\x00\x00\x00'
tRp7111
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7112
I0
sg6380
g6755
sS'block_loop.thisRepN'
p7113
I2
sg6383
g6498
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7114
I2
sg6385
g6505
sg55
g11
sS'block_loop.thisTrial'
p7115
Nsg70
Vn
sS'block_loop.thisTrialN'
p7116
I0
sg39
F0.84998722754244227
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1b%\x06\x06\xf8'
tRp7117
sa(dp7118
S'trial_loop.thisTrialN'
p7119
I49
sg6371
S'20-fruit_pastilles.png'
p7120
sS'block_loop.thisIndex'
p7121
g6365
sg38
S'right'
p7122
sg59
g63
sS'trial_loop.thisN'
p7123
I49
sg33
g6727
sg64
g65
sS'trial_loop.thisIndex'
p7124
g60
(g99
S'1\x00\x00\x00'
tRp7125
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7126
I0
sg6380
S'2-steamed_puddings.png'
p7127
sS'block_loop.thisRepN'
p7128
I2
sg6383
g6720
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7129
I2
sg6385
g6727
sg55
g11
sS'block_loop.thisTrial'
p7130
Nsg70
Vn
sS'block_loop.thisTrialN'
p7131
I0
sg39
F0.74987997313291999
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1b+\x04:\x08'
tRp7132
sa(dp7133
S'trial_loop.thisTrialN'
p7134
I50
sg6371
S'17-jacobs_mini_cheddars_redo.png'
p7135
sS'block_loop.thisIndex'
p7136
g6365
sg38
S'left'
p7137
sg59
g63
sS'trial_loop.thisN'
p7138
I50
sg33
g6547
sg64
g65
sS'trial_loop.thisIndex'
p7139
g60
(g99
S'2\x00\x00\x00'
tRp7140
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7141
I0
sg6380
S'8-liquorice_catherine_wheels.png'
p7142
sS'block_loop.thisRepN'
p7143
I2
sg6383
g6547
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7144
I2
sg6385
g6554
sg55
g11
sS'block_loop.thisTrial'
p7145
Nsg70
Vn
sS'block_loop.thisTrialN'
p7146
I0
sg39
F0.84992849706031848
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1b1\x00\xfa\x00'
tRp7147
sa(dp7148
S'trial_loop.thisTrialN'
p7149
I51
sg6371
g7066
sS'block_loop.thisIndex'
p7150
g6365
sg38
S'left'
p7151
sg59
g63
sS'trial_loop.thisN'
p7152
I51
sg33
g6536
sg64
g65
sS'trial_loop.thisIndex'
p7153
g60
(g99
S'3\x00\x00\x00'
tRp7154
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7155
I0
sg6380
g7073
sS'block_loop.thisRepN'
p7156
I2
sg6383
g6536
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7157
I2
sg6385
g6530
sg55
g11
sS'block_loop.thisTrial'
p7158
Nsg70
Vn
sS'block_loop.thisTrialN'
p7159
I0
sg39
F0.84988088544923812
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1b6\x0eoP'
tRp7160
sa(dp7161
S'trial_loop.thisTrialN'
p7162
I52
sg6371
g7120
sS'block_loop.thisIndex'
p7163
g6365
sg38
S'right'
p7164
sg59
g63
sS'trial_loop.thisN'
p7165
I52
sg33
g6720
sg64
g65
sS'trial_loop.thisIndex'
p7166
g60
(g99
S'4\x00\x00\x00'
tRp7167
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7168
I0
sg6380
g7127
sS'block_loop.thisRepN'
p7169
I2
sg6383
g6720
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7170
I2
sg6385
g6727
sg55
g11
sS'block_loop.thisTrial'
p7171
Nsg70
Vn
sS'block_loop.thisTrialN'
p7172
I0
sg39
F0.6332549119797477
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1c\x00\x0c\x9ex'
tRp7173
sa(dp7174
S'trial_loop.thisTrialN'
p7175
I53
sg6371
g6443
sS'block_loop.thisIndex'
p7176
g6365
sg38
S'right'
p7177
sg59
g63
sS'trial_loop.thisN'
p7178
I53
sg33
g6447
sg64
g65
sS'trial_loop.thisIndex'
p7179
g60
(g99
S'5\x00\x00\x00'
tRp7180
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7181
I0
sg6380
g6451
sS'block_loop.thisRepN'
p7182
I2
sg6383
g6447
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7183
I2
sg6385
g6454
sg55
g11
sS'block_loop.thisTrial'
p7184
Nsg70
Vn
sS'block_loop.thisTrialN'
p7185
I0
sg39
F0.71665020692671533
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1c\x06\x07z\x10'
tRp7186
sa(dp7187
S'trial_loop.thisTrialN'
p7188
I54
sg6371
g6609
sS'block_loop.thisIndex'
p7189
g6365
sg38
S'right'
p7190
sg59
g63
sS'trial_loop.thisN'
p7191
I54
sg33
g6613
sg64
g65
sS'trial_loop.thisIndex'
p7192
g60
(g99
S'6\x00\x00\x00'
tRp7193
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7194
I0
sg6380
g6617
sS'block_loop.thisRepN'
p7195
I2
sg6383
g6613
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7196
I2
sg6385
g6620
sg55
g11
sS'block_loop.thisTrial'
p7197
Nsg70
Vn
sS'block_loop.thisTrialN'
p7198
I0
sg39
F0.83326557469990803
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1c\x0c\x03\xc0\xf0'
tRp7199
sa(dp7200
S'trial_loop.thisTrialN'
p7201
I55
sg6371
g6682
sS'block_loop.thisIndex'
p7202
g6365
sg38
S'left'
p7203
sg59
g63
sS'trial_loop.thisN'
p7204
I55
sg33
g6686
sg64
g65
sS'trial_loop.thisIndex'
p7205
g60
(g99
S'7\x00\x00\x00'
tRp7206
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7207
I0
sg6380
g6690
sS'block_loop.thisRepN'
p7208
I2
sg6383
g6686
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7209
I2
sg6385
g6693
sg55
g11
sS'block_loop.thisTrial'
p7210
Nsg70
Vn
sS'block_loop.thisTrialN'
p7211
I0
sg39
F0.71654785622376949
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1c\x12\x01\xb5\x80'
tRp7212
sa(dp7213
S'trial_loop.thisTrialN'
p7214
I56
sg6371
g6543
sS'block_loop.thisIndex'
p7215
g6365
sg38
S'right'
p7216
sg59
g63
sS'trial_loop.thisN'
p7217
I56
sg33
g6547
sg64
g65
sS'trial_loop.thisIndex'
p7218
g60
(g99
S'8\x00\x00\x00'
tRp7219
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7220
I0
sg6380
g6551
sS'block_loop.thisRepN'
p7221
I2
sg6383
g6547
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7222
I2
sg6385
g6554
sg55
g11
sS'block_loop.thisTrial'
p7223
Nsg70
Vn
sS'block_loop.thisTrialN'
p7224
I0
sg39
F0.69991657990249223
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1c\x17\r>\xa0'
tRp7225
sa(dp7226
S'trial_loop.thisTrialN'
p7227
I57
sg6371
g6494
sS'block_loop.thisIndex'
p7228
g6365
sg38
S'left'
p7229
sg59
g63
sS'trial_loop.thisN'
p7230
I57
sg33
g6505
sg64
g65
sS'trial_loop.thisIndex'
p7231
g60
(g99
S'9\x00\x00\x00'
tRp7232
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7233
I0
sg6380
g6502
sS'block_loop.thisRepN'
p7234
I2
sg6383
g6498
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7235
I2
sg6385
g6505
sg55
g11
sS'block_loop.thisTrial'
p7236
Nsg70
Vn
sS'block_loop.thisTrialN'
p7237
I0
sg39
F0.91655823384280666
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1c\x1d\t\x0ch'
tRp7238
sa(dp7239
S'trial_loop.thisTrialN'
p7240
I58
sg6371
g6716
sS'block_loop.thisIndex'
p7241
g6365
sg38
S'left'
p7242
sg59
g63
sS'trial_loop.thisN'
p7243
I58
sg33
g6727
sg64
g65
sS'trial_loop.thisIndex'
p7244
g60
(g99
S':\x00\x00\x00'
tRp7245
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7246
I0
sg6380
g6724
sS'block_loop.thisRepN'
p7247
I2
sg6383
g6720
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7248
I2
sg6385
g6727
sg55
g11
sS'block_loop.thisTrial'
p7249
Nsg70
Vn
sS'block_loop.thisTrialN'
p7250
I0
sg39
F0.61667523865617113
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1c#\x08l@'
tRp7251
sa(dp7252
S'trial_loop.thisTrialN'
p7253
I59
sg6371
g6823
sS'block_loop.thisIndex'
p7254
g6365
sg38
S'left'
p7255
sg59
g63
sS'trial_loop.thisN'
p7256
I59
sg33
g6789
sg64
g65
sS'trial_loop.thisIndex'
p7257
g60
(g99
S';\x00\x00\x00'
tRp7258
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7259
I0
sg6380
g6830
sS'block_loop.thisRepN'
p7260
I2
sg6383
g6782
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7261
I2
sg6385
g6789
sg55
g11
sS'block_loop.thisTrial'
p7262
Nsg70
Vn
sS'block_loop.thisTrialN'
p7263
I0
sg39
F0.58328182536570239
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1c)\x03\r@'
tRp7264
sa(dp7265
S'trial_loop.thisTrialN'
p7266
I60
sg6371
g6952
sS'block_loop.thisIndex'
p7267
g6365
sg38
S'right'
p7268
sg59
g63
sS'trial_loop.thisN'
p7269
I60
sg33
g6487
sg64
g65
sS'trial_loop.thisIndex'
p7270
g60
(g99
S'<\x00\x00\x00'
tRp7271
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7272
I0
sg6380
g6959
sS'block_loop.thisRepN'
p7273
I2
sg6383
g6487
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7274
I2
sg6385
g6481
sg55
g11
sS'block_loop.thisTrial'
p7275
Nsg70
Vn
sS'block_loop.thisTrialN'
p7276
I0
sg39
F0.63327886033221148
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1c.\x0cs\x80'
tRp7277
sa(dp7278
S'trial_loop.thisTrialN'
p7279
I61
sg6371
S'23-crunchie_redo.png'
p7280
sS'block_loop.thisIndex'
p7281
g6365
sg38
S'left'
p7282
sg59
g63
sS'trial_loop.thisN'
p7283
I61
sg33
g6430
sg64
g65
sS'trial_loop.thisIndex'
p7284
g60
(g99
S'=\x00\x00\x00'
tRp7285
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7286
I0
sg6380
S'33-ambrosia_rice.png'
p7287
sS'block_loop.thisRepN'
p7288
I2
sg6383
g6430
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7289
I2
sg6385
g6437
sg55
g11
sS'block_loop.thisTrial'
p7290
Nsg70
Vn
sS'block_loop.thisTrialN'
p7291
I0
sg39
F0.83309594052479952
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1c4\x07K0'
tRp7292
sa(dp7293
S'trial_loop.thisTrialN'
p7294
I62
sg6371
g6748
sS'block_loop.thisIndex'
p7295
g6365
sg38
S'right'
p7296
sg59
g63
sS'trial_loop.thisN'
p7297
I62
sg33
g6498
sg64
g65
sS'trial_loop.thisIndex'
p7298
g60
(g99
S'>\x00\x00\x00'
tRp7299
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7300
I0
sg6380
g6755
sS'block_loop.thisRepN'
p7301
I2
sg6383
g6498
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7302
I2
sg6385
g6505
sg55
g11
sS'block_loop.thisTrial'
p7303
Nsg70
Vn
sS'block_loop.thisTrialN'
p7304
I0
sg39
F1.0331875714909984
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1c:\x05?\xc0'
tRp7305
sa(dp7306
S'trial_loop.thisTrialN'
p7307
I63
sg6371
g6460
sS'block_loop.thisIndex'
p7308
g6365
sg38
S'right'
p7309
sg59
g63
sS'trial_loop.thisN'
p7310
I63
sg33
g6464
sg64
g65
sS'trial_loop.thisIndex'
p7311
g60
(g99
S'?\x00\x00\x00'
tRp7312
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7313
I0
sg6380
g6468
sS'block_loop.thisRepN'
p7314
I2
sg6383
g6464
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7315
I2
sg6385
g6471
sg55
g11
sS'block_loop.thisTrial'
p7316
Nsg70
Vn
sS'block_loop.thisTrialN'
p7317
I0
sg39
F0.74993157613425865
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1d\x04\x06I`'
tRp7318
sa(dp7319
S'trial_loop.thisTrialN'
p7320
I64
sg6371
S'46-pistachios.png'
p7321
sS'block_loop.thisIndex'
p7322
g6365
sg38
S'left'
p7323
sg59
g63
sS'trial_loop.thisN'
p7324
I64
sg33
g6915
sg64
g65
sS'trial_loop.thisIndex'
p7325
g60
(g99
S'@\x00\x00\x00'
tRp7326
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7327
I0
sg6380
S'29-beans.png'
p7328
sS'block_loop.thisRepN'
p7329
I2
sg6383
g6915
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7330
I2
sg6385
g6909
sg55
g11
sS'block_loop.thisTrial'
p7331
Nsg70
Vn
sS'block_loop.thisTrialN'
p7332
I0
sg39
F0.89990101347211748
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1d\n\x03\r@'
tRp7333
sa(dp7334
S'trial_loop.thisTrialN'
p7335
I65
sg6371
g6763
sS'block_loop.thisIndex'
p7336
g6365
sg38
S'left'
p7337
sg59
g63
sS'trial_loop.thisN'
p7338
I65
sg33
g6656
sg64
g65
sS'trial_loop.thisIndex'
p7339
g60
(g99
S'A\x00\x00\x00'
tRp7340
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7341
I0
sg6380
g6770
sS'block_loop.thisRepN'
p7342
I2
sg6383
g6656
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7343
I2
sg6385
g6663
sg55
g11
sS'block_loop.thisTrial'
p7344
Nsg70
Vn
sS'block_loop.thisTrialN'
p7345
I0
sg39
F0.68368016631575301
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1d\x10\x01\xf4\x00'
tRp7346
sa(dp7347
S'trial_loop.thisTrialN'
p7348
I66
sg6371
g6460
sS'block_loop.thisIndex'
p7349
g6365
sg38
S'right'
p7350
sg59
g63
sS'trial_loop.thisN'
p7351
I66
sg33
g6471
sg64
g65
sS'trial_loop.thisIndex'
p7352
g60
(g99
S'B\x00\x00\x00'
tRp7353
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7354
I0
sg6380
g6468
sS'block_loop.thisRepN'
p7355
I2
sg6383
g6464
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7356
I2
sg6385
g6471
sg55
g11
sS'block_loop.thisTrial'
p7357
Nsg70
Vn
sS'block_loop.thisTrialN'
p7358
I0
sg39
F0.95003803226791206
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1d\x15\x0c\xc9p'
tRp7359
sa(dp7360
S'trial_loop.thisTrialN'
p7361
I67
sg6371
g6426
sS'block_loop.thisIndex'
p7362
g6365
sg38
S'right'
p7363
sg59
g63
sS'trial_loop.thisN'
p7364
I67
sg33
g6437
sg64
g65
sS'trial_loop.thisIndex'
p7365
g60
(g99
S'C\x00\x00\x00'
tRp7366
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7367
I0
sg6380
g6434
sS'block_loop.thisRepN'
p7368
I2
sg6383
g6430
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7369
I2
sg6385
g6437
sg55
g11
sS'block_loop.thisTrial'
p7370
Nsg70
Vn
sS'block_loop.thisTrialN'
p7371
I0
sg39
F0.79997023561736569
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1d\x1b\x0c\xa2`'
tRp7372
sa(dp7373
S'trial_loop.thisTrialN'
p7374
I68
sg6371
S'25-kitkat.png'
p7375
sS'block_loop.thisIndex'
p7376
g6365
sg38
S'right'
p7377
sg59
g63
sS'trial_loop.thisN'
p7378
I68
sg33
g7008
sg64
g65
sS'trial_loop.thisIndex'
p7379
g60
(g99
S'D\x00\x00\x00'
tRp7380
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7381
I0
sg6380
S'31-hobnobs.png'
p7382
sS'block_loop.thisRepN'
p7383
I2
sg6383
g7001
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7384
I2
sg6385
g7008
sg55
g11
sS'block_loop.thisTrial'
p7385
Nsg70
Vn
sS'block_loop.thisTrialN'
p7386
I0
sg39
F0.71659404233287205
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1d!\n\x19\xf0'
tRp7387
sa(dp7388
S'trial_loop.thisTrialN'
p7389
I69
sg6371
g6594
sS'block_loop.thisIndex'
p7390
g6365
sg38
S'left'
p7391
sg59
g63
sS'trial_loop.thisN'
p7392
I69
sg33
g6564
sg64
g65
sS'trial_loop.thisIndex'
p7393
g60
(g99
S'E\x00\x00\x00'
tRp7394
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7395
I0
sg6380
g6601
sS'block_loop.thisRepN'
p7396
I2
sg6383
g6564
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7397
I2
sg6385
g6571
sg55
g11
sS'block_loop.thisTrial'
p7398
Nsg70
Vn
sS'block_loop.thisTrialN'
p7399
I0
sg39
F0.71645919029469951
sg34
g753
(S"\x07\xdf\x07\x0b\x11\x1d'\x06d\xb8"
tRp7400
sa(dp7401
S'trial_loop.thisTrialN'
p7402
I70
sg6371
g6609
sS'block_loop.thisIndex'
p7403
g6365
sg38
S'right'
p7404
sg59
g63
sS'trial_loop.thisN'
p7405
I70
sg33
g6613
sg64
g65
sS'trial_loop.thisIndex'
p7406
g60
(g99
S'F\x00\x00\x00'
tRp7407
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7408
I0
sg6380
g6617
sS'block_loop.thisRepN'
p7409
I2
sg6383
g6613
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7410
I2
sg6385
g6620
sg55
g11
sS'block_loop.thisTrial'
p7411
Nsg70
Vn
sS'block_loop.thisTrialN'
p7412
I0
sg39
F0.86655749258352444
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1d-\x02q\x00'
tRp7413
sa(dp7414
S'trial_loop.thisTrialN'
p7415
I71
sg6371
g7321
sS'block_loop.thisIndex'
p7416
g6365
sg38
S'left'
p7417
sg59
g63
sS'trial_loop.thisN'
p7418
I71
sg33
g6909
sg64
g65
sS'trial_loop.thisIndex'
p7419
g60
(g99
S'G\x00\x00\x00'
tRp7420
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7421
I0
sg6380
g7328
sS'block_loop.thisRepN'
p7422
I2
sg6383
g6915
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7423
I2
sg6385
g6909
sg55
g11
sS'block_loop.thisTrial'
p7424
Nsg70
Vn
sS'block_loop.thisTrialN'
p7425
I0
sg39
F0.65004983538528904
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1d3\x00\xde\xa8'
tRp7426
sa(dp7427
S'trial_loop.thisTrialN'
p7428
I72
sg6371
g6982
sS'block_loop.thisIndex'
p7429
g6365
sg38
S'left'
p7430
sg59
g63
sS'trial_loop.thisN'
p7431
I72
sg33
g6471
sg64
g65
sS'trial_loop.thisIndex'
p7432
g60
(g99
S'H\x00\x00\x00'
tRp7433
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7434
I0
sg6380
g6989
sS'block_loop.thisRepN'
p7435
I2
sg6383
g6464
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7436
I2
sg6385
g6471
sg55
g11
sS'block_loop.thisTrial'
p7437
Nsg70
Vn
sS'block_loop.thisTrialN'
p7438
I0
sg39
F0.76656826934413402
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1d8\x0bu\x98'
tRp7439
sa(dp7440
S'trial_loop.thisTrialN'
p7441
I73
sg6371
g6609
sS'block_loop.thisIndex'
p7442
g6365
sg38
S'right'
p7443
sg59
g63
sS'trial_loop.thisN'
p7444
I73
sg33
g6613
sg64
g65
sS'trial_loop.thisIndex'
p7445
g60
(g99
S'I\x00\x00\x00'
tRp7446
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7447
I0
sg6380
g6617
sS'block_loop.thisRepN'
p7448
I2
sg6383
g6613
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7449
I2
sg6385
g6620
sg55
g11
sS'block_loop.thisTrial'
p7450
Nsg70
Vn
sS'block_loop.thisTrialN'
p7451
I0
sg39
F0.83321881838855916
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1e\x02\x085\x90'
tRp7452
sa(dp7453
S'trial_loop.thisTrialN'
p7454
I74
sg6371
g7066
sS'block_loop.thisIndex'
p7455
g6365
sg38
S'left'
p7456
sg59
g63
sS'trial_loop.thisN'
p7457
I74
sg33
g6536
sg64
g65
sS'trial_loop.thisIndex'
p7458
g60
(g99
S'J\x00\x00\x00'
tRp7459
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7460
I0
sg6380
g7073
sS'block_loop.thisRepN'
p7461
I2
sg6383
g6536
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7462
I2
sg6385
g6530
sg55
g11
sS'block_loop.thisTrial'
p7463
Nsg70
Vn
sS'block_loop.thisTrialN'
p7464
I0
sg39
F1.6831863740699191
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1e\x08\x06* '
tRp7465
sa(dp7466
S'trial_loop.thisTrialN'
p7467
I75
sg6371
g6997
sS'block_loop.thisIndex'
p7468
g6365
sg38
S'left'
p7469
sg59
g63
sS'trial_loop.thisN'
p7470
I75
sg33
g7001
sg64
g65
sS'trial_loop.thisIndex'
p7471
g60
(g99
S'K\x00\x00\x00'
tRp7472
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7473
I0
sg6380
g7005
sS'block_loop.thisRepN'
p7474
I2
sg6383
g7001
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7475
I2
sg6385
g7008
sg55
g11
sS'block_loop.thisTrial'
p7476
Nsg70
Vn
sS'block_loop.thisTrialN'
p7477
I0
sg39
F0.58325217502351734
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1e\x0f\x01\xf0\x18'
tRp7478
sa(dp7479
S'trial_loop.thisTrialN'
p7480
I76
sg6371
g6905
sS'block_loop.thisIndex'
p7481
g6365
sg38
S'right'
p7482
sg59
g63
sS'trial_loop.thisN'
p7483
I76
sg33
g6915
sg64
g65
sS'trial_loop.thisIndex'
p7484
g60
(g99
S'L\x00\x00\x00'
tRp7485
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7486
I0
sg6380
g6913
sS'block_loop.thisRepN'
p7487
I2
sg6383
g6915
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7488
I2
sg6385
g6909
sg55
g11
sS'block_loop.thisTrial'
p7489
Nsg70
Vn
sS'block_loop.thisTrialN'
p7490
I0
sg39
F0.64990044326987118
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1e\x14\x0bVX'
tRp7491
sa(dp7492
S'trial_loop.thisTrialN'
p7493
I77
sg6371
g6808
sS'block_loop.thisIndex'
p7494
g6365
sg38
S'left'
p7495
sg59
g63
sS'trial_loop.thisN'
p7496
I77
sg33
g6396
sg64
g65
sS'trial_loop.thisIndex'
p7497
g60
(g99
S'M\x00\x00\x00'
tRp7498
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7499
I0
sg6380
g6815
sS'block_loop.thisRepN'
p7500
I2
sg6383
g6396
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7501
I2
sg6385
g6403
sg55
g11
sS'block_loop.thisTrial'
p7502
Nsg70
Vn
sS'block_loop.thisTrialN'
p7503
I0
sg39
F0.66665402725629974
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1e\x1a\x06pp'
tRp7504
sa(dp7505
S'trial_loop.thisTrialN'
p7506
I78
sg6371
S'7-olives.png'
p7507
sS'block_loop.thisIndex'
p7508
g6365
sg38
S'left'
p7509
sg59
g63
sS'trial_loop.thisN'
p7510
I78
sg33
g6413
sg64
g65
sS'trial_loop.thisIndex'
p7511
g60
(g99
S'N\x00\x00\x00'
tRp7512
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7513
I0
sg6380
S'22-daim.png'
p7514
sS'block_loop.thisRepN'
p7515
I2
sg6383
g6413
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7516
I2
sg6385
g6420
sg55
g11
sS'block_loop.thisTrial'
p7517
Nsg70
Vn
sS'block_loop.thisTrialN'
p7518
I0
sg39
F0.71656068569791387
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1e \x01\xff\xb8'
tRp7519
sa(dp7520
S'trial_loop.thisTrialN'
p7521
I79
sg6371
g6922
sS'block_loop.thisIndex'
p7522
g6365
sg38
S'left'
p7523
sg59
g63
sS'trial_loop.thisN'
p7524
I79
sg33
g6376
sg64
g65
sS'trial_loop.thisIndex'
p7525
g60
(g99
S'O\x00\x00\x00'
tRp7526
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7527
I0
sg6380
g6929
sS'block_loop.thisRepN'
p7528
I2
sg6383
g6376
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7529
I2
sg6385
g6386
sg55
g11
sS'block_loop.thisTrial'
p7530
Nsg70
Vn
sS'block_loop.thisTrialN'
p7531
I0
sg39
F0.73326922397245653
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1e%\rN@'
tRp7532
sa(dp7533
S'trial_loop.thisTrialN'
p7534
I80
sg6371
g6823
sS'block_loop.thisIndex'
p7535
g6365
sg38
S'left'
p7536
sg59
g63
sS'trial_loop.thisN'
p7537
I80
sg33
g6789
sg64
g65
sS'trial_loop.thisIndex'
p7538
g60
(g99
S'P\x00\x00\x00'
tRp7539
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7540
I0
sg6380
g6830
sS'block_loop.thisRepN'
p7541
I2
sg6383
g6782
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7542
I2
sg6385
g6789
sg55
g11
sS'block_loop.thisTrial'
p7543
Nsg70
Vn
sS'block_loop.thisTrialN'
p7544
I0
sg39
F0.63323267422310892
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1e+\t\xd3\xa0'
tRp7545
sa(dp7546
S'trial_loop.thisTrialN'
p7547
I81
sg6371
g6733
sS'block_loop.thisIndex'
p7548
g6365
sg38
S'left'
p7549
sg59
g63
sS'trial_loop.thisN'
p7550
I81
sg33
g6613
sg64
g65
sS'trial_loop.thisIndex'
p7551
g60
(g99
S'Q\x00\x00\x00'
tRp7552
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7553
I0
sg6380
g6740
sS'block_loop.thisRepN'
p7554
I2
sg6383
g6613
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7555
I2
sg6385
g6620
sg55
g11
sS'block_loop.thisTrial'
p7556
Nsg70
Vn
sS'block_loop.thisTrialN'
p7557
I0
sg39
F0.69989548253943212
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1e1\x04\xaf8'
tRp7558
sa(dp7559
S'trial_loop.thisTrialN'
p7560
I82
sg6371
g6372
sS'block_loop.thisIndex'
p7561
g6365
sg38
S'right'
p7562
sg59
g63
sS'trial_loop.thisN'
p7563
I82
sg33
g6376
sg64
g65
sS'trial_loop.thisIndex'
p7564
g60
(g99
S'R\x00\x00\x00'
tRp7565
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7566
I0
sg6380
g6381
sS'block_loop.thisRepN'
p7567
I2
sg6383
g6376
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7568
I2
sg6385
g6386
sg55
g11
sS'block_loop.thisTrial'
p7569
Nsg70
Vn
sS'block_loop.thisTrialN'
p7570
I0
sg39
F0.89987678001853055
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1e7\x00\xbb\x80'
tRp7571
sa(dp7572
S'trial_loop.thisTrialN'
p7573
I83
sg6371
g7375
sS'block_loop.thisIndex'
p7574
g6365
sg38
S'right'
p7575
sg59
g63
sS'trial_loop.thisN'
p7576
I83
sg33
g7008
sg64
g65
sS'trial_loop.thisIndex'
p7577
g60
(g99
S'S\x00\x00\x00'
tRp7578
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7579
I0
sg6380
g7382
sS'block_loop.thisRepN'
p7580
I2
sg6383
g7001
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7581
I2
sg6385
g7008
sg55
g11
sS'block_loop.thisTrial'
p7582
Nsg70
Vn
sS'block_loop.thisTrialN'
p7583
I0
sg39
F0.76656997994359699
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1f\x00\x0e\xe4\x80'
tRp7584
sa(dp7585
S'trial_loop.thisTrialN'
p7586
I84
sg6371
g6877
sS'block_loop.thisIndex'
p7587
g6365
sg38
S'right'
p7588
sg59
g63
sS'trial_loop.thisN'
p7589
I84
sg33
g6588
sg64
g65
sS'trial_loop.thisIndex'
p7590
g60
(g99
S'T\x00\x00\x00'
tRp7591
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7592
I0
sg6380
g6884
sS'block_loop.thisRepN'
p7593
I2
sg6383
g6581
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7594
I2
sg6385
g6588
sg55
g11
sS'block_loop.thisTrial'
p7595
Nsg70
Vn
sS'block_loop.thisTrialN'
p7596
I0
sg39
F0.86662221016013063
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1f\x06\x0b\xe2\xf8'
tRp7597
sa(dp7598
S'trial_loop.thisTrialN'
p7599
I85
sg6371
g6443
sS'block_loop.thisIndex'
p7600
g6365
sg38
S'right'
p7601
sg59
g63
sS'trial_loop.thisN'
p7602
I85
sg33
g6447
sg64
g65
sS'trial_loop.thisIndex'
p7603
g60
(g99
S'U\x00\x00\x00'
tRp7604
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7605
I0
sg6380
g6451
sS'block_loop.thisRepN'
p7606
I2
sg6383
g6447
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7607
I2
sg6385
g6454
sg55
g11
sS'block_loop.thisTrial'
p7608
Nsg70
Vn
sS'block_loop.thisTrialN'
p7609
I0
sg39
F0.73331027829408413
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1f\x0c\nP\xa0'
tRp7610
sa(dp7611
S'trial_loop.thisTrialN'
p7612
I86
sg6371
g7120
sS'block_loop.thisIndex'
p7613
g6365
sg38
S'right'
p7614
sg59
g63
sS'trial_loop.thisN'
p7615
I86
sg33
g6720
sg64
g65
sS'trial_loop.thisIndex'
p7616
g60
(g99
S'V\x00\x00\x00'
tRp7617
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7618
I0
sg6380
g7127
sS'block_loop.thisRepN'
p7619
I2
sg6383
g6720
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7620
I2
sg6385
g6727
sg55
g11
sS'block_loop.thisTrial'
p7621
Nsg70
Vn
sS'block_loop.thisTrialN'
p7622
I0
sg39
F1.0998965659200621
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1f\x12\x06\xd6\x00'
tRp7623
sa(dp7624
S'trial_loop.thisTrialN'
p7625
I87
sg6371
g7507
sS'block_loop.thisIndex'
p7626
g6365
sg38
S'left'
p7627
sg59
g63
sS'trial_loop.thisN'
p7628
I87
sg33
g6413
sg64
g65
sS'trial_loop.thisIndex'
p7629
g60
(g99
S'W\x00\x00\x00'
tRp7630
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7631
I0
sg6380
g7514
sS'block_loop.thisRepN'
p7632
I2
sg6383
g6413
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7633
I2
sg6385
g6420
sg55
g11
sS'block_loop.thisTrial'
p7634
Nsg70
Vn
sS'block_loop.thisTrialN'
p7635
I0
sg39
F0.5832350690579915
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1f\x18\x08\xd5\xb8'
tRp7636
sa(dp7637
S'trial_loop.thisTrialN'
p7638
I88
sg6371
g6699
sS'block_loop.thisIndex'
p7639
g6365
sg38
S'left'
p7640
sg59
g63
sS'trial_loop.thisN'
p7641
I88
sg33
g6703
sg64
g65
sS'trial_loop.thisIndex'
p7642
g60
(g99
S'X\x00\x00\x00'
tRp7643
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7644
I0
sg6380
g6707
sS'block_loop.thisRepN'
p7645
I2
sg6383
g6703
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7646
I2
sg6385
g6710
sg55
g11
sS'block_loop.thisTrial'
p7647
Nsg70
Vn
sS'block_loop.thisTrialN'
p7648
I0
sg39
F0.73320821268862346
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1f\x1e\x02\xf9\xb8'
tRp7649
sa(dp7650
S'trial_loop.thisTrialN'
p7651
I89
sg6371
g6543
sS'block_loop.thisIndex'
p7652
g6365
sg38
S'right'
p7653
sg59
g63
sS'trial_loop.thisN'
p7654
I89
sg33
g6547
sg64
g65
sS'trial_loop.thisIndex'
p7655
g60
(g99
S'Y\x00\x00\x00'
tRp7656
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7657
I0
sg6380
g6551
sS'block_loop.thisRepN'
p7658
I2
sg6383
g6547
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7659
I2
sg6385
g6554
sg55
g11
sS'block_loop.thisTrial'
p7660
Nsg70
Vn
sS'block_loop.thisTrialN'
p7661
I0
sg39
F0.70000638622877887
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1f#\x0e\xc1X'
tRp7662
sa(dp7663
S'trial_loop.thisTrialN'
p7664
I90
sg6371
g7375
sS'block_loop.thisIndex'
p7665
g6365
sg38
S'right'
p7666
sg59
g63
sS'trial_loop.thisN'
p7667
I90
sg33
g7001
sg64
g65
sS'trial_loop.thisIndex'
p7668
g60
(g99
S'Z\x00\x00\x00'
tRp7669
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7670
I0
sg6380
g7382
sS'block_loop.thisRepN'
p7671
I2
sg6383
g7001
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7672
I2
sg6385
g7008
sg55
g11
sS'block_loop.thisTrial'
p7673
Nsg70
Vn
sS'block_loop.thisTrialN'
p7674
I0
sg39
F0.69988436366475071
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1f)\n\x8f '
tRp7675
sa(dp7676
S'trial_loop.thisTrialN'
p7677
I91
sg6371
g6967
sS'block_loop.thisIndex'
p7678
g6365
sg38
S'right'
p7679
sg59
g63
sS'trial_loop.thisN'
p7680
I91
sg33
g6686
sg64
g65
sS'trial_loop.thisIndex'
p7681
g60
(g99
S'[\x00\x00\x00'
tRp7682
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7683
I0
sg6380
g6974
sS'block_loop.thisRepN'
p7684
I2
sg6383
g6686
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7685
I2
sg6385
g6693
sg55
g11
sS'block_loop.thisTrial'
p7686
Nsg70
Vn
sS'block_loop.thisTrialN'
p7687
I0
sg39
F0.8332327882599202
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1f/\x06\x9bh'
tRp7688
sa(dp7689
S'trial_loop.thisTrialN'
p7690
I92
sg6371
g6494
sS'block_loop.thisIndex'
p7691
g6365
sg38
S'left'
p7692
sg59
g63
sS'trial_loop.thisN'
p7693
I92
sg33
g6498
sg64
g65
sS'trial_loop.thisIndex'
p7694
g60
(g99
S'\\\x00\x00\x00'
tRp7695
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7696
I0
sg6380
g6502
sS'block_loop.thisRepN'
p7697
I2
sg6383
g6498
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7698
I2
sg6385
g6505
sg55
g11
sS'block_loop.thisTrial'
p7699
Nsg70
Vn
sS'block_loop.thisTrialN'
p7700
I0
sg39
F0.83331774789621704
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1f5\x04\x8c\x10'
tRp7701
sa(dp7702
S'trial_loop.thisTrialN'
p7703
I93
sg6371
g6560
sS'block_loop.thisIndex'
p7704
g6365
sg38
S'right'
p7705
sg59
g63
sS'trial_loop.thisN'
p7706
I93
sg33
g6564
sg64
g65
sS'trial_loop.thisIndex'
p7707
g60
(g99
S']\x00\x00\x00'
tRp7708
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7709
I0
sg6380
g6568
sS'block_loop.thisRepN'
p7710
I2
sg6383
g6564
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7711
I2
sg6385
g6571
sg55
g11
sS'block_loop.thisTrial'
p7712
Nsg70
Vn
sS'block_loop.thisTrialN'
p7713
I0
sg39
F0.84977910494490061
sg34
g753
(S'\x07\xdf\x07\x0b\x11\x1f;\x02\x80\xa0'
tRp7714
sa(dp7715
S'trial_loop.thisTrialN'
p7716
I94
sg6371
g6937
sS'block_loop.thisIndex'
p7717
g6365
sg38
S'right'
p7718
sg59
g63
sS'trial_loop.thisN'
p7719
I94
sg33
g6703
sg64
g65
sS'trial_loop.thisIndex'
p7720
g60
(g99
S'^\x00\x00\x00'
tRp7721
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7722
I0
sg6380
g6944
sS'block_loop.thisRepN'
p7723
I2
sg6383
g6703
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7724
I2
sg6385
g6710
sg55
g11
sS'block_loop.thisTrial'
p7725
Nsg70
Vn
sS'block_loop.thisTrialN'
p7726
I0
sg39
F0.8333536704267317
sg34
g753
(S'\x07\xdf\x07\x0b\x11 \x05\x00\xaf\xc8'
tRp7727
sa(dp7728
S'trial_loop.thisTrialN'
p7729
I95
sg6371
g7280
sS'block_loop.thisIndex'
p7730
g6365
sg38
S'left'
p7731
sg59
g63
sS'trial_loop.thisN'
p7732
I95
sg33
g6430
sg64
g65
sS'trial_loop.thisIndex'
p7733
g60
(g99
S'_\x00\x00\x00'
tRp7734
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7735
I0
sg6380
g7287
sS'block_loop.thisRepN'
p7736
I2
sg6383
g6430
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7737
I2
sg6385
g6437
sg55
g11
sS'block_loop.thisTrial'
p7738
Nsg70
Vn
sS'block_loop.thisTrialN'
p7739
I0
sg39
F0.91668567329543293
sg34
g753
(S'\x07\xdf\x07\x0b\x11 \n\r\xe6\x98'
tRp7740
sa(dp7741
S'trial_loop.thisTrialN'
p7742
I96
sg6371
g6511
sS'block_loop.thisIndex'
p7743
g6365
sg38
S'left'
p7744
sg59
g63
sS'trial_loop.thisN'
p7745
I96
sg33
g6447
sg64
g65
sS'trial_loop.thisIndex'
p7746
g60
(g99
S'`\x00\x00\x00'
tRp7747
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7748
I0
sg6380
g6518
sS'block_loop.thisRepN'
p7749
I2
sg6383
g6447
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7750
I2
sg6385
g6454
sg55
g11
sS'block_loop.thisTrial'
p7751
Nsg70
Vn
sS'block_loop.thisTrialN'
p7752
I0
sg39
F0.64989046479240642
sg34
g753
(S'\x07\xdf\x07\x0b\x11 \x10\r\x07\xf0'
tRp7753
sa(dp7754
S'trial_loop.thisTrialN'
p7755
I97
sg6371
g7066
sS'block_loop.thisIndex'
p7756
g6365
sg38
S'left'
p7757
sg59
g63
sS'trial_loop.thisN'
p7758
I97
sg33
g6536
sg64
g65
sS'trial_loop.thisIndex'
p7759
g60
(g99
S'a\x00\x00\x00'
tRp7760
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7761
I0
sg6380
g7073
sS'block_loop.thisRepN'
p7762
I2
sg6383
g6536
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7763
I2
sg6385
g6530
sg55
g11
sS'block_loop.thisTrial'
p7764
Nsg70
Vn
sS'block_loop.thisTrialN'
p7765
I0
sg39
F1.1499956664883939
sg34
g753
(S'\x07\xdf\x07\x0b\x11 \x16\x08\\\xa0'
tRp7766
sa(dp7767
S'trial_loop.thisTrialN'
p7768
I98
sg6371
g6577
sS'block_loop.thisIndex'
p7769
g6365
sg38
S'left'
p7770
sg59
g63
sS'trial_loop.thisN'
p7771
I98
sg33
g6581
sg64
g65
sS'trial_loop.thisIndex'
p7772
g60
(g99
S'b\x00\x00\x00'
tRp7773
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7774
I0
sg6380
g6585
sS'block_loop.thisRepN'
p7775
I2
sg6383
g6581
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7776
I2
sg6385
g6588
sg55
g11
sS'block_loop.thisTrial'
p7777
Nsg70
Vn
sS'block_loop.thisTrialN'
p7778
I0
sg39
F0.58330292272512452
sg34
g753
(S'\x07\xdf\x07\x0b\x11 \x1c\x0b\x13\xf0'
tRp7779
sa(dp7780
S'trial_loop.thisTrialN'
p7781
I99
sg6371
g7321
sS'block_loop.thisIndex'
p7782
g6365
sg38
S'left'
p7783
sg59
g63
sS'trial_loop.thisN'
p7784
I99
sg33
g6915
sg64
g65
sS'trial_loop.thisIndex'
p7785
g60
(g99
S'c\x00\x00\x00'
tRp7786
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7787
I0
sg6380
g7328
sS'block_loop.thisRepN'
p7788
I2
sg6383
g6915
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7789
I2
sg6385
g6909
sg55
g11
sS'block_loop.thisTrial'
p7790
Nsg70
Vn
sS'block_loop.thisTrialN'
p7791
I0
sg39
F0.56667620799635188
sg34
g753
(S'\x07\xdf\x07\x0b\x11 "\x057\xf0'
tRp7792
sa(dp7793
S'trial_loop.thisTrialN'
p7794
I100
sg6371
g6560
sS'block_loop.thisIndex'
p7795
g6365
sg38
S'right'
p7796
sg59
g63
sS'trial_loop.thisN'
p7797
I100
sg33
g6564
sg64
g65
sS'trial_loop.thisIndex'
p7798
g60
(g99
S'd\x00\x00\x00'
tRp7799
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7800
I0
sg6380
g6568
sS'block_loop.thisRepN'
p7801
I2
sg6383
g6564
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7802
I2
sg6385
g6571
sg55
g11
sS'block_loop.thisTrial'
p7803
Nsg70
Vn
sS'block_loop.thisTrialN'
p7804
I0
sg39
F0.66647213380929315
sg34
g753
(S"\x07\xdf\x07\x0b\x11 '\x0e_\xb0"
tRp7805
sa(dp7806
S'trial_loop.thisTrialN'
p7807
I101
sg6371
g6477
sS'block_loop.thisIndex'
p7808
g6365
sg38
S'left'
p7809
sg59
g63
sS'trial_loop.thisN'
p7810
I101
sg33
g6481
sg64
g65
sS'trial_loop.thisIndex'
p7811
g60
(g99
S'e\x00\x00\x00'
tRp7812
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7813
I0
sg6380
g6485
sS'block_loop.thisRepN'
p7814
I2
sg6383
g6487
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7815
I2
sg6385
g6481
sg55
g11
sS'block_loop.thisTrial'
p7816
Nsg70
Vn
sS'block_loop.thisTrialN'
p7817
I0
sg39
F0.63370052241589292
sg34
g753
(S'\x07\xdf\x07\x0b\x11 -\t\xb4`'
tRp7818
sa(dp7819
S'trial_loop.thisTrialN'
p7820
I102
sg6371
g7280
sS'block_loop.thisIndex'
p7821
g6365
sg38
S'left'
p7822
sg59
g63
sS'trial_loop.thisN'
p7823
I102
sg33
g6430
sg64
g65
sS'trial_loop.thisIndex'
p7824
g60
(g99
S'f\x00\x00\x00'
tRp7825
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7826
I0
sg6380
g7287
sS'block_loop.thisRepN'
p7827
I2
sg6383
g6430
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7828
I2
sg6385
g6437
sg55
g11
sS'block_loop.thisTrial'
p7829
Nsg70
Vn
sS'block_loop.thisTrialN'
p7830
I0
sg39
F0.59992308016808238
sg34
g753
(S'\x07\xdf\x07\x0b\x11 3\x04\xcex'
tRp7831
sa(dp7832
S'trial_loop.thisTrialN'
p7833
I103
sg6371
g6997
sS'block_loop.thisIndex'
p7834
g6365
sg38
S'left'
p7835
sg59
g63
sS'trial_loop.thisN'
p7836
I103
sg33
g7001
sg64
g65
sS'trial_loop.thisIndex'
p7837
g60
(g99
S'g\x00\x00\x00'
tRp7838
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7839
I0
sg6380
g7005
sS'block_loop.thisRepN'
p7840
I2
sg6383
g7001
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7841
I2
sg6385
g7008
sg55
g11
sS'block_loop.thisTrial'
p7842
Nsg70
Vn
sS'block_loop.thisTrialN'
p7843
I0
sg39
F0.58327982966875425
sg34
g753
(S'\x07\xdf\x07\x0b\x11 8\x0eoP'
tRp7844
sa(dp7845
S'trial_loop.thisTrialN'
p7846
I104
sg6371
g6778
sS'block_loop.thisIndex'
p7847
g6365
sg38
S'right'
p7848
sg59
g63
sS'trial_loop.thisN'
p7849
I104
sg33
g6782
sg64
g65
sS'trial_loop.thisIndex'
p7850
g60
(g99
S'h\x00\x00\x00'
tRp7851
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7852
I0
sg6380
g6786
sS'block_loop.thisRepN'
p7853
I2
sg6383
g6782
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7854
I2
sg6385
g6789
sg55
g11
sS'block_loop.thisTrial'
p7855
Nsg70
Vn
sS'block_loop.thisTrialN'
p7856
I0
sg39
F0.59995415600860724
sg34
g753
(S'\x07\xdf\x07\x0b\x11!\x02\x08\x93P'
tRp7857
sa(dp7858
S'trial_loop.thisTrialN'
p7859
I105
sg6371
g6392
sS'block_loop.thisIndex'
p7860
g6365
sg38
S'right'
p7861
sg59
g63
sS'trial_loop.thisN'
p7862
I105
sg33
g6403
sg64
g65
sS'trial_loop.thisIndex'
p7863
g60
(g99
S'i\x00\x00\x00'
tRp7864
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7865
I0
sg6380
g6400
sS'block_loop.thisRepN'
p7866
I2
sg6383
g6396
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7867
I2
sg6385
g6403
sg55
g11
sS'block_loop.thisTrial'
p7868
Nsg70
Vn
sS'block_loop.thisTrialN'
p7869
I0
sg39
F0.69962349766865373
sg34
g753
(S'\x07\xdf\x07\x0b\x11!\x08\x02\xf5\xd0'
tRp7870
sa(dp7871
S'trial_loop.thisTrialN'
p7872
I106
sg6371
g7507
sS'block_loop.thisIndex'
p7873
g6365
sg38
S'left'
p7874
sg59
g63
sS'trial_loop.thisN'
p7875
I106
sg33
g6413
sg64
g65
sS'trial_loop.thisIndex'
p7876
g60
(g99
S'j\x00\x00\x00'
tRp7877
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7878
I0
sg6380
g7514
sS'block_loop.thisRepN'
p7879
I2
sg6383
g6413
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7880
I2
sg6385
g6420
sg55
g11
sS'block_loop.thisTrial'
p7881
Nsg70
Vn
sS'block_loop.thisTrialN'
p7882
I0
sg39
F0.68324538965680404
sg34
g753
(S'\x07\xdf\x07\x0b\x11!\r\x0e\x05\xd8'
tRp7883
sa(dp7884
S'trial_loop.thisTrialN'
p7885
I107
sg6371
g6426
sS'block_loop.thisIndex'
p7886
g6365
sg38
S'right'
p7887
sg59
g63
sS'trial_loop.thisN'
p7888
I107
sg33
g6430
sg64
g65
sS'trial_loop.thisIndex'
p7889
g60
(g99
S'k\x00\x00\x00'
tRp7890
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7891
I0
sg6380
g6434
sS'block_loop.thisRepN'
p7892
I2
sg6383
g6430
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7893
I2
sg6385
g6437
sg55
g11
sS'block_loop.thisTrial'
p7894
Nsg70
Vn
sS'block_loop.thisTrialN'
p7895
I0
sg39
F0.65040592459627078
sg34
g753
(S'\x07\xdf\x07\x0b\x11!\x13\t\xd3\xa0'
tRp7896
sa(dp7897
S'trial_loop.thisTrialN'
p7898
I108
sg6371
g6577
sS'block_loop.thisIndex'
p7899
g6365
sg38
S'left'
p7900
sg59
g63
sS'trial_loop.thisN'
p7901
I108
sg33
g6588
sg64
g65
sS'trial_loop.thisIndex'
p7902
g60
(g99
S'l\x00\x00\x00'
tRp7903
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7904
I0
sg6380
g6585
sS'block_loop.thisRepN'
p7905
I2
sg6383
g6581
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7906
I2
sg6385
g6588
sg55
g11
sS'block_loop.thisTrial'
p7907
Nsg70
Vn
sS'block_loop.thisTrialN'
p7908
I0
sg39
F0.6665776206064038
sg34
g753
(S'\x07\xdf\x07\x0b\x11!\x19\x04\xed\xb8'
tRp7909
sa(dp7910
S'trial_loop.thisTrialN'
p7911
I109
sg6371
g6426
sS'block_loop.thisIndex'
p7912
g6365
sg38
S'right'
p7913
sg59
g63
sS'trial_loop.thisN'
p7914
I109
sg33
g6437
sg64
g65
sS'trial_loop.thisIndex'
p7915
g60
(g99
S'm\x00\x00\x00'
tRp7916
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7917
I0
sg6380
g6434
sS'block_loop.thisRepN'
p7918
I2
sg6383
g6430
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7919
I2
sg6385
g6437
sg55
g11
sS'block_loop.thisTrial'
p7920
Nsg70
Vn
sS'block_loop.thisTrialN'
p7921
I0
sg39
F0.89991925983485999
sg34
g753
(S'\x07\xdf\x07\x0b\x11!\x1f\x00}\x00'
tRp7922
sa(dp7923
S'trial_loop.thisTrialN'
p7924
I110
sg6371
g6652
sS'block_loop.thisIndex'
p7925
g6365
sg38
S'right'
p7926
sg59
g63
sS'trial_loop.thisN'
p7927
I110
sg33
g6656
sg64
g65
sS'trial_loop.thisIndex'
p7928
g60
(g99
S'n\x00\x00\x00'
tRp7929
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7930
I0
sg6380
g6660
sS'block_loop.thisRepN'
p7931
I2
sg6383
g6656
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7932
I2
sg6385
g6663
sg55
g11
sS'block_loop.thisTrial'
p7933
Nsg70
Vn
sS'block_loop.thisTrialN'
p7934
I0
sg39
F0.76653206171249622
sg34
g753
(S'\x07\xdf\x07\x0b\x11!$\x0e\xa9\xe8'
tRp7935
sa(dp7936
S'trial_loop.thisTrialN'
p7937
I111
sg6371
g7135
sS'block_loop.thisIndex'
p7938
g6365
sg38
S'left'
p7939
sg59
g63
sS'trial_loop.thisN'
p7940
I111
sg33
g6547
sg64
g65
sS'trial_loop.thisIndex'
p7941
g60
(g99
S'o\x00\x00\x00'
tRp7942
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7943
I0
sg6380
g7142
sS'block_loop.thisRepN'
p7944
I2
sg6383
g6547
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7945
I2
sg6385
g6554
sg55
g11
sS'block_loop.thisTrial'
p7946
Nsg70
Vn
sS'block_loop.thisTrialN'
p7947
I0
sg39
F0.68323683667040314
sg34
g753
(S'\x07\xdf\x07\x0b\x11!*\x0b\xa8`'
tRp7948
sa(dp7949
S'trial_loop.thisTrialN'
p7950
I112
sg6371
g6937
sS'block_loop.thisIndex'
p7951
g6365
sg38
S'right'
p7952
sg59
g63
sS'trial_loop.thisN'
p7953
I112
sg33
g6703
sg64
g65
sS'trial_loop.thisIndex'
p7954
g60
(g99
S'p\x00\x00\x00'
tRp7955
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7956
I0
sg6380
g6944
sS'block_loop.thisRepN'
p7957
I2
sg6383
g6703
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7958
I2
sg6385
g6710
sg55
g11
sS'block_loop.thisTrial'
p7959
Nsg70
Vn
sS'block_loop.thisTrialN'
p7960
I0
sg39
F0.90000336417142535
sg34
g753
(S'\x07\xdf\x07\x0b\x11!0\x077\xa8'
tRp7961
sa(dp7962
S'trial_loop.thisTrialN'
p7963
I113
sg6371
g6967
sS'block_loop.thisIndex'
p7964
g6365
sg38
S'right'
p7965
sg59
g63
sS'trial_loop.thisN'
p7966
I113
sg33
g6686
sg64
g65
sS'trial_loop.thisIndex'
p7967
g60
(g99
S'q\x00\x00\x00'
tRp7968
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7969
I0
sg6380
g6974
sS'block_loop.thisRepN'
p7970
I2
sg6383
g6686
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7971
I2
sg6385
g6693
sg55
g11
sS'block_loop.thisTrial'
p7972
Nsg70
Vn
sS'block_loop.thisTrialN'
p7973
I0
sg39
F0.68322486249599024
sg34
g753
(S'\x07\xdf\x07\x0b\x11!6\x06\x1eh'
tRp7974
sa(dp7975
S'trial_loop.thisTrialN'
p7976
I114
sg6371
g6763
sS'block_loop.thisIndex'
p7977
g6365
sg38
S'left'
p7978
sg59
g63
sS'trial_loop.thisN'
p7979
I114
sg33
g6656
sg64
g65
sS'trial_loop.thisIndex'
p7980
g60
(g99
S'r\x00\x00\x00'
tRp7981
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7982
I0
sg6380
g6770
sS'block_loop.thisRepN'
p7983
I2
sg6383
g6656
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7984
I2
sg6385
g6663
sg55
g11
sS'block_loop.thisTrial'
p7985
Nsg70
Vn
sS'block_loop.thisTrialN'
p7986
I0
sg39
F0.68319008036269224
sg34
g753
(S'\x07\xdf\x07\x0b\x11"\x00\x01\xf0\x18'
tRp7987
sa(dp7988
S'trial_loop.thisTrialN'
p7989
I115
sg6371
g6560
sS'block_loop.thisIndex'
p7990
g6365
sg38
S'right'
p7991
sg59
g63
sS'trial_loop.thisN'
p7992
I115
sg33
g6564
sg64
g65
sS'trial_loop.thisIndex'
p7993
g60
(g99
S's\x00\x00\x00'
tRp7994
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p7995
I0
sg6380
g6568
sS'block_loop.thisRepN'
p7996
I2
sg6383
g6564
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p7997
I2
sg6385
g6571
sg55
g11
sS'block_loop.thisTrial'
p7998
Nsg70
Vn
sS'block_loop.thisTrialN'
p7999
I0
sg39
F0.78312285391439218
sg34
g753
(S'\x07\xdf\x07\x0b\x11"\x05\x0c\xc1\xa0'
tRp8000
sa(dp8001
S'trial_loop.thisTrialN'
p8002
I116
sg6371
g6997
sS'block_loop.thisIndex'
p8003
g6365
sg38
S'left'
p8004
sg59
g63
sS'trial_loop.thisN'
p8005
I116
sg33
g7001
sg64
g65
sS'trial_loop.thisIndex'
p8006
g60
(g99
S't\x00\x00\x00'
tRp8007
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8008
I0
sg6380
g7005
sS'block_loop.thisRepN'
p8009
I2
sg6383
g7001
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8010
I2
sg6385
g7008
sg55
g11
sS'block_loop.thisTrial'
p8011
Nsg70
Vn
sS'block_loop.thisTrialN'
p8012
I0
sg39
F0.59990654440116487
sg34
g753
(S'\x07\xdf\x07\x0b\x11"\x0b\t\xfe\x98'
tRp8013
sa(dp8014
S'trial_loop.thisTrialN'
p8015
I117
sg6371
g7321
sS'block_loop.thisIndex'
p8016
g6365
sg38
S'left'
p8017
sg59
g63
sS'trial_loop.thisN'
p8018
I117
sg33
g6915
sg64
g65
sS'trial_loop.thisIndex'
p8019
g60
(g99
S'u\x00\x00\x00'
tRp8020
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8021
I0
sg6380
g7328
sS'block_loop.thisRepN'
p8022
I2
sg6383
g6915
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8023
I2
sg6385
g6909
sg55
g11
sS'block_loop.thisTrial'
p8024
Nsg70
Vn
sS'block_loop.thisTrialN'
p8025
I0
sg39
F0.68317753598603304
sg34
g753
(S'\x07\xdf\x07\x0b\x11"\x11\x04a\x18'
tRp8026
sa(dp8027
S'trial_loop.thisTrialN'
p8028
I118
sg6371
g6594
sS'block_loop.thisIndex'
p8029
g6365
sg38
S'left'
p8030
sg59
g63
sS'trial_loop.thisN'
p8031
I118
sg33
g6571
sg64
g65
sS'trial_loop.thisIndex'
p8032
g60
(g99
S'v\x00\x00\x00'
tRp8033
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8034
I0
sg6380
g6601
sS'block_loop.thisRepN'
p8035
I2
sg6383
g6564
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8036
I2
sg6385
g6571
sg55
g11
sS'block_loop.thisTrial'
p8037
Nsg70
Vn
sS'block_loop.thisTrialN'
p8038
I0
sg39
F0.68322856878876337
sg34
g753
(S'\x07\xdf\x07\x0b\x11"\x17\x00.\xe0'
tRp8039
sa(dp8040
S'trial_loop.thisTrialN'
p8041
I119
sg6371
g6609
sS'block_loop.thisIndex'
p8042
g6365
sg38
S'right'
p8043
sg59
g63
sS'trial_loop.thisN'
p8044
I119
sg33
g6620
sg64
g65
sS'trial_loop.thisIndex'
p8045
g60
(g99
S'w\x00\x00\x00'
tRp8046
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8047
I0
sg6380
g6617
sS'block_loop.thisRepN'
p8048
I2
sg6383
g6613
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8049
I2
sg6385
g6620
sg55
g11
sS'block_loop.thisTrial'
p8050
Nsg70
Vn
sS'block_loop.thisTrialN'
p8051
I0
sg39
F0.68339478176858393
sg34
g753
(S'\x07\xdf\x07\x0b\x11"\x1c\x0b\x00h'
tRp8052
sa(dp8053
S'trial_loop.thisTrialN'
p8054
I120
sg6371
g6543
sS'block_loop.thisIndex'
p8055
g6365
sg38
S'right'
p8056
sg59
g63
sS'trial_loop.thisN'
p8057
I120
sg33
g6547
sg64
g65
sS'trial_loop.thisIndex'
p8058
g60
(g99
S'x\x00\x00\x00'
tRp8059
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8060
I0
sg6380
g6551
sS'block_loop.thisRepN'
p8061
I2
sg6383
g6547
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8062
I2
sg6385
g6554
sg55
g11
sS'block_loop.thisTrial'
p8063
Nsg70
Vn
sS'block_loop.thisTrialN'
p8064
I0
sg39
F0.68327475489786593
sg34
g753
(S'\x07\xdf\x07\x0b\x11""\x06\xd2\x18'
tRp8065
sa(dp8066
S'trial_loop.thisTrialN'
p8067
I121
sg6371
g6952
sS'block_loop.thisIndex'
p8068
g6365
sg38
S'right'
p8069
sg59
g63
sS'trial_loop.thisN'
p8070
I121
sg33
g6487
sg64
g65
sS'trial_loop.thisIndex'
p8071
g60
(g99
S'y\x00\x00\x00'
tRp8072
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8073
I0
sg6380
g6959
sS'block_loop.thisRepN'
p8074
I2
sg6383
g6487
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8075
I2
sg6385
g6481
sg55
g11
sS'block_loop.thisTrial'
p8076
Nsg70
Vn
sS'block_loop.thisTrialN'
p8077
I0
sg39
F0.5665812698789523
sg34
g753
(S'\x07\xdf\x07\x0b\x11"(\x02a`'
tRp8078
sa(dp8079
S'trial_loop.thisTrialN'
p8080
I122
sg6371
g6652
sS'block_loop.thisIndex'
p8081
g6365
sg38
S'right'
p8082
sg59
g63
sS'trial_loop.thisN'
p8083
I122
sg33
g6663
sg64
g65
sS'trial_loop.thisIndex'
p8084
g60
(g99
S'z\x00\x00\x00'
tRp8085
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8086
I0
sg6380
g6660
sS'block_loop.thisRepN'
p8087
I2
sg6383
g6656
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8088
I2
sg6385
g6663
sg55
g11
sS'block_loop.thisTrial'
p8089
Nsg70
Vn
sS'block_loop.thisTrialN'
p8090
I0
sg39
F0.74988282412596163
sg34
g753
(S'\x07\xdf\x07\x0b\x11"-\x0b\x8d\x08'
tRp8091
sa(dp8092
S'trial_loop.thisTrialN'
p8093
I123
sg6371
g6733
sS'block_loop.thisIndex'
p8094
g6365
sg38
S'left'
p8095
sg59
g63
sS'trial_loop.thisN'
p8096
I123
sg33
g6613
sg64
g65
sS'trial_loop.thisIndex'
p8097
g60
(g99
S'{\x00\x00\x00'
tRp8098
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8099
I0
sg6380
g6740
sS'block_loop.thisRepN'
p8100
I2
sg6383
g6613
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8101
I2
sg6385
g6620
sg55
g11
sS'block_loop.thisTrial'
p8102
Nsg70
Vn
sS'block_loop.thisTrialN'
p8103
I0
sg39
F0.7499084830742504
sg34
g753
(S'\x07\xdf\x07\x0b\x11"3\x08M\x00'
tRp8104
sa(dp8105
S'trial_loop.thisTrialN'
p8106
I124
sg6371
g6460
sS'block_loop.thisIndex'
p8107
g6365
sg38
S'right'
p8108
sg59
g63
sS'trial_loop.thisN'
p8109
I124
sg33
g6464
sg64
g65
sS'trial_loop.thisIndex'
p8110
g60
(g99
S'|\x00\x00\x00'
tRp8111
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8112
I0
sg6380
g6468
sS'block_loop.thisRepN'
p8113
I2
sg6383
g6464
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8114
I2
sg6385
g6471
sg55
g11
sS'block_loop.thisTrial'
p8115
Nsg70
Vn
sS'block_loop.thisTrialN'
p8116
I0
sg39
F0.74993556752451696
sg34
g753
(S'\x07\xdf\x07\x0b\x11"9\x05\x10\xe0'
tRp8117
sa(dp8118
S'trial_loop.thisTrialN'
p8119
I125
sg6371
g6937
sS'block_loop.thisIndex'
p8120
g6365
sg38
S'right'
p8121
sg59
g63
sS'trial_loop.thisN'
p8122
I125
sg33
g6703
sg64
g65
sS'trial_loop.thisIndex'
p8123
g60
(g99
S'}\x00\x00\x00'
tRp8124
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8125
I0
sg6380
g6944
sS'block_loop.thisRepN'
p8126
I2
sg6383
g6703
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8127
I2
sg6385
g6710
sg55
g11
sS'block_loop.thisTrial'
p8128
Nsg70
Vn
sS'block_loop.thisTrialN'
p8129
I0
sg39
F0.76645166366870399
sg34
g753
(S'\x07\xdf\x07\x0b\x11#\x03\x01\x96@'
tRp8130
sa(dp8131
S'trial_loop.thisTrialN'
p8132
I126
sg6371
g6511
sS'block_loop.thisIndex'
p8133
g6365
sg38
S'left'
p8134
sg59
g63
sS'trial_loop.thisN'
p8135
I126
sg33
g6447
sg64
g65
sS'trial_loop.thisIndex'
p8136
g60
(g99
S'~\x00\x00\x00'
tRp8137
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8138
I0
sg6380
g6518
sS'block_loop.thisRepN'
p8139
I2
sg6383
g6447
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8140
I2
sg6385
g6454
sg55
g11
sS'block_loop.thisTrial'
p8141
Nsg70
Vn
sS'block_loop.thisTrialN'
p8142
I0
sg39
F0.61660139789819368
sg34
g753
(S'\x07\xdf\x07\x0b\x11#\x08\r\xd6\xf8'
tRp8143
sa(dp8144
S'trial_loop.thisTrialN'
p8145
I127
sg6371
g6763
sS'block_loop.thisIndex'
p8146
g6365
sg38
S'left'
p8147
sg59
g63
sS'trial_loop.thisN'
p8148
I127
sg33
g6663
sg64
g65
sS'trial_loop.thisIndex'
p8149
g60
(g99
S'\x7f\x00\x00\x00'
tRp8150
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8151
I0
sg6380
g6770
sS'block_loop.thisRepN'
p8152
I2
sg6383
g6656
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8153
I2
sg6385
g6663
sg55
g11
sS'block_loop.thisTrial'
p8154
Nsg70
Vn
sS'block_loop.thisTrialN'
p8155
I0
sg39
F0.73323985872775665
sg34
g753
(S'\x07\xdf\x07\x0b\x11#\x0e\x08t\x10'
tRp8156
sa(dp8157
S'trial_loop.thisTrialN'
p8158
I128
sg6371
g6682
sS'block_loop.thisIndex'
p8159
g6365
sg38
S'left'
p8160
sg59
g63
sS'trial_loop.thisN'
p8161
I128
sg33
g6693
sg64
g65
sS'trial_loop.thisIndex'
p8162
g60
(g99
S'\x80\x00\x00\x00'
tRp8163
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8164
I0
sg6380
g6690
sS'block_loop.thisRepN'
p8165
I2
sg6383
g6686
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8166
I2
sg6385
g6693
sg55
g11
sS'block_loop.thisTrial'
p8167
Nsg70
Vn
sS'block_loop.thisTrialN'
p8168
I0
sg39
F0.68330526054342045
sg34
g753
(S'\x07\xdf\x07\x0b\x11#\x14\x04\xf9p'
tRp8169
sa(dp8170
S'trial_loop.thisTrialN'
p8171
I129
sg6371
g6594
sS'block_loop.thisIndex'
p8172
g6365
sg38
S'left'
p8173
sg59
g63
sS'trial_loop.thisN'
p8174
I129
sg33
g6564
sg64
g65
sS'trial_loop.thisIndex'
p8175
g60
(g99
S'\x81\x00\x00\x00'
tRp8176
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8177
I0
sg6380
g6601
sS'block_loop.thisRepN'
p8178
I2
sg6383
g6564
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8179
I2
sg6385
g6571
sg55
g11
sS'block_loop.thisTrial'
p8180
Nsg70
Vn
sS'block_loop.thisTrialN'
p8181
I0
sg39
F0.616429768029775
sg34
g753
(S'\x07\xdf\x07\x0b\x11#\x1a\x00\x8c\xa0'
tRp8182
sa(dp8183
S'trial_loop.thisTrialN'
p8184
I130
sg6371
g6778
sS'block_loop.thisIndex'
p8185
g6365
sg38
S'right'
p8186
sg59
g63
sS'trial_loop.thisN'
p8187
I130
sg33
g6789
sg64
g65
sS'trial_loop.thisIndex'
p8188
g60
(g99
S'\x82\x00\x00\x00'
tRp8189
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8190
I0
sg6380
g6786
sS'block_loop.thisRepN'
p8191
I2
sg6383
g6782
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8192
I2
sg6385
g6789
sg55
g11
sS'block_loop.thisTrial'
p8193
Nsg70
Vn
sS'block_loop.thisTrialN'
p8194
I0
sg39
F0.58326928098904318
sg34
g753
(S'\x07\xdf\x07\x0b\x11#\x1f\n\xaax'
tRp8195
sa(dp8196
S'trial_loop.thisTrialN'
p8197
I131
sg6371
g6699
sS'block_loop.thisIndex'
p8198
g6365
sg38
S'left'
p8199
sg59
g63
sS'trial_loop.thisN'
p8200
I131
sg33
g6710
sg64
g65
sS'trial_loop.thisIndex'
p8201
g60
(g99
S'\x83\x00\x00\x00'
tRp8202
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8203
I0
sg6380
g6707
sS'block_loop.thisRepN'
p8204
I2
sg6383
g6703
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8205
I2
sg6385
g6710
sg55
g11
sS'block_loop.thisTrial'
p8206
Nsg70
Vn
sS'block_loop.thisTrialN'
p8207
I0
sg39
F0.73328347894130275
sg34
g753
(S'\x07\xdf\x07\x0b\x11#%\x04\xcex'
tRp8208
sa(dp8209
S'trial_loop.thisTrialN'
p8210
I132
sg6371
g7375
sS'block_loop.thisIndex'
p8211
g6365
sg38
S'right'
p8212
sg59
g63
sS'trial_loop.thisN'
p8213
I132
sg33
g7001
sg64
g65
sS'trial_loop.thisIndex'
p8214
g60
(g99
S'\x84\x00\x00\x00'
tRp8215
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8216
I0
sg6380
g7382
sS'block_loop.thisRepN'
p8217
I2
sg6383
g7001
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8218
I2
sg6385
g7008
sg55
g11
sS'block_loop.thisTrial'
p8219
Nsg70
Vn
sS'block_loop.thisTrialN'
p8220
I0
sg39
F0.61660738498903811
sg34
g753
(S'\x07\xdf\x07\x0b\x11#+\x01\x15X'
tRp8221
sa(dp8222
S'trial_loop.thisTrialN'
p8223
I133
sg6371
g6699
sS'block_loop.thisIndex'
p8224
g6365
sg38
S'left'
p8225
sg59
g63
sS'trial_loop.thisN'
p8226
I133
sg33
g6703
sg64
g65
sS'trial_loop.thisIndex'
p8227
g60
(g99
S'\x85\x00\x00\x00'
tRp8228
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8229
I0
sg6380
g6707
sS'block_loop.thisRepN'
p8230
I2
sg6383
g6703
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8231
I2
sg6385
g6710
sg55
g11
sS'block_loop.thisTrial'
p8232
Nsg70
Vn
sS'block_loop.thisTrialN'
p8233
I0
sg39
F0.58321511209578603
sg34
g753
(S'\x07\xdf\x07\x0b\x11#0\n\xf4\xb0'
tRp8234
sa(dp8235
S'trial_loop.thisTrialN'
p8236
I134
sg6371
g6982
sS'block_loop.thisIndex'
p8237
g6365
sg38
S'left'
p8238
sg59
g63
sS'trial_loop.thisN'
p8239
I134
sg33
g6471
sg64
g65
sS'trial_loop.thisIndex'
p8240
g60
(g99
S'\x86\x00\x00\x00'
tRp8241
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8242
I0
sg6380
g6989
sS'block_loop.thisRepN'
p8243
I2
sg6383
g6464
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8244
I2
sg6385
g6471
sg55
g11
sS'block_loop.thisTrial'
p8245
Nsg70
Vn
sS'block_loop.thisTrialN'
p8246
I0
sg39
F0.59994332222777302
sg34
g753
(S'\x07\xdf\x07\x0b\x11#6\x05\x18\xb0'
tRp8247
sa(dp8248
S'trial_loop.thisTrialN'
p8249
I135
sg6371
g7280
sS'block_loop.thisIndex'
p8250
g6365
sg38
S'left'
p8251
sg59
g63
sS'trial_loop.thisN'
p8252
I135
sg33
g6430
sg64
g65
sS'trial_loop.thisIndex'
p8253
g60
(g99
S'\x87\x00\x00\x00'
tRp8254
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8255
I0
sg6380
g7287
sS'block_loop.thisRepN'
p8256
I2
sg6383
g6430
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8257
I2
sg6385
g6437
sg55
g11
sS'block_loop.thisTrial'
p8258
Nsg70
Vn
sS'block_loop.thisTrialN'
p8259
I0
sg39
F0.5832350690579915
sg34
g753
(S'\x07\xdf\x07\x0b\x11#;\x0e\xfb\xf0'
tRp8260
sa(dp8261
S'trial_loop.thisTrialN'
p8262
I136
sg6371
g6905
sS'block_loop.thisIndex'
p8263
g6365
sg38
S'right'
p8264
sg59
g63
sS'trial_loop.thisN'
p8265
I136
sg33
g6915
sg64
g65
sS'trial_loop.thisIndex'
p8266
g60
(g99
S'\x88\x00\x00\x00'
tRp8267
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8268
I0
sg6380
g6913
sS'block_loop.thisRepN'
p8269
I2
sg6383
g6915
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8270
I2
sg6385
g6909
sg55
g11
sS'block_loop.thisTrial'
p8271
Nsg70
Vn
sS'block_loop.thisTrialN'
p8272
I0
sg39
F0.88322440633419319
sg34
g753
(S'\x07\xdf\x07\x0b\x11$\x05\t\x1f\xf0'
tRp8273
sa(dp8274
S'trial_loop.thisTrialN'
p8275
I137
sg6371
g7135
sS'block_loop.thisIndex'
p8276
g6365
sg38
S'left'
p8277
sg59
g63
sS'trial_loop.thisN'
p8278
I137
sg33
g6547
sg64
g65
sS'trial_loop.thisIndex'
p8279
g60
(g99
S'\x89\x00\x00\x00'
tRp8280
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8281
I0
sg6380
g7142
sS'block_loop.thisRepN'
p8282
I2
sg6383
g6547
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8283
I2
sg6385
g6554
sg55
g11
sS'block_loop.thisTrial'
p8284
Nsg70
Vn
sS'block_loop.thisTrialN'
p8285
I0
sg39
F0.73337385546983569
sg34
g753
(S'\x07\xdf\x07\x0b\x11$\x0b\x07\xc80'
tRp8286
sa(dp8287
S'trial_loop.thisTrialN'
p8288
I138
sg6371
g6372
sS'block_loop.thisIndex'
p8289
g6365
sg38
S'right'
p8290
sg59
g63
sS'trial_loop.thisN'
p8291
I138
sg33
g6386
sg64
g65
sS'trial_loop.thisIndex'
p8292
g60
(g99
S'\x8a\x00\x00\x00'
tRp8293
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8294
I0
sg6380
g6381
sS'block_loop.thisRepN'
p8295
I2
sg6383
g6376
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8296
I2
sg6385
g6386
sg55
g11
sS'block_loop.thisTrial'
p8297
Nsg70
Vn
sS'block_loop.thisTrialN'
p8298
I0
sg39
F0.79990437764718081
sg34
g753
(S'\x07\xdf\x07\x0b\x11$\x11\x04\x0f\x10'
tRp8299
sa(dp8300
S'trial_loop.thisTrialN'
p8301
I139
sg6371
g6511
sS'block_loop.thisIndex'
p8302
g6365
sg38
S'left'
p8303
sg59
g63
sS'trial_loop.thisN'
p8304
I139
sg33
g6447
sg64
g65
sS'trial_loop.thisIndex'
p8305
g60
(g99
S'\x8b\x00\x00\x00'
tRp8306
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8307
I0
sg6380
g6518
sS'block_loop.thisRepN'
p8308
I2
sg6383
g6447
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8309
I2
sg6385
g6454
sg55
g11
sS'block_loop.thisTrial'
p8310
Nsg70
Vn
sS'block_loop.thisTrialN'
p8311
I0
sg39
F0.63327344343997538
sg34
g753
(S'\x07\xdf\x07\x0b\x11$\x17\x01\x8a\x88'
tRp8312
sa(dp8313
S'trial_loop.thisTrialN'
p8314
I140
sg6371
g6748
sS'block_loop.thisIndex'
p8315
g6365
sg38
S'left'
p8316
sg59
g63
sS'trial_loop.thisN'
p8317
I140
sg33
g6498
sg64
g65
sS'trial_loop.thisIndex'
p8318
g60
(g99
S'\x8c\x00\x00\x00'
tRp8319
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8320
I0
sg6380
g6755
sS'block_loop.thisRepN'
p8321
I2
sg6383
g6498
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8322
I2
sg6385
g6505
sg55
g11
sS'block_loop.thisTrial'
p8323
Nsg70
Vn
sS'block_loop.thisTrialN'
p8324
I0
sg39
F0.84990283810839173
sg34
g753
(S'\x07\xdf\x07\x0b\x11$\x1c\x0b\xe2\xf8'
tRp8325
sa(dp8326
S'trial_loop.thisTrialN'
p8327
I141
sg6371
g6808
sS'block_loop.thisIndex'
p8328
g6365
sg38
S'left'
p8329
sg59
g63
sS'trial_loop.thisN'
p8330
I141
sg33
g6396
sg64
g65
sS'trial_loop.thisIndex'
p8331
g60
(g99
S'\x8d\x00\x00\x00'
tRp8332
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8333
I0
sg6380
g6815
sS'block_loop.thisRepN'
p8334
I2
sg6383
g6396
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8335
I2
sg6385
g6403
sg55
g11
sS'block_loop.thisTrial'
p8336
Nsg70
Vn
sS'block_loop.thisTrialN'
p8337
I0
sg39
F0.59962857243590406
sg34
g753
(S'\x07\xdf\x07\x0b\x11$"\n\x12 '
tRp8338
sa(dp8339
S'trial_loop.thisTrialN'
p8340
I142
sg6371
g6905
sS'block_loop.thisIndex'
p8341
g6365
sg38
S'right'
p8342
sg59
g63
sS'trial_loop.thisN'
p8343
I142
sg33
g6915
sg64
g65
sS'trial_loop.thisIndex'
p8344
g60
(g99
S'\x8e\x00\x00\x00'
tRp8345
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8346
I0
sg6380
g6913
sS'block_loop.thisRepN'
p8347
I2
sg6383
g6915
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8348
I2
sg6385
g6909
sg55
g11
sS'block_loop.thisTrial'
p8349
Nsg70
Vn
sS'block_loop.thisTrialN'
p8350
I0
sg39
F0.74986315226487932
sg34
g753
(S'\x07\xdf\x07\x0b\x11$(\x04t\xa0'
tRp8351
sa(dp8352
S'trial_loop.thisTrialN'
p8353
I143
sg6371
g6733
sS'block_loop.thisIndex'
p8354
g6365
sg38
S'left'
p8355
sg59
g63
sS'trial_loop.thisN'
p8356
I143
sg33
g6620
sg64
g65
sS'trial_loop.thisIndex'
p8357
g60
(g99
S'\x8f\x00\x00\x00'
tRp8358
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8359
I0
sg6380
g6740
sS'block_loop.thisRepN'
p8360
I2
sg6383
g6613
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8361
I2
sg6385
g6620
sg55
g11
sS'block_loop.thisTrial'
p8362
Nsg70
Vn
sS'block_loop.thisTrialN'
p8363
I0
sg39
F0.75001197417805088
sg34
g753
(S'\x07\xdf\x07\x0b\x11$.\x018\x80'
tRp8364
sa(dp8365
S'trial_loop.thisTrialN'
p8366
I144
sg6371
g7135
sS'block_loop.thisIndex'
p8367
g6365
sg38
S'left'
p8368
sg59
g63
sS'trial_loop.thisN'
p8369
I144
sg33
g6547
sg64
g65
sS'trial_loop.thisIndex'
p8370
g60
(g99
S'\x90\x00\x00\x00'
tRp8371
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8372
I0
sg6380
g7142
sS'block_loop.thisRepN'
p8373
I2
sg6383
g6547
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8374
I2
sg6385
g6554
sg55
g11
sS'block_loop.thisTrial'
p8375
Nsg70
Vn
sS'block_loop.thisTrialN'
p8376
I0
sg39
F0.64987107802880928
sg34
g753
(S'\x07\xdf\x07\x0b\x11$3\r\x00 '
tRp8377
sa(dp8378
S'trial_loop.thisTrialN'
p8379
I145
sg6371
g6967
sS'block_loop.thisIndex'
p8380
g6365
sg38
S'right'
p8381
sg59
g63
sS'trial_loop.thisN'
p8382
I145
sg33
g6693
sg64
g65
sS'trial_loop.thisIndex'
p8383
g60
(g99
S'\x91\x00\x00\x00'
tRp8384
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8385
I0
sg6380
g6974
sS'block_loop.thisRepN'
p8386
I2
sg6383
g6686
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8387
I2
sg6385
g6693
sg55
g11
sS'block_loop.thisTrial'
p8388
Nsg70
Vn
sS'block_loop.thisTrialN'
p8389
I0
sg39
F0.81655133443564409
sg34
g753
(S'\x07\xdf\x07\x0b\x11$9\x08T\xd0'
tRp8390
sa(dp8391
S'trial_loop.thisTrialN'
p8392
I146
sg6371
g6494
sS'block_loop.thisIndex'
p8393
g6365
sg38
S'left'
p8394
sg59
g63
sS'trial_loop.thisN'
p8395
I146
sg33
g6498
sg64
g65
sS'trial_loop.thisIndex'
p8396
g60
(g99
S'\x92\x00\x00\x00'
tRp8397
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8398
I0
sg6380
g6502
sS'block_loop.thisRepN'
p8399
I2
sg6383
g6498
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8400
I2
sg6385
g6505
sg55
g11
sS'block_loop.thisTrial'
p8401
Nsg70
Vn
sS'block_loop.thisTrialN'
p8402
I0
sg39
F0.68326335092206136
sg34
g753
(S'\x07\xdf\x07\x0b\x11%\x03\x06\n\xe0'
tRp8403
sa(dp8404
S'trial_loop.thisTrialN'
p8405
I147
sg6371
g7135
sS'block_loop.thisIndex'
p8406
g6365
sg38
S'left'
p8407
sg59
g63
sS'trial_loop.thisN'
p8408
I147
sg33
g6547
sg64
g65
sS'trial_loop.thisIndex'
p8409
g60
(g99
S'\x93\x00\x00\x00'
tRp8410
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8411
I0
sg6380
g7142
sS'block_loop.thisRepN'
p8412
I2
sg6383
g6547
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8413
I2
sg6385
g6554
sg55
g11
sS'block_loop.thisTrial'
p8414
Nsg70
Vn
sS'block_loop.thisTrialN'
p8415
I0
sg39
F0.68330183934813249
sg34
g753
(S'\x07\xdf\x07\x0b\x11%\t\x01\x9a('
tRp8416
sa(dp8417
S'trial_loop.thisTrialN'
p8418
I148
sg6371
g6877
sS'block_loop.thisIndex'
p8419
g6365
sg38
S'right'
p8420
sg59
g63
sS'trial_loop.thisN'
p8421
I148
sg33
g6581
sg64
g65
sS'trial_loop.thisIndex'
p8422
g60
(g99
S'\x94\x00\x00\x00'
tRp8423
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8424
I0
sg6380
g6884
sS'block_loop.thisRepN'
p8425
I2
sg6383
g6581
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8426
I2
sg6385
g6588
sg55
g11
sS'block_loop.thisTrial'
p8427
Nsg70
Vn
sS'block_loop.thisTrialN'
p8428
I0
sg39
F0.91654711496448726
sg34
g753
(S'\x07\xdf\x07\x0b\x11%\x0e\x0c\xaa0'
tRp8429
sa(dp8430
S'trial_loop.thisTrialN'
p8431
I149
sg6371
g7280
sS'block_loop.thisIndex'
p8432
g6365
sg38
S'left'
p8433
sg59
g63
sS'trial_loop.thisN'
p8434
I149
sg33
g6437
sg64
g65
sS'trial_loop.thisIndex'
p8435
g60
(g99
S'\x95\x00\x00\x00'
tRp8436
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8437
I0
sg6380
g7287
sS'block_loop.thisRepN'
p8438
I2
sg6383
g6430
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8439
I2
sg6385
g6437
sg55
g11
sS'block_loop.thisTrial'
p8440
Nsg70
Vn
sS'block_loop.thisTrialN'
p8441
I0
sg39
F1.0670077786526235
sg34
g753
(S'\x07\xdf\x07\x0b\x11%\x14\x0b\xcfp'
tRp8442
sa(dp8443
S'trial_loop.thisTrialN'
p8444
I150
sg6371
g6494
sS'block_loop.thisIndex'
p8445
g6365
sg38
S'left'
p8446
sg59
g63
sS'trial_loop.thisN'
p8447
I150
sg33
g6505
sg64
g65
sS'trial_loop.thisIndex'
p8448
g60
(g99
S'\x96\x00\x00\x00'
tRp8449
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8450
I0
sg6380
g6502
sS'block_loop.thisRepN'
p8451
I2
sg6383
g6498
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8452
I2
sg6385
g6505
sg55
g11
sS'block_loop.thisTrial'
p8453
Nsg70
Vn
sS'block_loop.thisTrialN'
p8454
I0
sg39
F0.63325662257557269
sg34
g753
(S'\x07\xdf\x07\x0b\x11%\x1a\rV\x10'
tRp8455
sa(dp8456
S'trial_loop.thisTrialN'
p8457
I151
sg6371
g6409
sS'block_loop.thisIndex'
p8458
g6365
sg38
S'right'
p8459
sg59
g63
sS'trial_loop.thisN'
p8460
I151
sg33
g6413
sg64
g65
sS'trial_loop.thisIndex'
p8461
g60
(g99
S'\x97\x00\x00\x00'
tRp8462
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8463
I0
sg6380
g6417
sS'block_loop.thisRepN'
p8464
I2
sg6383
g6413
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8465
I2
sg6385
g6420
sg55
g11
sS'block_loop.thisTrial'
p8466
Nsg70
Vn
sS'block_loop.thisTrialN'
p8467
I0
sg39
F0.68332692809781292
sg34
g753
(S'\x07\xdf\x07\x0b\x11% \x081\xa8'
tRp8468
sa(dp8469
S'trial_loop.thisTrialN'
p8470
I152
sg6371
g6922
sS'block_loop.thisIndex'
p8471
g6365
sg38
S'left'
p8472
sg59
g63
sS'trial_loop.thisN'
p8473
I152
sg33
g6386
sg64
g65
sS'trial_loop.thisIndex'
p8474
g60
(g99
S'\x98\x00\x00\x00'
tRp8475
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8476
I0
sg6380
g6929
sS'block_loop.thisRepN'
p8477
I2
sg6383
g6376
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8478
I2
sg6385
g6386
sg55
g11
sS'block_loop.thisTrial'
p8479
Nsg70
Vn
sS'block_loop.thisTrialN'
p8480
I0
sg39
F0.78331273014555336
sg34
g753
(S'\x07\xdf\x07\x0b\x11%&\x03\xffp'
tRp8481
sa(dp8482
S'trial_loop.thisTrialN'
p8483
I153
sg6371
g6543
sS'block_loop.thisIndex'
p8484
g6365
sg38
S'right'
p8485
sg59
g63
sS'trial_loop.thisN'
p8486
I153
sg33
g6554
sg64
g65
sS'trial_loop.thisIndex'
p8487
g60
(g99
S'\x99\x00\x00\x00'
tRp8488
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8489
I0
sg6380
g6551
sS'block_loop.thisRepN'
p8490
I2
sg6383
g6547
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8491
I2
sg6385
g6554
sg55
g11
sS'block_loop.thisTrial'
p8492
Nsg70
Vn
sS'block_loop.thisTrialN'
p8493
I0
sg39
F1.016535197806661
sg34
g753
(S'\x07\xdf\x07\x0b\x11%,\x01<h'
tRp8494
sa(dp8495
S'trial_loop.thisTrialN'
p8496
I154
sg6371
g6808
sS'block_loop.thisIndex'
p8497
g6365
sg38
S'left'
p8498
sg59
g63
sS'trial_loop.thisN'
p8499
I154
sg33
g6396
sg64
g65
sS'trial_loop.thisIndex'
p8500
g60
(g99
S'\x9a\x00\x00\x00'
tRp8501
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8502
I0
sg6380
g6815
sS'block_loop.thisRepN'
p8503
I2
sg6383
g6396
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8504
I2
sg6385
g6403
sg55
g11
sS'block_loop.thisTrial'
p8505
Nsg70
Vn
sS'block_loop.thisTrialN'
p8506
I0
sg39
F0.71635655449426849
sg34
g753
(S'\x07\xdf\x07\x0b\x11%2\x01\xcc\xf0'
tRp8507
sa(dp8508
S'trial_loop.thisTrialN'
p8509
I155
sg6371
g6409
sS'block_loop.thisIndex'
p8510
g6365
sg38
S'right'
p8511
sg59
g63
sS'trial_loop.thisN'
p8512
I155
sg33
g6413
sg64
g65
sS'trial_loop.thisIndex'
p8513
g60
(g99
S'\x9b\x00\x00\x00'
tRp8514
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8515
I0
sg6380
g6417
sS'block_loop.thisRepN'
p8516
I2
sg6383
g6413
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8517
I2
sg6385
g6420
sg55
g11
sS'block_loop.thisTrial'
p8518
Nsg70
Vn
sS'block_loop.thisTrialN'
p8519
I0
sg39
F0.68329813305535936
sg34
g753
(S'\x07\xdf\x07\x0b\x11%7\rV\x10'
tRp8520
sa(dp8521
S'trial_loop.thisTrialN'
p8522
I156
sg6371
g6652
sS'block_loop.thisIndex'
p8523
g6365
sg38
S'right'
p8524
sg59
g63
sS'trial_loop.thisN'
p8525
I156
sg33
g6656
sg64
g65
sS'trial_loop.thisIndex'
p8526
g60
(g99
S'\x9c\x00\x00\x00'
tRp8527
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8528
I0
sg6380
g6660
sS'block_loop.thisRepN'
p8529
I2
sg6383
g6656
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8530
I2
sg6385
g6663
sg55
g11
sS'block_loop.thisTrial'
p8531
Nsg70
Vn
sS'block_loop.thisTrialN'
p8532
I0
sg39
F0.69988407856726553
sg34
g753
(S'\x07\xdf\x07\x0b\x11&\x01\x08\xe9@'
tRp8533
sa(dp8534
S'trial_loop.thisTrialN'
p8535
I157
sg6371
g6982
sS'block_loop.thisIndex'
p8536
g6365
sg38
S'left'
p8537
sg59
g63
sS'trial_loop.thisN'
p8538
I157
sg33
g6464
sg64
g65
sS'trial_loop.thisIndex'
p8539
g60
(g99
S'\x9d\x00\x00\x00'
tRp8540
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8541
I0
sg6380
g6989
sS'block_loop.thisRepN'
p8542
I2
sg6383
g6464
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8543
I2
sg6385
g6471
sg55
g11
sS'block_loop.thisTrial'
p8544
Nsg70
Vn
sS'block_loop.thisTrialN'
p8545
I0
sg39
F0.71664849632725236
sg34
g753
(S'\x07\xdf\x07\x0b\x11&\x07\x04\xf5\x88'
tRp8546
sa(dp8547
S'trial_loop.thisTrialN'
p8548
I158
sg6371
g7120
sS'block_loop.thisIndex'
p8549
g6365
sg38
S'right'
p8550
sg59
g63
sS'trial_loop.thisN'
p8551
I158
sg33
g6720
sg64
g65
sS'trial_loop.thisIndex'
p8552
g60
(g99
S'\x9e\x00\x00\x00'
tRp8553
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8554
I0
sg6380
g7127
sS'block_loop.thisRepN'
p8555
I2
sg6383
g6720
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8556
I2
sg6385
g6727
sg55
g11
sS'block_loop.thisTrial'
p8557
Nsg70
Vn
sS'block_loop.thisTrialN'
p8558
I0
sg39
F0.64991298764653038
sg34
g753
(S'\x07\xdf\x07\x0b\x11&\r\x00\xfd\xe8'
tRp8559
sa(dp8560
S'trial_loop.thisTrialN'
p8561
I159
sg6371
g6982
sS'block_loop.thisIndex'
p8562
g6365
sg38
S'left'
p8563
sg59
g63
sS'trial_loop.thisN'
p8564
I159
sg33
g6464
sg64
g65
sS'trial_loop.thisIndex'
p8565
g60
(g99
S'\x9f\x00\x00\x00'
tRp8566
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8567
I0
sg6380
g6989
sS'block_loop.thisRepN'
p8568
I2
sg6383
g6464
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8569
I2
sg6385
g6471
sg55
g11
sS'block_loop.thisTrial'
p8570
Nsg70
Vn
sS'block_loop.thisTrialN'
p8571
I0
sg39
F0.71655355821349076
sg34
g753
(S'\x07\xdf\x07\x0b\x11&\x12\x0b\x94\xd8'
tRp8572
sa(dp8573
S'trial_loop.thisTrialN'
p8574
I160
sg6371
g6526
sS'block_loop.thisIndex'
p8575
g6365
sg38
S'right'
p8576
sg59
g63
sS'trial_loop.thisN'
p8577
I160
sg33
g6536
sg64
g65
sS'trial_loop.thisIndex'
p8578
g60
(g99
S'\xa0\x00\x00\x00'
tRp8579
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8580
I0
sg6380
g6534
sS'block_loop.thisRepN'
p8581
I2
sg6383
g6536
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8582
I2
sg6385
g6530
sg55
g11
sS'block_loop.thisTrial'
p8583
Nsg70
Vn
sS'block_loop.thisTrialN'
p8584
I0
sg39
F0.84992564606363885
sg34
g753
(S'\x07\xdf\x07\x0b\x11&\x18\x07\xa1 '
tRp8585
sa(dp8586
S'trial_loop.thisTrialN'
p8587
I161
sg6371
g6477
sS'block_loop.thisIndex'
p8588
g6365
sg38
S'left'
p8589
sg59
g63
sS'trial_loop.thisN'
p8590
I161
sg33
g6481
sg64
g65
sS'trial_loop.thisIndex'
p8591
g60
(g99
S'\xa1\x00\x00\x00'
tRp8592
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8593
I0
sg6380
g6485
sS'block_loop.thisRepN'
p8594
I2
sg6383
g6487
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8595
I2
sg6385
g6481
sg55
g11
sS'block_loop.thisTrial'
p8596
Nsg70
Vn
sS'block_loop.thisTrialN'
p8597
I0
sg39
F0.70027181381374248
sg34
g753
(S'\x07\xdf\x07\x0b\x11&\x1e\x06\x0e\xc8'
tRp8598
sa(dp8599
S'trial_loop.thisTrialN'
p8600
I162
sg6371
g6560
sS'block_loop.thisIndex'
p8601
g6365
sg38
S'right'
p8602
sg59
g63
sS'trial_loop.thisN'
p8603
I162
sg33
g6564
sg64
g65
sS'trial_loop.thisIndex'
p8604
g60
(g99
S'\xa2\x00\x00\x00'
tRp8605
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8606
I0
sg6380
g6568
sS'block_loop.thisRepN'
p8607
I2
sg6383
g6564
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8608
I2
sg6385
g6571
sg55
g11
sS'block_loop.thisTrial'
p8609
Nsg70
Vn
sS'block_loop.thisTrialN'
p8610
I0
sg39
F0.733118691459822
sg34
g753
(S'\x07\xdf\x07\x0b\x11&$\x01\xdc\x90'
tRp8611
sa(dp8612
S'trial_loop.thisTrialN'
p8613
I163
sg6371
g6716
sS'block_loop.thisIndex'
p8614
g6365
sg38
S'left'
p8615
sg59
g63
sS'trial_loop.thisN'
p8616
I163
sg33
g6720
sg64
g65
sS'trial_loop.thisIndex'
p8617
g60
(g99
S'\xa3\x00\x00\x00'
tRp8618
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8619
I0
sg6380
g6724
sS'block_loop.thisRepN'
p8620
I2
sg6383
g6720
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8621
I2
sg6385
g6727
sg55
g11
sS'block_loop.thisTrial'
p8622
Nsg70
Vn
sS'block_loop.thisTrialN'
p8623
I0
sg39
F0.58324191144492943
sg34
g753
(S'\x07\xdf\x07\x0b\x11&)\r\xa40'
tRp8624
sa(dp8625
S'trial_loop.thisTrialN'
p8626
I164
sg6371
g6526
sS'block_loop.thisIndex'
p8627
g6365
sg38
S'right'
p8628
sg59
g63
sS'trial_loop.thisN'
p8629
I164
sg33
g6536
sg64
g65
sS'trial_loop.thisIndex'
p8630
g60
(g99
S'\xa4\x00\x00\x00'
tRp8631
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8632
I0
sg6380
g6534
sS'block_loop.thisRepN'
p8633
I2
sg6383
g6536
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8634
I2
sg6385
g6530
sg55
g11
sS'block_loop.thisTrial'
p8635
Nsg70
Vn
sS'block_loop.thisTrialN'
p8636
I0
sg39
F2.1831974929482385
sg34
g753
(S'\x07\xdf\x07\x0b\x11&/\x07\xc80'
tRp8637
sa(dp8638
S'trial_loop.thisTrialN'
p8639
I165
sg6371
g6952
sS'block_loop.thisIndex'
p8640
g6365
sg38
S'right'
p8641
sg59
g63
sS'trial_loop.thisN'
p8642
I165
sg33
g6487
sg64
g65
sS'trial_loop.thisIndex'
p8643
g60
(g99
S'\xa5\x00\x00\x00'
tRp8644
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8645
I0
sg6380
g6959
sS'block_loop.thisRepN'
p8646
I2
sg6383
g6487
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8647
I2
sg6385
g6481
sg55
g11
sS'block_loop.thisTrial'
p8648
Nsg70
Vn
sS'block_loop.thisTrialN'
p8649
I0
sg39
F0.86639270510568167
sg34
g753
(S'\x07\xdf\x07\x0b\x11&6\n\xf0\xc8'
tRp8650
sa(dp8651
S'trial_loop.thisTrialN'
p8652
I166
sg6371
g6682
sS'block_loop.thisIndex'
p8653
g6365
sg38
S'left'
p8654
sg59
g63
sS'trial_loop.thisN'
p8655
I166
sg33
g6693
sg64
g65
sS'trial_loop.thisIndex'
p8656
g60
(g99
S'\xa6\x00\x00\x00'
tRp8657
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8658
I0
sg6380
g6690
sS'block_loop.thisRepN'
p8659
I2
sg6383
g6686
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8660
I2
sg6385
g6693
sg55
g11
sS'block_loop.thisTrial'
p8661
Nsg70
Vn
sS'block_loop.thisTrialN'
p8662
I0
sg39
F0.79993516838658252
sg34
g753
(S"\x07\xdf\x07\x0b\x11'\x00\t\x9c\xf0"
tRp8663
sa(dp8664
S'trial_loop.thisTrialN'
p8665
I167
sg6371
g6922
sS'block_loop.thisIndex'
p8666
g6365
sg38
S'left'
p8667
sg59
g63
sS'trial_loop.thisN'
p8668
I167
sg33
g6376
sg64
g65
sS'trial_loop.thisIndex'
p8669
g60
(g99
S'\xa7\x00\x00\x00'
tRp8670
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8671
I0
sg6380
g6929
sS'block_loop.thisRepN'
p8672
I2
sg6383
g6376
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8673
I2
sg6385
g6386
sg55
g11
sS'block_loop.thisTrial'
p8674
Nsg70
Vn
sS'block_loop.thisTrialN'
p8675
I0
sg39
F0.76656883954274235
sg34
g753
(S"\x07\xdf\x07\x0b\x11'\x06\x06\xd9\xe8"
tRp8676
sa(dp8677
S'trial_loop.thisTrialN'
p8678
I168
sg6371
g7507
sS'block_loop.thisIndex'
p8679
g6365
sg38
S'left'
p8680
sg59
g63
sS'trial_loop.thisN'
p8681
I168
sg33
g6420
sg64
g65
sS'trial_loop.thisIndex'
p8682
g60
(g99
S'\xa8\x00\x00\x00'
tRp8683
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8684
I0
sg6380
g7514
sS'block_loop.thisRepN'
p8685
I2
sg6383
g6413
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8686
I2
sg6385
g6420
sg55
g11
sS'block_loop.thisTrial'
p8687
Nsg70
Vn
sS'block_loop.thisTrialN'
p8688
I0
sg39
F0.71653673734545009
sg34
g753
(S"\x07\xdf\x07\x0b\x11'\x0c\x03\xd8`"
tRp8689
sa(dp8690
S'trial_loop.thisTrialN'
p8691
I169
sg6371
g7321
sS'block_loop.thisIndex'
p8692
g6365
sg38
S'left'
p8693
sg59
g63
sS'trial_loop.thisN'
p8694
I169
sg33
g6915
sg64
g65
sS'trial_loop.thisIndex'
p8695
g60
(g99
S'\xa9\x00\x00\x00'
tRp8696
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8697
I0
sg6380
g7328
sS'block_loop.thisRepN'
p8698
I2
sg6383
g6915
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8699
I2
sg6385
g6909
sg55
g11
sS'block_loop.thisTrial'
p8700
Nsg70
Vn
sS'block_loop.thisTrialN'
p8701
I0
sg39
F0.58324903892935254
sg34
g753
(S"\x07\xdf\x07\x0b\x11'\x12\x00\x1f@"
tRp8702
sa(dp8703
S'trial_loop.thisTrialN'
p8704
I170
sg6371
g6823
sS'block_loop.thisIndex'
p8705
g6365
sg38
S'left'
p8706
sg59
g63
sS'trial_loop.thisN'
p8707
I170
sg33
g6782
sg64
g65
sS'trial_loop.thisIndex'
p8708
g60
(g99
S'\xaa\x00\x00\x00'
tRp8709
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8710
I0
sg6380
g6830
sS'block_loop.thisRepN'
p8711
I2
sg6383
g6782
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8712
I2
sg6385
g6789
sg55
g11
sS'block_loop.thisTrial'
p8713
Nsg70
Vn
sS'block_loop.thisTrialN'
p8714
I0
sg39
F1.2665257895278046
sg34
g753
(S"\x07\xdf\x07\x0b\x11'\x17\t\x85\x80"
tRp8715
sa(dp8716
S'trial_loop.thisTrialN'
p8717
I171
sg6371
g6877
sS'block_loop.thisIndex'
p8718
g6365
sg38
S'right'
p8719
sg59
g63
sS'trial_loop.thisN'
p8720
I171
sg33
g6588
sg64
g65
sS'trial_loop.thisIndex'
p8721
g60
(g99
S'\xab\x00\x00\x00'
tRp8722
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8723
I0
sg6380
g6884
sS'block_loop.thisRepN'
p8724
I2
sg6383
g6581
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8725
I2
sg6385
g6588
sg55
g11
sS'block_loop.thisTrial'
p8726
Nsg70
Vn
sS'block_loop.thisTrialN'
p8727
I0
sg39
F0.89976302533614216
sg34
g753
(S"\x07\xdf\x07\x0b\x11'\x1d\x0e%\x18"
tRp8728
sa(dp8729
S'trial_loop.thisTrialN'
p8730
I172
sg6371
g6952
sS'block_loop.thisIndex'
p8731
g6365
sg38
S'right'
p8732
sg59
g63
sS'trial_loop.thisN'
p8733
I172
sg33
g6487
sg64
g65
sS'trial_loop.thisIndex'
p8734
g60
(g99
S'\xac\x00\x00\x00'
tRp8735
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8736
I0
sg6380
g6959
sS'block_loop.thisRepN'
p8737
I2
sg6383
g6487
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8738
I2
sg6385
g6481
sg55
g11
sS'block_loop.thisTrial'
p8739
Nsg70
Vn
sS'block_loop.thisTrialN'
p8740
I0
sg39
F0.68335059135279153
sg34
g753
(S"\x07\xdf\x07\x0b\x11'#\r\x0b\xd8"
tRp8741
sa(dp8742
S'trial_loop.thisTrialN'
p8743
I173
sg6371
g6733
sS'block_loop.thisIndex'
p8744
g6365
sg38
S'left'
p8745
sg59
g63
sS'trial_loop.thisN'
p8746
I173
sg33
g6613
sg64
g65
sS'trial_loop.thisIndex'
p8747
g60
(g99
S'\xad\x00\x00\x00'
tRp8748
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8749
I0
sg6380
g6740
sS'block_loop.thisRepN'
p8750
I2
sg6383
g6613
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8751
I2
sg6385
g6620
sg55
g11
sS'block_loop.thisTrial'
p8752
Nsg70
Vn
sS'block_loop.thisTrialN'
p8753
I0
sg39
F0.69986925339253503
sg34
g753
(S"\x07\xdf\x07\x0b\x11')\x08\xd9\xa0"
tRp8754
sa(dp8755
S'trial_loop.thisTrialN'
p8756
I174
sg6371
g6905
sS'block_loop.thisIndex'
p8757
g6365
sg38
S'right'
p8758
sg59
g63
sS'trial_loop.thisN'
p8759
I174
sg33
g6915
sg64
g65
sS'trial_loop.thisIndex'
p8760
g60
(g99
S'\xae\x00\x00\x00'
tRp8761
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8762
I0
sg6380
g6913
sS'block_loop.thisRepN'
p8763
I2
sg6383
g6915
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8764
I2
sg6385
g6909
sg55
g11
sS'block_loop.thisTrial'
p8765
Nsg70
Vn
sS'block_loop.thisTrialN'
p8766
I0
sg39
F0.64991783434015815
sg34
g753
(S"\x07\xdf\x07\x0b\x11'/\x04\xa7h"
tRp8767
sa(dp8768
S'trial_loop.thisTrialN'
p8769
I175
sg6371
g6967
sS'block_loop.thisIndex'
p8770
g6365
sg38
S'right'
p8771
sg59
g63
sS'trial_loop.thisN'
p8772
I175
sg33
g6686
sg64
g65
sS'trial_loop.thisIndex'
p8773
g60
(g99
S'\xaf\x00\x00\x00'
tRp8774
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8775
I0
sg6380
g6974
sS'block_loop.thisRepN'
p8776
I2
sg6383
g6686
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8777
I2
sg6385
g6693
sg55
g11
sS'block_loop.thisTrial'
p8778
Nsg70
Vn
sS'block_loop.thisTrialN'
p8779
I0
sg39
F1.31644157115079
sg34
g753
(S"\x07\xdf\x07\x0b\x11'4\x0f\x03\xc0"
tRp8780
sa(dp8781
S'trial_loop.thisTrialN'
p8782
I176
sg6371
g6716
sS'block_loop.thisIndex'
p8783
g6365
sg38
S'left'
p8784
sg59
g63
sS'trial_loop.thisN'
p8785
I176
sg33
g6727
sg64
g65
sS'trial_loop.thisIndex'
p8786
g60
(g99
S'\xb0\x00\x00\x00'
tRp8787
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8788
I0
sg6380
g6724
sS'block_loop.thisRepN'
p8789
I2
sg6383
g6720
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8790
I2
sg6385
g6727
sg55
g11
sS'block_loop.thisTrial'
p8791
Nsg70
Vn
sS'block_loop.thisTrialN'
p8792
I0
sg39
F0.63322982322642929
sg34
g753
(S"\x07\xdf\x07\x0b\x11';\x05\x14\xc8"
tRp8793
sa(dp8794
S'trial_loop.thisTrialN'
p8795
I177
sg6371
g6443
sS'block_loop.thisIndex'
p8796
g6365
sg38
S'right'
p8797
sg59
g63
sS'trial_loop.thisN'
p8798
I177
sg33
g6447
sg64
g65
sS'trial_loop.thisIndex'
p8799
g60
(g99
S'\xb1\x00\x00\x00'
tRp8800
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8801
I0
sg6380
g6451
sS'block_loop.thisRepN'
p8802
I2
sg6383
g6447
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8803
I2
sg6385
g6454
sg55
g11
sS'block_loop.thisTrial'
p8804
Nsg70
Vn
sS'block_loop.thisTrialN'
p8805
I0
sg39
F0.73332852465682663
sg34
g753
(S'\x07\xdf\x07\x0b\x11(\x05\x00*\xf8'
tRp8806
sa(dp8807
S'trial_loop.thisTrialN'
p8808
I178
sg6371
g7066
sS'block_loop.thisIndex'
p8809
g6365
sg38
S'left'
p8810
sg59
g63
sS'trial_loop.thisN'
p8811
I178
sg33
g6530
sg64
g65
sS'trial_loop.thisIndex'
p8812
g60
(g99
S'\xb2\x00\x00\x00'
tRp8813
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8814
I0
sg6380
g7073
sS'block_loop.thisRepN'
p8815
I2
sg6383
g6536
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8816
I2
sg6385
g6530
sg55
g11
sS'block_loop.thisTrial'
p8817
Nsg70
Vn
sS'block_loop.thisTrialN'
p8818
I0
sg39
F0.76705151291025686
sg34
g753
(S'\x07\xdf\x07\x0b\x11(\n\x0b\xb8\x00'
tRp8819
sa(dp8820
S'trial_loop.thisTrialN'
p8821
I179
sg6371
g6426
sS'block_loop.thisIndex'
p8822
g6365
sg38
S'right'
p8823
sg59
g63
sS'trial_loop.thisN'
p8824
I179
sg33
g6437
sg64
g65
sS'trial_loop.thisIndex'
p8825
g60
(g99
S'\xb3\x00\x00\x00'
tRp8826
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8827
I0
sg6380
g6434
sS'block_loop.thisRepN'
p8828
I2
sg6383
g6430
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8829
I2
sg6385
g6437
sg55
g11
sS'block_loop.thisTrial'
p8830
Nsg70
Vn
sS'block_loop.thisTrialN'
p8831
I0
sg39
F0.84993533944361843
sg34
g753
(S'\x07\xdf\x07\x0b\x11(\x10\x08\xb6x'
tRp8832
sa(dp8833
S'trial_loop.thisTrialN'
p8834
I180
sg6371
g6577
sS'block_loop.thisIndex'
p8835
g6365
sg38
S'left'
p8836
sg59
g63
sS'trial_loop.thisN'
p8837
I180
sg33
g6588
sg64
g65
sS'trial_loop.thisIndex'
p8838
g60
(g99
S'\xb4\x00\x00\x00'
tRp8839
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8840
I0
sg6380
g6585
sS'block_loop.thisRepN'
p8841
I2
sg6383
g6581
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8842
I2
sg6385
g6588
sg55
g11
sS'block_loop.thisTrial'
p8843
Nsg70
Vn
sS'block_loop.thisTrialN'
p8844
I0
sg39
F0.73322645905136596
sg34
g753
(S'\x07\xdf\x07\x0b\x11(\x16\x06\xe5\xa0'
tRp8845
sa(dp8846
S'trial_loop.thisTrialN'
p8847
I181
sg6371
g7120
sS'block_loop.thisIndex'
p8848
g6365
sg38
S'right'
p8849
sg59
g63
sS'trial_loop.thisN'
p8850
I181
sg33
g6720
sg64
g65
sS'trial_loop.thisIndex'
p8851
g60
(g99
S'\xb5\x00\x00\x00'
tRp8852
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8853
I0
sg6380
g7127
sS'block_loop.thisRepN'
p8854
I2
sg6383
g6720
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8855
I2
sg6385
g6727
sg55
g11
sS'block_loop.thisTrial'
p8856
Nsg70
Vn
sS'block_loop.thisTrialN'
p8857
I0
sg39
F0.6666132580357953
sg34
g753
(S'\x07\xdf\x07\x0b\x11(\x1c\x03k\x00'
tRp8858
sa(dp8859
S'trial_loop.thisTrialN'
p8860
I182
sg6371
g6526
sS'block_loop.thisIndex'
p8861
g6365
sg38
S'right'
p8862
sg59
g63
sS'trial_loop.thisN'
p8863
I182
sg33
g6530
sg64
g65
sS'trial_loop.thisIndex'
p8864
g60
(g99
S'\xb6\x00\x00\x00'
tRp8865
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8866
I0
sg6380
g6534
sS'block_loop.thisRepN'
p8867
I2
sg6383
g6536
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8868
I2
sg6385
g6530
sg55
g11
sS'block_loop.thisTrial'
p8869
Nsg70
Vn
sS'block_loop.thisTrialN'
p8870
I0
sg39
F1.0165485974830517
sg34
g753
(S'\x07\xdf\x07\x0b\x11(!\x0e\x01\xf0'
tRp8871
sa(dp8872
S'trial_loop.thisTrialN'
p8873
I183
sg6371
g6460
sS'block_loop.thisIndex'
p8874
g6365
sg38
S'right'
p8875
sg59
g63
sS'trial_loop.thisN'
p8876
I183
sg33
g6464
sg64
g65
sS'trial_loop.thisIndex'
p8877
g60
(g99
S'\xb7\x00\x00\x00'
tRp8878
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8879
I0
sg6380
g6468
sS'block_loop.thisRepN'
p8880
I2
sg6383
g6464
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8881
I2
sg6385
g6471
sg55
g11
sS'block_loop.thisTrial'
p8882
Nsg70
Vn
sS'block_loop.thisTrialN'
p8883
I0
sg39
F0.81669416925797123
sg34
g753
(S"\x07\xdf\x07\x0b\x11('\x0e\xd0\xf8"
tRp8884
sa(dp8885
S'trial_loop.thisTrialN'
p8886
I184
sg6371
g6409
sS'block_loop.thisIndex'
p8887
g6365
sg38
S'right'
p8888
sg59
g63
sS'trial_loop.thisN'
p8889
I184
sg33
g6413
sg64
g65
sS'trial_loop.thisIndex'
p8890
g60
(g99
S'\xb8\x00\x00\x00'
tRp8891
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8892
I0
sg6380
g6417
sS'block_loop.thisRepN'
p8893
I2
sg6383
g6413
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8894
I2
sg6385
g6420
sg55
g11
sS'block_loop.thisTrial'
p8895
Nsg70
Vn
sS'block_loop.thisTrialN'
p8896
I0
sg39
F0.6004428164633282
sg34
g753
(S'\x07\xdf\x07\x0b\x11(-\x0c\x87\x08'
tRp8897
sa(dp8898
S'trial_loop.thisTrialN'
p8899
I185
sg6371
g7375
sS'block_loop.thisIndex'
p8900
g6365
sg38
S'right'
p8901
sg59
g63
sS'trial_loop.thisN'
p8902
I185
sg33
g7001
sg64
g65
sS'trial_loop.thisIndex'
p8903
g60
(g99
S'\xb9\x00\x00\x00'
tRp8904
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8905
I0
sg6380
g7382
sS'block_loop.thisRepN'
p8906
I2
sg6383
g7001
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8907
I2
sg6385
g7008
sg55
g11
sS'block_loop.thisTrial'
p8908
Nsg70
Vn
sS'block_loop.thisTrialN'
p8909
I0
sg39
F0.71654785622376949
sg34
g753
(S'\x07\xdf\x07\x0b\x11(3\x06\xe5\xa0'
tRp8910
sa(dp8911
S'trial_loop.thisTrialN'
p8912
I186
sg6371
g6778
sS'block_loop.thisIndex'
p8913
g6365
sg38
S'right'
p8914
sg59
g63
sS'trial_loop.thisN'
p8915
I186
sg33
g6782
sg64
g65
sS'trial_loop.thisIndex'
p8916
g60
(g99
S'\xba\x00\x00\x00'
tRp8917
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8918
I0
sg6380
g6786
sS'block_loop.thisRepN'
p8919
I2
sg6383
g6782
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8920
I2
sg6385
g6789
sg55
g11
sS'block_loop.thisTrial'
p8921
Nsg70
Vn
sS'block_loop.thisTrialN'
p8922
I0
sg39
F0.58321340149996104
sg34
g753
(S'\x07\xdf\x07\x0b\x11(9\x030h'
tRp8923
sa(dp8924
S'trial_loop.thisTrialN'
p8925
I187
sg6371
g6372
sS'block_loop.thisIndex'
p8926
g6365
sg38
S'right'
p8927
sg59
g63
sS'trial_loop.thisN'
p8928
I187
sg33
g6376
sg64
g65
sS'trial_loop.thisIndex'
p8929
g60
(g99
S'\xbb\x00\x00\x00'
tRp8930
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8931
I0
sg6380
g6381
sS'block_loop.thisRepN'
p8932
I2
sg6383
g6376
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8933
I2
sg6385
g6386
sg55
g11
sS'block_loop.thisTrial'
p8934
Nsg70
Vn
sS'block_loop.thisTrialN'
p8935
I0
sg39
F0.81663771956664277
sg34
g753
(S'\x07\xdf\x07\x0b\x11)\x02\x0c\x96\xa8'
tRp8936
sa(dp8937
S'trial_loop.thisTrialN'
p8938
I188
sg6371
g6716
sS'block_loop.thisIndex'
p8939
g6365
sg38
S'left'
p8940
sg59
g63
sS'trial_loop.thisN'
p8941
I188
sg33
g6727
sg64
g65
sS'trial_loop.thisIndex'
p8942
g60
(g99
S'\xbc\x00\x00\x00'
tRp8943
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8944
I0
sg6380
g6724
sS'block_loop.thisRepN'
p8945
I2
sg6383
g6720
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8946
I2
sg6385
g6727
sg55
g11
sS'block_loop.thisTrial'
p8947
Nsg70
Vn
sS'block_loop.thisTrialN'
p8948
I0
sg39
F0.63325234608419123
sg34
g753
(S'\x07\xdf\x07\x0b\x11)\x08\nL\xb8'
tRp8949
sa(dp8950
S'trial_loop.thisTrialN'
p8951
I189
sg6371
g6511
sS'block_loop.thisIndex'
p8952
g6365
sg38
S'left'
p8953
sg59
g63
sS'trial_loop.thisN'
p8954
I189
sg33
g6454
sg64
g65
sS'trial_loop.thisIndex'
p8955
g60
(g99
S'\xbd\x00\x00\x00'
tRp8956
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8957
I0
sg6380
g6518
sS'block_loop.thisRepN'
p8958
I2
sg6383
g6447
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8959
I2
sg6385
g6454
sg55
g11
sS'block_loop.thisTrial'
p8960
Nsg70
Vn
sS'block_loop.thisTrialN'
p8961
I0
sg39
F0.73323729283220018
sg34
g753
(S'\x07\xdf\x07\x0b\x11)\x0e\x05(P'
tRp8962
sa(dp8963
S'trial_loop.thisTrialN'
p8964
I190
sg6371
g7507
sS'block_loop.thisIndex'
p8965
g6365
sg38
S'left'
p8966
sg59
g63
sS'trial_loop.thisN'
p8967
I190
sg33
g6413
sg64
g65
sS'trial_loop.thisIndex'
p8968
g60
(g99
S'\xbe\x00\x00\x00'
tRp8969
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8970
I0
sg6380
g7514
sS'block_loop.thisRepN'
p8971
I2
sg6383
g6413
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8972
I2
sg6385
g6420
sg55
g11
sS'block_loop.thisTrial'
p8973
Nsg70
Vn
sS'block_loop.thisTrialN'
p8974
I0
sg39
F0.61665072010509903
sg34
g753
(S'\x07\xdf\x07\x0b\x11)\x14\x01\xad\xb0'
tRp8975
sa(dp8976
S'trial_loop.thisTrialN'
p8977
I191
sg6371
g6477
sS'block_loop.thisIndex'
p8978
g6365
sg38
S'left'
p8979
sg59
g63
sS'trial_loop.thisN'
p8980
I191
sg33
g6487
sg64
g65
sS'trial_loop.thisIndex'
p8981
g60
(g99
S'\xbf\x00\x00\x00'
tRp8982
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8983
I0
sg6380
g6485
sS'block_loop.thisRepN'
p8984
I2
sg6383
g6487
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8985
I2
sg6385
g6481
sg55
g11
sS'block_loop.thisTrial'
p8986
Nsg70
Vn
sS'block_loop.thisTrialN'
p8987
I0
sg39
F0.64990956645488041
sg34
g753
(S'\x07\xdf\x07\x0b\x11)\x19\x0b\x8d\x08'
tRp8988
sa(dp8989
S'trial_loop.thisTrialN'
p8990
I192
sg6371
g6778
sS'block_loop.thisIndex'
p8991
g6365
sg38
S'right'
p8992
sg59
g63
sS'trial_loop.thisN'
p8993
I192
sg33
g6782
sg64
g65
sS'trial_loop.thisIndex'
p8994
g60
(g99
S'\xc0\x00\x00\x00'
tRp8995
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p8996
I0
sg6380
g6786
sS'block_loop.thisRepN'
p8997
I2
sg6383
g6782
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p8998
I2
sg6385
g6789
sg55
g11
sS'block_loop.thisTrial'
p8999
Nsg70
Vn
sS'block_loop.thisTrialN'
p9000
I0
sg39
F0.7165375926415436
sg34
g753
(S'\x07\xdf\x07\x0b\x11)\x1f\x06\xa38'
tRp9001
sa(dp9002
S'trial_loop.thisTrialN'
p9003
I193
sg6371
g6748
sS'block_loop.thisIndex'
p9004
g6365
sg38
S'right'
p9005
sg59
g63
sS'trial_loop.thisN'
p9006
I193
sg33
g6498
sg64
g65
sS'trial_loop.thisIndex'
p9007
g60
(g99
S'\xc1\x00\x00\x00'
tRp9008
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p9009
I0
sg6380
g6755
sS'block_loop.thisRepN'
p9010
I2
sg6383
g6498
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p9011
I2
sg6385
g6505
sg55
g11
sS'block_loop.thisTrial'
p9012
Nsg70
Vn
sS'block_loop.thisTrialN'
p9013
I0
sg39
F1.0332377489903593
sg34
g753
(S'\x07\xdf\x07\x0b\x11)%\x02\xee\x00'
tRp9014
sa(dp9015
S'trial_loop.thisTrialN'
p9016
I194
sg6371
g6877
sS'block_loop.thisIndex'
p9017
g6365
sg38
S'right'
p9018
sg59
g63
sS'trial_loop.thisN'
p9019
I194
sg33
g6581
sg64
g65
sS'trial_loop.thisIndex'
p9020
g60
(g99
S'\xc2\x00\x00\x00'
tRp9021
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p9022
I0
sg6380
g6884
sS'block_loop.thisRepN'
p9023
I2
sg6383
g6581
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p9024
I2
sg6385
g6588
sg55
g11
sS'block_loop.thisTrial'
p9025
Nsg70
Vn
sS'block_loop.thisTrialN'
p9026
I0
sg39
F0.91659871796218795
sg34
g753
(S'\x07\xdf\x07\x0b\x11)+\x03\xf7\xa0'
tRp9027
sa(dp9028
S'trial_loop.thisTrialN'
p9029
I195
sg6371
g6443
sS'block_loop.thisIndex'
p9030
g6365
sg38
S'right'
p9031
sg59
g63
sS'trial_loop.thisN'
p9032
I195
sg33
g6447
sg64
g65
sS'trial_loop.thisIndex'
p9033
g60
(g99
S'\xc3\x00\x00\x00'
tRp9034
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p9035
I0
sg6380
g6451
sS'block_loop.thisRepN'
p9036
I2
sg6383
g6447
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p9037
I2
sg6385
g6454
sg55
g11
sS'block_loop.thisTrial'
p9038
Nsg70
Vn
sS'block_loop.thisTrialN'
p9039
I0
sg39
F0.7665622822532896
sg34
g753
(S'\x07\xdf\x07\x0b\x11)1\x03\x1c\xe0'
tRp9040
sa(dp9041
S'trial_loop.thisTrialN'
p9042
I196
sg6371
g6526
sS'block_loop.thisIndex'
p9043
g6365
sg38
S'left'
p9044
sg59
g63
sS'trial_loop.thisN'
p9045
I196
sg33
g6536
sg64
g65
sS'trial_loop.thisIndex'
p9046
g60
(g99
S'\xc4\x00\x00\x00'
tRp9047
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p9048
I0
sg6380
g6534
sS'block_loop.thisRepN'
p9049
I2
sg6383
g6536
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p9050
I2
sg6385
g6530
sg55
g11
sS'block_loop.thisTrial'
p9051
Nsg70
Vn
sS'block_loop.thisTrialN'
p9052
I0
sg39
F1.6999941269532428
sg34
g753
(S'\x07\xdf\x07\x0b\x11)7\x00\x1bX'
tRp9053
sa(dp9054
S'trial_loop.thisTrialN'
p9055
I197
sg6371
g6392
sS'block_loop.thisIndex'
p9056
g6365
sg38
S'right'
p9057
sg59
g63
sS'trial_loop.thisN'
p9058
I197
sg33
g6396
sg64
g65
sS'trial_loop.thisIndex'
p9059
g60
(g99
S'\xc5\x00\x00\x00'
tRp9060
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p9061
I0
sg6380
g6400
sS'block_loop.thisRepN'
p9062
I2
sg6383
g6396
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p9063
I2
sg6385
g6403
sg55
g11
sS'block_loop.thisTrial'
p9064
Nsg70
Vn
sS'block_loop.thisTrialN'
p9065
I0
sg39
F0.81629018334206194
sg34
g753
(S"\x07\xdf\x07\x0b\x11*\x01\x0b'x"
tRp9066
sa(dp9067
S'trial_loop.thisTrialN'
p9068
I198
sg6371
g6372
sS'block_loop.thisIndex'
p9069
g6365
sg38
S'right'
p9070
sg59
g63
sS'trial_loop.thisN'
p9071
I198
sg33
g6386
sg64
g65
sS'trial_loop.thisIndex'
p9072
g60
(g99
S'\xc6\x00\x00\x00'
tRp9073
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p9074
I0
sg6380
g6381
sS'block_loop.thisRepN'
p9075
I2
sg6383
g6376
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p9076
I2
sg6385
g6386
sg55
g11
sS'block_loop.thisTrial'
p9077
Nsg70
Vn
sS'block_loop.thisTrialN'
p9078
I0
sg39
F0.71665476851558196
sg34
g753
(S'\x07\xdf\x07\x0b\x11*\x07\x08\xdd\x88'
tRp9079
sa(dp9080
S'trial_loop.thisTrialN'
p9081
I199
sg6371
g6652
sS'block_loop.thisIndex'
p9082
g6365
sg38
S'right'
p9083
sg59
g63
sS'trial_loop.thisN'
p9084
I199
sg33
g6656
sg64
g65
sS'trial_loop.thisIndex'
p9085
g60
(g99
S'\xc7\x00\x00\x00'
tRp9086
sg66
g67
sg68
g69
sS'trial_loop.thisRepN'
p9087
I0
sg6380
g6660
sS'block_loop.thisRepN'
p9088
I2
sg6383
g6656
sg56
g57
sg58
Vy
sS'block_loop.thisN'
p9089
I2
sg6385
g6663
sg55
g11
sS'block_loop.thisTrial'
p9090
Nsg70
Vn
sS'block_loop.thisTrialN'
p9091
I0
sg39
F0.59994560302584432
sg34
g753
(S'\x07\xdf\x07\x0b\x11*\r\x05$h'
tRp9092
sa(dp9093
S'block_loop.thisRepN'
p9094
I2
sg56
g57
sS'block_loop.thisIndex'
p9095
g6365
sg58
Vy
sg59
g63
sS'block_loop.thisN'
p9096
I2
sg55
g11
sg64
g65
sS'block_loop.thisTrial'
p9097
Nsg66
g67
sg68
g69
sS'block_loop.thisTrialN'
p9098
I0
sg70
Vn
sa(dp9099
g64
g65
sg43
I49
sg56
g57
sg58
Vy
sg42
I551
sg59
g63
sg55
g11
sg66
g67
sg68
g69
sg70
Vn
sa(dp9100
g64
g65
sg43
I49
sg55
g11
sg56
g57
sg45
F1.6399999999999999
sg42
I551
sg49
F0.01
sg58
Vy
sg59
g63
sg44
I00
sg48
I25
sg47
g651
sg51
F30.509999999999998
sg46
F1.0799999999999994
sg66
g67
sg68
g69
sg50
I0
sg70
Vn
sasS'loops'
p9101
(lp9102
g1
(cpsychopy.data
TrialHandler
p9103
g3
NtRp9104
(dp9105
S'origin'
p9106
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a\u000a######################## CITATIONS ########################## \u000a##### Binary choice, BDM, auction routines, and instructions are modified from:\u000a##### \u000a##### De Martino, B., Fleming, S. M., Garrett, N., & Dolan, R. J. (2012). Confidence in value-based choice. Nature Neuroscience, 16(1), 105-110. \u000a#####\u000a##### Food item images are original.\u000a\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.80.01), July 16, 2014, at 03:20\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things bdm STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000afrom pyglet.window import key # to detect key state, whether key is held down, to move slider on key hold\u000aimport pandas as pd\u000aimport datetime\u000afrom psychopy.iohub import launchHubServer\u000aimport pylink\u000a\u000a# Initialize IOHub for eye tracker\u000aio=launchHubServer(iohub_config_name='iohub_config.yaml')\u000atracker = io.devices.tracker\u000a\u000a# Store info about the experiment session\u000aexpName = 'infer_design1'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u'', u'eye': u'', u'glasses': u'', u'contacts': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Setup filename for saving\u000afilename = 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# set up variable to track current state of key press, to move slider when keys held down\u000akeyState=key.KeyStateHandler()\u000a\u000a# Setup the Window\u000ascreenwidth = 1920\u000ascreenheight = 1080\u000awin = visual.Window(size=(screenwidth, screenheight), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color='black', colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000awin.winHandle.push_handlers(keyState)\u000a\u000a\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a\u000a######################## COMPONENTS ##########################\u000a\u000a# Set up directory path for stimuli. This avoids us having to put the entire image path in the conditions spreadsheet.\u000adir_path = 'stimuli/itempics/modified/small/'\u000a\u000a# Initialize components for Routine "instr_main"\u000ainstr_mainClock = core.Clock()\u000ainstr_main_txt = visual.TextStim(win=win, ori=0, name='instr_main_txt',\u000a    text=u'Welcome!\u005cn\u005cnPlease read the instructions carefully and get the experimenter when you\u005c're finished. Take as much time as you need.',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "instr_bdm"\u000ainstr_bdmClock = core.Clock()\u000ainstr_bdm_txt = visual.TextStim(win=win, ori=0, name='instr_bdm_txt',\u000a    text=u'The bidding task is about to begin. Use the LEFT and RIGHT arrow keys to move the cursor along the slider, then press the DOWN arrow to enter your bid.\u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "fixation"\u000afixationClock = core.Clock()\u000afixation_text = visual.TextStim(win=win, ori=0, name='fixation_text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "bdm"\u000abdmClock = core.Clock()\u000abdm_pic = visual.ImageStim(win=win, name='bdm_pic',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=0.0)\u000abdm_bid = visual.RatingScale(win=win, name='bdm_bid', marker=u'triangle', markerColor=u'orange', leftKeys=None, rightKeys=None,\u000a    size=1.0, pos=[0.0, -0.6], low=0, high=3, precision=100, labels=[u'\u005cxa30', u'\u005cxa33'],\u000a    scale=u'', markerStart=u'1.5', tickHeight=u'1', showAccept=False, acceptKeys=[u'down', u'return'])\u000a\u000a# Initialize components for Routine "instr_choice"\u000ainstr_choiceClock = core.Clock()\u000ainstr_choice_txt = visual.TextStim(win=win, ori=0, name='instr_choice_txt',\u000a    text=u'The choice task is about to begin. Choose your preferred item by pressing the LEFT or RIGHT arrow keys, then use the slider to indicate how confident you are that you made the best choice.\u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "choice"\u000achoiceClock = core.Clock()\u000achoice_pic_left = visual.ImageStim(win=win, name='choice_pic_left',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[-0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=0.0)\u000achoice_pic_right = visual.ImageStim(win=win, name='choice_pic_right',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=-1.0)\u000a\u000a# Initialize components for Routine "choice_selection"\u000achoice_selectionClock = core.Clock()\u000astar_left_selection = visual.TextStim(win=win, ori=0, name='star_left_selection',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[-0.5, -0.8], height=0.5, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=-2.0)\u000astar_right_selection = visual.TextStim(win=win, ori=0, name='star_right_selection',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[0.5, -0.8], height=0.5, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=-3.0)\u000a\u000a# Initialize components for Routine "confidence"\u000aconfidenceClock = core.Clock()\u000aconfidence_rating = visual.RatingScale(win=win, name='confidence_rating', marker=u'triangle', markerColor=u'orange', leftKeys=None, rightKeys=None,\u000a    size=1.0, pos=[0.0, 0.0], low=1, high=6, precision=20,\u000a    scale=u'', markerStart=u'3.5', tickHeight=u'1', showAccept=False, acceptKeys=[u'down', u'return'])\u000a\u000a# Initialize components for Routine "instr_infer_intro"\u000ainstr_infer_introClock = core.Clock()\u000ainstr_infer_intro_txt = visual.TextStim(win=win, ori=0, name='instr_infer_intro_txt',\u000a    text=u'Thanks! Now please get the experimenter, who will give you the instructions for the second part of the experiment. \u005cn\u005cnPlease read these instructions carefully and get the experimenter again when you\u005c're finished. Take as much time as you need.',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=1.5,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "instr_infer_practice"\u000ainstr_infer_practiceClock = core.Clock()\u000ainstr_infer_practice_txt = visual.TextStim(win=win, ori=0, name='instr_infer_practice_txt',\u000a    text=u'First, you\u005c'll do some practice trials. These are just for you to get used to the task; your responses won\u005c't count. Unlike in the real trials, the choices you will be learning here were generated randomly by a computer.\u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=1.5,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "instr_infer"\u000ainstr_inferClock = core.Clock()\u000ainstr_infer_txt = visual.TextStim(win=win, ori=0, name='instr_infer_txt',\u000a    text=u'Great! Now that you\u005c've done some practice trials, we\u005c're ready to start the real trials. If you have any questions, please get the experimenter now. Otherwise, you can begin whenever you\u005c're ready. \u005cn\u005cnUnlike in the practice trials, the choices you will be learning here were made by an actual person.\u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=1.5,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "get_ready"\u000aget_readyClock = core.Clock()\u000aget_ready_text = visual.TextStim(win=win, ori=0, name='get_ready_text',\u000a    text=u'Get ready!',    font=u'Arial',\u000a    pos=[0, 0], height=0.12, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000aimg_left_infer = visual.ImageStim(win=win, name='img_left_infer',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[-0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=0.0)\u000aimg_right_infer = visual.ImageStim(win=win, name='img_right_infer',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=-1.0)\u000a\u000a# Initialize components for Routine "trial_post_response"\u000atrial_post_responseClock = core.Clock()\u000aselection_arrow_left = visual.TextStim(win=win, ori=0, name='selection_arrow_left',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[-0.5, -0.09], height=0.5, wrapWidth=None,\u000a    color=u'red', colorSpace=u'rgb', opacity=1,\u000a    depth=-2.0)\u000aselection_arrow_right = visual.TextStim(win=win, ori=0, name='selection_arrow_right',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[0.5, -0.09], height=0.5, wrapWidth=None,\u000a    color=u'red', colorSpace=u'rgb', opacity=1,\u000a    depth=-3.0)\u000afeedback_box_left = visual.Rect(win=win, name='feedback_box_left',\u000a    width=[0.9, 0.9][0], height=[0.9, 0.9][1],\u000a    ori=0, pos=[-0.5, 0],\u000a    lineWidth=5, lineColor=u'yellow', lineColorSpace=u'rgb',\u000a    fillColor=None, fillColorSpace=u'rgb',\u000a    opacity=1, depth=-4.0, interpolate=True)\u000afeedback_box_right = visual.Rect(win=win, name='feedback_box_right',\u000a    width=[0.9, 0.9][0], height=[0.9, 0.9][1],\u000a    ori=0, pos=[0.5, 0],\u000a    lineWidth=5, lineColor=u'yellow', lineColorSpace=u'rgb',\u000a    fillColor=None, fillColorSpace=u'rgb',\u000a    opacity=1, depth=-5.0, interpolate=True)\u000a\u000a# Initialize components for Routine "rest_prompt"\u000arest_promptClock = core.Clock()\u000arest_prompt_txt = visual.TextStim(win=win, ori=0, name='rest_prompt_txt',\u000a    text=u'Great! Now take a rest and press the space bar when you\u005cu2019re ready to begin the next block.',    font=u'Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create counters for the number of correct and incorrect guesses made by subjects to determine extra payment.\u000acorrect_counter = 0\u000aincorrect_counter = 0\u000a\u000a# Create list of lists to store binary choice and BDM data to generate food reward at the end of the experiment\u000aprefs = [['left', 'right', 'choice', 'bid']]\u000abids = [['item', 'bid']] # For the bids collected during the first BDM routine, at the beginning of the experiment\u000a\u000a### CHOICE & INFERENCE RANDOMIZATION ###\u000a\u000a# Define two functions to generate constrained pseudorandom sequences of item pair presentations for the binary choice and inference\u000a# parts of the task. The constraint ensures that the same pair of items does not appear twice in a row (flipped or not).\u000a# In the conditions spreadsheet that the item pairs are drawn from, the flipped version of the same item pair is 20\u000a# rows apart.\u000a\u000a# Binary choice randomization\u000adef genseq_choice():\u000a    done = False\u000a    while done==False:\u000a        counter = 0\u000a        ans = np.random.choice(40, 40, replace=False) # Generate a pseudorandom sequence of 40 numbers\u000a        for x in range(1,40):\u000a            if (ans[x]-ans[x-1]) % 20 == 0: # Is the difference between any sequential numbers divisible by 20?\u000a                counter += 1\u000a        if counter==0: # If not, end the loop and return the array\u000a            done = True\u000a            return ans\u000a        else: # If so, continue the loop and try again\u000a            done = False\u000a\u000a# Inference practice block randomization\u000adef genseq_infer_practice():\u000a    done = False\u000a    while done==False:\u000a        counter = 0\u000a        ans = np.random.choice(14, 14, replace=False) # Generate a pseudorandom sequence of 200 numbers\u000a        for x in range(1,14):\u000a            if (ans[x]-ans[x-1]) % 7 == 0: # Is the difference between any sequential numbers divisible by 20?\u000a                counter += 1\u000a        if counter==0: # If not, end the loop and return the array\u000a            done = True\u000a            return ans\u000a        else: # If so, continue the loop and try again\u000a            done = False\u000a\u000a# Inference randomization\u000adef genseq_infer():\u000a    done = False\u000a    while done==False:\u000a        counter = 0\u000a        ans = np.random.choice(200, 200, replace=False) # Generate a pseudorandom sequence of 200 numbers\u000a        for x in range(1,200):\u000a            if (ans[x]-ans[x-1]) % 20 == 0: # Is the difference between any sequential numbers divisible by 20?\u000a                counter += 1\u000a        if counter==0: # If not, end the loop and return the array\u000a            done = True\u000a            return ans\u000a        else: # If so, continue the loop and try again\u000a            done = False\u000a\u000a\u000a# Set independent sequences for each of the two choice blocks, the inference practice block, and the three inference rest blocks. Each rest block contains 10 presentations of\u000a# each pair.\u000a\u000achoiceseq = genseq_choice()\u000apracticeseq = genseq_infer_practice()\u000ablock1seq = genseq_infer()\u000ablock2seq = genseq_infer()\u000ablock3seq = genseq_infer()\u000a\u000a\u000a# Choose a pilot participant whose choices will form the basis of the learning task\u000apartners = ['P1','P2','P3','P4','P5','P6','P8','P9','P10','P11','P12'] # List of pilot participants, P7 excluded for perfectly inconsistent choices\u000apartner = np.random.choice(partners,1) # Choose one at random\u000apartner_file = 'conditions/choices/infer_design1_value_pairs_' + partner[0] + '.csv' # Path to that participant's choice data\u000a\u000a# Create separate CSV files, one for each choice, practice, and rest block, with the item pairs in the pseudorandomly generated order.\u000a# These CSV files will be used as PsychoPy's conditions spreadsheets and run sequentially in the choice, practice, and inference loops below.\u000a\u000a\u000achoicecond_src = pd.read_csv('conditions/choice_design1_binary.csv', index_col=None, header=0)\u000achoicecond = choicecond_src.copy()\u000afor x in range(40):\u000a    seq = choiceseq[x]\u000a    choicecond.iloc[x] = choicecond_src.iloc[seq]\u000achoicecond.to_csv(path_or_buf=filename+'_choicecond.csv', index=False)\u000a\u000apracticecond_src = pd.read_csv('conditions/choices/infer_design1_value_pairs_practice.csv', index_col=None, header=0)\u000apracticecond = practicecond_src.copy()\u000afor x in range(14):\u000a    seq = practiceseq[x]\u000a    practicecond.iloc[x] = practicecond_src.iloc[seq]\u000apracticecond.to_csv(path_or_buf=filename+'_practicecond.csv', index=False)\u000a\u000ablock1cond_src = pd.read_csv(partner_file, index_col=None, header=0)\u000ablock1cond = block1cond_src.copy()\u000afor x in range(200):\u000a    seq = block1seq[x]\u000a    block1cond.iloc[x] = block1cond_src.iloc[seq]\u000ablock1cond.to_csv(path_or_buf=filename+'_block1cond.csv', index=False)\u000a\u000ablock2cond_src = pd.read_csv(partner_file, index_col=None, header=0)\u000ablock2cond = block2cond_src.copy()\u000afor x in range(200):\u000a    seq = block2seq[x]\u000a    block2cond.iloc[x] = block2cond_src.iloc[seq]\u000ablock2cond.to_csv(path_or_buf=filename+'_block2cond.csv', index=False)\u000a\u000ablock3cond_src = pd.read_csv(partner_file, index_col=None, header=0)\u000ablock3cond = block3cond_src.copy()\u000afor x in range(200):\u000a    seq = block3seq[x]\u000a    block3cond.iloc[x] = block3cond_src.iloc[seq]\u000ablock3cond.to_csv(path_or_buf=filename+'_block3cond.csv', index=False)\u000a\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instr_main"-------\u000at = 0\u000ainstr_mainClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_main_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_main_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_mainComponents = []\u000ainstr_mainComponents.append(instr_main_txt)\u000ainstr_mainComponents.append(instr_main_resp)\u000afor thisComponent in instr_mainComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_main"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_mainClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_main_txt* updates\u000a    if t >= 0.0 and instr_main_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_main_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_main_txt.frameNStart = frameN  # exact frame index\u000a        instr_main_txt.setAutoDraw(True)\u000a    \u000a    # *instr_main_resp* updates\u000a    if t >= 5.0 and instr_main_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_main_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_main_resp.frameNStart = frameN  # exact frame index\u000a        instr_main_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_main_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_main_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_main_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_main_resp.rt = instr_main_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_mainComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_main"-------\u000afor thisComponent in instr_mainComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_main_resp.keys in ['', [], None]:  # No response was made\u000a   instr_main_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_main_resp.keys',instr_main_resp.keys)\u000aif instr_main_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_main_resp.rt', instr_main_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a\u000a#------Prepare to start Routine "instr_bdm"-------\u000at = 0\u000ainstr_bdmClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_bdm_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_bdm_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_bdmComponents = []\u000ainstr_bdmComponents.append(instr_bdm_txt)\u000ainstr_bdmComponents.append(instr_bdm_resp)\u000afor thisComponent in instr_bdmComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_bdm"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_bdmClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_bdm_txt* updates\u000a    if t >= 0.0 and instr_bdm_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_bdm_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_bdm_txt.frameNStart = frameN  # exact frame index\u000a        instr_bdm_txt.setAutoDraw(True)\u000a    \u000a    # *instr_bdm_resp* updates\u000a    if t >= 2.0 and instr_bdm_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_bdm_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_bdm_resp.frameNStart = frameN  # exact frame index\u000a        instr_bdm_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_bdm_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_bdm_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space', 's'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_bdm_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_bdm_resp.rt = instr_bdm_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_bdmComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_bdm"-------\u000afor thisComponent in instr_bdmComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_bdm_resp.keys in ['', [], None]:  # No response was made\u000a   instr_bdm_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_bdm_resp.keys',instr_bdm_resp.keys)\u000athisExp.addData('partnered_pilot_participant', partner)\u000aif instr_bdm_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_bdm_resp.rt', instr_bdm_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## BDM LOOP 1 ##########################\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000abdm_loop1 = data.TrialHandler(nReps=1, method=u'random', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'conditions/choice_design1_bdm.xlsx'),\u000a    seed=None, name='bdm_loop1')\u000athisExp.addLoop(bdm_loop1)  # add the loop to the experiment\u000athisbdm_loop1 = bdm_loop1.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisbdm_loop1.rgb)\u000aif thisbdm_loop1 != None:\u000a    for paramName in thisbdm_loop1.keys():\u000a        exec(paramName + '= thisbdm_loop1.' + paramName)\u000a\u000a# Check if the 'skip' key was pressed in the instructions routine; if so, end the loop and move on to the inference task\u000aif instr_bdm_resp.keys=='s':\u000a    bdm_loop1.finished = True\u000a\u000afor thisbdm_loop1 in bdm_loop1:\u000a    currentLoop = bdm_loop1\u000a    # abbreviate parameter names if possible (e.g. rgb = thisbdm_loop1.rgb)\u000a    if thisbdm_loop1 != None:\u000a        for paramName in thisbdm_loop1.keys():\u000a            exec(paramName + '= thisbdm_loop1.' + paramName)\u000a    \u000a    #------Prepare to start Routine "bdm"-------\u000a    t = 0\u000a    bdmClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    bdm_pic.setImage(dir_path+bdm_img)\u000a    bdm_bid.reset()\u000a    # jitter the starting position of the BDM scale from a uniform distribution between 1 and 2, rounded to the nearest decimal place\u000a    bdm_marker_start = float(np.round(np.random.uniform(1, 2, 1)[0], 1))\u000a    bdm_bid.setMarkerPos(bdm_marker_start)\u000a    # keep track of which components have finished\u000a    bdmComponents = []\u000a    bdmComponents.append(fixation_text)\u000a    bdmComponents.append(bdm_pic)\u000a    bdmComponents.append(bdm_bid)\u000a    for thisComponent in bdmComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "bdm"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = bdmClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation_text* updates\u000a        if t >= 0 and fixation_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation_text.tStart = t  # underestimates by a little under one frame\u000a            fixation_text.frameNStart = frameN  # exact frame index\u000a            fixation_text.setAutoDraw(True)\u000a        elif fixation_text.status == STARTED and t>= (0 + (1.0-win.monitorFramePeriod*0.75)):\u000a            fixation_text.setAutoDraw(False)\u000a\u000a        # *bdm_pic* updates\u000a        if t >= 1.0 and bdm_pic.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bdm_pic.tStart = t  # underestimates by a little under one frame\u000a            bdm_pic.frameNStart = frameN  # exact frame index\u000a            bdm_pic.setAutoDraw(True)\u000a        # *bdm_bid* updates\u000a        if t >= 1.0:\u000a            bdm_bid.draw()\u000a            continueRoutine = bdm_bid.noResponse\u000a            if bdm_bid.noResponse == False:\u000a                bdm_bid.response = bdm_bid.getRating()\u000a                bdm_bid.rt = bdm_bid.getRT()\u000a            elif bdm_bid.noResponse==True:\u000a                if keyState[key.LEFT]==True and bdm_bid.markerPlacedAt >0.01:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt - 0.02\u000a                    bdm_bid.draw()\u000a                elif keyState[key.LEFT]==True and bdm_bid.markerPlacedAt==0.01:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt - 0.01\u000a                    bdm_bid.draw()\u000a                elif keyState[key.RIGHT]==True and bdm_bid.markerPlacedAt <2.99:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt + 0.02\u000a                    bdm_bid.draw()\u000a                elif keyState[key.RIGHT]==True and bdm_bid.markerPlacedAt==2.99:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt + 0.01\u000a                    bdm_bid.draw()\u000a                    \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in bdmComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "bdm"-------\u000a    for thisComponent in bdmComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # store data for bdm (TrialHandler)\u000a    bdm_loop1.addData('bdm_bid1.response', bdm_bid.getRating())\u000a    bdm_loop1.addData('bdm_bid1.rt', bdm_bid.getRT())\u000a    bdm_loop1.addData('bdm_marker_start', bdm_marker_start)\u000a\u000a    # Add the item and the subject's bid to the 'bids' list, which will be merged with the 'prefs' list later in order to run the auction\u000a    bids.append([bdm_img, bdm_bid.response])\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeat of 'bdm_loop1'\u000a\u000a\u000a#------Prepare to start Routine "instr_choice"-------\u000at = 0\u000ainstr_choiceClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_choice_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_choice_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_choiceComponents = []\u000ainstr_choiceComponents.append(instr_choice_txt)\u000ainstr_choiceComponents.append(instr_choice_resp)\u000afor thisComponent in instr_choiceComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_choice"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_choiceClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_choice_txt* updates\u000a    if t >= 0.0 and instr_choice_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_choice_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_choice_txt.frameNStart = frameN  # exact frame index\u000a        instr_choice_txt.setAutoDraw(True)\u000a    \u000a    # *instr_choice_resp* updates\u000a    if t >= 2.0 and instr_choice_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_choice_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_choice_resp.frameNStart = frameN  # exact frame index\u000a        instr_choice_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_choice_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_choice_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space', 's'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_choice_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_choice_resp.rt = instr_choice_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_choiceComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_choice"-------\u000afor thisComponent in instr_choiceComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_choice_resp.keys in ['', [], None]:  # No response was made\u000a   instr_choice_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_choice_resp.keys',instr_choice_resp.keys)\u000aif instr_choice_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_choice_resp.rt', instr_choice_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## BINARY LOOP ##########################\u000a\u000a# set up handler to look after randomisation of conditions etc\u000abinary = data.TrialHandler(nReps=1, method=u'sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(filename+'_choicecond.csv'),\u000a    seed=None, name='binary')\u000athisExp.addLoop(binary)  # add the loop to the experiment\u000athisBinary1 = binary.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBinary1.rgb)\u000aif thisBinary1 != None:\u000a    for paramName in thisBinary1.keys():\u000a        exec(paramName + '= thisBinary1.' + paramName)\u000a\u000a# Check if the 'skip' key was pressed in the instructions routine; if so, end the loop and move on to the BDM\u000aif instr_choice_resp.keys=='s':\u000a    binary.finished = True\u000a\u000afor thisBinary1 in binary:\u000a    currentLoop = binary\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBinary1.rgb)\u000a    if thisBinary1 != None:\u000a        for paramName in thisBinary1.keys():\u000a            exec(paramName + '= thisBinary1.' + paramName)\u000a    \u000a    #------Prepare to start Routine "choice"-------\u000a    t = 0\u000a    choiceClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    choice_pic_left.setImage(dir_path+choice_left)\u000a    choice_pic_right.setImage(dir_path+choice_right)\u000a    event.clearEvents(eventType='keyboard') # Clear keyboard event log to avoid last key press from prior loop being used\u000a    key_resp_choice = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_choice.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    choiceComponents = []\u000a    choiceComponents.append(fixation_text)\u000a    choiceComponents.append(choice_pic_left)\u000a    choiceComponents.append(choice_pic_right)\u000a    choiceComponents.append(key_resp_choice)\u000a    for thisComponent in choiceComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    \u000a    #-------Start Routine "choice"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = choiceClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation_text* updates\u000a        if t >= 0 and fixation_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation_text.tStart = t  # underestimates by a little under one frame\u000a            fixation_text.frameNStart = frameN  # exact frame index\u000a            fixation_text.setAutoDraw(True)\u000a        elif fixation_text.status == STARTED and t>= (0 + (1.0-win.monitorFramePeriod*0.75)):\u000a            fixation_text.setAutoDraw(False)\u000a\u000a        # *choice_pic_left* updates\u000a        if t >= 1.0 and choice_pic_left.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_left.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_left.frameNStart = frameN  # exact frame index\u000a            choice_pic_left.setAutoDraw(True)\u000a        \u000a        # *choice_pic_right* updates\u000a        if t >= 1.0 and choice_pic_right.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_right.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_right.frameNStart = frameN  # exact frame index\u000a            choice_pic_right.setAutoDraw(True)\u000a\u000a        # *key_resp_choice* updates\u000a        if t >= 1.0 and key_resp_choice.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_choice.tStart = t  # underestimates by a little under one frame\u000a            key_resp_choice.frameNStart = frameN  # exact frame index\u000a            key_resp_choice.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_choice.clock.reset()  # now t=0\u000a        if key_resp_choice.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_choice.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_choice.rt = key_resp_choice.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in choiceComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "choice"-------\u000a    for thisComponent in choiceComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_choice.keys in ['', [], None]:  # No response was made\u000a       key_resp_choice.keys=None\u000a    # store data for binary (TrialHandler)\u000a    binary.addData('key_resp_choice.keys',key_resp_choice.keys)\u000a    if key_resp_choice.keys != None:  # we had a response\u000a        binary.addData('key_resp_choice.rt', key_resp_choice.rt)\u000a\u000a    # define a function to append binary choices and the bid for the chosen item to the preference list\u000a    # lft is the left image displayed during that choice trial\u000a    # rt is the right image displayed\u000a    def rec_choice(lft, rt): \u000a        bd = False\u000a        if key_resp_choice.keys=='left':\u000a            chc = lft\u000a        elif key_resp_choice.keys=='right':\u000a            chc = rt\u000a        for x in range(len(bids)):\u000a            if bids[x][0]==chc:\u000a                bd = bids[x][1]\u000a        prefs.append([lft, rt, chc, bd])\u000a\u000a    # call the function\u000a    rec_choice(choice_left, choice_right)\u000a    \u000a\u000a    #------Prepare to start Routine "choice_selection"-------\u000a    t = 0\u000a    choice_selectionClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # keep track of which components have finished\u000a    choice_selectionComponents = []\u000a    choice_selectionComponents.append(choice_pic_left)\u000a    choice_selectionComponents.append(choice_pic_right)\u000a    choice_selectionComponents.append(star_left_selection)\u000a    choice_selectionComponents.append(star_right_selection)\u000a    for thisComponent in choice_selectionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "choice_selection"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = choice_selectionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *choice_pic_left* updates\u000a        if t >= 0.0 and choice_pic_left.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_left.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_left.frameNStart = frameN  # exact frame index\u000a            choice_pic_left.setAutoDraw(True)\u000a        elif choice_pic_left.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            choice_pic_left.setAutoDraw(False)\u000a        \u000a        # *choice_pic_right* updates\u000a        if t >= 0.0 and choice_pic_right.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_right.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_right.frameNStart = frameN  # exact frame index\u000a            choice_pic_right.setAutoDraw(True)\u000a        elif choice_pic_right.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            choice_pic_right.setAutoDraw(False)\u000a        \u000a        # *star_left_selection* updates\u000a        if key_resp_choice.keys=='left':\u000a            if t >= 0.0 and star_left_selection.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                star_left_selection.tStart = t  # underestimates by a little under one frame\u000a                star_left_selection.frameNStart = frameN  # exact frame index\u000a                star_left_selection.setAutoDraw(True)\u000a            elif star_left_selection.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                star_left_selection.setAutoDraw(False)\u000a        \u000a        # *star_right_selection* updates\u000a        if key_resp_choice.keys=='right':\u000a            if t >= 0.0 and star_right_selection.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                star_right_selection.tStart = t  # underestimates by a little under one frame\u000a                star_right_selection.frameNStart = frameN  # exact frame index\u000a                star_right_selection.setAutoDraw(True)\u000a            elif star_right_selection.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                star_right_selection.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in choice_selectionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "choice_selection"-------\u000a    for thisComponent in choice_selectionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    #thisExp.nextEntry()\u000a\u000a    #------Prepare to start Routine "confidence"-------\u000a    t = 0\u000a    confidenceClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    confidence_rating.reset()\u000a    # jitter the starting position of the confidence rating scale from a uniform distribution between 1.7 and 3.3 (the middle third of the scale), rounded to the nearest decimal place\u000a    confidence_marker_start = float(np.round(np.random.uniform(1.7, 3.3, 1)[0], 1))\u000a    confidence_rating.setMarkerPos(confidence_marker_start)\u000a    # keep track of which components have finished\u000a    confidenceComponents = []\u000a    confidenceComponents.append(confidence_rating)\u000a    for thisComponent in confidenceComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "confidence"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = confidenceClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *confidence_rating* updates\u000a        if t > 0.5:\u000a            confidence_rating.draw()\u000a            continueRoutine = confidence_rating.noResponse\u000a            if confidence_rating.noResponse == False:\u000a                confidence_rating.response = confidence_rating.getRating()\u000a                confidence_rating.rt = confidence_rating.getRT()\u000a            elif confidence_rating.noResponse==True:\u000a                if keyState[key.LEFT]==True and confidence_rating.markerPlacedAt >0:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt - 0.1\u000a                    confidence_rating.draw()\u000a                elif keyState[key.LEFT]==True and confidence_rating.markerPlacedAt==0.1:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt - 0.1\u000a                    confidence_rating.draw()\u000a                elif keyState[key.RIGHT]==True and confidence_rating.markerPlacedAt <4.9:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt + 0.1\u000a                    confidence_rating.draw()\u000a                elif keyState[key.RIGHT]==True and confidence_rating.markerPlacedAt==4.9:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt + 0.1\u000a                    confidence_rating.draw()\u000a                    \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in confidenceComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "confidence"-------\u000a    for thisComponent in confidenceComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # store data for confidence (TrialHandler)\u000a    binary.addData('confidence_rating1.response', confidence_rating.getRating())\u000a    binary.addData('confidence_rating1.rt', confidence_rating.getRT())\u000a    binary.addData('confidence_marker_start', confidence_marker_start+1) # Add 1 to convert from 0-5 to 1-6 scale\u000a\u000a    thisExp.nextEntry()\u000a\u000a\u000a# completed 1 repeat of 'binary'        \u000a\u000a#------Prepare to start Routine "instr_infer_intro"-------\u000at = 0\u000ainstr_infer_introClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_infer_intro_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_infer_intro_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_infer_introComponents = []\u000ainstr_infer_introComponents.append(instr_infer_intro_txt)\u000ainstr_infer_introComponents.append(instr_infer_intro_resp)\u000afor thisComponent in instr_infer_introComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_infer_intro"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_infer_introClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_infer_intro_txt* updates\u000a    if t >= 0.0 and instr_infer_intro_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_intro_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_intro_txt.frameNStart = frameN  # exact frame index\u000a        instr_infer_intro_txt.setAutoDraw(True)\u000a    \u000a    # *instr_infer_intro_resp* updates\u000a    if t >= 5.0 and instr_infer_intro_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_intro_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_intro_resp.frameNStart = frameN  # exact frame index\u000a        instr_infer_intro_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_infer_intro_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_infer_intro_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_infer_intro_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_infer_intro_resp.rt = instr_infer_intro_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_infer_introComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_infer_intro"-------\u000afor thisComponent in instr_infer_introComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_infer_intro_resp.keys in ['', [], None]:  # No response was made\u000a   instr_infer_intro_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_infer_intro_resp.keys',instr_infer_intro_resp.keys)\u000aif instr_infer_intro_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_infer_intro_resp.rt', instr_infer_intro_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a#------Prepare to start Routine "instr_infer_practice"-------\u000at = 0\u000ainstr_infer_practiceClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_infer_practice_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_infer_practice_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_infer_practiceComponents = []\u000ainstr_infer_practiceComponents.append(instr_infer_practice_txt)\u000ainstr_infer_practiceComponents.append(instr_infer_practice_resp)\u000afor thisComponent in instr_infer_practiceComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_infer_practice"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_infer_practiceClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_infer_practice_txt* updates\u000a    if t >= 0.0 and instr_infer_practice_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_practice_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_practice_txt.frameNStart = frameN  # exact frame index\u000a        instr_infer_practice_txt.setAutoDraw(True)\u000a    \u000a    # *instr_infer_practice_resp* updates\u000a    if t >= 5.0 and instr_infer_practice_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_practice_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_practice_resp.frameNStart = frameN  # exact frame index\u000a        instr_infer_practice_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_infer_practice_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_infer_practice_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_infer_practice_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_infer_practice_resp.rt = instr_infer_practice_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_infer_practiceComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_infer_practice"-------\u000afor thisComponent in instr_infer_practiceComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_infer_practice_resp.keys in ['', [], None]:  # No response was made\u000a   instr_infer_practice_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_infer_practice_resp.keys',instr_infer_practice_resp.keys)\u000aif instr_infer_practice_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_infer_practice_resp.rt', instr_infer_practice_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## PRACTICE LOOP ##########################\u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_loop = data.TrialHandler(nReps=1, method=u'sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(filename+'_practicecond.csv'),\u000a    seed=None, name='practice_loop')\u000athisExp.addLoop(practice_loop)  # add the loop to the experiment\u000athisPractice_loop = practice_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_loop.rgb)\u000aif thisPractice_loop != None:\u000a    for paramName in thisPractice_loop.keys():\u000a        exec(paramName + '= thisPractice_loop.' + paramName)\u000a\u000a  \u000afor thisPractice_loop in practice_loop:\u000a    currentLoop = practice_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_loop.rgb)\u000a    if thisPractice_loop != None:\u000a        for paramName in thisPractice_loop.keys():\u000a            exec(paramName + '= thisPractice_loop.' + paramName)    \u000a    \u000a        \u000a    # Define class for setting the feedback image\u000a    class set_feedback:\u000a        options = ['correct', 'wrong']\u000a        feedback = np.random.choice(options, replace=True, p=[0.8, 0.2])\u000a        if feedback=='correct':\u000a            feedback_img = img_correct\u000a        elif feedback=='wrong':\u000a            feedback_img = img_wrong\u000a\u000a        if feedback_img==img_left:\u000a            feedback_side = 'left'\u000a        elif feedback_img==img_right:\u000a            feedback_side = 'right'\u000a\u000a\u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialtime = datetime.datetime.now()\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    img_left_infer.setImage(dir_path+img_left)\u000a    img_right_infer.setImage(dir_path+img_right)\u000a    infer_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    infer_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(fixation_text)\u000a    trialComponents.append(img_left_infer)\u000a    trialComponents.append(img_right_infer)\u000a    trialComponents.append(infer_resp)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation_text* updates\u000a        if t >= 0 and fixation_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation_text.tStart = t  # underestimates by a little under one frame\u000a            fixation_text.frameNStart = frameN  # exact frame index\u000a            fixation_text.setAutoDraw(True)\u000a        elif fixation_text.status == STARTED and t>= (0 + (2.0-win.monitorFramePeriod*0.75)):\u000a            fixation_text.setAutoDraw(False)\u000a\u000a        # *img_left_infer* updates\u000a        if t >= 2.0 and img_left_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_left_infer.tStart = t  # underestimates by a little under one frame\u000a            img_left_infer.frameNStart = frameN  # exact frame index\u000a            img_left_infer.setAutoDraw(True)\u000a        \u000a        # *img_right_infer* updates\u000a        if t >= 2.0 and img_right_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_right_infer.tStart = t  # underestimates by a little under one frame\u000a            img_right_infer.frameNStart = frameN  # exact frame index\u000a            img_right_infer.setAutoDraw(True)\u000a                  \u000a        # *infer_resp* updates\u000a        if t >= 2.0 and infer_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            infer_resp.tStart = t  # underestimates by a little under one frame\u000a            infer_resp.frameNStart = frameN  # exact frame index\u000a            infer_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            infer_resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if infer_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                infer_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                infer_resp.rt = infer_resp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a\u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if infer_resp.keys in ['', [], None]:  # No response was made\u000a       infer_resp.keys=None\u000a    # # store data for practice_loop (TrialHandler)\u000a    # practice_loop.addData('infer_resp.keys',infer_resp.keys)\u000a    # if infer_resp.keys != None:  # we had a response\u000a    #     practice_loop.addData('infer_resp.rt', infer_resp.rt)\u000a    practice_loop.addData('set_feedback.feedback_img', set_feedback.feedback_img)\u000a    practice_loop.addData('trial_start_time', trialtime)\u000a    \u000a    # # Increase correct and incorrect response counters by 1 based on S's response\u000a    # if infer_resp.keys=='left' and img_correct==img_left:\u000a    #     correct_counter += 1\u000a    # elif infer_resp.keys=='left' and img_correct==img_right:\u000a    #     incorrect_counter += 1\u000a    # elif infer_resp.keys=='right' and img_correct==img_right:\u000a    #     correct_counter += 1\u000a    # elif infer_resp.keys=='right' and img_correct==img_left:\u000a    #     incorrect_counter += 1\u000a    \u000a\u000a    #------Prepare to start Routine "trial_post_response"-------\u000a    t = 0\u000a    trial_post_responseClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(3.000000)\u000a    # keep track of which components have finished\u000a    trial_post_responseComponents = []\u000a    trial_post_responseComponents.append(img_left_infer)\u000a    trial_post_responseComponents.append(img_right_infer)\u000a    trial_post_responseComponents.append(selection_arrow_left)\u000a    trial_post_responseComponents.append(selection_arrow_right)\u000a    trial_post_responseComponents.append(feedback_box_left)\u000a    trial_post_responseComponents.append(feedback_box_right)\u000a    for thisComponent in trial_post_responseComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial_post_response"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = trial_post_responseClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a\u000a        # *img_left_infer* updates\u000a        if t >= 0.0 and img_left_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_left_infer.tStart = t  # underestimates by a little under one frame\u000a            img_left_infer.frameNStart = frameN  # exact frame index\u000a            img_left_infer.setAutoDraw(True)\u000a        elif img_left_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            img_left_infer.setAutoDraw(False)\u000a        \u000a        # *img_right_infer* updates\u000a        if t >= 0.0 and img_right_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_right_infer.tStart = t  # underestimates by a little under one frame\u000a            img_right_infer.frameNStart = frameN  # exact frame index\u000a            img_right_infer.setAutoDraw(True)\u000a        elif img_right_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            img_right_infer.setAutoDraw(False)\u000a        \u000a        if infer_resp.keys == 'left':\u000a            # *selection_arrow_left* updates\u000a            if t >= 0.0 and selection_arrow_left.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                selection_arrow_left.tStart = t  # underestimates by a little under one frame\u000a                selection_arrow_left.frameNStart = frameN  # exact frame index\u000a                selection_arrow_left.setAutoDraw(True)\u000a            elif selection_arrow_left.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                selection_arrow_left.setAutoDraw(False)\u000a        \u000a        if infer_resp.keys == 'right':\u000a            # *selection_arrow_right* updates\u000a            if t >= 0.0 and selection_arrow_right.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                selection_arrow_right.tStart = t  # underestimates by a little under one frame\u000a                selection_arrow_right.frameNStart = frameN  # exact frame index\u000a                selection_arrow_right.setAutoDraw(True)\u000a            elif selection_arrow_right.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                selection_arrow_right.setAutoDraw(False)\u000a        \u000a        if set_feedback.feedback_side == 'left':\u000a            # *feedback_box_left* updates\u000a            if t >= 1.0 and feedback_box_left.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                feedback_box_left.tStart = t  # underestimates by a little under one frame\u000a                feedback_box_left.frameNStart = frameN  # exact frame index\u000a                feedback_box_left.setAutoDraw(True)\u000a            elif feedback_box_left.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                feedback_box_left.setAutoDraw(False)\u000a        \u000a        if set_feedback.feedback_side == 'right':\u000a            # *feedback_box_right* updates\u000a            if t >= 1.0 and feedback_box_right.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                feedback_box_right.tStart = t  # underestimates by a little under one frame\u000a                feedback_box_right.frameNStart = frameN  # exact frame index\u000a                feedback_box_right.setAutoDraw(True)\u000a            elif feedback_box_right.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period right\u000a                feedback_box_right.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trial_post_responseComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "trial_post_response"-------\u000a    for thisComponent in trial_post_responseComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000a    \u000a    thisExp.nextEntry()\u000a                        \u000a# completed 1 repeat of 'practice_loop'\u000a\u000a\u000a#------Prepare to start Routine "instr_infer"-------\u000at = 0\u000ainstr_inferClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_infer_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_infer_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_inferComponents = []\u000ainstr_inferComponents.append(instr_infer_txt)\u000ainstr_inferComponents.append(instr_infer_resp)\u000afor thisComponent in instr_inferComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_infer"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_inferClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_infer_txt* updates\u000a    if t >= 0.0 and instr_infer_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_txt.frameNStart = frameN  # exact frame index\u000a        instr_infer_txt.setAutoDraw(True)\u000a    \u000a    # *instr_infer_resp* updates\u000a    if t >= 5.0 and instr_infer_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_resp.frameNStart = frameN  # exact frame index\u000a        instr_infer_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_infer_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_infer_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_infer_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_infer_resp.rt = instr_infer_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_inferComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_infer"-------\u000afor thisComponent in instr_inferComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_infer_resp.keys in ['', [], None]:  # No response was made\u000a   instr_infer_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_infer_resp.keys',instr_infer_resp.keys)\u000aif instr_infer_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_infer_resp.rt', instr_infer_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## BLOCK LOOP ##########################\u000a\u000a# This loop runs a second nested loop that shows each item pair 10 times, followed by a rest break prompt.\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=3, method=u'sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=[None],\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000a# Set up counter to keep track of block loop cycle, so that the rest prompt is only shown twice\u000ablock_loop_counter = 0\u000a\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    # Increase loop counter by one\u000a    block_loop_counter += 1\u000a    \u000a    # Change the condition file for the feedback block based on which block loop we're on\u000a    condfilename = filename+u'_block'+str(block_loop_counter)+u'cond.csv'\u000a    \u000a    # Minimize the psychopy window so the calibration window can be seen\u000a    win.winHandle.minimize()\u000a    #Do the eye tracker setup at the beginning of each block\u000a    tracker.runSetupProcedure()\u000a    # Re-display the psychopy window after setup is completed\u000a    win.winHandle.maximize()\u000a    win.winHandle.activate()\u000a    \u000a\u000a    \u000a    #------Prepare to start Routine "get_ready"-------\u000a    t = 0\u000a    get_readyClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(3.000000)\u000a    # update component parameters for each repeat\u000a    get_ready_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    get_ready_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    get_readyComponents = []\u000a    get_readyComponents.append(get_ready_text)\u000a    get_readyComponents.append(get_ready_resp)\u000a    for thisComponent in get_readyComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    \u000a    #-------Start Routine "get_ready"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = get_readyClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *get_ready_text* updates\u000a        if t >= 0.0 and get_ready_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            get_ready_text.tStart = t  # underestimates by a little under one frame\u000a            get_ready_text.frameNStart = frameN  # exact frame index\u000a            get_ready_text.setAutoDraw(True)\u000a        \u000a        # *get_ready_resp* updates\u000a        if t >= 0.0 and get_ready_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            get_ready_resp.tStart = t  # underestimates by a little under one frame\u000a            get_ready_resp.frameNStart = frameN  # exact frame index\u000a            get_ready_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            get_ready_resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if get_ready_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['p'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                get_ready_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                get_ready_resp.rt = get_ready_resp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in get_readyComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "get_ready"-------\u000a    for thisComponent in get_readyComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if get_ready_resp.keys in ['', [], None]:  # No response was made\u000a       get_ready_resp.keys=None\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('get_ready_resp.keys',get_ready_resp.keys)\u000a    if get_ready_resp.keys != None:  # we had a response\u000a        thisExp.addData('get_ready_resp.rt', get_ready_resp.rt)\u000a    thisExp.nextEntry()\u000a\u000a    ######################## TRIAL LOOP ##########################\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    trial_loop = data.TrialHandler(nReps=1, method=u'sequential', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(condfilename),\u000a        seed=None, name='trial_loop')\u000a    thisExp.addLoop(trial_loop)  # add the loop to the experiment\u000a    thisTrial_loop = trial_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_loop.rgb)\u000a    if thisTrial_loop != None:\u000a        for paramName in thisTrial_loop.keys():\u000a            exec(paramName + '= thisTrial_loop.' + paramName)\u000a    \u000a      \u000a    for thisTrial_loop in trial_loop:\u000a        currentLoop = trial_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_loop.rgb)\u000a        if thisTrial_loop != None:\u000a            for paramName in thisTrial_loop.keys():\u000a                exec(paramName + '= thisTrial_loop.' + paramName)    \u000a        \u000a            \u000a        # Define class for setting the feedback image\u000a        class set_feedback:\u000a            options = ['correct', 'wrong']\u000a            feedback = np.random.choice(options, replace=True, p=[0.8, 0.2])\u000a            if feedback=='correct':\u000a                feedback_img = img_correct\u000a            elif feedback=='wrong':\u000a                feedback_img = img_wrong\u000a\u000a            if feedback_img==img_left:\u000a                feedback_side = 'left'\u000a            elif feedback_img==img_right:\u000a                feedback_side = 'right'\u000a                        \u000a        # Start getting data from the eye tracker\u000a        tracker.enableEventReporting(True)\u000a        # Send beginning-of-trial messages to eye tracker data file\u000a        trial_number = (block_loop.thisN * 200) + trial_loop.thisTrialN # Trial number out of 599 (starts at 0)\u000a        tracker.sendCommand("record_status_message 'INFERRING, Block %d/3, Trial %d/600 '" % (block_loop.thisN + 1, trial_number + 1))\u000a        tracker.sendMessage("TRIALID %d" % trial_number)\u000a        tracker.sendMessage("!V TRIAL_VAR_DATA %d" % trial_number)\u000a\u000a        \u000a        #------Prepare to start Routine "trial"-------\u000a        t = 0\u000a        trialtime = datetime.datetime.now()\u000a        trialClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        img_left_infer.setImage(dir_path+img_left)\u000a        img_right_infer.setImage(dir_path+img_right)\u000a        infer_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        infer_resp.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trialComponents = []\u000a        trialComponents.append(fixation_text)\u000a        trialComponents.append(img_left_infer)\u000a        trialComponents.append(img_right_infer)\u000a        trialComponents.append(infer_resp)\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        # Set indicator variable for whether eye tracker messages were sent during the first loop of the routine\u000a        eye_sync_messages_sent = 0\u000a        \u000a        #-------Start Routine "trial"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = trialClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *fixation_text* updates\u000a            if t >= 0 and fixation_text.status == NOT_STARTED:\u000a                if eye_sync_messages_sent==0:\u000a                    startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                # keep track of start time/frame for later\u000a                fixation_text.tStart = t  # underestimates by a little under one frame\u000a                fixation_text.frameNStart = frameN  # exact frame index\u000a                fixation_text.setAutoDraw(True)\u000a                if eye_sync_messages_sent==0:\u000a                    drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                    tracker.sendMessage("%d DISPLAY ON" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                    tracker.sendMessage("SYNCTIME %d" %drawTime)\u000a                    eye_sync_messages_sent = 1\u000a            elif fixation_text.status == STARTED and t>= (0 + (2.0-win.monitorFramePeriod*0.75)):\u000a                fixation_text.setAutoDraw(False)\u000a            \u000a            # *img_left_infer* updates\u000a            if t >= 2.0 and img_left_infer.status == NOT_STARTED:\u000a                if eye_sync_messages_sent==1:\u000a                    startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                # keep track of start time/frame for later\u000a                img_left_infer.tStart = t  # underestimates by a little under one frame\u000a                img_left_infer.frameNStart = frameN  # exact frame index\u000a                img_left_infer.setAutoDraw(True)\u000a            \u000a            # *img_right_infer* updates\u000a            if t >= 2.0 and img_right_infer.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                img_right_infer.tStart = t  # underestimates by a little under one frame\u000a                img_right_infer.frameNStart = frameN  # exact frame index\u000a                img_right_infer.setAutoDraw(True)\u000a                if eye_sync_messages_sent==1:\u000a                    drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                    tracker.sendMessage("%d DISPLAY ON ITEMS" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                    eye_sync_messages_sent = 2\u000a                      \u000a            # *infer_resp* updates\u000a            if t >= 2.0 and infer_resp.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                infer_resp.tStart = t  # underestimates by a little under one frame\u000a                infer_resp.frameNStart = frameN  # exact frame index\u000a                infer_resp.status = STARTED\u000a                # keyboard checking is just starting\u000a                infer_resp.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            if infer_resp.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['left', 'right'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    infer_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                    infer_resp.rt = infer_resp.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trialComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                tracker.enableEventReporting(False) # End eye tracker data recording\u000a                tracker.sendMessage("EXPERIMENT ABORTED")\u000a                io.quit() # Close iohub\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial"-------\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if infer_resp.keys in ['', [], None]:  # No response was made\u000a           infer_resp.keys=None\u000a        # store data for trial_loop (TrialHandler)\u000a        trial_loop.addData('infer_resp.keys',infer_resp.keys)\u000a        if infer_resp.keys != None:  # we had a response\u000a            trial_loop.addData('infer_resp.rt', infer_resp.rt)\u000a        trial_loop.addData('set_feedback.feedback_img', set_feedback.feedback_img)\u000a        trial_loop.addData('trial_start_time', trialtime)\u000a        \u000a        # Increase correct and incorrect response counters by 1 based on S's response\u000a        if infer_resp.keys=='left' and img_correct==img_left:\u000a            correct_counter += 1\u000a        elif infer_resp.keys=='left' and img_correct==img_right:\u000a            incorrect_counter += 1\u000a        elif infer_resp.keys=='right' and img_correct==img_right:\u000a            correct_counter += 1\u000a        elif infer_resp.keys=='right' and img_correct==img_left:\u000a            incorrect_counter += 1\u000a        \u000a\u000a        #------Prepare to start Routine "trial_post_response"-------\u000a        t = 0\u000a        trial_post_responseClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(3.000000)\u000a        # keep track of which components have finished\u000a        trial_post_responseComponents = []\u000a        trial_post_responseComponents.append(img_left_infer)\u000a        trial_post_responseComponents.append(img_right_infer)\u000a        trial_post_responseComponents.append(selection_arrow_left)\u000a        trial_post_responseComponents.append(selection_arrow_right)\u000a        trial_post_responseComponents.append(feedback_box_left)\u000a        trial_post_responseComponents.append(feedback_box_right)\u000a        for thisComponent in trial_post_responseComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        # Set indicator variable for whether eye tracker messages were sent during the first loop of the routine\u000a        eye_sync_messages_sent = 0\u000a\u000a        #-------Start Routine "trial_post_response"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = trial_post_responseClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a\u000a            # *img_left_infer* updates\u000a            if t >= 0.0 and img_left_infer.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                img_left_infer.tStart = t  # underestimates by a little under one frame\u000a                img_left_infer.frameNStart = frameN  # exact frame index\u000a                img_left_infer.setAutoDraw(True)\u000a            elif img_left_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                img_left_infer.setAutoDraw(False)\u000a            \u000a            # *img_right_infer* updates\u000a            if t >= 0.0 and img_right_infer.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                img_right_infer.tStart = t  # underestimates by a little under one frame\u000a                img_right_infer.frameNStart = frameN  # exact frame index\u000a                img_right_infer.setAutoDraw(True)\u000a            elif img_right_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                img_right_infer.setAutoDraw(False)\u000a            \u000a            if infer_resp.keys == 'left':\u000a                # *selection_arrow_left* updates\u000a                if t >= 0.0 and selection_arrow_left.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==0:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    selection_arrow_left.tStart = t  # underestimates by a little under one frame\u000a                    selection_arrow_left.frameNStart = frameN  # exact frame index\u000a                    selection_arrow_left.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==0:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        tracker.sendMessage("%d DISPLAY ON SELECTION" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 1\u000a                elif selection_arrow_left.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    if eye_sync_messages_sent==1:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    selection_arrow_left.setAutoDraw(False)\u000a                    if eye_sync_messages_sent==1:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        tracker.sendMessage("%d DISPLAY ON SELECTION OFF" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 2\u000a            \u000a            if infer_resp.keys == 'right':\u000a                # *selection_arrow_right* updates\u000a                if t >= 0.0 and selection_arrow_right.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==0:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    selection_arrow_right.tStart = t  # underestimates by a little under one frame\u000a                    selection_arrow_right.frameNStart = frameN  # exact frame index\u000a                    selection_arrow_right.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==0:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        tracker.sendMessage("%d DISPLAY ON SELECTION" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 1\u000a                elif selection_arrow_right.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    if eye_sync_messages_sent==1:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    selection_arrow_right.setAutoDraw(False)\u000a                    if eye_sync_messages_sent==1:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        tracker.sendMessage("%d DISPLAY ON SELECTION OFF" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 2\u000a            \u000a            if set_feedback.feedback_side == 'left':\u000a                # *feedback_box_left* updates\u000a                if t >= 1.0 and feedback_box_left.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==2:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    feedback_box_left.tStart = t  # underestimates by a little under one frame\u000a                    feedback_box_left.frameNStart = frameN  # exact frame index\u000a                    feedback_box_left.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==2:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        tracker.sendMessage("%d DISPLAY ON FEEDBACK" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 3\u000a                elif feedback_box_left.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    feedback_box_left.setAutoDraw(False)\u000a            \u000a            if set_feedback.feedback_side == 'right':\u000a                # *feedback_box_right* updates\u000a                if t >= 1.0 and feedback_box_right.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==2:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    feedback_box_right.tStart = t  # underestimates by a little under one frame\u000a                    feedback_box_right.frameNStart = frameN  # exact frame index\u000a                    feedback_box_right.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==2:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        tracker.sendMessage("%d DISPLAY ON FEEDBACK" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 3\u000a                elif feedback_box_right.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period right\u000a                    feedback_box_right.setAutoDraw(False)\u000a\u000a\u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial_post_responseComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                tracker.enableEventReporting(False) # End eye tracker data recording\u000a                tracker.sendMessage("EXPERIMENT ABORTED")\u000a                io.quit() # Close iohub\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "trial_post_response"-------\u000a        for thisComponent in trial_post_responseComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a        thisExp.nextEntry()\u000a                            \u000a    # completed 5 repeats of 'trial_loop'\u000a    \u000a    if block_loop_counter <= 2: # If this is the first or second cycle of the loop, display the rest break prompt\u000a\u000a        #------Prepare to start Routine "rest_prompt"-------\u000a        t = 0\u000a        rest_promptClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        rest_prompt_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        rest_prompt_resp.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        rest_promptComponents = []\u000a        rest_promptComponents.append(rest_prompt_txt)\u000a        rest_promptComponents.append(rest_prompt_resp)\u000a        for thisComponent in rest_promptComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a\u000a        #-------Start Routine "rest_prompt"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = rest_promptClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *rest_prompt_txt* updates\u000a            if t >= 0.0 and rest_prompt_txt.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                rest_prompt_txt.tStart = t  # underestimates by a little under one frame\u000a                rest_prompt_txt.frameNStart = frameN  # exact frame index\u000a                rest_prompt_txt.setAutoDraw(True)\u000a            \u000a            # *rest_prompt_resp* updates\u000a            if t >= 2.0 and rest_prompt_resp.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                rest_prompt_resp.tStart = t  # underestimates by a little under one frame\u000a                rest_prompt_resp.frameNStart = frameN  # exact frame index\u000a                rest_prompt_resp.status = STARTED\u000a                # keyboard checking is just starting\u000a                rest_prompt_resp.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            if rest_prompt_resp.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    rest_prompt_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                    rest_prompt_resp.rt = rest_prompt_resp.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in rest_promptComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                tracker.enableEventReporting(False) # End eye tracker data recording\u000a                tracker.sendMessage("EXPERIMENT ABORTED")\u000a                io.quit() # CLose iohub\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a\u000a        #-------Ending Routine "rest_prompt"-------\u000a        for thisComponent in rest_promptComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if rest_prompt_resp.keys in ['', [], None]:  # No response was made\u000a           rest_prompt_resp.keys=None\u000a        # store data for thisExp (ExperimentHandler)\u000a        thisExp.addData('rest_prompt_resp.keys',rest_prompt_resp.keys)\u000a        if rest_prompt_resp.keys != None:  # we had a response\u000a            thisExp.addData('rest_prompt_resp.rt', rest_prompt_resp.rt)\u000a\u000a\u000a    thisExp.nextEntry()\u000a    \u000a# completed 3 repeats of 'block_loop'\u000a\u000a\u000a# store data for total number of correct and incorrect responses    \u000athisExp.addData('correct_counter', correct_counter)\u000athisExp.addData('incorrect_counter', incorrect_counter)\u000athisExp.nextEntry()     \u000a\u000atracker.setConnectionState(False) # Close and transfer eye-tracking data, then close down eye tracker connection\u000a\u000a\u000a######################## AUCTION ##########################\u000a\u000aif len(prefs)==41 and len(bids)==41: # If S completed the entire binary choice and BDM routines, run the auction\u000a\u000a    # run the auction\u000a    class auction:\u000a        rand_itm = randint(1, (len(prefs))) # pick index for S's chosen item from a random choice\u000a        price = float((randint(1, 300)))/100 # assign a price to the item randomly from between 0.01 and 3 pounds\u000a        bid = prefs[rand_itm][3]\u000a        # check if S's bid for that item was above or below the price\u000a        if bid >= price:\u000a            win_item=True\u000a        elif bid < price:\u000a            win_item=False\u000a\u000a        # set text for the auction screen\u000a        if win_item==True:\u000a            auc_res_txt = u'Congratulations! You won the following item at auction. \u005cnThis was your preferred item out of a randomly selected pair from one of the choice tasks.'\u000a            auc_prc_txt = u'Your bid of \u005cxa3' + '{0:.2f}'.format(bid) + u' matched or exceeded the randomly generated price of \u005cxa3' + '{0:.2f}'.format(price) + '.\u005cn\u005cn[Press space bar to continue]'\u000a            cost = price\u000a        elif win_item==False:\u000a            auc_res_txt = u'Sorry, you did not win the following item at auction. \u005cnThis was your preferred item out of a randomly selected pair from one of the choice tasks.'\u000a            auc_prc_txt = u'Your bid of \u005cxa3' + '{0:.2f}'.format(bid) + u' was lower than the randomly generated price of \u005cxa3' + '{0:.2f}'.format(price) + '.\u005cn\u005cn[Press space bar to continue]'\u000a            cost = 0\u000a\u000a        # find the image path of the auction item\u000a        rand_itm_img = prefs[rand_itm][2]\u000a\u000a    # add up each component of S's payment\u000a    class score:\u000a        base = 25\u000a        rwrd = 0.01\u000a        loss = 0\u000a        rwrd_tot = rwrd * correct_counter\u000a        loss_tot = loss * incorrect_counter\u000a        pre_pymt = base + rwrd_tot - loss_tot\u000a        final_pymt = pre_pymt - auction.cost\u000a\u000a        pymt_expl_bdwn = u'\u005cxa3' + '{0:.2f}'.format(base) + u' base payment'+ u'\u005cn+ \u005cxa3' + '{0:.2f}'.format(rwrd_tot) + ' reward for ' + str(correct_counter) + u' correct responses (\u005cxa3' + '{0:.2f}'.format(rwrd) + u' each)' + u'\u005cn- \u005cxa3' + '{0:.2f}'.format(auction.cost) + ' cost of auction item' \u000a        pymt_expl_tot = u'Your total payment is: \u005cxa3' + '{0:.2f}'.format(final_pymt) + '\u005cn\u005cnThank you for participating! Please call the experimenter into the room.'\u000a\u000a\u000a    # Initialize components for Routine "auc_disp"\u000a    auc_dispClock = core.Clock()\u000a    pic_auc_itm = visual.ImageStim(win=win, name='pic_auc_itm',\u000a        image=dir_path+auction.rand_itm_img, mask=None,\u000a        ori=0, pos=[0, 0], size=None,\u000a        color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a        flipHoriz=False, flipVert=False,\u000a        texRes=128, interpolate=False, depth=0.0)\u000a    auc_txt1 = visual.TextStim(win=win, ori=0, name='auc_txt1',\u000a        text=auction.auc_res_txt, font=u'Arial',\u000a        pos=[0, 0.6], height=0.07, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    auc_txt2 = visual.TextStim(win=win, ori=0, name='auc_txt2',\u000a        text=auction.auc_prc_txt, font=u'Arial',\u000a        pos=[0, -0.6], height=0.07, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a\u000a    #------Prepare to start Routine "auc_disp"-------\u000a    t = 0\u000a    auc_dispClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    key_resp_auc_disp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_auc_disp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    auc_dispComponents = []\u000a    auc_dispComponents.append(pic_auc_itm)\u000a    auc_dispComponents.append(auc_txt1)\u000a    auc_dispComponents.append(auc_txt2)\u000a    for thisComponent in auc_dispComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "auc_disp"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = auc_dispClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *pic_auc_itm* updates\u000a        if t >= 0.2 and pic_auc_itm.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            pic_auc_itm.tStart = t  # underestimates by a little under one frame\u000a            pic_auc_itm.frameNStart = frameN  # exact frame index\u000a            pic_auc_itm.setAutoDraw(True)\u000a        \u000a        # *auc_txt1* updates\u000a        if t >= 0.2 and auc_txt1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            auc_txt1.tStart = t  # underestimates by a little under one frame\u000a            auc_txt1.frameNStart = frameN  # exact frame index\u000a            auc_txt1.setAutoDraw(True)\u000a\u000a        # *auc_txt2* updates\u000a        if t >= 0.2 and auc_txt2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            auc_txt2.tStart = t  # underestimates by a little under one frame\u000a            auc_txt2.frameNStart = frameN  # exact frame index\u000a            auc_txt2.setAutoDraw(True)\u000a        \u000a        # *key_resp_auc_disp* updates\u000a        if t >= 0.2 and key_resp_auc_disp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_auc_disp.tStart = t  # underestimates by a little under one frame\u000a            key_resp_auc_disp.frameNStart = frameN  # exact frame index\u000a            key_resp_auc_disp.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_auc_disp.clock.reset()  # now t=0\u000a        if key_resp_auc_disp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_auc_disp.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_auc_disp.rt = key_resp_auc_disp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in auc_dispComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "auc_disp"-------\u000a    for thisComponent in auc_dispComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_auc_disp.keys in ['', [], None]:  # No response was made\u000a       key_resp_auc_disp.keys=None\u000a    # store data for thisExp (TrialHandler)\u000a    thisExp.addData('auction.win_item', auction.win_item)\u000a    thisExp.addData('auction.price', auction.price)\u000a    thisExp.addData('auction.bid', auction.bid)\u000a    thisExp.addData('auction.rand_itm_img', auction.rand_itm_img)\u000a    thisExp.addData('score.base', score.base)\u000a    thisExp.addData('score.rwrd', score.rwrd)\u000a    thisExp.addData('score.loss', score.loss)\u000a    thisExp.addData('correct_counter', correct_counter)\u000a    thisExp.addData('incorrect_counter', incorrect_counter)\u000a    thisExp.addData('score.final_pymt', score.final_pymt)\u000a    thisExp.nextEntry()\u000a\u000a\u000a    # Initialize components for Routine "pymt_disp"\u000a    pymt_dispClock = core.Clock()\u000a    pymt_disp_txt1 = visual.TextStim(win=win, ori=0, name='pymt_disp_txt1',\u000a        text=score.pymt_expl_bdwn, font=u'Arial',\u000a        pos=[0, 0.6], height=0.07, wrapWidth=1.5,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    pymt_disp_txt2 = visual.TextStim(win=win, ori=0, name='pymt_disp_txt2',\u000a        text=score.pymt_expl_tot, font=u'Arial',\u000a        pos=[0, -0.65], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    #------Prepare to start Routine "pymt_disp"-------\u000a    t = 0\u000a    pymt_dispClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    key_resp_pymt_disp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_pymt_disp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    pymt_dispComponents = []\u000a    pymt_dispComponents.append(pic_auc_itm)\u000a    pymt_dispComponents.append(pymt_disp_txt1)\u000a    pymt_dispComponents.append(pymt_disp_txt2)\u000a    pymt_dispComponents.append(key_resp_pymt_disp)\u000a    for thisComponent in pymt_dispComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "pymt_disp"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = pymt_dispClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        if auction.win_item==True:\u000a            # *pic_auc_itm* updates\u000a            if t >= 0.0 and pic_auc_itm.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                pic_auc_itm.tStart = t  # underestimates by a little under one frame\u000a                pic_auc_itm.frameNStart = frameN  # exact frame index\u000a                pic_auc_itm.setAutoDraw(True)\u000a\u000a        # *pymt_disp_txt1* updates\u000a        if t >= 0.0 and pymt_disp_txt1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            pymt_disp_txt1.tStart = t  # underestimates by a little under one frame\u000a            pymt_disp_txt1.frameNStart = frameN  # exact frame index\u000a            pymt_disp_txt1.setAutoDraw(True)\u000a\u000a        # *pymt_disp_txt2* updates\u000a        if t >= 0.0 and pymt_disp_txt2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            pymt_disp_txt2.tStart = t  # underestimates by a little under one frame\u000a            pymt_disp_txt2.frameNStart = frameN  # exact frame index\u000a            pymt_disp_txt2.setAutoDraw(True)\u000a        \u000a        # *key_resp_pymt_disp* updates\u000a        if t >= 3.0 and key_resp_pymt_disp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_pymt_disp.tStart = t  # underestimates by a little under one frame\u000a            key_resp_pymt_disp.frameNStart = frameN  # exact frame index\u000a            key_resp_pymt_disp.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_pymt_disp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if key_resp_pymt_disp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_pymt_disp.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_pymt_disp.rt = key_resp_pymt_disp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in pymt_dispComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "pymt_disp"-------\u000a    for thisComponent in pymt_dispComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_pymt_disp.keys in ['', [], None]:  # No response was made\u000a       key_resp_pymt_disp.keys=None\u000a\u000aelse: # If S didn't complete the entire binary choice and BDM routines during this session, prompt a manual auction\u000a    # Initialize components for Routine "auc_manual"\u000a    auc_manualClock = core.Clock()\u000a    auc_manual_txt = visual.TextStim(win=win, ori=0, name='auc_manual_txt',\u000a        text=u'Thank you! This completes the experiment. Please get the experimenter, who will run the auction and calculate your final payment.\u005cn\u005cnCorrect: ' + str(correct_counter) + '\u005cnIncorrect: ' + str(incorrect_counter),    font=u'Arial',\u000a        pos=[0, 0], height=0.07, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    #------Prepare to start Routine "auc_manual"-------\u000a    t = 0\u000a    auc_manualClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    auc_manualComponents = []\u000a    auc_manualComponents.append(auc_manual_txt)\u000a    for thisComponent in auc_manualComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "auc_manual"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = auc_manualClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *auc_manual_txt* updates\u000a        if t >= 0.0 and auc_manual_txt.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            auc_manual_txt.tStart = t  # underestimates by a little under one frame\u000a            auc_manual_txt.frameNStart = frameN  # exact frame index\u000a            auc_manual_txt.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in auc_manualComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "auc_manual"-------\u000a    for thisComponent in auc_manualComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000athisExp.nextEntry()\u000a\u000aio.quit() # Close iohub\u000a\u000a\u000awin.close()\u000acore.quit()\u000a
p9107
sS'thisTrial'
p9108
(lp9109
sS'_exp'
p9110
I84422992
sg10
S'bdm_loop1'
p9111
sg6
S'C:\\DATA\\bdm\\tor\\inferring_intentions_task\\task_code\\infer_design1.py'
p9112
sS'thisRepN'
p9113
I1
sg52
I01
sg53
g54
sS'data'
p9114
g1
(cpsychopy.data
DataHandler
p9115
c__builtin__
dict
p9116
(dp9117
S'ran'
p9118
cnumpy.ma.core
_mareconstruct
p9119
(cnumpy.ma.core
MaskedArray
p9120
g93
(I0
tp9121
S'b'
tRp9122
(I1
(I40
I1
tg61
(S'f4'
I0
I1
tRp9123
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
g9119
(g9120
g93
g9121
S'b'
tRp9124
(I1
(I40
I1
tg9123
I00
S'\xaeG\x01@\x00\x00\x00@\xcd\xcc\xcc>\\\x8f\x82?\x00\x00\x80?=\n\x97?\x00\x00\x00\x00\n\xd7#>\x00\x00\x00\x00)\\\x0f?q=\n?)\\\x8f?\x00\x00\xc0?\n\xd7#?\x1f\x85\xeb>\x8f\xc2\xf5>\xa4p=?\x9a\x99\x19?\x9a\x99\x19?\xe1z\x14?\x8f\xc2\xf5>\x14\xae\x87?\x00\x00\x80?\xf6(\x9c?\\\x8fB?{\x14.?\x00\x00\x80?\\\x8f\x82?{\x14\xae?=\n\x97?q=\x8a?\x9a\x99\x99?q=\x8a?\xf6(\x9c?)\\\x8f>=\nW?H\xe1z?\x1f\x85k?\xecQ\xb8>333?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg20
g9119
(g9120
g93
g9121
S'b'
tRp9125
(I1
(I40
I1
tg9123
I00
S'D\x8b\x14Aw\xbe\xb3@/\xdd<@\x87\x16\x99@\xb2\x9dMAT\xe3M@!\xb0Z@\xee|\x97@\x0e-R@/\xdd\x1c@\xa8\xc6\x1b@\x10X\xbd@\x98n\x8e@!\xb0z@1\x08\xa0@d;\x83@!\xb0j@/\xdd\x1c@/\xdd,@w\xbe\xcb@!\xb0\xaa@\x87\x16\x91@\xfc\xa99@d;\x9b@T\xe3\x8d@\x10X\x85@\x98n\xd6@\xdb\xf9\x8e@1\x08\xa0@\xcb\xa1\xf1@\xbaI\x84@\xcb\xa1\x91@\xdb\xf9>@\x87\x16\x99@\xfc\xa9Y@w\xbe\x83@T\xe3}@d;\xb3@T\xe3-@b\x10 @'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbsS'order'
p9126
g9119
(g9120
g93
g9121
S'b'
tRp9127
(I1
(I40
I1
tg9123
I00
S'\x00\x00\x00B\x00\x00\x1cB\x00\x00\x04B\x00\x00\x14B\x00\x00\x00\x00\x00\x00\x88A\x00\x00\x00@\x00\x00\x80?\x00\x00pA\x00\x00PA\x00\x00\xe0A\x00\x00@A\x00\x00\x08B\x00\x00\xa0A\x00\x00`A\x00\x00@@\x00\x00\xf0A\x00\x00\x98A\x00\x00\xc0@\x00\x00\x10A\x00\x00\xa8A\x00\x00\xe0@\x00\x00\x90A\x00\x00\x0cB\x00\x00\xc8A\x00\x00\xa0@\x00\x00\xb8A\x00\x00\xc0A\x00\x00\xb0A\x00\x00\x80@\x00\x00\xf8A\x00\x00\xe8A\x00\x00\xd8A\x00\x00\x80A\x00\x00\x00A\x00\x00 A\x00\x000A\x00\x00\xd0A\x00\x00\x10B\x00\x00\x18B'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg21
g9119
(g9120
g93
g9121
S'b'
tRp9128
(I1
(I40
I1
tg9123
I00
S'\x9a\x99\x99?\x00\x00\x80?33\xf3?\x00\x00\x00@\x9a\x99\x99?33\xf3?\x00\x00\x00@33\xf3?\x00\x00\xc0?\x00\x00\xc0?\xcd\xcc\x8c?33\xf3?33\xb3?33\xf3?\x00\x00\xc0?33\xf3?33\xb3?\x9a\x99\x99?\x00\x00\xc0?\x00\x00\xc0?33\xb3?33\xf3?\xcd\xcc\x8c?\xcd\xcc\x8c?33\xf3?33\xf3?ff\xa6?\xcd\xcc\x8c?\xcd\xcc\x8c?\x00\x00\x80?\x9a\x99\xd9?\x9a\x99\xd9?\xcd\xcc\xcc?ff\xe6?ff\xa6?\xcd\xcc\x8c?33\xf3?\x9a\x99\x99?\xcd\xcc\x8c?33\xf3?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp9129
(dp9130
S'isNumeric'
p9131
(dp9132
g9118
I01
sg19
I01
sg20
I01
sg9126
I01
sg21
I01
ssS'trials'
p9133
g9104
sS'dataTypes'
p9134
(lp9135
g9118
ag9126
ag19
ag20
ag21
asS'dataShape'
p9136
(lp9137
I40
aI1
asbsS'method'
p9138
Vrandom
p9139
sS'sequenceIndices'
p9140
g92
(g93
(I0
tS'b'
tRp9141
(I1
(I40
I1
tg99
I01
S'\x04\x00\x00\x00\x07\x00\x00\x00\x06\x00\x00\x00\x0f\x00\x00\x00\x1d\x00\x00\x00\x19\x00\x00\x00\x12\x00\x00\x00\x15\x00\x00\x00"\x00\x00\x00\x13\x00\x00\x00#\x00\x00\x00$\x00\x00\x00\x0b\x00\x00\x00\t\x00\x00\x00\x0e\x00\x00\x00\x08\x00\x00\x00!\x00\x00\x00\x05\x00\x00\x00\x16\x00\x00\x00\x11\x00\x00\x00\r\x00\x00\x00\x14\x00\x00\x00\x1c\x00\x00\x00\x1a\x00\x00\x00\x1b\x00\x00\x00\x18\x00\x00\x00%\x00\x00\x00 \x00\x00\x00\n\x00\x00\x00\x1f\x00\x00\x00\x10\x00\x00\x00\x1e\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x0c\x00\x00\x00\x17\x00\x00\x00&\x00\x00\x00\x03\x00\x00\x00\'\x00\x00\x00\x01\x00\x00\x00'
tbsS'finished'
p9142
I01
sS'nReps'
p9143
I1
sS'nRemaining'
p9144
I-1
sS'trialList'
p9145
(lp9146
g1
(cpsychopy.data
TrialType
p9147
g9116
(dp9148
g79
g327
stRp9149
ag1
(g9147
g9116
(dp9150
g79
g376
stRp9151
ag1
(g9147
g9116
(dp9152
g79
g334
stRp9153
ag1
(g9147
g9116
(dp9154
g79
g362
stRp9155
ag1
(g9147
g9116
(dp9156
g79
g103
stRp9157
ag1
(g9147
g9116
(dp9158
g79
g222
stRp9159
ag1
(g9147
g9116
(dp9160
g79
g117
stRp9161
ag1
(g9147
g9116
(dp9162
g79
g110
stRp9163
ag1
(g9147
g9116
(dp9164
g79
g208
stRp9165
ag1
(g9147
g9116
(dp9166
g79
g194
stRp9167
ag1
(g9147
g9116
(dp9168
g79
g299
stRp9169
ag1
(g9147
g9116
(dp9170
g79
g187
stRp9171
ag1
(g9147
g9116
(dp9172
g79
g341
stRp9173
ag1
(g9147
g9116
(dp9174
g79
g243
stRp9175
ag1
(g9147
g9116
(dp9176
g79
g201
stRp9177
ag1
(g9147
g9116
(dp9178
g79
g124
stRp9179
ag1
(g9147
g9116
(dp9180
g79
g313
stRp9181
ag1
(g9147
g9116
(dp9182
g79
g236
stRp9183
ag1
(g9147
g9116
(dp9184
g79
g145
stRp9185
ag1
(g9147
g9116
(dp9186
g79
g166
stRp9187
ag1
(g9147
g9116
(dp9188
g79
g250
stRp9189
ag1
(g9147
g9116
(dp9190
g79
g152
stRp9191
ag1
(g9147
g9116
(dp9192
g79
g229
stRp9193
ag1
(g9147
g9116
(dp9194
g79
g348
stRp9195
ag1
(g9147
g9116
(dp9196
g79
g278
stRp9197
ag1
(g9147
g9116
(dp9198
g79
g138
stRp9199
ag1
(g9147
g9116
(dp9200
g79
g264
stRp9201
ag1
(g9147
g9116
(dp9202
g79
g271
stRp9203
ag1
(g9147
g9116
(dp9204
g79
g257
stRp9205
ag1
(g9147
g9116
(dp9206
g79
g131
stRp9207
ag1
(g9147
g9116
(dp9208
g79
g320
stRp9209
ag1
(g9147
g9116
(dp9210
g79
g306
stRp9211
ag1
(g9147
g9116
(dp9212
g79
g292
stRp9213
ag1
(g9147
g9116
(dp9214
g79
g215
stRp9215
ag1
(g9147
g9116
(dp9216
g79
g159
stRp9217
ag1
(g9147
g9116
(dp9218
g79
g173
stRp9219
ag1
(g9147
g9116
(dp9220
g79
g180
stRp9221
ag1
(g9147
g9116
(dp9222
g79
g285
stRp9223
ag1
(g9147
g9116
(dp9224
g79
g355
stRp9225
ag1
(g9147
g9116
(dp9226
g79
g369
stRp9227
asS'seed'
p9228
NsS'thisIndex'
p9229
g373
sS'thisN'
p9230
I40
sS'thisTrialN'
p9231
I0
sS'nTotal'
p9232
I40
sS'_warnUseOfNext'
p9233
I01
sbag1
(g9103
g3
NtRp9234
(dp9235
g9106
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a\u000a######################## CITATIONS ########################## \u000a##### Binary choice, BDM, auction routines, and instructions are modified from:\u000a##### \u000a##### De Martino, B., Fleming, S. M., Garrett, N., & Dolan, R. J. (2012). Confidence in value-based choice. Nature Neuroscience, 16(1), 105-110. \u000a#####\u000a##### Food item images are original.\u000a\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.80.01), July 16, 2014, at 03:20\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things bdm STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000afrom pyglet.window import key # to detect key state, whether key is held down, to move slider on key hold\u000aimport pandas as pd\u000aimport datetime\u000afrom psychopy.iohub import launchHubServer\u000aimport pylink\u000a\u000a# Initialize IOHub for eye tracker\u000aio=launchHubServer(iohub_config_name='iohub_config.yaml')\u000atracker = io.devices.tracker\u000a\u000a# Store info about the experiment session\u000aexpName = 'infer_design1'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u'', u'eye': u'', u'glasses': u'', u'contacts': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Setup filename for saving\u000afilename = 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# set up variable to track current state of key press, to move slider when keys held down\u000akeyState=key.KeyStateHandler()\u000a\u000a# Setup the Window\u000ascreenwidth = 1920\u000ascreenheight = 1080\u000awin = visual.Window(size=(screenwidth, screenheight), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color='black', colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000awin.winHandle.push_handlers(keyState)\u000a\u000a\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a\u000a######################## COMPONENTS ##########################\u000a\u000a# Set up directory path for stimuli. This avoids us having to put the entire image path in the conditions spreadsheet.\u000adir_path = 'stimuli/itempics/modified/small/'\u000a\u000a# Initialize components for Routine "instr_main"\u000ainstr_mainClock = core.Clock()\u000ainstr_main_txt = visual.TextStim(win=win, ori=0, name='instr_main_txt',\u000a    text=u'Welcome!\u005cn\u005cnPlease read the instructions carefully and get the experimenter when you\u005c're finished. Take as much time as you need.',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "instr_bdm"\u000ainstr_bdmClock = core.Clock()\u000ainstr_bdm_txt = visual.TextStim(win=win, ori=0, name='instr_bdm_txt',\u000a    text=u'The bidding task is about to begin. Use the LEFT and RIGHT arrow keys to move the cursor along the slider, then press the DOWN arrow to enter your bid.\u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "fixation"\u000afixationClock = core.Clock()\u000afixation_text = visual.TextStim(win=win, ori=0, name='fixation_text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "bdm"\u000abdmClock = core.Clock()\u000abdm_pic = visual.ImageStim(win=win, name='bdm_pic',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=0.0)\u000abdm_bid = visual.RatingScale(win=win, name='bdm_bid', marker=u'triangle', markerColor=u'orange', leftKeys=None, rightKeys=None,\u000a    size=1.0, pos=[0.0, -0.6], low=0, high=3, precision=100, labels=[u'\u005cxa30', u'\u005cxa33'],\u000a    scale=u'', markerStart=u'1.5', tickHeight=u'1', showAccept=False, acceptKeys=[u'down', u'return'])\u000a\u000a# Initialize components for Routine "instr_choice"\u000ainstr_choiceClock = core.Clock()\u000ainstr_choice_txt = visual.TextStim(win=win, ori=0, name='instr_choice_txt',\u000a    text=u'The choice task is about to begin. Choose your preferred item by pressing the LEFT or RIGHT arrow keys, then use the slider to indicate how confident you are that you made the best choice.\u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "choice"\u000achoiceClock = core.Clock()\u000achoice_pic_left = visual.ImageStim(win=win, name='choice_pic_left',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[-0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=0.0)\u000achoice_pic_right = visual.ImageStim(win=win, name='choice_pic_right',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=-1.0)\u000a\u000a# Initialize components for Routine "choice_selection"\u000achoice_selectionClock = core.Clock()\u000astar_left_selection = visual.TextStim(win=win, ori=0, name='star_left_selection',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[-0.5, -0.8], height=0.5, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=-2.0)\u000astar_right_selection = visual.TextStim(win=win, ori=0, name='star_right_selection',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[0.5, -0.8], height=0.5, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=-3.0)\u000a\u000a# Initialize components for Routine "confidence"\u000aconfidenceClock = core.Clock()\u000aconfidence_rating = visual.RatingScale(win=win, name='confidence_rating', marker=u'triangle', markerColor=u'orange', leftKeys=None, rightKeys=None,\u000a    size=1.0, pos=[0.0, 0.0], low=1, high=6, precision=20,\u000a    scale=u'', markerStart=u'3.5', tickHeight=u'1', showAccept=False, acceptKeys=[u'down', u'return'])\u000a\u000a# Initialize components for Routine "instr_infer_intro"\u000ainstr_infer_introClock = core.Clock()\u000ainstr_infer_intro_txt = visual.TextStim(win=win, ori=0, name='instr_infer_intro_txt',\u000a    text=u'Thanks! Now please get the experimenter, who will give you the instructions for the second part of the experiment. \u005cn\u005cnPlease read these instructions carefully and get the experimenter again when you\u005c're finished. Take as much time as you need.',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=1.5,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "instr_infer_practice"\u000ainstr_infer_practiceClock = core.Clock()\u000ainstr_infer_practice_txt = visual.TextStim(win=win, ori=0, name='instr_infer_practice_txt',\u000a    text=u'First, you\u005c'll do some practice trials. These are just for you to get used to the task; your responses won\u005c't count. Unlike in the real trials, the choices you will be learning here were generated randomly by a computer.\u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=1.5,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "instr_infer"\u000ainstr_inferClock = core.Clock()\u000ainstr_infer_txt = visual.TextStim(win=win, ori=0, name='instr_infer_txt',\u000a    text=u'Great! Now that you\u005c've done some practice trials, we\u005c're ready to start the real trials. If you have any questions, please get the experimenter now. Otherwise, you can begin whenever you\u005c're ready. \u005cn\u005cnUnlike in the practice trials, the choices you will be learning here were made by an actual person.\u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=1.5,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "get_ready"\u000aget_readyClock = core.Clock()\u000aget_ready_text = visual.TextStim(win=win, ori=0, name='get_ready_text',\u000a    text=u'Get ready!',    font=u'Arial',\u000a    pos=[0, 0], height=0.12, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000aimg_left_infer = visual.ImageStim(win=win, name='img_left_infer',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[-0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=0.0)\u000aimg_right_infer = visual.ImageStim(win=win, name='img_right_infer',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=-1.0)\u000a\u000a# Initialize components for Routine "trial_post_response"\u000atrial_post_responseClock = core.Clock()\u000aselection_arrow_left = visual.TextStim(win=win, ori=0, name='selection_arrow_left',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[-0.5, -0.09], height=0.5, wrapWidth=None,\u000a    color=u'red', colorSpace=u'rgb', opacity=1,\u000a    depth=-2.0)\u000aselection_arrow_right = visual.TextStim(win=win, ori=0, name='selection_arrow_right',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[0.5, -0.09], height=0.5, wrapWidth=None,\u000a    color=u'red', colorSpace=u'rgb', opacity=1,\u000a    depth=-3.0)\u000afeedback_box_left = visual.Rect(win=win, name='feedback_box_left',\u000a    width=[0.9, 0.9][0], height=[0.9, 0.9][1],\u000a    ori=0, pos=[-0.5, 0],\u000a    lineWidth=5, lineColor=u'yellow', lineColorSpace=u'rgb',\u000a    fillColor=None, fillColorSpace=u'rgb',\u000a    opacity=1, depth=-4.0, interpolate=True)\u000afeedback_box_right = visual.Rect(win=win, name='feedback_box_right',\u000a    width=[0.9, 0.9][0], height=[0.9, 0.9][1],\u000a    ori=0, pos=[0.5, 0],\u000a    lineWidth=5, lineColor=u'yellow', lineColorSpace=u'rgb',\u000a    fillColor=None, fillColorSpace=u'rgb',\u000a    opacity=1, depth=-5.0, interpolate=True)\u000a\u000a# Initialize components for Routine "rest_prompt"\u000arest_promptClock = core.Clock()\u000arest_prompt_txt = visual.TextStim(win=win, ori=0, name='rest_prompt_txt',\u000a    text=u'Great! Now take a rest and press the space bar when you\u005cu2019re ready to begin the next block.',    font=u'Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create counters for the number of correct and incorrect guesses made by subjects to determine extra payment.\u000acorrect_counter = 0\u000aincorrect_counter = 0\u000a\u000a# Create list of lists to store binary choice and BDM data to generate food reward at the end of the experiment\u000aprefs = [['left', 'right', 'choice', 'bid']]\u000abids = [['item', 'bid']] # For the bids collected during the first BDM routine, at the beginning of the experiment\u000a\u000a### CHOICE & INFERENCE RANDOMIZATION ###\u000a\u000a# Define two functions to generate constrained pseudorandom sequences of item pair presentations for the binary choice and inference\u000a# parts of the task. The constraint ensures that the same pair of items does not appear twice in a row (flipped or not).\u000a# In the conditions spreadsheet that the item pairs are drawn from, the flipped version of the same item pair is 20\u000a# rows apart.\u000a\u000a# Binary choice randomization\u000adef genseq_choice():\u000a    done = False\u000a    while done==False:\u000a        counter = 0\u000a        ans = np.random.choice(40, 40, replace=False) # Generate a pseudorandom sequence of 40 numbers\u000a        for x in range(1,40):\u000a            if (ans[x]-ans[x-1]) % 20 == 0: # Is the difference between any sequential numbers divisible by 20?\u000a                counter += 1\u000a        if counter==0: # If not, end the loop and return the array\u000a            done = True\u000a            return ans\u000a        else: # If so, continue the loop and try again\u000a            done = False\u000a\u000a# Inference practice block randomization\u000adef genseq_infer_practice():\u000a    done = False\u000a    while done==False:\u000a        counter = 0\u000a        ans = np.random.choice(14, 14, replace=False) # Generate a pseudorandom sequence of 200 numbers\u000a        for x in range(1,14):\u000a            if (ans[x]-ans[x-1]) % 7 == 0: # Is the difference between any sequential numbers divisible by 20?\u000a                counter += 1\u000a        if counter==0: # If not, end the loop and return the array\u000a            done = True\u000a            return ans\u000a        else: # If so, continue the loop and try again\u000a            done = False\u000a\u000a# Inference randomization\u000adef genseq_infer():\u000a    done = False\u000a    while done==False:\u000a        counter = 0\u000a        ans = np.random.choice(200, 200, replace=False) # Generate a pseudorandom sequence of 200 numbers\u000a        for x in range(1,200):\u000a            if (ans[x]-ans[x-1]) % 20 == 0: # Is the difference between any sequential numbers divisible by 20?\u000a                counter += 1\u000a        if counter==0: # If not, end the loop and return the array\u000a            done = True\u000a            return ans\u000a        else: # If so, continue the loop and try again\u000a            done = False\u000a\u000a\u000a# Set independent sequences for each of the two choice blocks, the inference practice block, and the three inference rest blocks. Each rest block contains 10 presentations of\u000a# each pair.\u000a\u000achoiceseq = genseq_choice()\u000apracticeseq = genseq_infer_practice()\u000ablock1seq = genseq_infer()\u000ablock2seq = genseq_infer()\u000ablock3seq = genseq_infer()\u000a\u000a\u000a# Choose a pilot participant whose choices will form the basis of the learning task\u000apartners = ['P1','P2','P3','P4','P5','P6','P8','P9','P10','P11','P12'] # List of pilot participants, P7 excluded for perfectly inconsistent choices\u000apartner = np.random.choice(partners,1) # Choose one at random\u000apartner_file = 'conditions/choices/infer_design1_value_pairs_' + partner[0] + '.csv' # Path to that participant's choice data\u000a\u000a# Create separate CSV files, one for each choice, practice, and rest block, with the item pairs in the pseudorandomly generated order.\u000a# These CSV files will be used as PsychoPy's conditions spreadsheets and run sequentially in the choice, practice, and inference loops below.\u000a\u000a\u000achoicecond_src = pd.read_csv('conditions/choice_design1_binary.csv', index_col=None, header=0)\u000achoicecond = choicecond_src.copy()\u000afor x in range(40):\u000a    seq = choiceseq[x]\u000a    choicecond.iloc[x] = choicecond_src.iloc[seq]\u000achoicecond.to_csv(path_or_buf=filename+'_choicecond.csv', index=False)\u000a\u000apracticecond_src = pd.read_csv('conditions/choices/infer_design1_value_pairs_practice.csv', index_col=None, header=0)\u000apracticecond = practicecond_src.copy()\u000afor x in range(14):\u000a    seq = practiceseq[x]\u000a    practicecond.iloc[x] = practicecond_src.iloc[seq]\u000apracticecond.to_csv(path_or_buf=filename+'_practicecond.csv', index=False)\u000a\u000ablock1cond_src = pd.read_csv(partner_file, index_col=None, header=0)\u000ablock1cond = block1cond_src.copy()\u000afor x in range(200):\u000a    seq = block1seq[x]\u000a    block1cond.iloc[x] = block1cond_src.iloc[seq]\u000ablock1cond.to_csv(path_or_buf=filename+'_block1cond.csv', index=False)\u000a\u000ablock2cond_src = pd.read_csv(partner_file, index_col=None, header=0)\u000ablock2cond = block2cond_src.copy()\u000afor x in range(200):\u000a    seq = block2seq[x]\u000a    block2cond.iloc[x] = block2cond_src.iloc[seq]\u000ablock2cond.to_csv(path_or_buf=filename+'_block2cond.csv', index=False)\u000a\u000ablock3cond_src = pd.read_csv(partner_file, index_col=None, header=0)\u000ablock3cond = block3cond_src.copy()\u000afor x in range(200):\u000a    seq = block3seq[x]\u000a    block3cond.iloc[x] = block3cond_src.iloc[seq]\u000ablock3cond.to_csv(path_or_buf=filename+'_block3cond.csv', index=False)\u000a\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instr_main"-------\u000at = 0\u000ainstr_mainClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_main_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_main_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_mainComponents = []\u000ainstr_mainComponents.append(instr_main_txt)\u000ainstr_mainComponents.append(instr_main_resp)\u000afor thisComponent in instr_mainComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_main"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_mainClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_main_txt* updates\u000a    if t >= 0.0 and instr_main_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_main_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_main_txt.frameNStart = frameN  # exact frame index\u000a        instr_main_txt.setAutoDraw(True)\u000a    \u000a    # *instr_main_resp* updates\u000a    if t >= 5.0 and instr_main_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_main_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_main_resp.frameNStart = frameN  # exact frame index\u000a        instr_main_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_main_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_main_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_main_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_main_resp.rt = instr_main_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_mainComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_main"-------\u000afor thisComponent in instr_mainComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_main_resp.keys in ['', [], None]:  # No response was made\u000a   instr_main_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_main_resp.keys',instr_main_resp.keys)\u000aif instr_main_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_main_resp.rt', instr_main_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a\u000a#------Prepare to start Routine "instr_bdm"-------\u000at = 0\u000ainstr_bdmClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_bdm_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_bdm_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_bdmComponents = []\u000ainstr_bdmComponents.append(instr_bdm_txt)\u000ainstr_bdmComponents.append(instr_bdm_resp)\u000afor thisComponent in instr_bdmComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_bdm"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_bdmClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_bdm_txt* updates\u000a    if t >= 0.0 and instr_bdm_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_bdm_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_bdm_txt.frameNStart = frameN  # exact frame index\u000a        instr_bdm_txt.setAutoDraw(True)\u000a    \u000a    # *instr_bdm_resp* updates\u000a    if t >= 2.0 and instr_bdm_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_bdm_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_bdm_resp.frameNStart = frameN  # exact frame index\u000a        instr_bdm_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_bdm_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_bdm_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space', 's'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_bdm_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_bdm_resp.rt = instr_bdm_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_bdmComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_bdm"-------\u000afor thisComponent in instr_bdmComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_bdm_resp.keys in ['', [], None]:  # No response was made\u000a   instr_bdm_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_bdm_resp.keys',instr_bdm_resp.keys)\u000athisExp.addData('partnered_pilot_participant', partner)\u000aif instr_bdm_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_bdm_resp.rt', instr_bdm_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## BDM LOOP 1 ##########################\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000abdm_loop1 = data.TrialHandler(nReps=1, method=u'random', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'conditions/choice_design1_bdm.xlsx'),\u000a    seed=None, name='bdm_loop1')\u000athisExp.addLoop(bdm_loop1)  # add the loop to the experiment\u000athisbdm_loop1 = bdm_loop1.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisbdm_loop1.rgb)\u000aif thisbdm_loop1 != None:\u000a    for paramName in thisbdm_loop1.keys():\u000a        exec(paramName + '= thisbdm_loop1.' + paramName)\u000a\u000a# Check if the 'skip' key was pressed in the instructions routine; if so, end the loop and move on to the inference task\u000aif instr_bdm_resp.keys=='s':\u000a    bdm_loop1.finished = True\u000a\u000afor thisbdm_loop1 in bdm_loop1:\u000a    currentLoop = bdm_loop1\u000a    # abbreviate parameter names if possible (e.g. rgb = thisbdm_loop1.rgb)\u000a    if thisbdm_loop1 != None:\u000a        for paramName in thisbdm_loop1.keys():\u000a            exec(paramName + '= thisbdm_loop1.' + paramName)\u000a    \u000a    #------Prepare to start Routine "bdm"-------\u000a    t = 0\u000a    bdmClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    bdm_pic.setImage(dir_path+bdm_img)\u000a    bdm_bid.reset()\u000a    # jitter the starting position of the BDM scale from a uniform distribution between 1 and 2, rounded to the nearest decimal place\u000a    bdm_marker_start = float(np.round(np.random.uniform(1, 2, 1)[0], 1))\u000a    bdm_bid.setMarkerPos(bdm_marker_start)\u000a    # keep track of which components have finished\u000a    bdmComponents = []\u000a    bdmComponents.append(fixation_text)\u000a    bdmComponents.append(bdm_pic)\u000a    bdmComponents.append(bdm_bid)\u000a    for thisComponent in bdmComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "bdm"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = bdmClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation_text* updates\u000a        if t >= 0 and fixation_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation_text.tStart = t  # underestimates by a little under one frame\u000a            fixation_text.frameNStart = frameN  # exact frame index\u000a            fixation_text.setAutoDraw(True)\u000a        elif fixation_text.status == STARTED and t>= (0 + (1.0-win.monitorFramePeriod*0.75)):\u000a            fixation_text.setAutoDraw(False)\u000a\u000a        # *bdm_pic* updates\u000a        if t >= 1.0 and bdm_pic.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bdm_pic.tStart = t  # underestimates by a little under one frame\u000a            bdm_pic.frameNStart = frameN  # exact frame index\u000a            bdm_pic.setAutoDraw(True)\u000a        # *bdm_bid* updates\u000a        if t >= 1.0:\u000a            bdm_bid.draw()\u000a            continueRoutine = bdm_bid.noResponse\u000a            if bdm_bid.noResponse == False:\u000a                bdm_bid.response = bdm_bid.getRating()\u000a                bdm_bid.rt = bdm_bid.getRT()\u000a            elif bdm_bid.noResponse==True:\u000a                if keyState[key.LEFT]==True and bdm_bid.markerPlacedAt >0.01:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt - 0.02\u000a                    bdm_bid.draw()\u000a                elif keyState[key.LEFT]==True and bdm_bid.markerPlacedAt==0.01:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt - 0.01\u000a                    bdm_bid.draw()\u000a                elif keyState[key.RIGHT]==True and bdm_bid.markerPlacedAt <2.99:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt + 0.02\u000a                    bdm_bid.draw()\u000a                elif keyState[key.RIGHT]==True and bdm_bid.markerPlacedAt==2.99:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt + 0.01\u000a                    bdm_bid.draw()\u000a                    \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in bdmComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "bdm"-------\u000a    for thisComponent in bdmComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # store data for bdm (TrialHandler)\u000a    bdm_loop1.addData('bdm_bid1.response', bdm_bid.getRating())\u000a    bdm_loop1.addData('bdm_bid1.rt', bdm_bid.getRT())\u000a    bdm_loop1.addData('bdm_marker_start', bdm_marker_start)\u000a\u000a    # Add the item and the subject's bid to the 'bids' list, which will be merged with the 'prefs' list later in order to run the auction\u000a    bids.append([bdm_img, bdm_bid.response])\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeat of 'bdm_loop1'\u000a\u000a\u000a#------Prepare to start Routine "instr_choice"-------\u000at = 0\u000ainstr_choiceClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_choice_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_choice_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_choiceComponents = []\u000ainstr_choiceComponents.append(instr_choice_txt)\u000ainstr_choiceComponents.append(instr_choice_resp)\u000afor thisComponent in instr_choiceComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_choice"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_choiceClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_choice_txt* updates\u000a    if t >= 0.0 and instr_choice_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_choice_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_choice_txt.frameNStart = frameN  # exact frame index\u000a        instr_choice_txt.setAutoDraw(True)\u000a    \u000a    # *instr_choice_resp* updates\u000a    if t >= 2.0 and instr_choice_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_choice_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_choice_resp.frameNStart = frameN  # exact frame index\u000a        instr_choice_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_choice_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_choice_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space', 's'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_choice_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_choice_resp.rt = instr_choice_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_choiceComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_choice"-------\u000afor thisComponent in instr_choiceComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_choice_resp.keys in ['', [], None]:  # No response was made\u000a   instr_choice_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_choice_resp.keys',instr_choice_resp.keys)\u000aif instr_choice_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_choice_resp.rt', instr_choice_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## BINARY LOOP ##########################\u000a\u000a# set up handler to look after randomisation of conditions etc\u000abinary = data.TrialHandler(nReps=1, method=u'sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(filename+'_choicecond.csv'),\u000a    seed=None, name='binary')\u000athisExp.addLoop(binary)  # add the loop to the experiment\u000athisBinary1 = binary.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBinary1.rgb)\u000aif thisBinary1 != None:\u000a    for paramName in thisBinary1.keys():\u000a        exec(paramName + '= thisBinary1.' + paramName)\u000a\u000a# Check if the 'skip' key was pressed in the instructions routine; if so, end the loop and move on to the BDM\u000aif instr_choice_resp.keys=='s':\u000a    binary.finished = True\u000a\u000afor thisBinary1 in binary:\u000a    currentLoop = binary\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBinary1.rgb)\u000a    if thisBinary1 != None:\u000a        for paramName in thisBinary1.keys():\u000a            exec(paramName + '= thisBinary1.' + paramName)\u000a    \u000a    #------Prepare to start Routine "choice"-------\u000a    t = 0\u000a    choiceClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    choice_pic_left.setImage(dir_path+choice_left)\u000a    choice_pic_right.setImage(dir_path+choice_right)\u000a    event.clearEvents(eventType='keyboard') # Clear keyboard event log to avoid last key press from prior loop being used\u000a    key_resp_choice = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_choice.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    choiceComponents = []\u000a    choiceComponents.append(fixation_text)\u000a    choiceComponents.append(choice_pic_left)\u000a    choiceComponents.append(choice_pic_right)\u000a    choiceComponents.append(key_resp_choice)\u000a    for thisComponent in choiceComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    \u000a    #-------Start Routine "choice"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = choiceClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation_text* updates\u000a        if t >= 0 and fixation_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation_text.tStart = t  # underestimates by a little under one frame\u000a            fixation_text.frameNStart = frameN  # exact frame index\u000a            fixation_text.setAutoDraw(True)\u000a        elif fixation_text.status == STARTED and t>= (0 + (1.0-win.monitorFramePeriod*0.75)):\u000a            fixation_text.setAutoDraw(False)\u000a\u000a        # *choice_pic_left* updates\u000a        if t >= 1.0 and choice_pic_left.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_left.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_left.frameNStart = frameN  # exact frame index\u000a            choice_pic_left.setAutoDraw(True)\u000a        \u000a        # *choice_pic_right* updates\u000a        if t >= 1.0 and choice_pic_right.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_right.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_right.frameNStart = frameN  # exact frame index\u000a            choice_pic_right.setAutoDraw(True)\u000a\u000a        # *key_resp_choice* updates\u000a        if t >= 1.0 and key_resp_choice.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_choice.tStart = t  # underestimates by a little under one frame\u000a            key_resp_choice.frameNStart = frameN  # exact frame index\u000a            key_resp_choice.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_choice.clock.reset()  # now t=0\u000a        if key_resp_choice.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_choice.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_choice.rt = key_resp_choice.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in choiceComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "choice"-------\u000a    for thisComponent in choiceComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_choice.keys in ['', [], None]:  # No response was made\u000a       key_resp_choice.keys=None\u000a    # store data for binary (TrialHandler)\u000a    binary.addData('key_resp_choice.keys',key_resp_choice.keys)\u000a    if key_resp_choice.keys != None:  # we had a response\u000a        binary.addData('key_resp_choice.rt', key_resp_choice.rt)\u000a\u000a    # define a function to append binary choices and the bid for the chosen item to the preference list\u000a    # lft is the left image displayed during that choice trial\u000a    # rt is the right image displayed\u000a    def rec_choice(lft, rt): \u000a        bd = False\u000a        if key_resp_choice.keys=='left':\u000a            chc = lft\u000a        elif key_resp_choice.keys=='right':\u000a            chc = rt\u000a        for x in range(len(bids)):\u000a            if bids[x][0]==chc:\u000a                bd = bids[x][1]\u000a        prefs.append([lft, rt, chc, bd])\u000a\u000a    # call the function\u000a    rec_choice(choice_left, choice_right)\u000a    \u000a\u000a    #------Prepare to start Routine "choice_selection"-------\u000a    t = 0\u000a    choice_selectionClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # keep track of which components have finished\u000a    choice_selectionComponents = []\u000a    choice_selectionComponents.append(choice_pic_left)\u000a    choice_selectionComponents.append(choice_pic_right)\u000a    choice_selectionComponents.append(star_left_selection)\u000a    choice_selectionComponents.append(star_right_selection)\u000a    for thisComponent in choice_selectionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "choice_selection"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = choice_selectionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *choice_pic_left* updates\u000a        if t >= 0.0 and choice_pic_left.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_left.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_left.frameNStart = frameN  # exact frame index\u000a            choice_pic_left.setAutoDraw(True)\u000a        elif choice_pic_left.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            choice_pic_left.setAutoDraw(False)\u000a        \u000a        # *choice_pic_right* updates\u000a        if t >= 0.0 and choice_pic_right.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_right.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_right.frameNStart = frameN  # exact frame index\u000a            choice_pic_right.setAutoDraw(True)\u000a        elif choice_pic_right.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            choice_pic_right.setAutoDraw(False)\u000a        \u000a        # *star_left_selection* updates\u000a        if key_resp_choice.keys=='left':\u000a            if t >= 0.0 and star_left_selection.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                star_left_selection.tStart = t  # underestimates by a little under one frame\u000a                star_left_selection.frameNStart = frameN  # exact frame index\u000a                star_left_selection.setAutoDraw(True)\u000a            elif star_left_selection.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                star_left_selection.setAutoDraw(False)\u000a        \u000a        # *star_right_selection* updates\u000a        if key_resp_choice.keys=='right':\u000a            if t >= 0.0 and star_right_selection.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                star_right_selection.tStart = t  # underestimates by a little under one frame\u000a                star_right_selection.frameNStart = frameN  # exact frame index\u000a                star_right_selection.setAutoDraw(True)\u000a            elif star_right_selection.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                star_right_selection.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in choice_selectionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "choice_selection"-------\u000a    for thisComponent in choice_selectionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    #thisExp.nextEntry()\u000a\u000a    #------Prepare to start Routine "confidence"-------\u000a    t = 0\u000a    confidenceClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    confidence_rating.reset()\u000a    # jitter the starting position of the confidence rating scale from a uniform distribution between 1.7 and 3.3 (the middle third of the scale), rounded to the nearest decimal place\u000a    confidence_marker_start = float(np.round(np.random.uniform(1.7, 3.3, 1)[0], 1))\u000a    confidence_rating.setMarkerPos(confidence_marker_start)\u000a    # keep track of which components have finished\u000a    confidenceComponents = []\u000a    confidenceComponents.append(confidence_rating)\u000a    for thisComponent in confidenceComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "confidence"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = confidenceClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *confidence_rating* updates\u000a        if t > 0.5:\u000a            confidence_rating.draw()\u000a            continueRoutine = confidence_rating.noResponse\u000a            if confidence_rating.noResponse == False:\u000a                confidence_rating.response = confidence_rating.getRating()\u000a                confidence_rating.rt = confidence_rating.getRT()\u000a            elif confidence_rating.noResponse==True:\u000a                if keyState[key.LEFT]==True and confidence_rating.markerPlacedAt >0:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt - 0.1\u000a                    confidence_rating.draw()\u000a                elif keyState[key.LEFT]==True and confidence_rating.markerPlacedAt==0.1:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt - 0.1\u000a                    confidence_rating.draw()\u000a                elif keyState[key.RIGHT]==True and confidence_rating.markerPlacedAt <4.9:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt + 0.1\u000a                    confidence_rating.draw()\u000a                elif keyState[key.RIGHT]==True and confidence_rating.markerPlacedAt==4.9:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt + 0.1\u000a                    confidence_rating.draw()\u000a                    \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in confidenceComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "confidence"-------\u000a    for thisComponent in confidenceComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # store data for confidence (TrialHandler)\u000a    binary.addData('confidence_rating1.response', confidence_rating.getRating())\u000a    binary.addData('confidence_rating1.rt', confidence_rating.getRT())\u000a    binary.addData('confidence_marker_start', confidence_marker_start+1) # Add 1 to convert from 0-5 to 1-6 scale\u000a\u000a    thisExp.nextEntry()\u000a\u000a\u000a# completed 1 repeat of 'binary'        \u000a\u000a#------Prepare to start Routine "instr_infer_intro"-------\u000at = 0\u000ainstr_infer_introClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_infer_intro_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_infer_intro_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_infer_introComponents = []\u000ainstr_infer_introComponents.append(instr_infer_intro_txt)\u000ainstr_infer_introComponents.append(instr_infer_intro_resp)\u000afor thisComponent in instr_infer_introComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_infer_intro"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_infer_introClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_infer_intro_txt* updates\u000a    if t >= 0.0 and instr_infer_intro_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_intro_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_intro_txt.frameNStart = frameN  # exact frame index\u000a        instr_infer_intro_txt.setAutoDraw(True)\u000a    \u000a    # *instr_infer_intro_resp* updates\u000a    if t >= 5.0 and instr_infer_intro_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_intro_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_intro_resp.frameNStart = frameN  # exact frame index\u000a        instr_infer_intro_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_infer_intro_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_infer_intro_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_infer_intro_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_infer_intro_resp.rt = instr_infer_intro_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_infer_introComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_infer_intro"-------\u000afor thisComponent in instr_infer_introComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_infer_intro_resp.keys in ['', [], None]:  # No response was made\u000a   instr_infer_intro_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_infer_intro_resp.keys',instr_infer_intro_resp.keys)\u000aif instr_infer_intro_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_infer_intro_resp.rt', instr_infer_intro_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a#------Prepare to start Routine "instr_infer_practice"-------\u000at = 0\u000ainstr_infer_practiceClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_infer_practice_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_infer_practice_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_infer_practiceComponents = []\u000ainstr_infer_practiceComponents.append(instr_infer_practice_txt)\u000ainstr_infer_practiceComponents.append(instr_infer_practice_resp)\u000afor thisComponent in instr_infer_practiceComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_infer_practice"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_infer_practiceClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_infer_practice_txt* updates\u000a    if t >= 0.0 and instr_infer_practice_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_practice_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_practice_txt.frameNStart = frameN  # exact frame index\u000a        instr_infer_practice_txt.setAutoDraw(True)\u000a    \u000a    # *instr_infer_practice_resp* updates\u000a    if t >= 5.0 and instr_infer_practice_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_practice_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_practice_resp.frameNStart = frameN  # exact frame index\u000a        instr_infer_practice_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_infer_practice_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_infer_practice_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_infer_practice_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_infer_practice_resp.rt = instr_infer_practice_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_infer_practiceComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_infer_practice"-------\u000afor thisComponent in instr_infer_practiceComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_infer_practice_resp.keys in ['', [], None]:  # No response was made\u000a   instr_infer_practice_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_infer_practice_resp.keys',instr_infer_practice_resp.keys)\u000aif instr_infer_practice_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_infer_practice_resp.rt', instr_infer_practice_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## PRACTICE LOOP ##########################\u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_loop = data.TrialHandler(nReps=1, method=u'sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(filename+'_practicecond.csv'),\u000a    seed=None, name='practice_loop')\u000athisExp.addLoop(practice_loop)  # add the loop to the experiment\u000athisPractice_loop = practice_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_loop.rgb)\u000aif thisPractice_loop != None:\u000a    for paramName in thisPractice_loop.keys():\u000a        exec(paramName + '= thisPractice_loop.' + paramName)\u000a\u000a  \u000afor thisPractice_loop in practice_loop:\u000a    currentLoop = practice_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_loop.rgb)\u000a    if thisPractice_loop != None:\u000a        for paramName in thisPractice_loop.keys():\u000a            exec(paramName + '= thisPractice_loop.' + paramName)    \u000a    \u000a        \u000a    # Define class for setting the feedback image\u000a    class set_feedback:\u000a        options = ['correct', 'wrong']\u000a        feedback = np.random.choice(options, replace=True, p=[0.8, 0.2])\u000a        if feedback=='correct':\u000a            feedback_img = img_correct\u000a        elif feedback=='wrong':\u000a            feedback_img = img_wrong\u000a\u000a        if feedback_img==img_left:\u000a            feedback_side = 'left'\u000a        elif feedback_img==img_right:\u000a            feedback_side = 'right'\u000a\u000a\u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialtime = datetime.datetime.now()\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    img_left_infer.setImage(dir_path+img_left)\u000a    img_right_infer.setImage(dir_path+img_right)\u000a    infer_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    infer_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(fixation_text)\u000a    trialComponents.append(img_left_infer)\u000a    trialComponents.append(img_right_infer)\u000a    trialComponents.append(infer_resp)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation_text* updates\u000a        if t >= 0 and fixation_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation_text.tStart = t  # underestimates by a little under one frame\u000a            fixation_text.frameNStart = frameN  # exact frame index\u000a            fixation_text.setAutoDraw(True)\u000a        elif fixation_text.status == STARTED and t>= (0 + (2.0-win.monitorFramePeriod*0.75)):\u000a            fixation_text.setAutoDraw(False)\u000a\u000a        # *img_left_infer* updates\u000a        if t >= 2.0 and img_left_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_left_infer.tStart = t  # underestimates by a little under one frame\u000a            img_left_infer.frameNStart = frameN  # exact frame index\u000a            img_left_infer.setAutoDraw(True)\u000a        \u000a        # *img_right_infer* updates\u000a        if t >= 2.0 and img_right_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_right_infer.tStart = t  # underestimates by a little under one frame\u000a            img_right_infer.frameNStart = frameN  # exact frame index\u000a            img_right_infer.setAutoDraw(True)\u000a                  \u000a        # *infer_resp* updates\u000a        if t >= 2.0 and infer_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            infer_resp.tStart = t  # underestimates by a little under one frame\u000a            infer_resp.frameNStart = frameN  # exact frame index\u000a            infer_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            infer_resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if infer_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                infer_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                infer_resp.rt = infer_resp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a\u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if infer_resp.keys in ['', [], None]:  # No response was made\u000a       infer_resp.keys=None\u000a    # # store data for practice_loop (TrialHandler)\u000a    # practice_loop.addData('infer_resp.keys',infer_resp.keys)\u000a    # if infer_resp.keys != None:  # we had a response\u000a    #     practice_loop.addData('infer_resp.rt', infer_resp.rt)\u000a    practice_loop.addData('set_feedback.feedback_img', set_feedback.feedback_img)\u000a    practice_loop.addData('trial_start_time', trialtime)\u000a    \u000a    # # Increase correct and incorrect response counters by 1 based on S's response\u000a    # if infer_resp.keys=='left' and img_correct==img_left:\u000a    #     correct_counter += 1\u000a    # elif infer_resp.keys=='left' and img_correct==img_right:\u000a    #     incorrect_counter += 1\u000a    # elif infer_resp.keys=='right' and img_correct==img_right:\u000a    #     correct_counter += 1\u000a    # elif infer_resp.keys=='right' and img_correct==img_left:\u000a    #     incorrect_counter += 1\u000a    \u000a\u000a    #------Prepare to start Routine "trial_post_response"-------\u000a    t = 0\u000a    trial_post_responseClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(3.000000)\u000a    # keep track of which components have finished\u000a    trial_post_responseComponents = []\u000a    trial_post_responseComponents.append(img_left_infer)\u000a    trial_post_responseComponents.append(img_right_infer)\u000a    trial_post_responseComponents.append(selection_arrow_left)\u000a    trial_post_responseComponents.append(selection_arrow_right)\u000a    trial_post_responseComponents.append(feedback_box_left)\u000a    trial_post_responseComponents.append(feedback_box_right)\u000a    for thisComponent in trial_post_responseComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial_post_response"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = trial_post_responseClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a\u000a        # *img_left_infer* updates\u000a        if t >= 0.0 and img_left_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_left_infer.tStart = t  # underestimates by a little under one frame\u000a            img_left_infer.frameNStart = frameN  # exact frame index\u000a            img_left_infer.setAutoDraw(True)\u000a        elif img_left_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            img_left_infer.setAutoDraw(False)\u000a        \u000a        # *img_right_infer* updates\u000a        if t >= 0.0 and img_right_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_right_infer.tStart = t  # underestimates by a little under one frame\u000a            img_right_infer.frameNStart = frameN  # exact frame index\u000a            img_right_infer.setAutoDraw(True)\u000a        elif img_right_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            img_right_infer.setAutoDraw(False)\u000a        \u000a        if infer_resp.keys == 'left':\u000a            # *selection_arrow_left* updates\u000a            if t >= 0.0 and selection_arrow_left.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                selection_arrow_left.tStart = t  # underestimates by a little under one frame\u000a                selection_arrow_left.frameNStart = frameN  # exact frame index\u000a                selection_arrow_left.setAutoDraw(True)\u000a            elif selection_arrow_left.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                selection_arrow_left.setAutoDraw(False)\u000a        \u000a        if infer_resp.keys == 'right':\u000a            # *selection_arrow_right* updates\u000a            if t >= 0.0 and selection_arrow_right.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                selection_arrow_right.tStart = t  # underestimates by a little under one frame\u000a                selection_arrow_right.frameNStart = frameN  # exact frame index\u000a                selection_arrow_right.setAutoDraw(True)\u000a            elif selection_arrow_right.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                selection_arrow_right.setAutoDraw(False)\u000a        \u000a        if set_feedback.feedback_side == 'left':\u000a            # *feedback_box_left* updates\u000a            if t >= 1.0 and feedback_box_left.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                feedback_box_left.tStart = t  # underestimates by a little under one frame\u000a                feedback_box_left.frameNStart = frameN  # exact frame index\u000a                feedback_box_left.setAutoDraw(True)\u000a            elif feedback_box_left.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                feedback_box_left.setAutoDraw(False)\u000a        \u000a        if set_feedback.feedback_side == 'right':\u000a            # *feedback_box_right* updates\u000a            if t >= 1.0 and feedback_box_right.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                feedback_box_right.tStart = t  # underestimates by a little under one frame\u000a                feedback_box_right.frameNStart = frameN  # exact frame index\u000a                feedback_box_right.setAutoDraw(True)\u000a            elif feedback_box_right.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period right\u000a                feedback_box_right.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trial_post_responseComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "trial_post_response"-------\u000a    for thisComponent in trial_post_responseComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000a    \u000a    thisExp.nextEntry()\u000a                        \u000a# completed 1 repeat of 'practice_loop'\u000a\u000a\u000a#------Prepare to start Routine "instr_infer"-------\u000at = 0\u000ainstr_inferClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_infer_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_infer_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_inferComponents = []\u000ainstr_inferComponents.append(instr_infer_txt)\u000ainstr_inferComponents.append(instr_infer_resp)\u000afor thisComponent in instr_inferComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_infer"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_inferClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_infer_txt* updates\u000a    if t >= 0.0 and instr_infer_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_txt.frameNStart = frameN  # exact frame index\u000a        instr_infer_txt.setAutoDraw(True)\u000a    \u000a    # *instr_infer_resp* updates\u000a    if t >= 5.0 and instr_infer_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_resp.frameNStart = frameN  # exact frame index\u000a        instr_infer_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_infer_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_infer_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_infer_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_infer_resp.rt = instr_infer_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_inferComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_infer"-------\u000afor thisComponent in instr_inferComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_infer_resp.keys in ['', [], None]:  # No response was made\u000a   instr_infer_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_infer_resp.keys',instr_infer_resp.keys)\u000aif instr_infer_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_infer_resp.rt', instr_infer_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## BLOCK LOOP ##########################\u000a\u000a# This loop runs a second nested loop that shows each item pair 10 times, followed by a rest break prompt.\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=3, method=u'sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=[None],\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000a# Set up counter to keep track of block loop cycle, so that the rest prompt is only shown twice\u000ablock_loop_counter = 0\u000a\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    # Increase loop counter by one\u000a    block_loop_counter += 1\u000a    \u000a    # Change the condition file for the feedback block based on which block loop we're on\u000a    condfilename = filename+u'_block'+str(block_loop_counter)+u'cond.csv'\u000a    \u000a    # Minimize the psychopy window so the calibration window can be seen\u000a    win.winHandle.minimize()\u000a    #Do the eye tracker setup at the beginning of each block\u000a    tracker.runSetupProcedure()\u000a    # Re-display the psychopy window after setup is completed\u000a    win.winHandle.maximize()\u000a    win.winHandle.activate()\u000a    \u000a\u000a    \u000a    #------Prepare to start Routine "get_ready"-------\u000a    t = 0\u000a    get_readyClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(3.000000)\u000a    # update component parameters for each repeat\u000a    get_ready_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    get_ready_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    get_readyComponents = []\u000a    get_readyComponents.append(get_ready_text)\u000a    get_readyComponents.append(get_ready_resp)\u000a    for thisComponent in get_readyComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    \u000a    #-------Start Routine "get_ready"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = get_readyClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *get_ready_text* updates\u000a        if t >= 0.0 and get_ready_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            get_ready_text.tStart = t  # underestimates by a little under one frame\u000a            get_ready_text.frameNStart = frameN  # exact frame index\u000a            get_ready_text.setAutoDraw(True)\u000a        \u000a        # *get_ready_resp* updates\u000a        if t >= 0.0 and get_ready_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            get_ready_resp.tStart = t  # underestimates by a little under one frame\u000a            get_ready_resp.frameNStart = frameN  # exact frame index\u000a            get_ready_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            get_ready_resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if get_ready_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['p'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                get_ready_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                get_ready_resp.rt = get_ready_resp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in get_readyComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "get_ready"-------\u000a    for thisComponent in get_readyComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if get_ready_resp.keys in ['', [], None]:  # No response was made\u000a       get_ready_resp.keys=None\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('get_ready_resp.keys',get_ready_resp.keys)\u000a    if get_ready_resp.keys != None:  # we had a response\u000a        thisExp.addData('get_ready_resp.rt', get_ready_resp.rt)\u000a    thisExp.nextEntry()\u000a\u000a    ######################## TRIAL LOOP ##########################\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    trial_loop = data.TrialHandler(nReps=1, method=u'sequential', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(condfilename),\u000a        seed=None, name='trial_loop')\u000a    thisExp.addLoop(trial_loop)  # add the loop to the experiment\u000a    thisTrial_loop = trial_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_loop.rgb)\u000a    if thisTrial_loop != None:\u000a        for paramName in thisTrial_loop.keys():\u000a            exec(paramName + '= thisTrial_loop.' + paramName)\u000a    \u000a      \u000a    for thisTrial_loop in trial_loop:\u000a        currentLoop = trial_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_loop.rgb)\u000a        if thisTrial_loop != None:\u000a            for paramName in thisTrial_loop.keys():\u000a                exec(paramName + '= thisTrial_loop.' + paramName)    \u000a        \u000a            \u000a        # Define class for setting the feedback image\u000a        class set_feedback:\u000a            options = ['correct', 'wrong']\u000a            feedback = np.random.choice(options, replace=True, p=[0.8, 0.2])\u000a            if feedback=='correct':\u000a                feedback_img = img_correct\u000a            elif feedback=='wrong':\u000a                feedback_img = img_wrong\u000a\u000a            if feedback_img==img_left:\u000a                feedback_side = 'left'\u000a            elif feedback_img==img_right:\u000a                feedback_side = 'right'\u000a                        \u000a        # Start getting data from the eye tracker\u000a        tracker.enableEventReporting(True)\u000a        # Send beginning-of-trial messages to eye tracker data file\u000a        trial_number = (block_loop.thisN * 200) + trial_loop.thisTrialN # Trial number out of 599 (starts at 0)\u000a        tracker.sendCommand("record_status_message 'INFERRING, Block %d/3, Trial %d/600 '" % (block_loop.thisN + 1, trial_number + 1))\u000a        tracker.sendMessage("TRIALID %d" % trial_number)\u000a        tracker.sendMessage("!V TRIAL_VAR_DATA %d" % trial_number)\u000a\u000a        \u000a        #------Prepare to start Routine "trial"-------\u000a        t = 0\u000a        trialtime = datetime.datetime.now()\u000a        trialClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        img_left_infer.setImage(dir_path+img_left)\u000a        img_right_infer.setImage(dir_path+img_right)\u000a        infer_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        infer_resp.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trialComponents = []\u000a        trialComponents.append(fixation_text)\u000a        trialComponents.append(img_left_infer)\u000a        trialComponents.append(img_right_infer)\u000a        trialComponents.append(infer_resp)\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        # Set indicator variable for whether eye tracker messages were sent during the first loop of the routine\u000a        eye_sync_messages_sent = 0\u000a        \u000a        #-------Start Routine "trial"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = trialClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *fixation_text* updates\u000a            if t >= 0 and fixation_text.status == NOT_STARTED:\u000a                if eye_sync_messages_sent==0:\u000a                    startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                # keep track of start time/frame for later\u000a                fixation_text.tStart = t  # underestimates by a little under one frame\u000a                fixation_text.frameNStart = frameN  # exact frame index\u000a                fixation_text.setAutoDraw(True)\u000a                if eye_sync_messages_sent==0:\u000a                    drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                    tracker.sendMessage("%d DISPLAY ON" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                    tracker.sendMessage("SYNCTIME %d" %drawTime)\u000a                    eye_sync_messages_sent = 1\u000a            elif fixation_text.status == STARTED and t>= (0 + (2.0-win.monitorFramePeriod*0.75)):\u000a                fixation_text.setAutoDraw(False)\u000a            \u000a            # *img_left_infer* updates\u000a            if t >= 2.0 and img_left_infer.status == NOT_STARTED:\u000a                if eye_sync_messages_sent==1:\u000a                    startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                # keep track of start time/frame for later\u000a                img_left_infer.tStart = t  # underestimates by a little under one frame\u000a                img_left_infer.frameNStart = frameN  # exact frame index\u000a                img_left_infer.setAutoDraw(True)\u000a            \u000a            # *img_right_infer* updates\u000a            if t >= 2.0 and img_right_infer.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                img_right_infer.tStart = t  # underestimates by a little under one frame\u000a                img_right_infer.frameNStart = frameN  # exact frame index\u000a                img_right_infer.setAutoDraw(True)\u000a                if eye_sync_messages_sent==1:\u000a                    drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                    tracker.sendMessage("%d DISPLAY ON ITEMS" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                    eye_sync_messages_sent = 2\u000a                      \u000a            # *infer_resp* updates\u000a            if t >= 2.0 and infer_resp.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                infer_resp.tStart = t  # underestimates by a little under one frame\u000a                infer_resp.frameNStart = frameN  # exact frame index\u000a                infer_resp.status = STARTED\u000a                # keyboard checking is just starting\u000a                infer_resp.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            if infer_resp.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['left', 'right'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    infer_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                    infer_resp.rt = infer_resp.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trialComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                tracker.enableEventReporting(False) # End eye tracker data recording\u000a                tracker.sendMessage("EXPERIMENT ABORTED")\u000a                io.quit() # Close iohub\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial"-------\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if infer_resp.keys in ['', [], None]:  # No response was made\u000a           infer_resp.keys=None\u000a        # store data for trial_loop (TrialHandler)\u000a        trial_loop.addData('infer_resp.keys',infer_resp.keys)\u000a        if infer_resp.keys != None:  # we had a response\u000a            trial_loop.addData('infer_resp.rt', infer_resp.rt)\u000a        trial_loop.addData('set_feedback.feedback_img', set_feedback.feedback_img)\u000a        trial_loop.addData('trial_start_time', trialtime)\u000a        \u000a        # Increase correct and incorrect response counters by 1 based on S's response\u000a        if infer_resp.keys=='left' and img_correct==img_left:\u000a            correct_counter += 1\u000a        elif infer_resp.keys=='left' and img_correct==img_right:\u000a            incorrect_counter += 1\u000a        elif infer_resp.keys=='right' and img_correct==img_right:\u000a            correct_counter += 1\u000a        elif infer_resp.keys=='right' and img_correct==img_left:\u000a            incorrect_counter += 1\u000a        \u000a\u000a        #------Prepare to start Routine "trial_post_response"-------\u000a        t = 0\u000a        trial_post_responseClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(3.000000)\u000a        # keep track of which components have finished\u000a        trial_post_responseComponents = []\u000a        trial_post_responseComponents.append(img_left_infer)\u000a        trial_post_responseComponents.append(img_right_infer)\u000a        trial_post_responseComponents.append(selection_arrow_left)\u000a        trial_post_responseComponents.append(selection_arrow_right)\u000a        trial_post_responseComponents.append(feedback_box_left)\u000a        trial_post_responseComponents.append(feedback_box_right)\u000a        for thisComponent in trial_post_responseComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        # Set indicator variable for whether eye tracker messages were sent during the first loop of the routine\u000a        eye_sync_messages_sent = 0\u000a\u000a        #-------Start Routine "trial_post_response"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = trial_post_responseClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a\u000a            # *img_left_infer* updates\u000a            if t >= 0.0 and img_left_infer.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                img_left_infer.tStart = t  # underestimates by a little under one frame\u000a                img_left_infer.frameNStart = frameN  # exact frame index\u000a                img_left_infer.setAutoDraw(True)\u000a            elif img_left_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                img_left_infer.setAutoDraw(False)\u000a            \u000a            # *img_right_infer* updates\u000a            if t >= 0.0 and img_right_infer.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                img_right_infer.tStart = t  # underestimates by a little under one frame\u000a                img_right_infer.frameNStart = frameN  # exact frame index\u000a                img_right_infer.setAutoDraw(True)\u000a            elif img_right_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                img_right_infer.setAutoDraw(False)\u000a            \u000a            if infer_resp.keys == 'left':\u000a                # *selection_arrow_left* updates\u000a                if t >= 0.0 and selection_arrow_left.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==0:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    selection_arrow_left.tStart = t  # underestimates by a little under one frame\u000a                    selection_arrow_left.frameNStart = frameN  # exact frame index\u000a                    selection_arrow_left.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==0:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        tracker.sendMessage("%d DISPLAY ON SELECTION" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 1\u000a                elif selection_arrow_left.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    if eye_sync_messages_sent==1:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    selection_arrow_left.setAutoDraw(False)\u000a                    if eye_sync_messages_sent==1:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        tracker.sendMessage("%d DISPLAY ON SELECTION OFF" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 2\u000a            \u000a            if infer_resp.keys == 'right':\u000a                # *selection_arrow_right* updates\u000a                if t >= 0.0 and selection_arrow_right.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==0:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    selection_arrow_right.tStart = t  # underestimates by a little under one frame\u000a                    selection_arrow_right.frameNStart = frameN  # exact frame index\u000a                    selection_arrow_right.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==0:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        tracker.sendMessage("%d DISPLAY ON SELECTION" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 1\u000a                elif selection_arrow_right.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    if eye_sync_messages_sent==1:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    selection_arrow_right.setAutoDraw(False)\u000a                    if eye_sync_messages_sent==1:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        tracker.sendMessage("%d DISPLAY ON SELECTION OFF" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 2\u000a            \u000a            if set_feedback.feedback_side == 'left':\u000a                # *feedback_box_left* updates\u000a                if t >= 1.0 and feedback_box_left.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==2:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    feedback_box_left.tStart = t  # underestimates by a little under one frame\u000a                    feedback_box_left.frameNStart = frameN  # exact frame index\u000a                    feedback_box_left.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==2:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        tracker.sendMessage("%d DISPLAY ON FEEDBACK" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 3\u000a                elif feedback_box_left.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    feedback_box_left.setAutoDraw(False)\u000a            \u000a            if set_feedback.feedback_side == 'right':\u000a                # *feedback_box_right* updates\u000a                if t >= 1.0 and feedback_box_right.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==2:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    feedback_box_right.tStart = t  # underestimates by a little under one frame\u000a                    feedback_box_right.frameNStart = frameN  # exact frame index\u000a                    feedback_box_right.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==2:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        tracker.sendMessage("%d DISPLAY ON FEEDBACK" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 3\u000a                elif feedback_box_right.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period right\u000a                    feedback_box_right.setAutoDraw(False)\u000a\u000a\u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial_post_responseComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                tracker.enableEventReporting(False) # End eye tracker data recording\u000a                tracker.sendMessage("EXPERIMENT ABORTED")\u000a                io.quit() # Close iohub\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "trial_post_response"-------\u000a        for thisComponent in trial_post_responseComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a        thisExp.nextEntry()\u000a                            \u000a    # completed 5 repeats of 'trial_loop'\u000a    \u000a    if block_loop_counter <= 2: # If this is the first or second cycle of the loop, display the rest break prompt\u000a\u000a        #------Prepare to start Routine "rest_prompt"-------\u000a        t = 0\u000a        rest_promptClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        rest_prompt_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        rest_prompt_resp.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        rest_promptComponents = []\u000a        rest_promptComponents.append(rest_prompt_txt)\u000a        rest_promptComponents.append(rest_prompt_resp)\u000a        for thisComponent in rest_promptComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a\u000a        #-------Start Routine "rest_prompt"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = rest_promptClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *rest_prompt_txt* updates\u000a            if t >= 0.0 and rest_prompt_txt.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                rest_prompt_txt.tStart = t  # underestimates by a little under one frame\u000a                rest_prompt_txt.frameNStart = frameN  # exact frame index\u000a                rest_prompt_txt.setAutoDraw(True)\u000a            \u000a            # *rest_prompt_resp* updates\u000a            if t >= 2.0 and rest_prompt_resp.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                rest_prompt_resp.tStart = t  # underestimates by a little under one frame\u000a                rest_prompt_resp.frameNStart = frameN  # exact frame index\u000a                rest_prompt_resp.status = STARTED\u000a                # keyboard checking is just starting\u000a                rest_prompt_resp.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            if rest_prompt_resp.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    rest_prompt_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                    rest_prompt_resp.rt = rest_prompt_resp.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in rest_promptComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                tracker.enableEventReporting(False) # End eye tracker data recording\u000a                tracker.sendMessage("EXPERIMENT ABORTED")\u000a                io.quit() # CLose iohub\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a\u000a        #-------Ending Routine "rest_prompt"-------\u000a        for thisComponent in rest_promptComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if rest_prompt_resp.keys in ['', [], None]:  # No response was made\u000a           rest_prompt_resp.keys=None\u000a        # store data for thisExp (ExperimentHandler)\u000a        thisExp.addData('rest_prompt_resp.keys',rest_prompt_resp.keys)\u000a        if rest_prompt_resp.keys != None:  # we had a response\u000a            thisExp.addData('rest_prompt_resp.rt', rest_prompt_resp.rt)\u000a\u000a\u000a    thisExp.nextEntry()\u000a    \u000a# completed 3 repeats of 'block_loop'\u000a\u000a\u000a# store data for total number of correct and incorrect responses    \u000athisExp.addData('correct_counter', correct_counter)\u000athisExp.addData('incorrect_counter', incorrect_counter)\u000athisExp.nextEntry()     \u000a\u000atracker.setConnectionState(False) # Close and transfer eye-tracking data, then close down eye tracker connection\u000a\u000a\u000a######################## AUCTION ##########################\u000a\u000aif len(prefs)==41 and len(bids)==41: # If S completed the entire binary choice and BDM routines, run the auction\u000a\u000a    # run the auction\u000a    class auction:\u000a        rand_itm = randint(1, (len(prefs))) # pick index for S's chosen item from a random choice\u000a        price = float((randint(1, 300)))/100 # assign a price to the item randomly from between 0.01 and 3 pounds\u000a        bid = prefs[rand_itm][3]\u000a        # check if S's bid for that item was above or below the price\u000a        if bid >= price:\u000a            win_item=True\u000a        elif bid < price:\u000a            win_item=False\u000a\u000a        # set text for the auction screen\u000a        if win_item==True:\u000a            auc_res_txt = u'Congratulations! You won the following item at auction. \u005cnThis was your preferred item out of a randomly selected pair from one of the choice tasks.'\u000a            auc_prc_txt = u'Your bid of \u005cxa3' + '{0:.2f}'.format(bid) + u' matched or exceeded the randomly generated price of \u005cxa3' + '{0:.2f}'.format(price) + '.\u005cn\u005cn[Press space bar to continue]'\u000a            cost = price\u000a        elif win_item==False:\u000a            auc_res_txt = u'Sorry, you did not win the following item at auction. \u005cnThis was your preferred item out of a randomly selected pair from one of the choice tasks.'\u000a            auc_prc_txt = u'Your bid of \u005cxa3' + '{0:.2f}'.format(bid) + u' was lower than the randomly generated price of \u005cxa3' + '{0:.2f}'.format(price) + '.\u005cn\u005cn[Press space bar to continue]'\u000a            cost = 0\u000a\u000a        # find the image path of the auction item\u000a        rand_itm_img = prefs[rand_itm][2]\u000a\u000a    # add up each component of S's payment\u000a    class score:\u000a        base = 25\u000a        rwrd = 0.01\u000a        loss = 0\u000a        rwrd_tot = rwrd * correct_counter\u000a        loss_tot = loss * incorrect_counter\u000a        pre_pymt = base + rwrd_tot - loss_tot\u000a        final_pymt = pre_pymt - auction.cost\u000a\u000a        pymt_expl_bdwn = u'\u005cxa3' + '{0:.2f}'.format(base) + u' base payment'+ u'\u005cn+ \u005cxa3' + '{0:.2f}'.format(rwrd_tot) + ' reward for ' + str(correct_counter) + u' correct responses (\u005cxa3' + '{0:.2f}'.format(rwrd) + u' each)' + u'\u005cn- \u005cxa3' + '{0:.2f}'.format(auction.cost) + ' cost of auction item' \u000a        pymt_expl_tot = u'Your total payment is: \u005cxa3' + '{0:.2f}'.format(final_pymt) + '\u005cn\u005cnThank you for participating! Please call the experimenter into the room.'\u000a\u000a\u000a    # Initialize components for Routine "auc_disp"\u000a    auc_dispClock = core.Clock()\u000a    pic_auc_itm = visual.ImageStim(win=win, name='pic_auc_itm',\u000a        image=dir_path+auction.rand_itm_img, mask=None,\u000a        ori=0, pos=[0, 0], size=None,\u000a        color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a        flipHoriz=False, flipVert=False,\u000a        texRes=128, interpolate=False, depth=0.0)\u000a    auc_txt1 = visual.TextStim(win=win, ori=0, name='auc_txt1',\u000a        text=auction.auc_res_txt, font=u'Arial',\u000a        pos=[0, 0.6], height=0.07, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    auc_txt2 = visual.TextStim(win=win, ori=0, name='auc_txt2',\u000a        text=auction.auc_prc_txt, font=u'Arial',\u000a        pos=[0, -0.6], height=0.07, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a\u000a    #------Prepare to start Routine "auc_disp"-------\u000a    t = 0\u000a    auc_dispClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    key_resp_auc_disp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_auc_disp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    auc_dispComponents = []\u000a    auc_dispComponents.append(pic_auc_itm)\u000a    auc_dispComponents.append(auc_txt1)\u000a    auc_dispComponents.append(auc_txt2)\u000a    for thisComponent in auc_dispComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "auc_disp"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = auc_dispClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *pic_auc_itm* updates\u000a        if t >= 0.2 and pic_auc_itm.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            pic_auc_itm.tStart = t  # underestimates by a little under one frame\u000a            pic_auc_itm.frameNStart = frameN  # exact frame index\u000a            pic_auc_itm.setAutoDraw(True)\u000a        \u000a        # *auc_txt1* updates\u000a        if t >= 0.2 and auc_txt1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            auc_txt1.tStart = t  # underestimates by a little under one frame\u000a            auc_txt1.frameNStart = frameN  # exact frame index\u000a            auc_txt1.setAutoDraw(True)\u000a\u000a        # *auc_txt2* updates\u000a        if t >= 0.2 and auc_txt2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            auc_txt2.tStart = t  # underestimates by a little under one frame\u000a            auc_txt2.frameNStart = frameN  # exact frame index\u000a            auc_txt2.setAutoDraw(True)\u000a        \u000a        # *key_resp_auc_disp* updates\u000a        if t >= 0.2 and key_resp_auc_disp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_auc_disp.tStart = t  # underestimates by a little under one frame\u000a            key_resp_auc_disp.frameNStart = frameN  # exact frame index\u000a            key_resp_auc_disp.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_auc_disp.clock.reset()  # now t=0\u000a        if key_resp_auc_disp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_auc_disp.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_auc_disp.rt = key_resp_auc_disp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in auc_dispComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "auc_disp"-------\u000a    for thisComponent in auc_dispComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_auc_disp.keys in ['', [], None]:  # No response was made\u000a       key_resp_auc_disp.keys=None\u000a    # store data for thisExp (TrialHandler)\u000a    thisExp.addData('auction.win_item', auction.win_item)\u000a    thisExp.addData('auction.price', auction.price)\u000a    thisExp.addData('auction.bid', auction.bid)\u000a    thisExp.addData('auction.rand_itm_img', auction.rand_itm_img)\u000a    thisExp.addData('score.base', score.base)\u000a    thisExp.addData('score.rwrd', score.rwrd)\u000a    thisExp.addData('score.loss', score.loss)\u000a    thisExp.addData('correct_counter', correct_counter)\u000a    thisExp.addData('incorrect_counter', incorrect_counter)\u000a    thisExp.addData('score.final_pymt', score.final_pymt)\u000a    thisExp.nextEntry()\u000a\u000a\u000a    # Initialize components for Routine "pymt_disp"\u000a    pymt_dispClock = core.Clock()\u000a    pymt_disp_txt1 = visual.TextStim(win=win, ori=0, name='pymt_disp_txt1',\u000a        text=score.pymt_expl_bdwn, font=u'Arial',\u000a        pos=[0, 0.6], height=0.07, wrapWidth=1.5,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    pymt_disp_txt2 = visual.TextStim(win=win, ori=0, name='pymt_disp_txt2',\u000a        text=score.pymt_expl_tot, font=u'Arial',\u000a        pos=[0, -0.65], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    #------Prepare to start Routine "pymt_disp"-------\u000a    t = 0\u000a    pymt_dispClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    key_resp_pymt_disp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_pymt_disp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    pymt_dispComponents = []\u000a    pymt_dispComponents.append(pic_auc_itm)\u000a    pymt_dispComponents.append(pymt_disp_txt1)\u000a    pymt_dispComponents.append(pymt_disp_txt2)\u000a    pymt_dispComponents.append(key_resp_pymt_disp)\u000a    for thisComponent in pymt_dispComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "pymt_disp"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = pymt_dispClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        if auction.win_item==True:\u000a            # *pic_auc_itm* updates\u000a            if t >= 0.0 and pic_auc_itm.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                pic_auc_itm.tStart = t  # underestimates by a little under one frame\u000a                pic_auc_itm.frameNStart = frameN  # exact frame index\u000a                pic_auc_itm.setAutoDraw(True)\u000a\u000a        # *pymt_disp_txt1* updates\u000a        if t >= 0.0 and pymt_disp_txt1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            pymt_disp_txt1.tStart = t  # underestimates by a little under one frame\u000a            pymt_disp_txt1.frameNStart = frameN  # exact frame index\u000a            pymt_disp_txt1.setAutoDraw(True)\u000a\u000a        # *pymt_disp_txt2* updates\u000a        if t >= 0.0 and pymt_disp_txt2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            pymt_disp_txt2.tStart = t  # underestimates by a little under one frame\u000a            pymt_disp_txt2.frameNStart = frameN  # exact frame index\u000a            pymt_disp_txt2.setAutoDraw(True)\u000a        \u000a        # *key_resp_pymt_disp* updates\u000a        if t >= 3.0 and key_resp_pymt_disp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_pymt_disp.tStart = t  # underestimates by a little under one frame\u000a            key_resp_pymt_disp.frameNStart = frameN  # exact frame index\u000a            key_resp_pymt_disp.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_pymt_disp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if key_resp_pymt_disp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_pymt_disp.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_pymt_disp.rt = key_resp_pymt_disp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in pymt_dispComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "pymt_disp"-------\u000a    for thisComponent in pymt_dispComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_pymt_disp.keys in ['', [], None]:  # No response was made\u000a       key_resp_pymt_disp.keys=None\u000a\u000aelse: # If S didn't complete the entire binary choice and BDM routines during this session, prompt a manual auction\u000a    # Initialize components for Routine "auc_manual"\u000a    auc_manualClock = core.Clock()\u000a    auc_manual_txt = visual.TextStim(win=win, ori=0, name='auc_manual_txt',\u000a        text=u'Thank you! This completes the experiment. Please get the experimenter, who will run the auction and calculate your final payment.\u005cn\u005cnCorrect: ' + str(correct_counter) + '\u005cnIncorrect: ' + str(incorrect_counter),    font=u'Arial',\u000a        pos=[0, 0], height=0.07, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    #------Prepare to start Routine "auc_manual"-------\u000a    t = 0\u000a    auc_manualClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    auc_manualComponents = []\u000a    auc_manualComponents.append(auc_manual_txt)\u000a    for thisComponent in auc_manualComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "auc_manual"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = auc_manualClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *auc_manual_txt* updates\u000a        if t >= 0.0 and auc_manual_txt.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            auc_manual_txt.tStart = t  # underestimates by a little under one frame\u000a            auc_manual_txt.frameNStart = frameN  # exact frame index\u000a            auc_manual_txt.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in auc_manualComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "auc_manual"-------\u000a    for thisComponent in auc_manualComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000athisExp.nextEntry()\u000a\u000aio.quit() # Close iohub\u000a\u000a\u000awin.close()\u000acore.quit()\u000a
p9236
sg9108
(lp9237
sg9110
I84422992
sg10
S'binary'
p9238
sg6
g9112
sg9113
I1
sg52
I01
sg53
g54
sg9114
g1
(g9115
g9116
(dp9239
g26
g9119
(g9120
g93
g9121
S'b'
tRp9240
(I1
(I40
I1
tg9123
I00
S'\x00\x00\xc0@\x9a\x99y@\x00\x00`@33\xa3@33\x93@\x00\x00\x80@\x9a\x99\x19@\x00\x00\xb0@33\xa3@ff\xa6?\x00\x00\x80@\xcd\xcc\x8c?\x00\x00\x80@\xcd\xcc\xac@\x00\x00\xa0@\xcd\xcc\xac@\x00\x00\xc0@\x9a\x99\x99?33\xf3?\x00\x00\x80@\xcd\xcc,@\x00\x00\x80@\x00\x00@@\x00\x00\xc0@\x00\x00\xc0@\x00\x00\xc0@\x00\x00`@\x9a\x99\x99@33S@\x00\x00\x90@\x9a\x99\x99@\x00\x00\xc0@\x00\x00\xc0@\xcd\xcc\x9c@33\xb3?\x00\x00\xc0@33\x93@\x9a\x99\x99@\x00\x00\xb0@\xcd\xcc\x8c@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg9118
g9119
(g9120
g93
g9121
S'b'
tRp9241
(I1
(I40
I1
tg9123
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg25
g9119
(g9120
g93
g9121
S'b'
tRp9242
(I1
(I40
I1
tg9123
I00
S'vx\xb7?j\x0c\x91?\xe0\xad\xca?v|w?9,b?\xde\x01\xa0?p\xb9{@Z\xe2]?O%\xa2?q\xde\x85@\x0c\x8a\x08@j"\x8a@\x80\xe2\xbd?\xe6$\x82?,\xf2??A~7?\xc3\xaa\xaa?\x15mv@\xf0E\xc4?\x02\x02\xa0?Z\xf2\xae?\xdfg\x16@k\xe1\xbd?\xf5\x9c\x99?\xddjf?\xfaT)Ag\x12\xd1?\x8f\x00P@P\xffn?\x7fG\xa4?`I\xc4?\x8bF\x84?\xd34\xb3?\x94\xf0\xce?R43@K\xfd]?1T\xf5?\xb8\x12\x91?\x0b\xad\x8a?\r\xafj?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg28
g9119
(g9120
g93
g9121
S'b'
tRp9243
(I1
(I40
I1
tg9123
I00
S'\xcd\xccl@ffF@\xcd\xccl@\xcd\xccl@\xcd\xccL@ff\x86@\x00\x00@@\x00\x00`@333@\x9a\x999@\x00\x00@@fff@33\x83@ff\x86@\x00\x00@@\x9a\x999@fff@ffF@\x9a\x99Y@\x00\x00@@ffF@33s@\x9a\x99y@fff@\x9a\x99y@33\x83@\x9a\x99\x89@333@\x9a\x99Y@\x9a\x99y@\x9a\x99Y@\x00\x00\x80@\xcd\xccl@\x9a\x999@\x00\x00`@\x9a\x999@\x00\x00@@33S@fff@\x9a\x99y@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg24
g9119
(g9120
g93
g9121
S'b'
tRp9244
(I1
(I40
I1
tg61
(S'O4'
I0
I1
tRp9245
(I3
S'|'
NNNI-1
I-1
I63
tbI00
S'\xe0\xdah\x0c`\xe6\xf5\x0b\xe0\x15\xf4\x0b\x00\x1b\xf4\x0b`\x1b\xf4\x0b\x80\x10\xf4\x0b\xa0\x1a\xf4\x0b@\x11\xf3\x0b  5\x03\x80\x057\x03\xc0 5\x03 "5\x03`\x1a\xf4\x0b\x00!5\x03` 5\x03`\xed\xf5\x0b\x00\xec\xf5\x0b \xec\xf5\x0b\x00\xeb\xf5\x0b\xe0\xe5\xf5\x0b\x80!5\x03 #5\x03\xe0\xeb\xf5\x0b\xa0\xe5\xf5\x0b\x00\xed\xf5\x0b\x80\xe7\xf5\x0b@\xec\xf5\x0b\xa0\x19\xf4\x0b\xe0\xd7h\x0c@\xd4h\x0c\xa0\xdah\x0c@\xdah\x0c`\xdbh\x0c`\xdch\x0c\xa0\xd9h\x0c`\xdah\x0c\x80\xdbh\x0c\x00\xd6h\x0c \xdbh\x0c\xe0\xdbh\x0c'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg27
g9119
(g9120
g93
g9121
S'b'
tRp9246
(I1
(I40
I1
tg9123
I00
S'!\xb0\x92@\xdb\xf9\x1e@\xfe\xd4\xa4@\xa8\xc6\xbb?\xa0\x1a\xef?P\x8d\xf7?\xdb\xf9\xae?/\xdd\x0c@B`\x85@P\x8d\xb7?\x0e-"@\x1dZ\xa4?1\x08\xd8@\xc5 \x80?/\xddL@T\xe3]@\xa8\xc6\x9b?\xb6\xf3\x9d?\xfc\xa9i@/\xdd,@\xfe\xd4\x94@\xfc\xa99@u\x93\x08@\xf0\xa7f?\xe9&\x11?9\xb4\x08?\xc5 \x80?\xa8\xc6K@\x87\x16\x11@^\xba\xb9?\xaa\xf1\xce@#\xdbY?\xf0\xa7&?\xfc\xa9)@\x0e-\xa2?P\x8d7?\x96C\x03@\xe9&Q?P\x8d\xb7?P\x8d\xd7?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg9126
g9119
(g9120
g93
g9121
S'b'
tRp9247
(I1
(I40
I1
tg9123
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00@\x00\x00@@\x00\x00\x80@\x00\x00\xa0@\x00\x00\xc0@\x00\x00\xe0@\x00\x00\x00A\x00\x00\x10A\x00\x00 A\x00\x000A\x00\x00@A\x00\x00PA\x00\x00`A\x00\x00pA\x00\x00\x80A\x00\x00\x88A\x00\x00\x90A\x00\x00\x98A\x00\x00\xa0A\x00\x00\xa8A\x00\x00\xb0A\x00\x00\xb8A\x00\x00\xc0A\x00\x00\xc8A\x00\x00\xd0A\x00\x00\xd8A\x00\x00\xe0A\x00\x00\xe8A\x00\x00\xf0A\x00\x00\xf8A\x00\x00\x00B\x00\x00\x04B\x00\x00\x08B\x00\x00\x0cB\x00\x00\x10B\x00\x00\x14B\x00\x00\x18B\x00\x00\x1cB'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp9248
(dp9249
g9131
(dp9250
g26
I01
sg9118
I01
sg28
I01
sg25
I01
sg24
I00
sg9126
I01
sg27
I01
ssg9133
g9234
sg9134
(lp9251
g9118
ag9126
ag24
ag25
ag26
ag27
ag28
asg9136
(lp9252
I40
aI1
asbsg9138
Vsequential
p9253
sg9140
g92
(g93
(I0
tS'b'
tRp9254
(I1
(I40
I1
tg99
I00
S'\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00\x04\x00\x00\x00\x05\x00\x00\x00\x06\x00\x00\x00\x07\x00\x00\x00\x08\x00\x00\x00\t\x00\x00\x00\n\x00\x00\x00\x0b\x00\x00\x00\x0c\x00\x00\x00\r\x00\x00\x00\x0e\x00\x00\x00\x0f\x00\x00\x00\x10\x00\x00\x00\x11\x00\x00\x00\x12\x00\x00\x00\x13\x00\x00\x00\x14\x00\x00\x00\x15\x00\x00\x00\x16\x00\x00\x00\x17\x00\x00\x00\x18\x00\x00\x00\x19\x00\x00\x00\x1a\x00\x00\x00\x1b\x00\x00\x00\x1c\x00\x00\x00\x1d\x00\x00\x00\x1e\x00\x00\x00\x1f\x00\x00\x00 \x00\x00\x00!\x00\x00\x00"\x00\x00\x00#\x00\x00\x00$\x00\x00\x00%\x00\x00\x00&\x00\x00\x00\'\x00\x00\x00'
tbsg9142
I01
sg9143
I1
sg9144
I-1
sg9145
(lp9255
g1
(g9147
g9116
(dp9256
g80
g381
sg81
g382
stRp9257
ag1
(g9147
g9116
(dp9258
g80
g390
sg81
g391
stRp9259
ag1
(g9147
g9116
(dp9260
g80
g399
sg81
g400
stRp9261
ag1
(g9147
g9116
(dp9262
g80
g408
sg81
g409
stRp9263
ag1
(g9147
g9116
(dp9264
g80
g417
sg81
g418
stRp9265
ag1
(g9147
g9116
(dp9266
g80
g426
sg81
g427
stRp9267
ag1
(g9147
g9116
(dp9268
g80
g435
sg81
g436
stRp9269
ag1
(g9147
g9116
(dp9270
g80
g444
sg81
g445
stRp9271
ag1
(g9147
g9116
(dp9272
g80
g453
sg81
g454
stRp9273
ag1
(g9147
g9116
(dp9274
g80
g462
sg81
g463
stRp9275
ag1
(g9147
g9116
(dp9276
g80
g471
sg81
g472
stRp9277
ag1
(g9147
g9116
(dp9278
g80
g480
sg81
g481
stRp9279
ag1
(g9147
g9116
(dp9280
g80
g489
sg81
g490
stRp9281
ag1
(g9147
g9116
(dp9282
g80
g498
sg81
g499
stRp9283
ag1
(g9147
g9116
(dp9284
g80
g507
sg81
g508
stRp9285
ag1
(g9147
g9116
(dp9286
g80
g516
sg81
g517
stRp9287
ag1
(g9147
g9116
(dp9288
g80
g525
sg81
g526
stRp9289
ag1
(g9147
g9116
(dp9290
g80
g534
sg81
g535
stRp9291
ag1
(g9147
g9116
(dp9292
g80
g543
sg81
g544
stRp9293
ag1
(g9147
g9116
(dp9294
g80
g552
sg81
g553
stRp9295
ag1
(g9147
g9116
(dp9296
g80
g561
sg81
g562
stRp9297
ag1
(g9147
g9116
(dp9298
g80
g570
sg81
g571
stRp9299
ag1
(g9147
g9116
(dp9300
g80
g579
sg81
g580
stRp9301
ag1
(g9147
g9116
(dp9302
g80
g588
sg81
g589
stRp9303
ag1
(g9147
g9116
(dp9304
g80
g597
sg81
g598
stRp9305
ag1
(g9147
g9116
(dp9306
g80
g606
sg81
g607
stRp9307
ag1
(g9147
g9116
(dp9308
g80
g615
sg81
g616
stRp9309
ag1
(g9147
g9116
(dp9310
g80
g624
sg81
g625
stRp9311
ag1
(g9147
g9116
(dp9312
g80
g633
sg81
g634
stRp9313
ag1
(g9147
g9116
(dp9314
g80
g642
sg81
g643
stRp9315
ag1
(g9147
g9116
(dp9316
g80
g651
sg81
g652
stRp9317
ag1
(g9147
g9116
(dp9318
g80
g660
sg81
g661
stRp9319
ag1
(g9147
g9116
(dp9320
g80
g669
sg81
g670
stRp9321
ag1
(g9147
g9116
(dp9322
g80
g678
sg81
g679
stRp9323
ag1
(g9147
g9116
(dp9324
g80
g687
sg81
g688
stRp9325
ag1
(g9147
g9116
(dp9326
g80
g696
sg81
g697
stRp9327
ag1
(g9147
g9116
(dp9328
g80
g705
sg81
g706
stRp9329
ag1
(g9147
g9116
(dp9330
g80
g714
sg81
g715
stRp9331
ag1
(g9147
g9116
(dp9332
g80
g723
sg81
g724
stRp9333
ag1
(g9147
g9116
(dp9334
g80
g732
sg81
g733
stRp9335
asg9228
Nsg9229
g736
sg9230
I40
sg9231
I0
sg9232
I40
sg9233
I01
sbag1
(g9103
g3
NtRp9336
(dp9337
g9106
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a\u000a######################## CITATIONS ########################## \u000a##### Binary choice, BDM, auction routines, and instructions are modified from:\u000a##### \u000a##### De Martino, B., Fleming, S. M., Garrett, N., & Dolan, R. J. (2012). Confidence in value-based choice. Nature Neuroscience, 16(1), 105-110. \u000a#####\u000a##### Food item images are original.\u000a\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.80.01), July 16, 2014, at 03:20\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things bdm STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000afrom pyglet.window import key # to detect key state, whether key is held down, to move slider on key hold\u000aimport pandas as pd\u000aimport datetime\u000afrom psychopy.iohub import launchHubServer\u000aimport pylink\u000a\u000a# Initialize IOHub for eye tracker\u000aio=launchHubServer(iohub_config_name='iohub_config.yaml')\u000atracker = io.devices.tracker\u000a\u000a# Store info about the experiment session\u000aexpName = 'infer_design1'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u'', u'eye': u'', u'glasses': u'', u'contacts': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Setup filename for saving\u000afilename = 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# set up variable to track current state of key press, to move slider when keys held down\u000akeyState=key.KeyStateHandler()\u000a\u000a# Setup the Window\u000ascreenwidth = 1920\u000ascreenheight = 1080\u000awin = visual.Window(size=(screenwidth, screenheight), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color='black', colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000awin.winHandle.push_handlers(keyState)\u000a\u000a\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a\u000a######################## COMPONENTS ##########################\u000a\u000a# Set up directory path for stimuli. This avoids us having to put the entire image path in the conditions spreadsheet.\u000adir_path = 'stimuli/itempics/modified/small/'\u000a\u000a# Initialize components for Routine "instr_main"\u000ainstr_mainClock = core.Clock()\u000ainstr_main_txt = visual.TextStim(win=win, ori=0, name='instr_main_txt',\u000a    text=u'Welcome!\u005cn\u005cnPlease read the instructions carefully and get the experimenter when you\u005c're finished. Take as much time as you need.',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "instr_bdm"\u000ainstr_bdmClock = core.Clock()\u000ainstr_bdm_txt = visual.TextStim(win=win, ori=0, name='instr_bdm_txt',\u000a    text=u'The bidding task is about to begin. Use the LEFT and RIGHT arrow keys to move the cursor along the slider, then press the DOWN arrow to enter your bid.\u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "fixation"\u000afixationClock = core.Clock()\u000afixation_text = visual.TextStim(win=win, ori=0, name='fixation_text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "bdm"\u000abdmClock = core.Clock()\u000abdm_pic = visual.ImageStim(win=win, name='bdm_pic',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=0.0)\u000abdm_bid = visual.RatingScale(win=win, name='bdm_bid', marker=u'triangle', markerColor=u'orange', leftKeys=None, rightKeys=None,\u000a    size=1.0, pos=[0.0, -0.6], low=0, high=3, precision=100, labels=[u'\u005cxa30', u'\u005cxa33'],\u000a    scale=u'', markerStart=u'1.5', tickHeight=u'1', showAccept=False, acceptKeys=[u'down', u'return'])\u000a\u000a# Initialize components for Routine "instr_choice"\u000ainstr_choiceClock = core.Clock()\u000ainstr_choice_txt = visual.TextStim(win=win, ori=0, name='instr_choice_txt',\u000a    text=u'The choice task is about to begin. Choose your preferred item by pressing the LEFT or RIGHT arrow keys, then use the slider to indicate how confident you are that you made the best choice.\u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "choice"\u000achoiceClock = core.Clock()\u000achoice_pic_left = visual.ImageStim(win=win, name='choice_pic_left',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[-0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=0.0)\u000achoice_pic_right = visual.ImageStim(win=win, name='choice_pic_right',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=-1.0)\u000a\u000a# Initialize components for Routine "choice_selection"\u000achoice_selectionClock = core.Clock()\u000astar_left_selection = visual.TextStim(win=win, ori=0, name='star_left_selection',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[-0.5, -0.8], height=0.5, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=-2.0)\u000astar_right_selection = visual.TextStim(win=win, ori=0, name='star_right_selection',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[0.5, -0.8], height=0.5, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=-3.0)\u000a\u000a# Initialize components for Routine "confidence"\u000aconfidenceClock = core.Clock()\u000aconfidence_rating = visual.RatingScale(win=win, name='confidence_rating', marker=u'triangle', markerColor=u'orange', leftKeys=None, rightKeys=None,\u000a    size=1.0, pos=[0.0, 0.0], low=1, high=6, precision=20,\u000a    scale=u'', markerStart=u'3.5', tickHeight=u'1', showAccept=False, acceptKeys=[u'down', u'return'])\u000a\u000a# Initialize components for Routine "instr_infer_intro"\u000ainstr_infer_introClock = core.Clock()\u000ainstr_infer_intro_txt = visual.TextStim(win=win, ori=0, name='instr_infer_intro_txt',\u000a    text=u'Thanks! Now please get the experimenter, who will give you the instructions for the second part of the experiment. \u005cn\u005cnPlease read these instructions carefully and get the experimenter again when you\u005c're finished. Take as much time as you need.',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=1.5,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "instr_infer_practice"\u000ainstr_infer_practiceClock = core.Clock()\u000ainstr_infer_practice_txt = visual.TextStim(win=win, ori=0, name='instr_infer_practice_txt',\u000a    text=u'First, you\u005c'll do some practice trials. These are just for you to get used to the task; your responses won\u005c't count. Unlike in the real trials, the choices you will be learning here were generated randomly by a computer.\u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=1.5,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "instr_infer"\u000ainstr_inferClock = core.Clock()\u000ainstr_infer_txt = visual.TextStim(win=win, ori=0, name='instr_infer_txt',\u000a    text=u'Great! Now that you\u005c've done some practice trials, we\u005c're ready to start the real trials. If you have any questions, please get the experimenter now. Otherwise, you can begin whenever you\u005c're ready. \u005cn\u005cnUnlike in the practice trials, the choices you will be learning here were made by an actual person.\u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=1.5,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "get_ready"\u000aget_readyClock = core.Clock()\u000aget_ready_text = visual.TextStim(win=win, ori=0, name='get_ready_text',\u000a    text=u'Get ready!',    font=u'Arial',\u000a    pos=[0, 0], height=0.12, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000aimg_left_infer = visual.ImageStim(win=win, name='img_left_infer',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[-0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=0.0)\u000aimg_right_infer = visual.ImageStim(win=win, name='img_right_infer',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=-1.0)\u000a\u000a# Initialize components for Routine "trial_post_response"\u000atrial_post_responseClock = core.Clock()\u000aselection_arrow_left = visual.TextStim(win=win, ori=0, name='selection_arrow_left',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[-0.5, -0.09], height=0.5, wrapWidth=None,\u000a    color=u'red', colorSpace=u'rgb', opacity=1,\u000a    depth=-2.0)\u000aselection_arrow_right = visual.TextStim(win=win, ori=0, name='selection_arrow_right',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[0.5, -0.09], height=0.5, wrapWidth=None,\u000a    color=u'red', colorSpace=u'rgb', opacity=1,\u000a    depth=-3.0)\u000afeedback_box_left = visual.Rect(win=win, name='feedback_box_left',\u000a    width=[0.9, 0.9][0], height=[0.9, 0.9][1],\u000a    ori=0, pos=[-0.5, 0],\u000a    lineWidth=5, lineColor=u'yellow', lineColorSpace=u'rgb',\u000a    fillColor=None, fillColorSpace=u'rgb',\u000a    opacity=1, depth=-4.0, interpolate=True)\u000afeedback_box_right = visual.Rect(win=win, name='feedback_box_right',\u000a    width=[0.9, 0.9][0], height=[0.9, 0.9][1],\u000a    ori=0, pos=[0.5, 0],\u000a    lineWidth=5, lineColor=u'yellow', lineColorSpace=u'rgb',\u000a    fillColor=None, fillColorSpace=u'rgb',\u000a    opacity=1, depth=-5.0, interpolate=True)\u000a\u000a# Initialize components for Routine "rest_prompt"\u000arest_promptClock = core.Clock()\u000arest_prompt_txt = visual.TextStim(win=win, ori=0, name='rest_prompt_txt',\u000a    text=u'Great! Now take a rest and press the space bar when you\u005cu2019re ready to begin the next block.',    font=u'Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create counters for the number of correct and incorrect guesses made by subjects to determine extra payment.\u000acorrect_counter = 0\u000aincorrect_counter = 0\u000a\u000a# Create list of lists to store binary choice and BDM data to generate food reward at the end of the experiment\u000aprefs = [['left', 'right', 'choice', 'bid']]\u000abids = [['item', 'bid']] # For the bids collected during the first BDM routine, at the beginning of the experiment\u000a\u000a### CHOICE & INFERENCE RANDOMIZATION ###\u000a\u000a# Define two functions to generate constrained pseudorandom sequences of item pair presentations for the binary choice and inference\u000a# parts of the task. The constraint ensures that the same pair of items does not appear twice in a row (flipped or not).\u000a# In the conditions spreadsheet that the item pairs are drawn from, the flipped version of the same item pair is 20\u000a# rows apart.\u000a\u000a# Binary choice randomization\u000adef genseq_choice():\u000a    done = False\u000a    while done==False:\u000a        counter = 0\u000a        ans = np.random.choice(40, 40, replace=False) # Generate a pseudorandom sequence of 40 numbers\u000a        for x in range(1,40):\u000a            if (ans[x]-ans[x-1]) % 20 == 0: # Is the difference between any sequential numbers divisible by 20?\u000a                counter += 1\u000a        if counter==0: # If not, end the loop and return the array\u000a            done = True\u000a            return ans\u000a        else: # If so, continue the loop and try again\u000a            done = False\u000a\u000a# Inference practice block randomization\u000adef genseq_infer_practice():\u000a    done = False\u000a    while done==False:\u000a        counter = 0\u000a        ans = np.random.choice(14, 14, replace=False) # Generate a pseudorandom sequence of 200 numbers\u000a        for x in range(1,14):\u000a            if (ans[x]-ans[x-1]) % 7 == 0: # Is the difference between any sequential numbers divisible by 20?\u000a                counter += 1\u000a        if counter==0: # If not, end the loop and return the array\u000a            done = True\u000a            return ans\u000a        else: # If so, continue the loop and try again\u000a            done = False\u000a\u000a# Inference randomization\u000adef genseq_infer():\u000a    done = False\u000a    while done==False:\u000a        counter = 0\u000a        ans = np.random.choice(200, 200, replace=False) # Generate a pseudorandom sequence of 200 numbers\u000a        for x in range(1,200):\u000a            if (ans[x]-ans[x-1]) % 20 == 0: # Is the difference between any sequential numbers divisible by 20?\u000a                counter += 1\u000a        if counter==0: # If not, end the loop and return the array\u000a            done = True\u000a            return ans\u000a        else: # If so, continue the loop and try again\u000a            done = False\u000a\u000a\u000a# Set independent sequences for each of the two choice blocks, the inference practice block, and the three inference rest blocks. Each rest block contains 10 presentations of\u000a# each pair.\u000a\u000achoiceseq = genseq_choice()\u000apracticeseq = genseq_infer_practice()\u000ablock1seq = genseq_infer()\u000ablock2seq = genseq_infer()\u000ablock3seq = genseq_infer()\u000a\u000a\u000a# Choose a pilot participant whose choices will form the basis of the learning task\u000apartners = ['P1','P2','P3','P4','P5','P6','P8','P9','P10','P11','P12'] # List of pilot participants, P7 excluded for perfectly inconsistent choices\u000apartner = np.random.choice(partners,1) # Choose one at random\u000apartner_file = 'conditions/choices/infer_design1_value_pairs_' + partner[0] + '.csv' # Path to that participant's choice data\u000a\u000a# Create separate CSV files, one for each choice, practice, and rest block, with the item pairs in the pseudorandomly generated order.\u000a# These CSV files will be used as PsychoPy's conditions spreadsheets and run sequentially in the choice, practice, and inference loops below.\u000a\u000a\u000achoicecond_src = pd.read_csv('conditions/choice_design1_binary.csv', index_col=None, header=0)\u000achoicecond = choicecond_src.copy()\u000afor x in range(40):\u000a    seq = choiceseq[x]\u000a    choicecond.iloc[x] = choicecond_src.iloc[seq]\u000achoicecond.to_csv(path_or_buf=filename+'_choicecond.csv', index=False)\u000a\u000apracticecond_src = pd.read_csv('conditions/choices/infer_design1_value_pairs_practice.csv', index_col=None, header=0)\u000apracticecond = practicecond_src.copy()\u000afor x in range(14):\u000a    seq = practiceseq[x]\u000a    practicecond.iloc[x] = practicecond_src.iloc[seq]\u000apracticecond.to_csv(path_or_buf=filename+'_practicecond.csv', index=False)\u000a\u000ablock1cond_src = pd.read_csv(partner_file, index_col=None, header=0)\u000ablock1cond = block1cond_src.copy()\u000afor x in range(200):\u000a    seq = block1seq[x]\u000a    block1cond.iloc[x] = block1cond_src.iloc[seq]\u000ablock1cond.to_csv(path_or_buf=filename+'_block1cond.csv', index=False)\u000a\u000ablock2cond_src = pd.read_csv(partner_file, index_col=None, header=0)\u000ablock2cond = block2cond_src.copy()\u000afor x in range(200):\u000a    seq = block2seq[x]\u000a    block2cond.iloc[x] = block2cond_src.iloc[seq]\u000ablock2cond.to_csv(path_or_buf=filename+'_block2cond.csv', index=False)\u000a\u000ablock3cond_src = pd.read_csv(partner_file, index_col=None, header=0)\u000ablock3cond = block3cond_src.copy()\u000afor x in range(200):\u000a    seq = block3seq[x]\u000a    block3cond.iloc[x] = block3cond_src.iloc[seq]\u000ablock3cond.to_csv(path_or_buf=filename+'_block3cond.csv', index=False)\u000a\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instr_main"-------\u000at = 0\u000ainstr_mainClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_main_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_main_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_mainComponents = []\u000ainstr_mainComponents.append(instr_main_txt)\u000ainstr_mainComponents.append(instr_main_resp)\u000afor thisComponent in instr_mainComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_main"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_mainClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_main_txt* updates\u000a    if t >= 0.0 and instr_main_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_main_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_main_txt.frameNStart = frameN  # exact frame index\u000a        instr_main_txt.setAutoDraw(True)\u000a    \u000a    # *instr_main_resp* updates\u000a    if t >= 5.0 and instr_main_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_main_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_main_resp.frameNStart = frameN  # exact frame index\u000a        instr_main_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_main_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_main_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_main_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_main_resp.rt = instr_main_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_mainComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_main"-------\u000afor thisComponent in instr_mainComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_main_resp.keys in ['', [], None]:  # No response was made\u000a   instr_main_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_main_resp.keys',instr_main_resp.keys)\u000aif instr_main_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_main_resp.rt', instr_main_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a\u000a#------Prepare to start Routine "instr_bdm"-------\u000at = 0\u000ainstr_bdmClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_bdm_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_bdm_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_bdmComponents = []\u000ainstr_bdmComponents.append(instr_bdm_txt)\u000ainstr_bdmComponents.append(instr_bdm_resp)\u000afor thisComponent in instr_bdmComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_bdm"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_bdmClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_bdm_txt* updates\u000a    if t >= 0.0 and instr_bdm_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_bdm_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_bdm_txt.frameNStart = frameN  # exact frame index\u000a        instr_bdm_txt.setAutoDraw(True)\u000a    \u000a    # *instr_bdm_resp* updates\u000a    if t >= 2.0 and instr_bdm_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_bdm_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_bdm_resp.frameNStart = frameN  # exact frame index\u000a        instr_bdm_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_bdm_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_bdm_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space', 's'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_bdm_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_bdm_resp.rt = instr_bdm_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_bdmComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_bdm"-------\u000afor thisComponent in instr_bdmComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_bdm_resp.keys in ['', [], None]:  # No response was made\u000a   instr_bdm_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_bdm_resp.keys',instr_bdm_resp.keys)\u000athisExp.addData('partnered_pilot_participant', partner)\u000aif instr_bdm_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_bdm_resp.rt', instr_bdm_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## BDM LOOP 1 ##########################\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000abdm_loop1 = data.TrialHandler(nReps=1, method=u'random', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'conditions/choice_design1_bdm.xlsx'),\u000a    seed=None, name='bdm_loop1')\u000athisExp.addLoop(bdm_loop1)  # add the loop to the experiment\u000athisbdm_loop1 = bdm_loop1.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisbdm_loop1.rgb)\u000aif thisbdm_loop1 != None:\u000a    for paramName in thisbdm_loop1.keys():\u000a        exec(paramName + '= thisbdm_loop1.' + paramName)\u000a\u000a# Check if the 'skip' key was pressed in the instructions routine; if so, end the loop and move on to the inference task\u000aif instr_bdm_resp.keys=='s':\u000a    bdm_loop1.finished = True\u000a\u000afor thisbdm_loop1 in bdm_loop1:\u000a    currentLoop = bdm_loop1\u000a    # abbreviate parameter names if possible (e.g. rgb = thisbdm_loop1.rgb)\u000a    if thisbdm_loop1 != None:\u000a        for paramName in thisbdm_loop1.keys():\u000a            exec(paramName + '= thisbdm_loop1.' + paramName)\u000a    \u000a    #------Prepare to start Routine "bdm"-------\u000a    t = 0\u000a    bdmClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    bdm_pic.setImage(dir_path+bdm_img)\u000a    bdm_bid.reset()\u000a    # jitter the starting position of the BDM scale from a uniform distribution between 1 and 2, rounded to the nearest decimal place\u000a    bdm_marker_start = float(np.round(np.random.uniform(1, 2, 1)[0], 1))\u000a    bdm_bid.setMarkerPos(bdm_marker_start)\u000a    # keep track of which components have finished\u000a    bdmComponents = []\u000a    bdmComponents.append(fixation_text)\u000a    bdmComponents.append(bdm_pic)\u000a    bdmComponents.append(bdm_bid)\u000a    for thisComponent in bdmComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "bdm"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = bdmClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation_text* updates\u000a        if t >= 0 and fixation_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation_text.tStart = t  # underestimates by a little under one frame\u000a            fixation_text.frameNStart = frameN  # exact frame index\u000a            fixation_text.setAutoDraw(True)\u000a        elif fixation_text.status == STARTED and t>= (0 + (1.0-win.monitorFramePeriod*0.75)):\u000a            fixation_text.setAutoDraw(False)\u000a\u000a        # *bdm_pic* updates\u000a        if t >= 1.0 and bdm_pic.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bdm_pic.tStart = t  # underestimates by a little under one frame\u000a            bdm_pic.frameNStart = frameN  # exact frame index\u000a            bdm_pic.setAutoDraw(True)\u000a        # *bdm_bid* updates\u000a        if t >= 1.0:\u000a            bdm_bid.draw()\u000a            continueRoutine = bdm_bid.noResponse\u000a            if bdm_bid.noResponse == False:\u000a                bdm_bid.response = bdm_bid.getRating()\u000a                bdm_bid.rt = bdm_bid.getRT()\u000a            elif bdm_bid.noResponse==True:\u000a                if keyState[key.LEFT]==True and bdm_bid.markerPlacedAt >0.01:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt - 0.02\u000a                    bdm_bid.draw()\u000a                elif keyState[key.LEFT]==True and bdm_bid.markerPlacedAt==0.01:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt - 0.01\u000a                    bdm_bid.draw()\u000a                elif keyState[key.RIGHT]==True and bdm_bid.markerPlacedAt <2.99:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt + 0.02\u000a                    bdm_bid.draw()\u000a                elif keyState[key.RIGHT]==True and bdm_bid.markerPlacedAt==2.99:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt + 0.01\u000a                    bdm_bid.draw()\u000a                    \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in bdmComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "bdm"-------\u000a    for thisComponent in bdmComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # store data for bdm (TrialHandler)\u000a    bdm_loop1.addData('bdm_bid1.response', bdm_bid.getRating())\u000a    bdm_loop1.addData('bdm_bid1.rt', bdm_bid.getRT())\u000a    bdm_loop1.addData('bdm_marker_start', bdm_marker_start)\u000a\u000a    # Add the item and the subject's bid to the 'bids' list, which will be merged with the 'prefs' list later in order to run the auction\u000a    bids.append([bdm_img, bdm_bid.response])\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeat of 'bdm_loop1'\u000a\u000a\u000a#------Prepare to start Routine "instr_choice"-------\u000at = 0\u000ainstr_choiceClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_choice_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_choice_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_choiceComponents = []\u000ainstr_choiceComponents.append(instr_choice_txt)\u000ainstr_choiceComponents.append(instr_choice_resp)\u000afor thisComponent in instr_choiceComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_choice"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_choiceClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_choice_txt* updates\u000a    if t >= 0.0 and instr_choice_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_choice_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_choice_txt.frameNStart = frameN  # exact frame index\u000a        instr_choice_txt.setAutoDraw(True)\u000a    \u000a    # *instr_choice_resp* updates\u000a    if t >= 2.0 and instr_choice_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_choice_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_choice_resp.frameNStart = frameN  # exact frame index\u000a        instr_choice_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_choice_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_choice_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space', 's'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_choice_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_choice_resp.rt = instr_choice_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_choiceComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_choice"-------\u000afor thisComponent in instr_choiceComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_choice_resp.keys in ['', [], None]:  # No response was made\u000a   instr_choice_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_choice_resp.keys',instr_choice_resp.keys)\u000aif instr_choice_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_choice_resp.rt', instr_choice_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## BINARY LOOP ##########################\u000a\u000a# set up handler to look after randomisation of conditions etc\u000abinary = data.TrialHandler(nReps=1, method=u'sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(filename+'_choicecond.csv'),\u000a    seed=None, name='binary')\u000athisExp.addLoop(binary)  # add the loop to the experiment\u000athisBinary1 = binary.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBinary1.rgb)\u000aif thisBinary1 != None:\u000a    for paramName in thisBinary1.keys():\u000a        exec(paramName + '= thisBinary1.' + paramName)\u000a\u000a# Check if the 'skip' key was pressed in the instructions routine; if so, end the loop and move on to the BDM\u000aif instr_choice_resp.keys=='s':\u000a    binary.finished = True\u000a\u000afor thisBinary1 in binary:\u000a    currentLoop = binary\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBinary1.rgb)\u000a    if thisBinary1 != None:\u000a        for paramName in thisBinary1.keys():\u000a            exec(paramName + '= thisBinary1.' + paramName)\u000a    \u000a    #------Prepare to start Routine "choice"-------\u000a    t = 0\u000a    choiceClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    choice_pic_left.setImage(dir_path+choice_left)\u000a    choice_pic_right.setImage(dir_path+choice_right)\u000a    event.clearEvents(eventType='keyboard') # Clear keyboard event log to avoid last key press from prior loop being used\u000a    key_resp_choice = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_choice.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    choiceComponents = []\u000a    choiceComponents.append(fixation_text)\u000a    choiceComponents.append(choice_pic_left)\u000a    choiceComponents.append(choice_pic_right)\u000a    choiceComponents.append(key_resp_choice)\u000a    for thisComponent in choiceComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    \u000a    #-------Start Routine "choice"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = choiceClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation_text* updates\u000a        if t >= 0 and fixation_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation_text.tStart = t  # underestimates by a little under one frame\u000a            fixation_text.frameNStart = frameN  # exact frame index\u000a            fixation_text.setAutoDraw(True)\u000a        elif fixation_text.status == STARTED and t>= (0 + (1.0-win.monitorFramePeriod*0.75)):\u000a            fixation_text.setAutoDraw(False)\u000a\u000a        # *choice_pic_left* updates\u000a        if t >= 1.0 and choice_pic_left.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_left.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_left.frameNStart = frameN  # exact frame index\u000a            choice_pic_left.setAutoDraw(True)\u000a        \u000a        # *choice_pic_right* updates\u000a        if t >= 1.0 and choice_pic_right.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_right.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_right.frameNStart = frameN  # exact frame index\u000a            choice_pic_right.setAutoDraw(True)\u000a\u000a        # *key_resp_choice* updates\u000a        if t >= 1.0 and key_resp_choice.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_choice.tStart = t  # underestimates by a little under one frame\u000a            key_resp_choice.frameNStart = frameN  # exact frame index\u000a            key_resp_choice.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_choice.clock.reset()  # now t=0\u000a        if key_resp_choice.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_choice.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_choice.rt = key_resp_choice.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in choiceComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "choice"-------\u000a    for thisComponent in choiceComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_choice.keys in ['', [], None]:  # No response was made\u000a       key_resp_choice.keys=None\u000a    # store data for binary (TrialHandler)\u000a    binary.addData('key_resp_choice.keys',key_resp_choice.keys)\u000a    if key_resp_choice.keys != None:  # we had a response\u000a        binary.addData('key_resp_choice.rt', key_resp_choice.rt)\u000a\u000a    # define a function to append binary choices and the bid for the chosen item to the preference list\u000a    # lft is the left image displayed during that choice trial\u000a    # rt is the right image displayed\u000a    def rec_choice(lft, rt): \u000a        bd = False\u000a        if key_resp_choice.keys=='left':\u000a            chc = lft\u000a        elif key_resp_choice.keys=='right':\u000a            chc = rt\u000a        for x in range(len(bids)):\u000a            if bids[x][0]==chc:\u000a                bd = bids[x][1]\u000a        prefs.append([lft, rt, chc, bd])\u000a\u000a    # call the function\u000a    rec_choice(choice_left, choice_right)\u000a    \u000a\u000a    #------Prepare to start Routine "choice_selection"-------\u000a    t = 0\u000a    choice_selectionClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # keep track of which components have finished\u000a    choice_selectionComponents = []\u000a    choice_selectionComponents.append(choice_pic_left)\u000a    choice_selectionComponents.append(choice_pic_right)\u000a    choice_selectionComponents.append(star_left_selection)\u000a    choice_selectionComponents.append(star_right_selection)\u000a    for thisComponent in choice_selectionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "choice_selection"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = choice_selectionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *choice_pic_left* updates\u000a        if t >= 0.0 and choice_pic_left.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_left.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_left.frameNStart = frameN  # exact frame index\u000a            choice_pic_left.setAutoDraw(True)\u000a        elif choice_pic_left.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            choice_pic_left.setAutoDraw(False)\u000a        \u000a        # *choice_pic_right* updates\u000a        if t >= 0.0 and choice_pic_right.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_right.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_right.frameNStart = frameN  # exact frame index\u000a            choice_pic_right.setAutoDraw(True)\u000a        elif choice_pic_right.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            choice_pic_right.setAutoDraw(False)\u000a        \u000a        # *star_left_selection* updates\u000a        if key_resp_choice.keys=='left':\u000a            if t >= 0.0 and star_left_selection.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                star_left_selection.tStart = t  # underestimates by a little under one frame\u000a                star_left_selection.frameNStart = frameN  # exact frame index\u000a                star_left_selection.setAutoDraw(True)\u000a            elif star_left_selection.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                star_left_selection.setAutoDraw(False)\u000a        \u000a        # *star_right_selection* updates\u000a        if key_resp_choice.keys=='right':\u000a            if t >= 0.0 and star_right_selection.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                star_right_selection.tStart = t  # underestimates by a little under one frame\u000a                star_right_selection.frameNStart = frameN  # exact frame index\u000a                star_right_selection.setAutoDraw(True)\u000a            elif star_right_selection.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                star_right_selection.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in choice_selectionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "choice_selection"-------\u000a    for thisComponent in choice_selectionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    #thisExp.nextEntry()\u000a\u000a    #------Prepare to start Routine "confidence"-------\u000a    t = 0\u000a    confidenceClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    confidence_rating.reset()\u000a    # jitter the starting position of the confidence rating scale from a uniform distribution between 1.7 and 3.3 (the middle third of the scale), rounded to the nearest decimal place\u000a    confidence_marker_start = float(np.round(np.random.uniform(1.7, 3.3, 1)[0], 1))\u000a    confidence_rating.setMarkerPos(confidence_marker_start)\u000a    # keep track of which components have finished\u000a    confidenceComponents = []\u000a    confidenceComponents.append(confidence_rating)\u000a    for thisComponent in confidenceComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "confidence"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = confidenceClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *confidence_rating* updates\u000a        if t > 0.5:\u000a            confidence_rating.draw()\u000a            continueRoutine = confidence_rating.noResponse\u000a            if confidence_rating.noResponse == False:\u000a                confidence_rating.response = confidence_rating.getRating()\u000a                confidence_rating.rt = confidence_rating.getRT()\u000a            elif confidence_rating.noResponse==True:\u000a                if keyState[key.LEFT]==True and confidence_rating.markerPlacedAt >0:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt - 0.1\u000a                    confidence_rating.draw()\u000a                elif keyState[key.LEFT]==True and confidence_rating.markerPlacedAt==0.1:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt - 0.1\u000a                    confidence_rating.draw()\u000a                elif keyState[key.RIGHT]==True and confidence_rating.markerPlacedAt <4.9:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt + 0.1\u000a                    confidence_rating.draw()\u000a                elif keyState[key.RIGHT]==True and confidence_rating.markerPlacedAt==4.9:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt + 0.1\u000a                    confidence_rating.draw()\u000a                    \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in confidenceComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "confidence"-------\u000a    for thisComponent in confidenceComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # store data for confidence (TrialHandler)\u000a    binary.addData('confidence_rating1.response', confidence_rating.getRating())\u000a    binary.addData('confidence_rating1.rt', confidence_rating.getRT())\u000a    binary.addData('confidence_marker_start', confidence_marker_start+1) # Add 1 to convert from 0-5 to 1-6 scale\u000a\u000a    thisExp.nextEntry()\u000a\u000a\u000a# completed 1 repeat of 'binary'        \u000a\u000a#------Prepare to start Routine "instr_infer_intro"-------\u000at = 0\u000ainstr_infer_introClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_infer_intro_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_infer_intro_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_infer_introComponents = []\u000ainstr_infer_introComponents.append(instr_infer_intro_txt)\u000ainstr_infer_introComponents.append(instr_infer_intro_resp)\u000afor thisComponent in instr_infer_introComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_infer_intro"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_infer_introClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_infer_intro_txt* updates\u000a    if t >= 0.0 and instr_infer_intro_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_intro_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_intro_txt.frameNStart = frameN  # exact frame index\u000a        instr_infer_intro_txt.setAutoDraw(True)\u000a    \u000a    # *instr_infer_intro_resp* updates\u000a    if t >= 5.0 and instr_infer_intro_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_intro_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_intro_resp.frameNStart = frameN  # exact frame index\u000a        instr_infer_intro_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_infer_intro_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_infer_intro_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_infer_intro_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_infer_intro_resp.rt = instr_infer_intro_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_infer_introComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_infer_intro"-------\u000afor thisComponent in instr_infer_introComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_infer_intro_resp.keys in ['', [], None]:  # No response was made\u000a   instr_infer_intro_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_infer_intro_resp.keys',instr_infer_intro_resp.keys)\u000aif instr_infer_intro_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_infer_intro_resp.rt', instr_infer_intro_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a#------Prepare to start Routine "instr_infer_practice"-------\u000at = 0\u000ainstr_infer_practiceClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_infer_practice_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_infer_practice_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_infer_practiceComponents = []\u000ainstr_infer_practiceComponents.append(instr_infer_practice_txt)\u000ainstr_infer_practiceComponents.append(instr_infer_practice_resp)\u000afor thisComponent in instr_infer_practiceComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_infer_practice"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_infer_practiceClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_infer_practice_txt* updates\u000a    if t >= 0.0 and instr_infer_practice_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_practice_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_practice_txt.frameNStart = frameN  # exact frame index\u000a        instr_infer_practice_txt.setAutoDraw(True)\u000a    \u000a    # *instr_infer_practice_resp* updates\u000a    if t >= 5.0 and instr_infer_practice_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_practice_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_practice_resp.frameNStart = frameN  # exact frame index\u000a        instr_infer_practice_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_infer_practice_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_infer_practice_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_infer_practice_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_infer_practice_resp.rt = instr_infer_practice_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_infer_practiceComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_infer_practice"-------\u000afor thisComponent in instr_infer_practiceComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_infer_practice_resp.keys in ['', [], None]:  # No response was made\u000a   instr_infer_practice_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_infer_practice_resp.keys',instr_infer_practice_resp.keys)\u000aif instr_infer_practice_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_infer_practice_resp.rt', instr_infer_practice_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## PRACTICE LOOP ##########################\u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_loop = data.TrialHandler(nReps=1, method=u'sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(filename+'_practicecond.csv'),\u000a    seed=None, name='practice_loop')\u000athisExp.addLoop(practice_loop)  # add the loop to the experiment\u000athisPractice_loop = practice_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_loop.rgb)\u000aif thisPractice_loop != None:\u000a    for paramName in thisPractice_loop.keys():\u000a        exec(paramName + '= thisPractice_loop.' + paramName)\u000a\u000a  \u000afor thisPractice_loop in practice_loop:\u000a    currentLoop = practice_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_loop.rgb)\u000a    if thisPractice_loop != None:\u000a        for paramName in thisPractice_loop.keys():\u000a            exec(paramName + '= thisPractice_loop.' + paramName)    \u000a    \u000a        \u000a    # Define class for setting the feedback image\u000a    class set_feedback:\u000a        options = ['correct', 'wrong']\u000a        feedback = np.random.choice(options, replace=True, p=[0.8, 0.2])\u000a        if feedback=='correct':\u000a            feedback_img = img_correct\u000a        elif feedback=='wrong':\u000a            feedback_img = img_wrong\u000a\u000a        if feedback_img==img_left:\u000a            feedback_side = 'left'\u000a        elif feedback_img==img_right:\u000a            feedback_side = 'right'\u000a\u000a\u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialtime = datetime.datetime.now()\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    img_left_infer.setImage(dir_path+img_left)\u000a    img_right_infer.setImage(dir_path+img_right)\u000a    infer_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    infer_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(fixation_text)\u000a    trialComponents.append(img_left_infer)\u000a    trialComponents.append(img_right_infer)\u000a    trialComponents.append(infer_resp)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation_text* updates\u000a        if t >= 0 and fixation_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation_text.tStart = t  # underestimates by a little under one frame\u000a            fixation_text.frameNStart = frameN  # exact frame index\u000a            fixation_text.setAutoDraw(True)\u000a        elif fixation_text.status == STARTED and t>= (0 + (2.0-win.monitorFramePeriod*0.75)):\u000a            fixation_text.setAutoDraw(False)\u000a\u000a        # *img_left_infer* updates\u000a        if t >= 2.0 and img_left_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_left_infer.tStart = t  # underestimates by a little under one frame\u000a            img_left_infer.frameNStart = frameN  # exact frame index\u000a            img_left_infer.setAutoDraw(True)\u000a        \u000a        # *img_right_infer* updates\u000a        if t >= 2.0 and img_right_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_right_infer.tStart = t  # underestimates by a little under one frame\u000a            img_right_infer.frameNStart = frameN  # exact frame index\u000a            img_right_infer.setAutoDraw(True)\u000a                  \u000a        # *infer_resp* updates\u000a        if t >= 2.0 and infer_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            infer_resp.tStart = t  # underestimates by a little under one frame\u000a            infer_resp.frameNStart = frameN  # exact frame index\u000a            infer_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            infer_resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if infer_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                infer_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                infer_resp.rt = infer_resp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a\u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if infer_resp.keys in ['', [], None]:  # No response was made\u000a       infer_resp.keys=None\u000a    # # store data for practice_loop (TrialHandler)\u000a    # practice_loop.addData('infer_resp.keys',infer_resp.keys)\u000a    # if infer_resp.keys != None:  # we had a response\u000a    #     practice_loop.addData('infer_resp.rt', infer_resp.rt)\u000a    practice_loop.addData('set_feedback.feedback_img', set_feedback.feedback_img)\u000a    practice_loop.addData('trial_start_time', trialtime)\u000a    \u000a    # # Increase correct and incorrect response counters by 1 based on S's response\u000a    # if infer_resp.keys=='left' and img_correct==img_left:\u000a    #     correct_counter += 1\u000a    # elif infer_resp.keys=='left' and img_correct==img_right:\u000a    #     incorrect_counter += 1\u000a    # elif infer_resp.keys=='right' and img_correct==img_right:\u000a    #     correct_counter += 1\u000a    # elif infer_resp.keys=='right' and img_correct==img_left:\u000a    #     incorrect_counter += 1\u000a    \u000a\u000a    #------Prepare to start Routine "trial_post_response"-------\u000a    t = 0\u000a    trial_post_responseClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(3.000000)\u000a    # keep track of which components have finished\u000a    trial_post_responseComponents = []\u000a    trial_post_responseComponents.append(img_left_infer)\u000a    trial_post_responseComponents.append(img_right_infer)\u000a    trial_post_responseComponents.append(selection_arrow_left)\u000a    trial_post_responseComponents.append(selection_arrow_right)\u000a    trial_post_responseComponents.append(feedback_box_left)\u000a    trial_post_responseComponents.append(feedback_box_right)\u000a    for thisComponent in trial_post_responseComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial_post_response"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = trial_post_responseClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a\u000a        # *img_left_infer* updates\u000a        if t >= 0.0 and img_left_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_left_infer.tStart = t  # underestimates by a little under one frame\u000a            img_left_infer.frameNStart = frameN  # exact frame index\u000a            img_left_infer.setAutoDraw(True)\u000a        elif img_left_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            img_left_infer.setAutoDraw(False)\u000a        \u000a        # *img_right_infer* updates\u000a        if t >= 0.0 and img_right_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_right_infer.tStart = t  # underestimates by a little under one frame\u000a            img_right_infer.frameNStart = frameN  # exact frame index\u000a            img_right_infer.setAutoDraw(True)\u000a        elif img_right_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            img_right_infer.setAutoDraw(False)\u000a        \u000a        if infer_resp.keys == 'left':\u000a            # *selection_arrow_left* updates\u000a            if t >= 0.0 and selection_arrow_left.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                selection_arrow_left.tStart = t  # underestimates by a little under one frame\u000a                selection_arrow_left.frameNStart = frameN  # exact frame index\u000a                selection_arrow_left.setAutoDraw(True)\u000a            elif selection_arrow_left.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                selection_arrow_left.setAutoDraw(False)\u000a        \u000a        if infer_resp.keys == 'right':\u000a            # *selection_arrow_right* updates\u000a            if t >= 0.0 and selection_arrow_right.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                selection_arrow_right.tStart = t  # underestimates by a little under one frame\u000a                selection_arrow_right.frameNStart = frameN  # exact frame index\u000a                selection_arrow_right.setAutoDraw(True)\u000a            elif selection_arrow_right.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                selection_arrow_right.setAutoDraw(False)\u000a        \u000a        if set_feedback.feedback_side == 'left':\u000a            # *feedback_box_left* updates\u000a            if t >= 1.0 and feedback_box_left.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                feedback_box_left.tStart = t  # underestimates by a little under one frame\u000a                feedback_box_left.frameNStart = frameN  # exact frame index\u000a                feedback_box_left.setAutoDraw(True)\u000a            elif feedback_box_left.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                feedback_box_left.setAutoDraw(False)\u000a        \u000a        if set_feedback.feedback_side == 'right':\u000a            # *feedback_box_right* updates\u000a            if t >= 1.0 and feedback_box_right.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                feedback_box_right.tStart = t  # underestimates by a little under one frame\u000a                feedback_box_right.frameNStart = frameN  # exact frame index\u000a                feedback_box_right.setAutoDraw(True)\u000a            elif feedback_box_right.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period right\u000a                feedback_box_right.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trial_post_responseComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "trial_post_response"-------\u000a    for thisComponent in trial_post_responseComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000a    \u000a    thisExp.nextEntry()\u000a                        \u000a# completed 1 repeat of 'practice_loop'\u000a\u000a\u000a#------Prepare to start Routine "instr_infer"-------\u000at = 0\u000ainstr_inferClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_infer_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_infer_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_inferComponents = []\u000ainstr_inferComponents.append(instr_infer_txt)\u000ainstr_inferComponents.append(instr_infer_resp)\u000afor thisComponent in instr_inferComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_infer"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_inferClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_infer_txt* updates\u000a    if t >= 0.0 and instr_infer_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_txt.frameNStart = frameN  # exact frame index\u000a        instr_infer_txt.setAutoDraw(True)\u000a    \u000a    # *instr_infer_resp* updates\u000a    if t >= 5.0 and instr_infer_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_resp.frameNStart = frameN  # exact frame index\u000a        instr_infer_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_infer_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_infer_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_infer_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_infer_resp.rt = instr_infer_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_inferComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_infer"-------\u000afor thisComponent in instr_inferComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_infer_resp.keys in ['', [], None]:  # No response was made\u000a   instr_infer_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_infer_resp.keys',instr_infer_resp.keys)\u000aif instr_infer_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_infer_resp.rt', instr_infer_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## BLOCK LOOP ##########################\u000a\u000a# This loop runs a second nested loop that shows each item pair 10 times, followed by a rest break prompt.\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=3, method=u'sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=[None],\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000a# Set up counter to keep track of block loop cycle, so that the rest prompt is only shown twice\u000ablock_loop_counter = 0\u000a\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    # Increase loop counter by one\u000a    block_loop_counter += 1\u000a    \u000a    # Change the condition file for the feedback block based on which block loop we're on\u000a    condfilename = filename+u'_block'+str(block_loop_counter)+u'cond.csv'\u000a    \u000a    # Minimize the psychopy window so the calibration window can be seen\u000a    win.winHandle.minimize()\u000a    #Do the eye tracker setup at the beginning of each block\u000a    tracker.runSetupProcedure()\u000a    # Re-display the psychopy window after setup is completed\u000a    win.winHandle.maximize()\u000a    win.winHandle.activate()\u000a    \u000a\u000a    \u000a    #------Prepare to start Routine "get_ready"-------\u000a    t = 0\u000a    get_readyClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(3.000000)\u000a    # update component parameters for each repeat\u000a    get_ready_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    get_ready_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    get_readyComponents = []\u000a    get_readyComponents.append(get_ready_text)\u000a    get_readyComponents.append(get_ready_resp)\u000a    for thisComponent in get_readyComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    \u000a    #-------Start Routine "get_ready"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = get_readyClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *get_ready_text* updates\u000a        if t >= 0.0 and get_ready_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            get_ready_text.tStart = t  # underestimates by a little under one frame\u000a            get_ready_text.frameNStart = frameN  # exact frame index\u000a            get_ready_text.setAutoDraw(True)\u000a        \u000a        # *get_ready_resp* updates\u000a        if t >= 0.0 and get_ready_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            get_ready_resp.tStart = t  # underestimates by a little under one frame\u000a            get_ready_resp.frameNStart = frameN  # exact frame index\u000a            get_ready_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            get_ready_resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if get_ready_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['p'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                get_ready_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                get_ready_resp.rt = get_ready_resp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in get_readyComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "get_ready"-------\u000a    for thisComponent in get_readyComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if get_ready_resp.keys in ['', [], None]:  # No response was made\u000a       get_ready_resp.keys=None\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('get_ready_resp.keys',get_ready_resp.keys)\u000a    if get_ready_resp.keys != None:  # we had a response\u000a        thisExp.addData('get_ready_resp.rt', get_ready_resp.rt)\u000a    thisExp.nextEntry()\u000a\u000a    ######################## TRIAL LOOP ##########################\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    trial_loop = data.TrialHandler(nReps=1, method=u'sequential', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(condfilename),\u000a        seed=None, name='trial_loop')\u000a    thisExp.addLoop(trial_loop)  # add the loop to the experiment\u000a    thisTrial_loop = trial_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_loop.rgb)\u000a    if thisTrial_loop != None:\u000a        for paramName in thisTrial_loop.keys():\u000a            exec(paramName + '= thisTrial_loop.' + paramName)\u000a    \u000a      \u000a    for thisTrial_loop in trial_loop:\u000a        currentLoop = trial_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_loop.rgb)\u000a        if thisTrial_loop != None:\u000a            for paramName in thisTrial_loop.keys():\u000a                exec(paramName + '= thisTrial_loop.' + paramName)    \u000a        \u000a            \u000a        # Define class for setting the feedback image\u000a        class set_feedback:\u000a            options = ['correct', 'wrong']\u000a            feedback = np.random.choice(options, replace=True, p=[0.8, 0.2])\u000a            if feedback=='correct':\u000a                feedback_img = img_correct\u000a            elif feedback=='wrong':\u000a                feedback_img = img_wrong\u000a\u000a            if feedback_img==img_left:\u000a                feedback_side = 'left'\u000a            elif feedback_img==img_right:\u000a                feedback_side = 'right'\u000a                        \u000a        # Start getting data from the eye tracker\u000a        tracker.enableEventReporting(True)\u000a        # Send beginning-of-trial messages to eye tracker data file\u000a        trial_number = (block_loop.thisN * 200) + trial_loop.thisTrialN # Trial number out of 599 (starts at 0)\u000a        tracker.sendCommand("record_status_message 'INFERRING, Block %d/3, Trial %d/600 '" % (block_loop.thisN + 1, trial_number + 1))\u000a        tracker.sendMessage("TRIALID %d" % trial_number)\u000a        tracker.sendMessage("!V TRIAL_VAR_DATA %d" % trial_number)\u000a\u000a        \u000a        #------Prepare to start Routine "trial"-------\u000a        t = 0\u000a        trialtime = datetime.datetime.now()\u000a        trialClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        img_left_infer.setImage(dir_path+img_left)\u000a        img_right_infer.setImage(dir_path+img_right)\u000a        infer_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        infer_resp.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trialComponents = []\u000a        trialComponents.append(fixation_text)\u000a        trialComponents.append(img_left_infer)\u000a        trialComponents.append(img_right_infer)\u000a        trialComponents.append(infer_resp)\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        # Set indicator variable for whether eye tracker messages were sent during the first loop of the routine\u000a        eye_sync_messages_sent = 0\u000a        \u000a        #-------Start Routine "trial"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = trialClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *fixation_text* updates\u000a            if t >= 0 and fixation_text.status == NOT_STARTED:\u000a                if eye_sync_messages_sent==0:\u000a                    startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                # keep track of start time/frame for later\u000a                fixation_text.tStart = t  # underestimates by a little under one frame\u000a                fixation_text.frameNStart = frameN  # exact frame index\u000a                fixation_text.setAutoDraw(True)\u000a                if eye_sync_messages_sent==0:\u000a                    drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                    tracker.sendMessage("%d DISPLAY ON" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                    tracker.sendMessage("SYNCTIME %d" %drawTime)\u000a                    eye_sync_messages_sent = 1\u000a            elif fixation_text.status == STARTED and t>= (0 + (2.0-win.monitorFramePeriod*0.75)):\u000a                fixation_text.setAutoDraw(False)\u000a            \u000a            # *img_left_infer* updates\u000a            if t >= 2.0 and img_left_infer.status == NOT_STARTED:\u000a                if eye_sync_messages_sent==1:\u000a                    startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                # keep track of start time/frame for later\u000a                img_left_infer.tStart = t  # underestimates by a little under one frame\u000a                img_left_infer.frameNStart = frameN  # exact frame index\u000a                img_left_infer.setAutoDraw(True)\u000a            \u000a            # *img_right_infer* updates\u000a            if t >= 2.0 and img_right_infer.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                img_right_infer.tStart = t  # underestimates by a little under one frame\u000a                img_right_infer.frameNStart = frameN  # exact frame index\u000a                img_right_infer.setAutoDraw(True)\u000a                if eye_sync_messages_sent==1:\u000a                    drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                    tracker.sendMessage("%d DISPLAY ON ITEMS" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                    eye_sync_messages_sent = 2\u000a                      \u000a            # *infer_resp* updates\u000a            if t >= 2.0 and infer_resp.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                infer_resp.tStart = t  # underestimates by a little under one frame\u000a                infer_resp.frameNStart = frameN  # exact frame index\u000a                infer_resp.status = STARTED\u000a                # keyboard checking is just starting\u000a                infer_resp.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            if infer_resp.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['left', 'right'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    infer_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                    infer_resp.rt = infer_resp.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trialComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                tracker.enableEventReporting(False) # End eye tracker data recording\u000a                tracker.sendMessage("EXPERIMENT ABORTED")\u000a                io.quit() # Close iohub\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial"-------\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if infer_resp.keys in ['', [], None]:  # No response was made\u000a           infer_resp.keys=None\u000a        # store data for trial_loop (TrialHandler)\u000a        trial_loop.addData('infer_resp.keys',infer_resp.keys)\u000a        if infer_resp.keys != None:  # we had a response\u000a            trial_loop.addData('infer_resp.rt', infer_resp.rt)\u000a        trial_loop.addData('set_feedback.feedback_img', set_feedback.feedback_img)\u000a        trial_loop.addData('trial_start_time', trialtime)\u000a        \u000a        # Increase correct and incorrect response counters by 1 based on S's response\u000a        if infer_resp.keys=='left' and img_correct==img_left:\u000a            correct_counter += 1\u000a        elif infer_resp.keys=='left' and img_correct==img_right:\u000a            incorrect_counter += 1\u000a        elif infer_resp.keys=='right' and img_correct==img_right:\u000a            correct_counter += 1\u000a        elif infer_resp.keys=='right' and img_correct==img_left:\u000a            incorrect_counter += 1\u000a        \u000a\u000a        #------Prepare to start Routine "trial_post_response"-------\u000a        t = 0\u000a        trial_post_responseClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(3.000000)\u000a        # keep track of which components have finished\u000a        trial_post_responseComponents = []\u000a        trial_post_responseComponents.append(img_left_infer)\u000a        trial_post_responseComponents.append(img_right_infer)\u000a        trial_post_responseComponents.append(selection_arrow_left)\u000a        trial_post_responseComponents.append(selection_arrow_right)\u000a        trial_post_responseComponents.append(feedback_box_left)\u000a        trial_post_responseComponents.append(feedback_box_right)\u000a        for thisComponent in trial_post_responseComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        # Set indicator variable for whether eye tracker messages were sent during the first loop of the routine\u000a        eye_sync_messages_sent = 0\u000a\u000a        #-------Start Routine "trial_post_response"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = trial_post_responseClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a\u000a            # *img_left_infer* updates\u000a            if t >= 0.0 and img_left_infer.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                img_left_infer.tStart = t  # underestimates by a little under one frame\u000a                img_left_infer.frameNStart = frameN  # exact frame index\u000a                img_left_infer.setAutoDraw(True)\u000a            elif img_left_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                img_left_infer.setAutoDraw(False)\u000a            \u000a            # *img_right_infer* updates\u000a            if t >= 0.0 and img_right_infer.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                img_right_infer.tStart = t  # underestimates by a little under one frame\u000a                img_right_infer.frameNStart = frameN  # exact frame index\u000a                img_right_infer.setAutoDraw(True)\u000a            elif img_right_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                img_right_infer.setAutoDraw(False)\u000a            \u000a            if infer_resp.keys == 'left':\u000a                # *selection_arrow_left* updates\u000a                if t >= 0.0 and selection_arrow_left.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==0:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    selection_arrow_left.tStart = t  # underestimates by a little under one frame\u000a                    selection_arrow_left.frameNStart = frameN  # exact frame index\u000a                    selection_arrow_left.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==0:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        tracker.sendMessage("%d DISPLAY ON SELECTION" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 1\u000a                elif selection_arrow_left.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    if eye_sync_messages_sent==1:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    selection_arrow_left.setAutoDraw(False)\u000a                    if eye_sync_messages_sent==1:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        tracker.sendMessage("%d DISPLAY ON SELECTION OFF" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 2\u000a            \u000a            if infer_resp.keys == 'right':\u000a                # *selection_arrow_right* updates\u000a                if t >= 0.0 and selection_arrow_right.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==0:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    selection_arrow_right.tStart = t  # underestimates by a little under one frame\u000a                    selection_arrow_right.frameNStart = frameN  # exact frame index\u000a                    selection_arrow_right.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==0:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        tracker.sendMessage("%d DISPLAY ON SELECTION" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 1\u000a                elif selection_arrow_right.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    if eye_sync_messages_sent==1:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    selection_arrow_right.setAutoDraw(False)\u000a                    if eye_sync_messages_sent==1:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        tracker.sendMessage("%d DISPLAY ON SELECTION OFF" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 2\u000a            \u000a            if set_feedback.feedback_side == 'left':\u000a                # *feedback_box_left* updates\u000a                if t >= 1.0 and feedback_box_left.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==2:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    feedback_box_left.tStart = t  # underestimates by a little under one frame\u000a                    feedback_box_left.frameNStart = frameN  # exact frame index\u000a                    feedback_box_left.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==2:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        tracker.sendMessage("%d DISPLAY ON FEEDBACK" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 3\u000a                elif feedback_box_left.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    feedback_box_left.setAutoDraw(False)\u000a            \u000a            if set_feedback.feedback_side == 'right':\u000a                # *feedback_box_right* updates\u000a                if t >= 1.0 and feedback_box_right.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==2:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    feedback_box_right.tStart = t  # underestimates by a little under one frame\u000a                    feedback_box_right.frameNStart = frameN  # exact frame index\u000a                    feedback_box_right.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==2:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        tracker.sendMessage("%d DISPLAY ON FEEDBACK" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 3\u000a                elif feedback_box_right.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period right\u000a                    feedback_box_right.setAutoDraw(False)\u000a\u000a\u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial_post_responseComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                tracker.enableEventReporting(False) # End eye tracker data recording\u000a                tracker.sendMessage("EXPERIMENT ABORTED")\u000a                io.quit() # Close iohub\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "trial_post_response"-------\u000a        for thisComponent in trial_post_responseComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a        thisExp.nextEntry()\u000a                            \u000a    # completed 5 repeats of 'trial_loop'\u000a    \u000a    if block_loop_counter <= 2: # If this is the first or second cycle of the loop, display the rest break prompt\u000a\u000a        #------Prepare to start Routine "rest_prompt"-------\u000a        t = 0\u000a        rest_promptClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        rest_prompt_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        rest_prompt_resp.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        rest_promptComponents = []\u000a        rest_promptComponents.append(rest_prompt_txt)\u000a        rest_promptComponents.append(rest_prompt_resp)\u000a        for thisComponent in rest_promptComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a\u000a        #-------Start Routine "rest_prompt"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = rest_promptClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *rest_prompt_txt* updates\u000a            if t >= 0.0 and rest_prompt_txt.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                rest_prompt_txt.tStart = t  # underestimates by a little under one frame\u000a                rest_prompt_txt.frameNStart = frameN  # exact frame index\u000a                rest_prompt_txt.setAutoDraw(True)\u000a            \u000a            # *rest_prompt_resp* updates\u000a            if t >= 2.0 and rest_prompt_resp.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                rest_prompt_resp.tStart = t  # underestimates by a little under one frame\u000a                rest_prompt_resp.frameNStart = frameN  # exact frame index\u000a                rest_prompt_resp.status = STARTED\u000a                # keyboard checking is just starting\u000a                rest_prompt_resp.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            if rest_prompt_resp.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    rest_prompt_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                    rest_prompt_resp.rt = rest_prompt_resp.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in rest_promptComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                tracker.enableEventReporting(False) # End eye tracker data recording\u000a                tracker.sendMessage("EXPERIMENT ABORTED")\u000a                io.quit() # CLose iohub\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a\u000a        #-------Ending Routine "rest_prompt"-------\u000a        for thisComponent in rest_promptComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if rest_prompt_resp.keys in ['', [], None]:  # No response was made\u000a           rest_prompt_resp.keys=None\u000a        # store data for thisExp (ExperimentHandler)\u000a        thisExp.addData('rest_prompt_resp.keys',rest_prompt_resp.keys)\u000a        if rest_prompt_resp.keys != None:  # we had a response\u000a            thisExp.addData('rest_prompt_resp.rt', rest_prompt_resp.rt)\u000a\u000a\u000a    thisExp.nextEntry()\u000a    \u000a# completed 3 repeats of 'block_loop'\u000a\u000a\u000a# store data for total number of correct and incorrect responses    \u000athisExp.addData('correct_counter', correct_counter)\u000athisExp.addData('incorrect_counter', incorrect_counter)\u000athisExp.nextEntry()     \u000a\u000atracker.setConnectionState(False) # Close and transfer eye-tracking data, then close down eye tracker connection\u000a\u000a\u000a######################## AUCTION ##########################\u000a\u000aif len(prefs)==41 and len(bids)==41: # If S completed the entire binary choice and BDM routines, run the auction\u000a\u000a    # run the auction\u000a    class auction:\u000a        rand_itm = randint(1, (len(prefs))) # pick index for S's chosen item from a random choice\u000a        price = float((randint(1, 300)))/100 # assign a price to the item randomly from between 0.01 and 3 pounds\u000a        bid = prefs[rand_itm][3]\u000a        # check if S's bid for that item was above or below the price\u000a        if bid >= price:\u000a            win_item=True\u000a        elif bid < price:\u000a            win_item=False\u000a\u000a        # set text for the auction screen\u000a        if win_item==True:\u000a            auc_res_txt = u'Congratulations! You won the following item at auction. \u005cnThis was your preferred item out of a randomly selected pair from one of the choice tasks.'\u000a            auc_prc_txt = u'Your bid of \u005cxa3' + '{0:.2f}'.format(bid) + u' matched or exceeded the randomly generated price of \u005cxa3' + '{0:.2f}'.format(price) + '.\u005cn\u005cn[Press space bar to continue]'\u000a            cost = price\u000a        elif win_item==False:\u000a            auc_res_txt = u'Sorry, you did not win the following item at auction. \u005cnThis was your preferred item out of a randomly selected pair from one of the choice tasks.'\u000a            auc_prc_txt = u'Your bid of \u005cxa3' + '{0:.2f}'.format(bid) + u' was lower than the randomly generated price of \u005cxa3' + '{0:.2f}'.format(price) + '.\u005cn\u005cn[Press space bar to continue]'\u000a            cost = 0\u000a\u000a        # find the image path of the auction item\u000a        rand_itm_img = prefs[rand_itm][2]\u000a\u000a    # add up each component of S's payment\u000a    class score:\u000a        base = 25\u000a        rwrd = 0.01\u000a        loss = 0\u000a        rwrd_tot = rwrd * correct_counter\u000a        loss_tot = loss * incorrect_counter\u000a        pre_pymt = base + rwrd_tot - loss_tot\u000a        final_pymt = pre_pymt - auction.cost\u000a\u000a        pymt_expl_bdwn = u'\u005cxa3' + '{0:.2f}'.format(base) + u' base payment'+ u'\u005cn+ \u005cxa3' + '{0:.2f}'.format(rwrd_tot) + ' reward for ' + str(correct_counter) + u' correct responses (\u005cxa3' + '{0:.2f}'.format(rwrd) + u' each)' + u'\u005cn- \u005cxa3' + '{0:.2f}'.format(auction.cost) + ' cost of auction item' \u000a        pymt_expl_tot = u'Your total payment is: \u005cxa3' + '{0:.2f}'.format(final_pymt) + '\u005cn\u005cnThank you for participating! Please call the experimenter into the room.'\u000a\u000a\u000a    # Initialize components for Routine "auc_disp"\u000a    auc_dispClock = core.Clock()\u000a    pic_auc_itm = visual.ImageStim(win=win, name='pic_auc_itm',\u000a        image=dir_path+auction.rand_itm_img, mask=None,\u000a        ori=0, pos=[0, 0], size=None,\u000a        color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a        flipHoriz=False, flipVert=False,\u000a        texRes=128, interpolate=False, depth=0.0)\u000a    auc_txt1 = visual.TextStim(win=win, ori=0, name='auc_txt1',\u000a        text=auction.auc_res_txt, font=u'Arial',\u000a        pos=[0, 0.6], height=0.07, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    auc_txt2 = visual.TextStim(win=win, ori=0, name='auc_txt2',\u000a        text=auction.auc_prc_txt, font=u'Arial',\u000a        pos=[0, -0.6], height=0.07, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a\u000a    #------Prepare to start Routine "auc_disp"-------\u000a    t = 0\u000a    auc_dispClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    key_resp_auc_disp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_auc_disp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    auc_dispComponents = []\u000a    auc_dispComponents.append(pic_auc_itm)\u000a    auc_dispComponents.append(auc_txt1)\u000a    auc_dispComponents.append(auc_txt2)\u000a    for thisComponent in auc_dispComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "auc_disp"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = auc_dispClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *pic_auc_itm* updates\u000a        if t >= 0.2 and pic_auc_itm.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            pic_auc_itm.tStart = t  # underestimates by a little under one frame\u000a            pic_auc_itm.frameNStart = frameN  # exact frame index\u000a            pic_auc_itm.setAutoDraw(True)\u000a        \u000a        # *auc_txt1* updates\u000a        if t >= 0.2 and auc_txt1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            auc_txt1.tStart = t  # underestimates by a little under one frame\u000a            auc_txt1.frameNStart = frameN  # exact frame index\u000a            auc_txt1.setAutoDraw(True)\u000a\u000a        # *auc_txt2* updates\u000a        if t >= 0.2 and auc_txt2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            auc_txt2.tStart = t  # underestimates by a little under one frame\u000a            auc_txt2.frameNStart = frameN  # exact frame index\u000a            auc_txt2.setAutoDraw(True)\u000a        \u000a        # *key_resp_auc_disp* updates\u000a        if t >= 0.2 and key_resp_auc_disp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_auc_disp.tStart = t  # underestimates by a little under one frame\u000a            key_resp_auc_disp.frameNStart = frameN  # exact frame index\u000a            key_resp_auc_disp.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_auc_disp.clock.reset()  # now t=0\u000a        if key_resp_auc_disp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_auc_disp.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_auc_disp.rt = key_resp_auc_disp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in auc_dispComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "auc_disp"-------\u000a    for thisComponent in auc_dispComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_auc_disp.keys in ['', [], None]:  # No response was made\u000a       key_resp_auc_disp.keys=None\u000a    # store data for thisExp (TrialHandler)\u000a    thisExp.addData('auction.win_item', auction.win_item)\u000a    thisExp.addData('auction.price', auction.price)\u000a    thisExp.addData('auction.bid', auction.bid)\u000a    thisExp.addData('auction.rand_itm_img', auction.rand_itm_img)\u000a    thisExp.addData('score.base', score.base)\u000a    thisExp.addData('score.rwrd', score.rwrd)\u000a    thisExp.addData('score.loss', score.loss)\u000a    thisExp.addData('correct_counter', correct_counter)\u000a    thisExp.addData('incorrect_counter', incorrect_counter)\u000a    thisExp.addData('score.final_pymt', score.final_pymt)\u000a    thisExp.nextEntry()\u000a\u000a\u000a    # Initialize components for Routine "pymt_disp"\u000a    pymt_dispClock = core.Clock()\u000a    pymt_disp_txt1 = visual.TextStim(win=win, ori=0, name='pymt_disp_txt1',\u000a        text=score.pymt_expl_bdwn, font=u'Arial',\u000a        pos=[0, 0.6], height=0.07, wrapWidth=1.5,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    pymt_disp_txt2 = visual.TextStim(win=win, ori=0, name='pymt_disp_txt2',\u000a        text=score.pymt_expl_tot, font=u'Arial',\u000a        pos=[0, -0.65], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    #------Prepare to start Routine "pymt_disp"-------\u000a    t = 0\u000a    pymt_dispClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    key_resp_pymt_disp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_pymt_disp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    pymt_dispComponents = []\u000a    pymt_dispComponents.append(pic_auc_itm)\u000a    pymt_dispComponents.append(pymt_disp_txt1)\u000a    pymt_dispComponents.append(pymt_disp_txt2)\u000a    pymt_dispComponents.append(key_resp_pymt_disp)\u000a    for thisComponent in pymt_dispComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "pymt_disp"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = pymt_dispClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        if auction.win_item==True:\u000a            # *pic_auc_itm* updates\u000a            if t >= 0.0 and pic_auc_itm.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                pic_auc_itm.tStart = t  # underestimates by a little under one frame\u000a                pic_auc_itm.frameNStart = frameN  # exact frame index\u000a                pic_auc_itm.setAutoDraw(True)\u000a\u000a        # *pymt_disp_txt1* updates\u000a        if t >= 0.0 and pymt_disp_txt1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            pymt_disp_txt1.tStart = t  # underestimates by a little under one frame\u000a            pymt_disp_txt1.frameNStart = frameN  # exact frame index\u000a            pymt_disp_txt1.setAutoDraw(True)\u000a\u000a        # *pymt_disp_txt2* updates\u000a        if t >= 0.0 and pymt_disp_txt2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            pymt_disp_txt2.tStart = t  # underestimates by a little under one frame\u000a            pymt_disp_txt2.frameNStart = frameN  # exact frame index\u000a            pymt_disp_txt2.setAutoDraw(True)\u000a        \u000a        # *key_resp_pymt_disp* updates\u000a        if t >= 3.0 and key_resp_pymt_disp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_pymt_disp.tStart = t  # underestimates by a little under one frame\u000a            key_resp_pymt_disp.frameNStart = frameN  # exact frame index\u000a            key_resp_pymt_disp.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_pymt_disp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if key_resp_pymt_disp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_pymt_disp.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_pymt_disp.rt = key_resp_pymt_disp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in pymt_dispComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "pymt_disp"-------\u000a    for thisComponent in pymt_dispComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_pymt_disp.keys in ['', [], None]:  # No response was made\u000a       key_resp_pymt_disp.keys=None\u000a\u000aelse: # If S didn't complete the entire binary choice and BDM routines during this session, prompt a manual auction\u000a    # Initialize components for Routine "auc_manual"\u000a    auc_manualClock = core.Clock()\u000a    auc_manual_txt = visual.TextStim(win=win, ori=0, name='auc_manual_txt',\u000a        text=u'Thank you! This completes the experiment. Please get the experimenter, who will run the auction and calculate your final payment.\u005cn\u005cnCorrect: ' + str(correct_counter) + '\u005cnIncorrect: ' + str(incorrect_counter),    font=u'Arial',\u000a        pos=[0, 0], height=0.07, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    #------Prepare to start Routine "auc_manual"-------\u000a    t = 0\u000a    auc_manualClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    auc_manualComponents = []\u000a    auc_manualComponents.append(auc_manual_txt)\u000a    for thisComponent in auc_manualComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "auc_manual"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = auc_manualClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *auc_manual_txt* updates\u000a        if t >= 0.0 and auc_manual_txt.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            auc_manual_txt.tStart = t  # underestimates by a little under one frame\u000a            auc_manual_txt.frameNStart = frameN  # exact frame index\u000a            auc_manual_txt.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in auc_manualComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "auc_manual"-------\u000a    for thisComponent in auc_manualComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000athisExp.nextEntry()\u000a\u000aio.quit() # Close iohub\u000a\u000a\u000awin.close()\u000acore.quit()\u000a
p9338
sg9108
(lp9339
sg9110
I84422992
sg10
S'practice_loop'
p9340
sg6
g9112
sg9113
I1
sg52
I01
sg53
g54
sg9114
g1
(g9115
g9116
(dp9341
g9118
g9119
(g9120
g93
g9121
S'b'
tRp9342
(I1
(I14
I1
tg9123
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg33
g9119
(g9120
g93
g9121
S'b'
tRp9343
(I1
(I14
I1
tg9245
I00
S'@S\xa0\x0chS\xa0\x0c\x80\xc6\x88\x0c\x90S\xa0\x0chS\xa0\x0c\x90S\xa0\x0c\xb0\xc6\x88\x0c\xb8S\xa0\x0c\x10\xc7\x88\x0c@S\xa0\x0c\xe0S\xa0\x0c\x80T\xa0\x0c\xe0S\xa0\x0c\x80\xc6\x88\x0c'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg9126
g9119
(g9120
g93
g9121
S'b'
tRp9344
(I1
(I14
I1
tg9123
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00@\x00\x00@@\x00\x00\x80@\x00\x00\xa0@\x00\x00\xc0@\x00\x00\xe0@\x00\x00\x00A\x00\x00\x10A\x00\x00 A\x00\x000A\x00\x00@A\x00\x00PA'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg34
g9119
(g9120
g93
g9121
S'b'
tRp9345
(I1
(I14
I1
tg9245
I00
S'\xd0\x87\xda\x04\x80\x8c\xda\x04\xa8\x8b\xda\x04@\x8d\xda\x04X\x84\xda\x04\xf8\x83\xda\x04(\x8a\xda\x04\xa8U\x0b\x05\xe0Y\x0b\x05\x18X\x0b\x05hS\x0b\x05\x88Q\x0b\x05hP\x0b\x05\xd8R\x0b\x05'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp9346
(dp9347
g9131
(dp9348
g9118
I01
sg33
I00
sg9126
I01
sg34
I00
ssg9133
g9336
sg9134
(lp9349
g9118
ag9126
ag33
ag34
asg9136
(lp9350
I14
aI1
asbsg9138
g9253
sg9140
g92
(g93
(I0
tS'b'
tRp9351
(I1
(I14
I1
tg99
I00
S'\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00\x04\x00\x00\x00\x05\x00\x00\x00\x06\x00\x00\x00\x07\x00\x00\x00\x08\x00\x00\x00\t\x00\x00\x00\n\x00\x00\x00\x0b\x00\x00\x00\x0c\x00\x00\x00\r\x00\x00\x00'
tbsg9142
I01
sg9143
I1
sg9144
I-1
sg9145
(lp9352
g1
(g9147
g9116
(dp9353
g82
g744
sg83
g745
sg84
g749
sg85
g750
stRp9354
ag1
(g9147
g9116
(dp9355
g82
g756
sg83
g757
sg84
g761
sg85
g762
stRp9356
ag1
(g9147
g9116
(dp9357
g82
g767
sg83
g768
sg84
g772
sg85
g773
stRp9358
ag1
(g9147
g9116
(dp9359
g82
g778
sg83
g779
sg84
g783
sg85
g784
stRp9360
ag1
(g9147
g9116
(dp9361
g82
g756
sg83
g789
sg84
g761
sg85
g793
stRp9362
ag1
(g9147
g9116
(dp9363
g82
g778
sg83
g798
sg84
g783
sg85
g802
stRp9364
ag1
(g9147
g9116
(dp9365
g82
g807
sg83
g808
sg84
g812
sg85
g813
stRp9366
ag1
(g9147
g9116
(dp9367
g82
g818
sg83
g819
sg84
g823
sg85
g824
stRp9368
ag1
(g9147
g9116
(dp9369
g82
g807
sg83
g829
sg84
g812
sg85
g833
stRp9370
ag1
(g9147
g9116
(dp9371
g82
g744
sg83
g838
sg84
g749
sg85
g842
stRp9372
ag1
(g9147
g9116
(dp9373
g82
g847
sg83
g848
sg84
g852
sg85
g853
stRp9374
ag1
(g9147
g9116
(dp9375
g82
g818
sg83
g858
sg84
g823
sg85
g862
stRp9376
ag1
(g9147
g9116
(dp9377
g82
g847
sg83
g867
sg84
g852
sg85
g871
stRp9378
ag1
(g9147
g9116
(dp9379
g82
g767
sg83
g876
sg84
g772
sg85
g880
stRp9380
asg9228
Nsg9229
g882
sg9230
I14
sg9231
I0
sg9232
I14
sg9233
I01
sbag1
(g9103
g3
NtRp9381
(dp9382
g9106
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a\u000a######################## CITATIONS ########################## \u000a##### Binary choice, BDM, auction routines, and instructions are modified from:\u000a##### \u000a##### De Martino, B., Fleming, S. M., Garrett, N., & Dolan, R. J. (2012). Confidence in value-based choice. Nature Neuroscience, 16(1), 105-110. \u000a#####\u000a##### Food item images are original.\u000a\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.80.01), July 16, 2014, at 03:20\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things bdm STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000afrom pyglet.window import key # to detect key state, whether key is held down, to move slider on key hold\u000aimport pandas as pd\u000aimport datetime\u000afrom psychopy.iohub import launchHubServer\u000aimport pylink\u000a\u000a# Initialize IOHub for eye tracker\u000aio=launchHubServer(iohub_config_name='iohub_config.yaml')\u000atracker = io.devices.tracker\u000a\u000a# Store info about the experiment session\u000aexpName = 'infer_design1'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u'', u'eye': u'', u'glasses': u'', u'contacts': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Setup filename for saving\u000afilename = 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# set up variable to track current state of key press, to move slider when keys held down\u000akeyState=key.KeyStateHandler()\u000a\u000a# Setup the Window\u000ascreenwidth = 1920\u000ascreenheight = 1080\u000awin = visual.Window(size=(screenwidth, screenheight), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color='black', colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000awin.winHandle.push_handlers(keyState)\u000a\u000a\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a\u000a######################## COMPONENTS ##########################\u000a\u000a# Set up directory path for stimuli. This avoids us having to put the entire image path in the conditions spreadsheet.\u000adir_path = 'stimuli/itempics/modified/small/'\u000a\u000a# Initialize components for Routine "instr_main"\u000ainstr_mainClock = core.Clock()\u000ainstr_main_txt = visual.TextStim(win=win, ori=0, name='instr_main_txt',\u000a    text=u'Welcome!\u005cn\u005cnPlease read the instructions carefully and get the experimenter when you\u005c're finished. Take as much time as you need.',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "instr_bdm"\u000ainstr_bdmClock = core.Clock()\u000ainstr_bdm_txt = visual.TextStim(win=win, ori=0, name='instr_bdm_txt',\u000a    text=u'The bidding task is about to begin. Use the LEFT and RIGHT arrow keys to move the cursor along the slider, then press the DOWN arrow to enter your bid.\u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "fixation"\u000afixationClock = core.Clock()\u000afixation_text = visual.TextStim(win=win, ori=0, name='fixation_text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "bdm"\u000abdmClock = core.Clock()\u000abdm_pic = visual.ImageStim(win=win, name='bdm_pic',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=0.0)\u000abdm_bid = visual.RatingScale(win=win, name='bdm_bid', marker=u'triangle', markerColor=u'orange', leftKeys=None, rightKeys=None,\u000a    size=1.0, pos=[0.0, -0.6], low=0, high=3, precision=100, labels=[u'\u005cxa30', u'\u005cxa33'],\u000a    scale=u'', markerStart=u'1.5', tickHeight=u'1', showAccept=False, acceptKeys=[u'down', u'return'])\u000a\u000a# Initialize components for Routine "instr_choice"\u000ainstr_choiceClock = core.Clock()\u000ainstr_choice_txt = visual.TextStim(win=win, ori=0, name='instr_choice_txt',\u000a    text=u'The choice task is about to begin. Choose your preferred item by pressing the LEFT or RIGHT arrow keys, then use the slider to indicate how confident you are that you made the best choice.\u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "choice"\u000achoiceClock = core.Clock()\u000achoice_pic_left = visual.ImageStim(win=win, name='choice_pic_left',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[-0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=0.0)\u000achoice_pic_right = visual.ImageStim(win=win, name='choice_pic_right',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=-1.0)\u000a\u000a# Initialize components for Routine "choice_selection"\u000achoice_selectionClock = core.Clock()\u000astar_left_selection = visual.TextStim(win=win, ori=0, name='star_left_selection',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[-0.5, -0.8], height=0.5, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=-2.0)\u000astar_right_selection = visual.TextStim(win=win, ori=0, name='star_right_selection',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[0.5, -0.8], height=0.5, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=-3.0)\u000a\u000a# Initialize components for Routine "confidence"\u000aconfidenceClock = core.Clock()\u000aconfidence_rating = visual.RatingScale(win=win, name='confidence_rating', marker=u'triangle', markerColor=u'orange', leftKeys=None, rightKeys=None,\u000a    size=1.0, pos=[0.0, 0.0], low=1, high=6, precision=20,\u000a    scale=u'', markerStart=u'3.5', tickHeight=u'1', showAccept=False, acceptKeys=[u'down', u'return'])\u000a\u000a# Initialize components for Routine "instr_infer_intro"\u000ainstr_infer_introClock = core.Clock()\u000ainstr_infer_intro_txt = visual.TextStim(win=win, ori=0, name='instr_infer_intro_txt',\u000a    text=u'Thanks! Now please get the experimenter, who will give you the instructions for the second part of the experiment. \u005cn\u005cnPlease read these instructions carefully and get the experimenter again when you\u005c're finished. Take as much time as you need.',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=1.5,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "instr_infer_practice"\u000ainstr_infer_practiceClock = core.Clock()\u000ainstr_infer_practice_txt = visual.TextStim(win=win, ori=0, name='instr_infer_practice_txt',\u000a    text=u'First, you\u005c'll do some practice trials. These are just for you to get used to the task; your responses won\u005c't count. Unlike in the real trials, the choices you will be learning here were generated randomly by a computer.\u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=1.5,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "instr_infer"\u000ainstr_inferClock = core.Clock()\u000ainstr_infer_txt = visual.TextStim(win=win, ori=0, name='instr_infer_txt',\u000a    text=u'Great! Now that you\u005c've done some practice trials, we\u005c're ready to start the real trials. If you have any questions, please get the experimenter now. Otherwise, you can begin whenever you\u005c're ready. \u005cn\u005cnUnlike in the practice trials, the choices you will be learning here were made by an actual person.\u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=1.5,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "get_ready"\u000aget_readyClock = core.Clock()\u000aget_ready_text = visual.TextStim(win=win, ori=0, name='get_ready_text',\u000a    text=u'Get ready!',    font=u'Arial',\u000a    pos=[0, 0], height=0.12, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000aimg_left_infer = visual.ImageStim(win=win, name='img_left_infer',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[-0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=0.0)\u000aimg_right_infer = visual.ImageStim(win=win, name='img_right_infer',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=-1.0)\u000a\u000a# Initialize components for Routine "trial_post_response"\u000atrial_post_responseClock = core.Clock()\u000aselection_arrow_left = visual.TextStim(win=win, ori=0, name='selection_arrow_left',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[-0.5, -0.09], height=0.5, wrapWidth=None,\u000a    color=u'red', colorSpace=u'rgb', opacity=1,\u000a    depth=-2.0)\u000aselection_arrow_right = visual.TextStim(win=win, ori=0, name='selection_arrow_right',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[0.5, -0.09], height=0.5, wrapWidth=None,\u000a    color=u'red', colorSpace=u'rgb', opacity=1,\u000a    depth=-3.0)\u000afeedback_box_left = visual.Rect(win=win, name='feedback_box_left',\u000a    width=[0.9, 0.9][0], height=[0.9, 0.9][1],\u000a    ori=0, pos=[-0.5, 0],\u000a    lineWidth=5, lineColor=u'yellow', lineColorSpace=u'rgb',\u000a    fillColor=None, fillColorSpace=u'rgb',\u000a    opacity=1, depth=-4.0, interpolate=True)\u000afeedback_box_right = visual.Rect(win=win, name='feedback_box_right',\u000a    width=[0.9, 0.9][0], height=[0.9, 0.9][1],\u000a    ori=0, pos=[0.5, 0],\u000a    lineWidth=5, lineColor=u'yellow', lineColorSpace=u'rgb',\u000a    fillColor=None, fillColorSpace=u'rgb',\u000a    opacity=1, depth=-5.0, interpolate=True)\u000a\u000a# Initialize components for Routine "rest_prompt"\u000arest_promptClock = core.Clock()\u000arest_prompt_txt = visual.TextStim(win=win, ori=0, name='rest_prompt_txt',\u000a    text=u'Great! Now take a rest and press the space bar when you\u005cu2019re ready to begin the next block.',    font=u'Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create counters for the number of correct and incorrect guesses made by subjects to determine extra payment.\u000acorrect_counter = 0\u000aincorrect_counter = 0\u000a\u000a# Create list of lists to store binary choice and BDM data to generate food reward at the end of the experiment\u000aprefs = [['left', 'right', 'choice', 'bid']]\u000abids = [['item', 'bid']] # For the bids collected during the first BDM routine, at the beginning of the experiment\u000a\u000a### CHOICE & INFERENCE RANDOMIZATION ###\u000a\u000a# Define two functions to generate constrained pseudorandom sequences of item pair presentations for the binary choice and inference\u000a# parts of the task. The constraint ensures that the same pair of items does not appear twice in a row (flipped or not).\u000a# In the conditions spreadsheet that the item pairs are drawn from, the flipped version of the same item pair is 20\u000a# rows apart.\u000a\u000a# Binary choice randomization\u000adef genseq_choice():\u000a    done = False\u000a    while done==False:\u000a        counter = 0\u000a        ans = np.random.choice(40, 40, replace=False) # Generate a pseudorandom sequence of 40 numbers\u000a        for x in range(1,40):\u000a            if (ans[x]-ans[x-1]) % 20 == 0: # Is the difference between any sequential numbers divisible by 20?\u000a                counter += 1\u000a        if counter==0: # If not, end the loop and return the array\u000a            done = True\u000a            return ans\u000a        else: # If so, continue the loop and try again\u000a            done = False\u000a\u000a# Inference practice block randomization\u000adef genseq_infer_practice():\u000a    done = False\u000a    while done==False:\u000a        counter = 0\u000a        ans = np.random.choice(14, 14, replace=False) # Generate a pseudorandom sequence of 200 numbers\u000a        for x in range(1,14):\u000a            if (ans[x]-ans[x-1]) % 7 == 0: # Is the difference between any sequential numbers divisible by 20?\u000a                counter += 1\u000a        if counter==0: # If not, end the loop and return the array\u000a            done = True\u000a            return ans\u000a        else: # If so, continue the loop and try again\u000a            done = False\u000a\u000a# Inference randomization\u000adef genseq_infer():\u000a    done = False\u000a    while done==False:\u000a        counter = 0\u000a        ans = np.random.choice(200, 200, replace=False) # Generate a pseudorandom sequence of 200 numbers\u000a        for x in range(1,200):\u000a            if (ans[x]-ans[x-1]) % 20 == 0: # Is the difference between any sequential numbers divisible by 20?\u000a                counter += 1\u000a        if counter==0: # If not, end the loop and return the array\u000a            done = True\u000a            return ans\u000a        else: # If so, continue the loop and try again\u000a            done = False\u000a\u000a\u000a# Set independent sequences for each of the two choice blocks, the inference practice block, and the three inference rest blocks. Each rest block contains 10 presentations of\u000a# each pair.\u000a\u000achoiceseq = genseq_choice()\u000apracticeseq = genseq_infer_practice()\u000ablock1seq = genseq_infer()\u000ablock2seq = genseq_infer()\u000ablock3seq = genseq_infer()\u000a\u000a\u000a# Choose a pilot participant whose choices will form the basis of the learning task\u000apartners = ['P1','P2','P3','P4','P5','P6','P8','P9','P10','P11','P12'] # List of pilot participants, P7 excluded for perfectly inconsistent choices\u000apartner = np.random.choice(partners,1) # Choose one at random\u000apartner_file = 'conditions/choices/infer_design1_value_pairs_' + partner[0] + '.csv' # Path to that participant's choice data\u000a\u000a# Create separate CSV files, one for each choice, practice, and rest block, with the item pairs in the pseudorandomly generated order.\u000a# These CSV files will be used as PsychoPy's conditions spreadsheets and run sequentially in the choice, practice, and inference loops below.\u000a\u000a\u000achoicecond_src = pd.read_csv('conditions/choice_design1_binary.csv', index_col=None, header=0)\u000achoicecond = choicecond_src.copy()\u000afor x in range(40):\u000a    seq = choiceseq[x]\u000a    choicecond.iloc[x] = choicecond_src.iloc[seq]\u000achoicecond.to_csv(path_or_buf=filename+'_choicecond.csv', index=False)\u000a\u000apracticecond_src = pd.read_csv('conditions/choices/infer_design1_value_pairs_practice.csv', index_col=None, header=0)\u000apracticecond = practicecond_src.copy()\u000afor x in range(14):\u000a    seq = practiceseq[x]\u000a    practicecond.iloc[x] = practicecond_src.iloc[seq]\u000apracticecond.to_csv(path_or_buf=filename+'_practicecond.csv', index=False)\u000a\u000ablock1cond_src = pd.read_csv(partner_file, index_col=None, header=0)\u000ablock1cond = block1cond_src.copy()\u000afor x in range(200):\u000a    seq = block1seq[x]\u000a    block1cond.iloc[x] = block1cond_src.iloc[seq]\u000ablock1cond.to_csv(path_or_buf=filename+'_block1cond.csv', index=False)\u000a\u000ablock2cond_src = pd.read_csv(partner_file, index_col=None, header=0)\u000ablock2cond = block2cond_src.copy()\u000afor x in range(200):\u000a    seq = block2seq[x]\u000a    block2cond.iloc[x] = block2cond_src.iloc[seq]\u000ablock2cond.to_csv(path_or_buf=filename+'_block2cond.csv', index=False)\u000a\u000ablock3cond_src = pd.read_csv(partner_file, index_col=None, header=0)\u000ablock3cond = block3cond_src.copy()\u000afor x in range(200):\u000a    seq = block3seq[x]\u000a    block3cond.iloc[x] = block3cond_src.iloc[seq]\u000ablock3cond.to_csv(path_or_buf=filename+'_block3cond.csv', index=False)\u000a\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instr_main"-------\u000at = 0\u000ainstr_mainClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_main_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_main_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_mainComponents = []\u000ainstr_mainComponents.append(instr_main_txt)\u000ainstr_mainComponents.append(instr_main_resp)\u000afor thisComponent in instr_mainComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_main"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_mainClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_main_txt* updates\u000a    if t >= 0.0 and instr_main_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_main_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_main_txt.frameNStart = frameN  # exact frame index\u000a        instr_main_txt.setAutoDraw(True)\u000a    \u000a    # *instr_main_resp* updates\u000a    if t >= 5.0 and instr_main_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_main_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_main_resp.frameNStart = frameN  # exact frame index\u000a        instr_main_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_main_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_main_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_main_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_main_resp.rt = instr_main_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_mainComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_main"-------\u000afor thisComponent in instr_mainComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_main_resp.keys in ['', [], None]:  # No response was made\u000a   instr_main_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_main_resp.keys',instr_main_resp.keys)\u000aif instr_main_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_main_resp.rt', instr_main_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a\u000a#------Prepare to start Routine "instr_bdm"-------\u000at = 0\u000ainstr_bdmClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_bdm_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_bdm_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_bdmComponents = []\u000ainstr_bdmComponents.append(instr_bdm_txt)\u000ainstr_bdmComponents.append(instr_bdm_resp)\u000afor thisComponent in instr_bdmComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_bdm"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_bdmClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_bdm_txt* updates\u000a    if t >= 0.0 and instr_bdm_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_bdm_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_bdm_txt.frameNStart = frameN  # exact frame index\u000a        instr_bdm_txt.setAutoDraw(True)\u000a    \u000a    # *instr_bdm_resp* updates\u000a    if t >= 2.0 and instr_bdm_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_bdm_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_bdm_resp.frameNStart = frameN  # exact frame index\u000a        instr_bdm_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_bdm_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_bdm_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space', 's'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_bdm_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_bdm_resp.rt = instr_bdm_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_bdmComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_bdm"-------\u000afor thisComponent in instr_bdmComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_bdm_resp.keys in ['', [], None]:  # No response was made\u000a   instr_bdm_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_bdm_resp.keys',instr_bdm_resp.keys)\u000athisExp.addData('partnered_pilot_participant', partner)\u000aif instr_bdm_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_bdm_resp.rt', instr_bdm_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## BDM LOOP 1 ##########################\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000abdm_loop1 = data.TrialHandler(nReps=1, method=u'random', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'conditions/choice_design1_bdm.xlsx'),\u000a    seed=None, name='bdm_loop1')\u000athisExp.addLoop(bdm_loop1)  # add the loop to the experiment\u000athisbdm_loop1 = bdm_loop1.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisbdm_loop1.rgb)\u000aif thisbdm_loop1 != None:\u000a    for paramName in thisbdm_loop1.keys():\u000a        exec(paramName + '= thisbdm_loop1.' + paramName)\u000a\u000a# Check if the 'skip' key was pressed in the instructions routine; if so, end the loop and move on to the inference task\u000aif instr_bdm_resp.keys=='s':\u000a    bdm_loop1.finished = True\u000a\u000afor thisbdm_loop1 in bdm_loop1:\u000a    currentLoop = bdm_loop1\u000a    # abbreviate parameter names if possible (e.g. rgb = thisbdm_loop1.rgb)\u000a    if thisbdm_loop1 != None:\u000a        for paramName in thisbdm_loop1.keys():\u000a            exec(paramName + '= thisbdm_loop1.' + paramName)\u000a    \u000a    #------Prepare to start Routine "bdm"-------\u000a    t = 0\u000a    bdmClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    bdm_pic.setImage(dir_path+bdm_img)\u000a    bdm_bid.reset()\u000a    # jitter the starting position of the BDM scale from a uniform distribution between 1 and 2, rounded to the nearest decimal place\u000a    bdm_marker_start = float(np.round(np.random.uniform(1, 2, 1)[0], 1))\u000a    bdm_bid.setMarkerPos(bdm_marker_start)\u000a    # keep track of which components have finished\u000a    bdmComponents = []\u000a    bdmComponents.append(fixation_text)\u000a    bdmComponents.append(bdm_pic)\u000a    bdmComponents.append(bdm_bid)\u000a    for thisComponent in bdmComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "bdm"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = bdmClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation_text* updates\u000a        if t >= 0 and fixation_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation_text.tStart = t  # underestimates by a little under one frame\u000a            fixation_text.frameNStart = frameN  # exact frame index\u000a            fixation_text.setAutoDraw(True)\u000a        elif fixation_text.status == STARTED and t>= (0 + (1.0-win.monitorFramePeriod*0.75)):\u000a            fixation_text.setAutoDraw(False)\u000a\u000a        # *bdm_pic* updates\u000a        if t >= 1.0 and bdm_pic.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bdm_pic.tStart = t  # underestimates by a little under one frame\u000a            bdm_pic.frameNStart = frameN  # exact frame index\u000a            bdm_pic.setAutoDraw(True)\u000a        # *bdm_bid* updates\u000a        if t >= 1.0:\u000a            bdm_bid.draw()\u000a            continueRoutine = bdm_bid.noResponse\u000a            if bdm_bid.noResponse == False:\u000a                bdm_bid.response = bdm_bid.getRating()\u000a                bdm_bid.rt = bdm_bid.getRT()\u000a            elif bdm_bid.noResponse==True:\u000a                if keyState[key.LEFT]==True and bdm_bid.markerPlacedAt >0.01:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt - 0.02\u000a                    bdm_bid.draw()\u000a                elif keyState[key.LEFT]==True and bdm_bid.markerPlacedAt==0.01:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt - 0.01\u000a                    bdm_bid.draw()\u000a                elif keyState[key.RIGHT]==True and bdm_bid.markerPlacedAt <2.99:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt + 0.02\u000a                    bdm_bid.draw()\u000a                elif keyState[key.RIGHT]==True and bdm_bid.markerPlacedAt==2.99:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt + 0.01\u000a                    bdm_bid.draw()\u000a                    \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in bdmComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "bdm"-------\u000a    for thisComponent in bdmComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # store data for bdm (TrialHandler)\u000a    bdm_loop1.addData('bdm_bid1.response', bdm_bid.getRating())\u000a    bdm_loop1.addData('bdm_bid1.rt', bdm_bid.getRT())\u000a    bdm_loop1.addData('bdm_marker_start', bdm_marker_start)\u000a\u000a    # Add the item and the subject's bid to the 'bids' list, which will be merged with the 'prefs' list later in order to run the auction\u000a    bids.append([bdm_img, bdm_bid.response])\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeat of 'bdm_loop1'\u000a\u000a\u000a#------Prepare to start Routine "instr_choice"-------\u000at = 0\u000ainstr_choiceClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_choice_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_choice_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_choiceComponents = []\u000ainstr_choiceComponents.append(instr_choice_txt)\u000ainstr_choiceComponents.append(instr_choice_resp)\u000afor thisComponent in instr_choiceComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_choice"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_choiceClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_choice_txt* updates\u000a    if t >= 0.0 and instr_choice_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_choice_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_choice_txt.frameNStart = frameN  # exact frame index\u000a        instr_choice_txt.setAutoDraw(True)\u000a    \u000a    # *instr_choice_resp* updates\u000a    if t >= 2.0 and instr_choice_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_choice_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_choice_resp.frameNStart = frameN  # exact frame index\u000a        instr_choice_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_choice_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_choice_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space', 's'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_choice_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_choice_resp.rt = instr_choice_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_choiceComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_choice"-------\u000afor thisComponent in instr_choiceComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_choice_resp.keys in ['', [], None]:  # No response was made\u000a   instr_choice_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_choice_resp.keys',instr_choice_resp.keys)\u000aif instr_choice_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_choice_resp.rt', instr_choice_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## BINARY LOOP ##########################\u000a\u000a# set up handler to look after randomisation of conditions etc\u000abinary = data.TrialHandler(nReps=1, method=u'sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(filename+'_choicecond.csv'),\u000a    seed=None, name='binary')\u000athisExp.addLoop(binary)  # add the loop to the experiment\u000athisBinary1 = binary.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBinary1.rgb)\u000aif thisBinary1 != None:\u000a    for paramName in thisBinary1.keys():\u000a        exec(paramName + '= thisBinary1.' + paramName)\u000a\u000a# Check if the 'skip' key was pressed in the instructions routine; if so, end the loop and move on to the BDM\u000aif instr_choice_resp.keys=='s':\u000a    binary.finished = True\u000a\u000afor thisBinary1 in binary:\u000a    currentLoop = binary\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBinary1.rgb)\u000a    if thisBinary1 != None:\u000a        for paramName in thisBinary1.keys():\u000a            exec(paramName + '= thisBinary1.' + paramName)\u000a    \u000a    #------Prepare to start Routine "choice"-------\u000a    t = 0\u000a    choiceClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    choice_pic_left.setImage(dir_path+choice_left)\u000a    choice_pic_right.setImage(dir_path+choice_right)\u000a    event.clearEvents(eventType='keyboard') # Clear keyboard event log to avoid last key press from prior loop being used\u000a    key_resp_choice = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_choice.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    choiceComponents = []\u000a    choiceComponents.append(fixation_text)\u000a    choiceComponents.append(choice_pic_left)\u000a    choiceComponents.append(choice_pic_right)\u000a    choiceComponents.append(key_resp_choice)\u000a    for thisComponent in choiceComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    \u000a    #-------Start Routine "choice"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = choiceClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation_text* updates\u000a        if t >= 0 and fixation_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation_text.tStart = t  # underestimates by a little under one frame\u000a            fixation_text.frameNStart = frameN  # exact frame index\u000a            fixation_text.setAutoDraw(True)\u000a        elif fixation_text.status == STARTED and t>= (0 + (1.0-win.monitorFramePeriod*0.75)):\u000a            fixation_text.setAutoDraw(False)\u000a\u000a        # *choice_pic_left* updates\u000a        if t >= 1.0 and choice_pic_left.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_left.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_left.frameNStart = frameN  # exact frame index\u000a            choice_pic_left.setAutoDraw(True)\u000a        \u000a        # *choice_pic_right* updates\u000a        if t >= 1.0 and choice_pic_right.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_right.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_right.frameNStart = frameN  # exact frame index\u000a            choice_pic_right.setAutoDraw(True)\u000a\u000a        # *key_resp_choice* updates\u000a        if t >= 1.0 and key_resp_choice.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_choice.tStart = t  # underestimates by a little under one frame\u000a            key_resp_choice.frameNStart = frameN  # exact frame index\u000a            key_resp_choice.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_choice.clock.reset()  # now t=0\u000a        if key_resp_choice.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_choice.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_choice.rt = key_resp_choice.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in choiceComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "choice"-------\u000a    for thisComponent in choiceComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_choice.keys in ['', [], None]:  # No response was made\u000a       key_resp_choice.keys=None\u000a    # store data for binary (TrialHandler)\u000a    binary.addData('key_resp_choice.keys',key_resp_choice.keys)\u000a    if key_resp_choice.keys != None:  # we had a response\u000a        binary.addData('key_resp_choice.rt', key_resp_choice.rt)\u000a\u000a    # define a function to append binary choices and the bid for the chosen item to the preference list\u000a    # lft is the left image displayed during that choice trial\u000a    # rt is the right image displayed\u000a    def rec_choice(lft, rt): \u000a        bd = False\u000a        if key_resp_choice.keys=='left':\u000a            chc = lft\u000a        elif key_resp_choice.keys=='right':\u000a            chc = rt\u000a        for x in range(len(bids)):\u000a            if bids[x][0]==chc:\u000a                bd = bids[x][1]\u000a        prefs.append([lft, rt, chc, bd])\u000a\u000a    # call the function\u000a    rec_choice(choice_left, choice_right)\u000a    \u000a\u000a    #------Prepare to start Routine "choice_selection"-------\u000a    t = 0\u000a    choice_selectionClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # keep track of which components have finished\u000a    choice_selectionComponents = []\u000a    choice_selectionComponents.append(choice_pic_left)\u000a    choice_selectionComponents.append(choice_pic_right)\u000a    choice_selectionComponents.append(star_left_selection)\u000a    choice_selectionComponents.append(star_right_selection)\u000a    for thisComponent in choice_selectionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "choice_selection"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = choice_selectionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *choice_pic_left* updates\u000a        if t >= 0.0 and choice_pic_left.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_left.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_left.frameNStart = frameN  # exact frame index\u000a            choice_pic_left.setAutoDraw(True)\u000a        elif choice_pic_left.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            choice_pic_left.setAutoDraw(False)\u000a        \u000a        # *choice_pic_right* updates\u000a        if t >= 0.0 and choice_pic_right.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_right.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_right.frameNStart = frameN  # exact frame index\u000a            choice_pic_right.setAutoDraw(True)\u000a        elif choice_pic_right.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            choice_pic_right.setAutoDraw(False)\u000a        \u000a        # *star_left_selection* updates\u000a        if key_resp_choice.keys=='left':\u000a            if t >= 0.0 and star_left_selection.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                star_left_selection.tStart = t  # underestimates by a little under one frame\u000a                star_left_selection.frameNStart = frameN  # exact frame index\u000a                star_left_selection.setAutoDraw(True)\u000a            elif star_left_selection.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                star_left_selection.setAutoDraw(False)\u000a        \u000a        # *star_right_selection* updates\u000a        if key_resp_choice.keys=='right':\u000a            if t >= 0.0 and star_right_selection.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                star_right_selection.tStart = t  # underestimates by a little under one frame\u000a                star_right_selection.frameNStart = frameN  # exact frame index\u000a                star_right_selection.setAutoDraw(True)\u000a            elif star_right_selection.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                star_right_selection.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in choice_selectionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "choice_selection"-------\u000a    for thisComponent in choice_selectionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    #thisExp.nextEntry()\u000a\u000a    #------Prepare to start Routine "confidence"-------\u000a    t = 0\u000a    confidenceClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    confidence_rating.reset()\u000a    # jitter the starting position of the confidence rating scale from a uniform distribution between 1.7 and 3.3 (the middle third of the scale), rounded to the nearest decimal place\u000a    confidence_marker_start = float(np.round(np.random.uniform(1.7, 3.3, 1)[0], 1))\u000a    confidence_rating.setMarkerPos(confidence_marker_start)\u000a    # keep track of which components have finished\u000a    confidenceComponents = []\u000a    confidenceComponents.append(confidence_rating)\u000a    for thisComponent in confidenceComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "confidence"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = confidenceClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *confidence_rating* updates\u000a        if t > 0.5:\u000a            confidence_rating.draw()\u000a            continueRoutine = confidence_rating.noResponse\u000a            if confidence_rating.noResponse == False:\u000a                confidence_rating.response = confidence_rating.getRating()\u000a                confidence_rating.rt = confidence_rating.getRT()\u000a            elif confidence_rating.noResponse==True:\u000a                if keyState[key.LEFT]==True and confidence_rating.markerPlacedAt >0:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt - 0.1\u000a                    confidence_rating.draw()\u000a                elif keyState[key.LEFT]==True and confidence_rating.markerPlacedAt==0.1:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt - 0.1\u000a                    confidence_rating.draw()\u000a                elif keyState[key.RIGHT]==True and confidence_rating.markerPlacedAt <4.9:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt + 0.1\u000a                    confidence_rating.draw()\u000a                elif keyState[key.RIGHT]==True and confidence_rating.markerPlacedAt==4.9:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt + 0.1\u000a                    confidence_rating.draw()\u000a                    \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in confidenceComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "confidence"-------\u000a    for thisComponent in confidenceComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # store data for confidence (TrialHandler)\u000a    binary.addData('confidence_rating1.response', confidence_rating.getRating())\u000a    binary.addData('confidence_rating1.rt', confidence_rating.getRT())\u000a    binary.addData('confidence_marker_start', confidence_marker_start+1) # Add 1 to convert from 0-5 to 1-6 scale\u000a\u000a    thisExp.nextEntry()\u000a\u000a\u000a# completed 1 repeat of 'binary'        \u000a\u000a#------Prepare to start Routine "instr_infer_intro"-------\u000at = 0\u000ainstr_infer_introClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_infer_intro_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_infer_intro_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_infer_introComponents = []\u000ainstr_infer_introComponents.append(instr_infer_intro_txt)\u000ainstr_infer_introComponents.append(instr_infer_intro_resp)\u000afor thisComponent in instr_infer_introComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_infer_intro"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_infer_introClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_infer_intro_txt* updates\u000a    if t >= 0.0 and instr_infer_intro_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_intro_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_intro_txt.frameNStart = frameN  # exact frame index\u000a        instr_infer_intro_txt.setAutoDraw(True)\u000a    \u000a    # *instr_infer_intro_resp* updates\u000a    if t >= 5.0 and instr_infer_intro_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_intro_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_intro_resp.frameNStart = frameN  # exact frame index\u000a        instr_infer_intro_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_infer_intro_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_infer_intro_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_infer_intro_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_infer_intro_resp.rt = instr_infer_intro_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_infer_introComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_infer_intro"-------\u000afor thisComponent in instr_infer_introComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_infer_intro_resp.keys in ['', [], None]:  # No response was made\u000a   instr_infer_intro_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_infer_intro_resp.keys',instr_infer_intro_resp.keys)\u000aif instr_infer_intro_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_infer_intro_resp.rt', instr_infer_intro_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a#------Prepare to start Routine "instr_infer_practice"-------\u000at = 0\u000ainstr_infer_practiceClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_infer_practice_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_infer_practice_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_infer_practiceComponents = []\u000ainstr_infer_practiceComponents.append(instr_infer_practice_txt)\u000ainstr_infer_practiceComponents.append(instr_infer_practice_resp)\u000afor thisComponent in instr_infer_practiceComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_infer_practice"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_infer_practiceClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_infer_practice_txt* updates\u000a    if t >= 0.0 and instr_infer_practice_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_practice_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_practice_txt.frameNStart = frameN  # exact frame index\u000a        instr_infer_practice_txt.setAutoDraw(True)\u000a    \u000a    # *instr_infer_practice_resp* updates\u000a    if t >= 5.0 and instr_infer_practice_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_practice_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_practice_resp.frameNStart = frameN  # exact frame index\u000a        instr_infer_practice_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_infer_practice_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_infer_practice_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_infer_practice_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_infer_practice_resp.rt = instr_infer_practice_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_infer_practiceComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_infer_practice"-------\u000afor thisComponent in instr_infer_practiceComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_infer_practice_resp.keys in ['', [], None]:  # No response was made\u000a   instr_infer_practice_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_infer_practice_resp.keys',instr_infer_practice_resp.keys)\u000aif instr_infer_practice_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_infer_practice_resp.rt', instr_infer_practice_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## PRACTICE LOOP ##########################\u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_loop = data.TrialHandler(nReps=1, method=u'sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(filename+'_practicecond.csv'),\u000a    seed=None, name='practice_loop')\u000athisExp.addLoop(practice_loop)  # add the loop to the experiment\u000athisPractice_loop = practice_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_loop.rgb)\u000aif thisPractice_loop != None:\u000a    for paramName in thisPractice_loop.keys():\u000a        exec(paramName + '= thisPractice_loop.' + paramName)\u000a\u000a  \u000afor thisPractice_loop in practice_loop:\u000a    currentLoop = practice_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_loop.rgb)\u000a    if thisPractice_loop != None:\u000a        for paramName in thisPractice_loop.keys():\u000a            exec(paramName + '= thisPractice_loop.' + paramName)    \u000a    \u000a        \u000a    # Define class for setting the feedback image\u000a    class set_feedback:\u000a        options = ['correct', 'wrong']\u000a        feedback = np.random.choice(options, replace=True, p=[0.8, 0.2])\u000a        if feedback=='correct':\u000a            feedback_img = img_correct\u000a        elif feedback=='wrong':\u000a            feedback_img = img_wrong\u000a\u000a        if feedback_img==img_left:\u000a            feedback_side = 'left'\u000a        elif feedback_img==img_right:\u000a            feedback_side = 'right'\u000a\u000a\u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialtime = datetime.datetime.now()\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    img_left_infer.setImage(dir_path+img_left)\u000a    img_right_infer.setImage(dir_path+img_right)\u000a    infer_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    infer_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(fixation_text)\u000a    trialComponents.append(img_left_infer)\u000a    trialComponents.append(img_right_infer)\u000a    trialComponents.append(infer_resp)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation_text* updates\u000a        if t >= 0 and fixation_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation_text.tStart = t  # underestimates by a little under one frame\u000a            fixation_text.frameNStart = frameN  # exact frame index\u000a            fixation_text.setAutoDraw(True)\u000a        elif fixation_text.status == STARTED and t>= (0 + (2.0-win.monitorFramePeriod*0.75)):\u000a            fixation_text.setAutoDraw(False)\u000a\u000a        # *img_left_infer* updates\u000a        if t >= 2.0 and img_left_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_left_infer.tStart = t  # underestimates by a little under one frame\u000a            img_left_infer.frameNStart = frameN  # exact frame index\u000a            img_left_infer.setAutoDraw(True)\u000a        \u000a        # *img_right_infer* updates\u000a        if t >= 2.0 and img_right_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_right_infer.tStart = t  # underestimates by a little under one frame\u000a            img_right_infer.frameNStart = frameN  # exact frame index\u000a            img_right_infer.setAutoDraw(True)\u000a                  \u000a        # *infer_resp* updates\u000a        if t >= 2.0 and infer_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            infer_resp.tStart = t  # underestimates by a little under one frame\u000a            infer_resp.frameNStart = frameN  # exact frame index\u000a            infer_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            infer_resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if infer_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                infer_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                infer_resp.rt = infer_resp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a\u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if infer_resp.keys in ['', [], None]:  # No response was made\u000a       infer_resp.keys=None\u000a    # # store data for practice_loop (TrialHandler)\u000a    # practice_loop.addData('infer_resp.keys',infer_resp.keys)\u000a    # if infer_resp.keys != None:  # we had a response\u000a    #     practice_loop.addData('infer_resp.rt', infer_resp.rt)\u000a    practice_loop.addData('set_feedback.feedback_img', set_feedback.feedback_img)\u000a    practice_loop.addData('trial_start_time', trialtime)\u000a    \u000a    # # Increase correct and incorrect response counters by 1 based on S's response\u000a    # if infer_resp.keys=='left' and img_correct==img_left:\u000a    #     correct_counter += 1\u000a    # elif infer_resp.keys=='left' and img_correct==img_right:\u000a    #     incorrect_counter += 1\u000a    # elif infer_resp.keys=='right' and img_correct==img_right:\u000a    #     correct_counter += 1\u000a    # elif infer_resp.keys=='right' and img_correct==img_left:\u000a    #     incorrect_counter += 1\u000a    \u000a\u000a    #------Prepare to start Routine "trial_post_response"-------\u000a    t = 0\u000a    trial_post_responseClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(3.000000)\u000a    # keep track of which components have finished\u000a    trial_post_responseComponents = []\u000a    trial_post_responseComponents.append(img_left_infer)\u000a    trial_post_responseComponents.append(img_right_infer)\u000a    trial_post_responseComponents.append(selection_arrow_left)\u000a    trial_post_responseComponents.append(selection_arrow_right)\u000a    trial_post_responseComponents.append(feedback_box_left)\u000a    trial_post_responseComponents.append(feedback_box_right)\u000a    for thisComponent in trial_post_responseComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial_post_response"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = trial_post_responseClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a\u000a        # *img_left_infer* updates\u000a        if t >= 0.0 and img_left_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_left_infer.tStart = t  # underestimates by a little under one frame\u000a            img_left_infer.frameNStart = frameN  # exact frame index\u000a            img_left_infer.setAutoDraw(True)\u000a        elif img_left_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            img_left_infer.setAutoDraw(False)\u000a        \u000a        # *img_right_infer* updates\u000a        if t >= 0.0 and img_right_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_right_infer.tStart = t  # underestimates by a little under one frame\u000a            img_right_infer.frameNStart = frameN  # exact frame index\u000a            img_right_infer.setAutoDraw(True)\u000a        elif img_right_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            img_right_infer.setAutoDraw(False)\u000a        \u000a        if infer_resp.keys == 'left':\u000a            # *selection_arrow_left* updates\u000a            if t >= 0.0 and selection_arrow_left.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                selection_arrow_left.tStart = t  # underestimates by a little under one frame\u000a                selection_arrow_left.frameNStart = frameN  # exact frame index\u000a                selection_arrow_left.setAutoDraw(True)\u000a            elif selection_arrow_left.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                selection_arrow_left.setAutoDraw(False)\u000a        \u000a        if infer_resp.keys == 'right':\u000a            # *selection_arrow_right* updates\u000a            if t >= 0.0 and selection_arrow_right.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                selection_arrow_right.tStart = t  # underestimates by a little under one frame\u000a                selection_arrow_right.frameNStart = frameN  # exact frame index\u000a                selection_arrow_right.setAutoDraw(True)\u000a            elif selection_arrow_right.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                selection_arrow_right.setAutoDraw(False)\u000a        \u000a        if set_feedback.feedback_side == 'left':\u000a            # *feedback_box_left* updates\u000a            if t >= 1.0 and feedback_box_left.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                feedback_box_left.tStart = t  # underestimates by a little under one frame\u000a                feedback_box_left.frameNStart = frameN  # exact frame index\u000a                feedback_box_left.setAutoDraw(True)\u000a            elif feedback_box_left.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                feedback_box_left.setAutoDraw(False)\u000a        \u000a        if set_feedback.feedback_side == 'right':\u000a            # *feedback_box_right* updates\u000a            if t >= 1.0 and feedback_box_right.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                feedback_box_right.tStart = t  # underestimates by a little under one frame\u000a                feedback_box_right.frameNStart = frameN  # exact frame index\u000a                feedback_box_right.setAutoDraw(True)\u000a            elif feedback_box_right.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period right\u000a                feedback_box_right.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trial_post_responseComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "trial_post_response"-------\u000a    for thisComponent in trial_post_responseComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000a    \u000a    thisExp.nextEntry()\u000a                        \u000a# completed 1 repeat of 'practice_loop'\u000a\u000a\u000a#------Prepare to start Routine "instr_infer"-------\u000at = 0\u000ainstr_inferClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_infer_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_infer_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_inferComponents = []\u000ainstr_inferComponents.append(instr_infer_txt)\u000ainstr_inferComponents.append(instr_infer_resp)\u000afor thisComponent in instr_inferComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_infer"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_inferClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_infer_txt* updates\u000a    if t >= 0.0 and instr_infer_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_txt.frameNStart = frameN  # exact frame index\u000a        instr_infer_txt.setAutoDraw(True)\u000a    \u000a    # *instr_infer_resp* updates\u000a    if t >= 5.0 and instr_infer_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_resp.frameNStart = frameN  # exact frame index\u000a        instr_infer_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_infer_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_infer_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_infer_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_infer_resp.rt = instr_infer_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_inferComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_infer"-------\u000afor thisComponent in instr_inferComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_infer_resp.keys in ['', [], None]:  # No response was made\u000a   instr_infer_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_infer_resp.keys',instr_infer_resp.keys)\u000aif instr_infer_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_infer_resp.rt', instr_infer_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## BLOCK LOOP ##########################\u000a\u000a# This loop runs a second nested loop that shows each item pair 10 times, followed by a rest break prompt.\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=3, method=u'sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=[None],\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000a# Set up counter to keep track of block loop cycle, so that the rest prompt is only shown twice\u000ablock_loop_counter = 0\u000a\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    # Increase loop counter by one\u000a    block_loop_counter += 1\u000a    \u000a    # Change the condition file for the feedback block based on which block loop we're on\u000a    condfilename = filename+u'_block'+str(block_loop_counter)+u'cond.csv'\u000a    \u000a    # Minimize the psychopy window so the calibration window can be seen\u000a    win.winHandle.minimize()\u000a    #Do the eye tracker setup at the beginning of each block\u000a    tracker.runSetupProcedure()\u000a    # Re-display the psychopy window after setup is completed\u000a    win.winHandle.maximize()\u000a    win.winHandle.activate()\u000a    \u000a\u000a    \u000a    #------Prepare to start Routine "get_ready"-------\u000a    t = 0\u000a    get_readyClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(3.000000)\u000a    # update component parameters for each repeat\u000a    get_ready_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    get_ready_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    get_readyComponents = []\u000a    get_readyComponents.append(get_ready_text)\u000a    get_readyComponents.append(get_ready_resp)\u000a    for thisComponent in get_readyComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    \u000a    #-------Start Routine "get_ready"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = get_readyClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *get_ready_text* updates\u000a        if t >= 0.0 and get_ready_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            get_ready_text.tStart = t  # underestimates by a little under one frame\u000a            get_ready_text.frameNStart = frameN  # exact frame index\u000a            get_ready_text.setAutoDraw(True)\u000a        \u000a        # *get_ready_resp* updates\u000a        if t >= 0.0 and get_ready_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            get_ready_resp.tStart = t  # underestimates by a little under one frame\u000a            get_ready_resp.frameNStart = frameN  # exact frame index\u000a            get_ready_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            get_ready_resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if get_ready_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['p'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                get_ready_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                get_ready_resp.rt = get_ready_resp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in get_readyComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "get_ready"-------\u000a    for thisComponent in get_readyComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if get_ready_resp.keys in ['', [], None]:  # No response was made\u000a       get_ready_resp.keys=None\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('get_ready_resp.keys',get_ready_resp.keys)\u000a    if get_ready_resp.keys != None:  # we had a response\u000a        thisExp.addData('get_ready_resp.rt', get_ready_resp.rt)\u000a    thisExp.nextEntry()\u000a\u000a    ######################## TRIAL LOOP ##########################\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    trial_loop = data.TrialHandler(nReps=1, method=u'sequential', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(condfilename),\u000a        seed=None, name='trial_loop')\u000a    thisExp.addLoop(trial_loop)  # add the loop to the experiment\u000a    thisTrial_loop = trial_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_loop.rgb)\u000a    if thisTrial_loop != None:\u000a        for paramName in thisTrial_loop.keys():\u000a            exec(paramName + '= thisTrial_loop.' + paramName)\u000a    \u000a      \u000a    for thisTrial_loop in trial_loop:\u000a        currentLoop = trial_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_loop.rgb)\u000a        if thisTrial_loop != None:\u000a            for paramName in thisTrial_loop.keys():\u000a                exec(paramName + '= thisTrial_loop.' + paramName)    \u000a        \u000a            \u000a        # Define class for setting the feedback image\u000a        class set_feedback:\u000a            options = ['correct', 'wrong']\u000a            feedback = np.random.choice(options, replace=True, p=[0.8, 0.2])\u000a            if feedback=='correct':\u000a                feedback_img = img_correct\u000a            elif feedback=='wrong':\u000a                feedback_img = img_wrong\u000a\u000a            if feedback_img==img_left:\u000a                feedback_side = 'left'\u000a            elif feedback_img==img_right:\u000a                feedback_side = 'right'\u000a                        \u000a        # Start getting data from the eye tracker\u000a        tracker.enableEventReporting(True)\u000a        # Send beginning-of-trial messages to eye tracker data file\u000a        trial_number = (block_loop.thisN * 200) + trial_loop.thisTrialN # Trial number out of 599 (starts at 0)\u000a        tracker.sendCommand("record_status_message 'INFERRING, Block %d/3, Trial %d/600 '" % (block_loop.thisN + 1, trial_number + 1))\u000a        tracker.sendMessage("TRIALID %d" % trial_number)\u000a        tracker.sendMessage("!V TRIAL_VAR_DATA %d" % trial_number)\u000a\u000a        \u000a        #------Prepare to start Routine "trial"-------\u000a        t = 0\u000a        trialtime = datetime.datetime.now()\u000a        trialClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        img_left_infer.setImage(dir_path+img_left)\u000a        img_right_infer.setImage(dir_path+img_right)\u000a        infer_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        infer_resp.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trialComponents = []\u000a        trialComponents.append(fixation_text)\u000a        trialComponents.append(img_left_infer)\u000a        trialComponents.append(img_right_infer)\u000a        trialComponents.append(infer_resp)\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        # Set indicator variable for whether eye tracker messages were sent during the first loop of the routine\u000a        eye_sync_messages_sent = 0\u000a        \u000a        #-------Start Routine "trial"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = trialClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *fixation_text* updates\u000a            if t >= 0 and fixation_text.status == NOT_STARTED:\u000a                if eye_sync_messages_sent==0:\u000a                    startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                # keep track of start time/frame for later\u000a                fixation_text.tStart = t  # underestimates by a little under one frame\u000a                fixation_text.frameNStart = frameN  # exact frame index\u000a                fixation_text.setAutoDraw(True)\u000a                if eye_sync_messages_sent==0:\u000a                    drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                    tracker.sendMessage("%d DISPLAY ON" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                    tracker.sendMessage("SYNCTIME %d" %drawTime)\u000a                    eye_sync_messages_sent = 1\u000a            elif fixation_text.status == STARTED and t>= (0 + (2.0-win.monitorFramePeriod*0.75)):\u000a                fixation_text.setAutoDraw(False)\u000a            \u000a            # *img_left_infer* updates\u000a            if t >= 2.0 and img_left_infer.status == NOT_STARTED:\u000a                if eye_sync_messages_sent==1:\u000a                    startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                # keep track of start time/frame for later\u000a                img_left_infer.tStart = t  # underestimates by a little under one frame\u000a                img_left_infer.frameNStart = frameN  # exact frame index\u000a                img_left_infer.setAutoDraw(True)\u000a            \u000a            # *img_right_infer* updates\u000a            if t >= 2.0 and img_right_infer.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                img_right_infer.tStart = t  # underestimates by a little under one frame\u000a                img_right_infer.frameNStart = frameN  # exact frame index\u000a                img_right_infer.setAutoDraw(True)\u000a                if eye_sync_messages_sent==1:\u000a                    drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                    tracker.sendMessage("%d DISPLAY ON ITEMS" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                    eye_sync_messages_sent = 2\u000a                      \u000a            # *infer_resp* updates\u000a            if t >= 2.0 and infer_resp.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                infer_resp.tStart = t  # underestimates by a little under one frame\u000a                infer_resp.frameNStart = frameN  # exact frame index\u000a                infer_resp.status = STARTED\u000a                # keyboard checking is just starting\u000a                infer_resp.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            if infer_resp.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['left', 'right'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    infer_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                    infer_resp.rt = infer_resp.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trialComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                tracker.enableEventReporting(False) # End eye tracker data recording\u000a                tracker.sendMessage("EXPERIMENT ABORTED")\u000a                io.quit() # Close iohub\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial"-------\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if infer_resp.keys in ['', [], None]:  # No response was made\u000a           infer_resp.keys=None\u000a        # store data for trial_loop (TrialHandler)\u000a        trial_loop.addData('infer_resp.keys',infer_resp.keys)\u000a        if infer_resp.keys != None:  # we had a response\u000a            trial_loop.addData('infer_resp.rt', infer_resp.rt)\u000a        trial_loop.addData('set_feedback.feedback_img', set_feedback.feedback_img)\u000a        trial_loop.addData('trial_start_time', trialtime)\u000a        \u000a        # Increase correct and incorrect response counters by 1 based on S's response\u000a        if infer_resp.keys=='left' and img_correct==img_left:\u000a            correct_counter += 1\u000a        elif infer_resp.keys=='left' and img_correct==img_right:\u000a            incorrect_counter += 1\u000a        elif infer_resp.keys=='right' and img_correct==img_right:\u000a            correct_counter += 1\u000a        elif infer_resp.keys=='right' and img_correct==img_left:\u000a            incorrect_counter += 1\u000a        \u000a\u000a        #------Prepare to start Routine "trial_post_response"-------\u000a        t = 0\u000a        trial_post_responseClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(3.000000)\u000a        # keep track of which components have finished\u000a        trial_post_responseComponents = []\u000a        trial_post_responseComponents.append(img_left_infer)\u000a        trial_post_responseComponents.append(img_right_infer)\u000a        trial_post_responseComponents.append(selection_arrow_left)\u000a        trial_post_responseComponents.append(selection_arrow_right)\u000a        trial_post_responseComponents.append(feedback_box_left)\u000a        trial_post_responseComponents.append(feedback_box_right)\u000a        for thisComponent in trial_post_responseComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        # Set indicator variable for whether eye tracker messages were sent during the first loop of the routine\u000a        eye_sync_messages_sent = 0\u000a\u000a        #-------Start Routine "trial_post_response"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = trial_post_responseClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a\u000a            # *img_left_infer* updates\u000a            if t >= 0.0 and img_left_infer.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                img_left_infer.tStart = t  # underestimates by a little under one frame\u000a                img_left_infer.frameNStart = frameN  # exact frame index\u000a                img_left_infer.setAutoDraw(True)\u000a            elif img_left_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                img_left_infer.setAutoDraw(False)\u000a            \u000a            # *img_right_infer* updates\u000a            if t >= 0.0 and img_right_infer.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                img_right_infer.tStart = t  # underestimates by a little under one frame\u000a                img_right_infer.frameNStart = frameN  # exact frame index\u000a                img_right_infer.setAutoDraw(True)\u000a            elif img_right_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                img_right_infer.setAutoDraw(False)\u000a            \u000a            if infer_resp.keys == 'left':\u000a                # *selection_arrow_left* updates\u000a                if t >= 0.0 and selection_arrow_left.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==0:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    selection_arrow_left.tStart = t  # underestimates by a little under one frame\u000a                    selection_arrow_left.frameNStart = frameN  # exact frame index\u000a                    selection_arrow_left.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==0:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        tracker.sendMessage("%d DISPLAY ON SELECTION" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 1\u000a                elif selection_arrow_left.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    if eye_sync_messages_sent==1:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    selection_arrow_left.setAutoDraw(False)\u000a                    if eye_sync_messages_sent==1:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        tracker.sendMessage("%d DISPLAY ON SELECTION OFF" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 2\u000a            \u000a            if infer_resp.keys == 'right':\u000a                # *selection_arrow_right* updates\u000a                if t >= 0.0 and selection_arrow_right.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==0:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    selection_arrow_right.tStart = t  # underestimates by a little under one frame\u000a                    selection_arrow_right.frameNStart = frameN  # exact frame index\u000a                    selection_arrow_right.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==0:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        tracker.sendMessage("%d DISPLAY ON SELECTION" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 1\u000a                elif selection_arrow_right.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    if eye_sync_messages_sent==1:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    selection_arrow_right.setAutoDraw(False)\u000a                    if eye_sync_messages_sent==1:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        tracker.sendMessage("%d DISPLAY ON SELECTION OFF" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 2\u000a            \u000a            if set_feedback.feedback_side == 'left':\u000a                # *feedback_box_left* updates\u000a                if t >= 1.0 and feedback_box_left.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==2:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    feedback_box_left.tStart = t  # underestimates by a little under one frame\u000a                    feedback_box_left.frameNStart = frameN  # exact frame index\u000a                    feedback_box_left.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==2:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        tracker.sendMessage("%d DISPLAY ON FEEDBACK" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 3\u000a                elif feedback_box_left.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    feedback_box_left.setAutoDraw(False)\u000a            \u000a            if set_feedback.feedback_side == 'right':\u000a                # *feedback_box_right* updates\u000a                if t >= 1.0 and feedback_box_right.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==2:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    feedback_box_right.tStart = t  # underestimates by a little under one frame\u000a                    feedback_box_right.frameNStart = frameN  # exact frame index\u000a                    feedback_box_right.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==2:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        tracker.sendMessage("%d DISPLAY ON FEEDBACK" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 3\u000a                elif feedback_box_right.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period right\u000a                    feedback_box_right.setAutoDraw(False)\u000a\u000a\u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial_post_responseComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                tracker.enableEventReporting(False) # End eye tracker data recording\u000a                tracker.sendMessage("EXPERIMENT ABORTED")\u000a                io.quit() # Close iohub\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "trial_post_response"-------\u000a        for thisComponent in trial_post_responseComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a        thisExp.nextEntry()\u000a                            \u000a    # completed 5 repeats of 'trial_loop'\u000a    \u000a    if block_loop_counter <= 2: # If this is the first or second cycle of the loop, display the rest break prompt\u000a\u000a        #------Prepare to start Routine "rest_prompt"-------\u000a        t = 0\u000a        rest_promptClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        rest_prompt_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        rest_prompt_resp.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        rest_promptComponents = []\u000a        rest_promptComponents.append(rest_prompt_txt)\u000a        rest_promptComponents.append(rest_prompt_resp)\u000a        for thisComponent in rest_promptComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a\u000a        #-------Start Routine "rest_prompt"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = rest_promptClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *rest_prompt_txt* updates\u000a            if t >= 0.0 and rest_prompt_txt.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                rest_prompt_txt.tStart = t  # underestimates by a little under one frame\u000a                rest_prompt_txt.frameNStart = frameN  # exact frame index\u000a                rest_prompt_txt.setAutoDraw(True)\u000a            \u000a            # *rest_prompt_resp* updates\u000a            if t >= 2.0 and rest_prompt_resp.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                rest_prompt_resp.tStart = t  # underestimates by a little under one frame\u000a                rest_prompt_resp.frameNStart = frameN  # exact frame index\u000a                rest_prompt_resp.status = STARTED\u000a                # keyboard checking is just starting\u000a                rest_prompt_resp.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            if rest_prompt_resp.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    rest_prompt_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                    rest_prompt_resp.rt = rest_prompt_resp.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in rest_promptComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                tracker.enableEventReporting(False) # End eye tracker data recording\u000a                tracker.sendMessage("EXPERIMENT ABORTED")\u000a                io.quit() # CLose iohub\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a\u000a        #-------Ending Routine "rest_prompt"-------\u000a        for thisComponent in rest_promptComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if rest_prompt_resp.keys in ['', [], None]:  # No response was made\u000a           rest_prompt_resp.keys=None\u000a        # store data for thisExp (ExperimentHandler)\u000a        thisExp.addData('rest_prompt_resp.keys',rest_prompt_resp.keys)\u000a        if rest_prompt_resp.keys != None:  # we had a response\u000a            thisExp.addData('rest_prompt_resp.rt', rest_prompt_resp.rt)\u000a\u000a\u000a    thisExp.nextEntry()\u000a    \u000a# completed 3 repeats of 'block_loop'\u000a\u000a\u000a# store data for total number of correct and incorrect responses    \u000athisExp.addData('correct_counter', correct_counter)\u000athisExp.addData('incorrect_counter', incorrect_counter)\u000athisExp.nextEntry()     \u000a\u000atracker.setConnectionState(False) # Close and transfer eye-tracking data, then close down eye tracker connection\u000a\u000a\u000a######################## AUCTION ##########################\u000a\u000aif len(prefs)==41 and len(bids)==41: # If S completed the entire binary choice and BDM routines, run the auction\u000a\u000a    # run the auction\u000a    class auction:\u000a        rand_itm = randint(1, (len(prefs))) # pick index for S's chosen item from a random choice\u000a        price = float((randint(1, 300)))/100 # assign a price to the item randomly from between 0.01 and 3 pounds\u000a        bid = prefs[rand_itm][3]\u000a        # check if S's bid for that item was above or below the price\u000a        if bid >= price:\u000a            win_item=True\u000a        elif bid < price:\u000a            win_item=False\u000a\u000a        # set text for the auction screen\u000a        if win_item==True:\u000a            auc_res_txt = u'Congratulations! You won the following item at auction. \u005cnThis was your preferred item out of a randomly selected pair from one of the choice tasks.'\u000a            auc_prc_txt = u'Your bid of \u005cxa3' + '{0:.2f}'.format(bid) + u' matched or exceeded the randomly generated price of \u005cxa3' + '{0:.2f}'.format(price) + '.\u005cn\u005cn[Press space bar to continue]'\u000a            cost = price\u000a        elif win_item==False:\u000a            auc_res_txt = u'Sorry, you did not win the following item at auction. \u005cnThis was your preferred item out of a randomly selected pair from one of the choice tasks.'\u000a            auc_prc_txt = u'Your bid of \u005cxa3' + '{0:.2f}'.format(bid) + u' was lower than the randomly generated price of \u005cxa3' + '{0:.2f}'.format(price) + '.\u005cn\u005cn[Press space bar to continue]'\u000a            cost = 0\u000a\u000a        # find the image path of the auction item\u000a        rand_itm_img = prefs[rand_itm][2]\u000a\u000a    # add up each component of S's payment\u000a    class score:\u000a        base = 25\u000a        rwrd = 0.01\u000a        loss = 0\u000a        rwrd_tot = rwrd * correct_counter\u000a        loss_tot = loss * incorrect_counter\u000a        pre_pymt = base + rwrd_tot - loss_tot\u000a        final_pymt = pre_pymt - auction.cost\u000a\u000a        pymt_expl_bdwn = u'\u005cxa3' + '{0:.2f}'.format(base) + u' base payment'+ u'\u005cn+ \u005cxa3' + '{0:.2f}'.format(rwrd_tot) + ' reward for ' + str(correct_counter) + u' correct responses (\u005cxa3' + '{0:.2f}'.format(rwrd) + u' each)' + u'\u005cn- \u005cxa3' + '{0:.2f}'.format(auction.cost) + ' cost of auction item' \u000a        pymt_expl_tot = u'Your total payment is: \u005cxa3' + '{0:.2f}'.format(final_pymt) + '\u005cn\u005cnThank you for participating! Please call the experimenter into the room.'\u000a\u000a\u000a    # Initialize components for Routine "auc_disp"\u000a    auc_dispClock = core.Clock()\u000a    pic_auc_itm = visual.ImageStim(win=win, name='pic_auc_itm',\u000a        image=dir_path+auction.rand_itm_img, mask=None,\u000a        ori=0, pos=[0, 0], size=None,\u000a        color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a        flipHoriz=False, flipVert=False,\u000a        texRes=128, interpolate=False, depth=0.0)\u000a    auc_txt1 = visual.TextStim(win=win, ori=0, name='auc_txt1',\u000a        text=auction.auc_res_txt, font=u'Arial',\u000a        pos=[0, 0.6], height=0.07, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    auc_txt2 = visual.TextStim(win=win, ori=0, name='auc_txt2',\u000a        text=auction.auc_prc_txt, font=u'Arial',\u000a        pos=[0, -0.6], height=0.07, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a\u000a    #------Prepare to start Routine "auc_disp"-------\u000a    t = 0\u000a    auc_dispClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    key_resp_auc_disp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_auc_disp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    auc_dispComponents = []\u000a    auc_dispComponents.append(pic_auc_itm)\u000a    auc_dispComponents.append(auc_txt1)\u000a    auc_dispComponents.append(auc_txt2)\u000a    for thisComponent in auc_dispComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "auc_disp"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = auc_dispClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *pic_auc_itm* updates\u000a        if t >= 0.2 and pic_auc_itm.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            pic_auc_itm.tStart = t  # underestimates by a little under one frame\u000a            pic_auc_itm.frameNStart = frameN  # exact frame index\u000a            pic_auc_itm.setAutoDraw(True)\u000a        \u000a        # *auc_txt1* updates\u000a        if t >= 0.2 and auc_txt1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            auc_txt1.tStart = t  # underestimates by a little under one frame\u000a            auc_txt1.frameNStart = frameN  # exact frame index\u000a            auc_txt1.setAutoDraw(True)\u000a\u000a        # *auc_txt2* updates\u000a        if t >= 0.2 and auc_txt2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            auc_txt2.tStart = t  # underestimates by a little under one frame\u000a            auc_txt2.frameNStart = frameN  # exact frame index\u000a            auc_txt2.setAutoDraw(True)\u000a        \u000a        # *key_resp_auc_disp* updates\u000a        if t >= 0.2 and key_resp_auc_disp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_auc_disp.tStart = t  # underestimates by a little under one frame\u000a            key_resp_auc_disp.frameNStart = frameN  # exact frame index\u000a            key_resp_auc_disp.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_auc_disp.clock.reset()  # now t=0\u000a        if key_resp_auc_disp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_auc_disp.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_auc_disp.rt = key_resp_auc_disp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in auc_dispComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "auc_disp"-------\u000a    for thisComponent in auc_dispComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_auc_disp.keys in ['', [], None]:  # No response was made\u000a       key_resp_auc_disp.keys=None\u000a    # store data for thisExp (TrialHandler)\u000a    thisExp.addData('auction.win_item', auction.win_item)\u000a    thisExp.addData('auction.price', auction.price)\u000a    thisExp.addData('auction.bid', auction.bid)\u000a    thisExp.addData('auction.rand_itm_img', auction.rand_itm_img)\u000a    thisExp.addData('score.base', score.base)\u000a    thisExp.addData('score.rwrd', score.rwrd)\u000a    thisExp.addData('score.loss', score.loss)\u000a    thisExp.addData('correct_counter', correct_counter)\u000a    thisExp.addData('incorrect_counter', incorrect_counter)\u000a    thisExp.addData('score.final_pymt', score.final_pymt)\u000a    thisExp.nextEntry()\u000a\u000a\u000a    # Initialize components for Routine "pymt_disp"\u000a    pymt_dispClock = core.Clock()\u000a    pymt_disp_txt1 = visual.TextStim(win=win, ori=0, name='pymt_disp_txt1',\u000a        text=score.pymt_expl_bdwn, font=u'Arial',\u000a        pos=[0, 0.6], height=0.07, wrapWidth=1.5,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    pymt_disp_txt2 = visual.TextStim(win=win, ori=0, name='pymt_disp_txt2',\u000a        text=score.pymt_expl_tot, font=u'Arial',\u000a        pos=[0, -0.65], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    #------Prepare to start Routine "pymt_disp"-------\u000a    t = 0\u000a    pymt_dispClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    key_resp_pymt_disp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_pymt_disp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    pymt_dispComponents = []\u000a    pymt_dispComponents.append(pic_auc_itm)\u000a    pymt_dispComponents.append(pymt_disp_txt1)\u000a    pymt_dispComponents.append(pymt_disp_txt2)\u000a    pymt_dispComponents.append(key_resp_pymt_disp)\u000a    for thisComponent in pymt_dispComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "pymt_disp"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = pymt_dispClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        if auction.win_item==True:\u000a            # *pic_auc_itm* updates\u000a            if t >= 0.0 and pic_auc_itm.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                pic_auc_itm.tStart = t  # underestimates by a little under one frame\u000a                pic_auc_itm.frameNStart = frameN  # exact frame index\u000a                pic_auc_itm.setAutoDraw(True)\u000a\u000a        # *pymt_disp_txt1* updates\u000a        if t >= 0.0 and pymt_disp_txt1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            pymt_disp_txt1.tStart = t  # underestimates by a little under one frame\u000a            pymt_disp_txt1.frameNStart = frameN  # exact frame index\u000a            pymt_disp_txt1.setAutoDraw(True)\u000a\u000a        # *pymt_disp_txt2* updates\u000a        if t >= 0.0 and pymt_disp_txt2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            pymt_disp_txt2.tStart = t  # underestimates by a little under one frame\u000a            pymt_disp_txt2.frameNStart = frameN  # exact frame index\u000a            pymt_disp_txt2.setAutoDraw(True)\u000a        \u000a        # *key_resp_pymt_disp* updates\u000a        if t >= 3.0 and key_resp_pymt_disp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_pymt_disp.tStart = t  # underestimates by a little under one frame\u000a            key_resp_pymt_disp.frameNStart = frameN  # exact frame index\u000a            key_resp_pymt_disp.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_pymt_disp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if key_resp_pymt_disp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_pymt_disp.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_pymt_disp.rt = key_resp_pymt_disp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in pymt_dispComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "pymt_disp"-------\u000a    for thisComponent in pymt_dispComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_pymt_disp.keys in ['', [], None]:  # No response was made\u000a       key_resp_pymt_disp.keys=None\u000a\u000aelse: # If S didn't complete the entire binary choice and BDM routines during this session, prompt a manual auction\u000a    # Initialize components for Routine "auc_manual"\u000a    auc_manualClock = core.Clock()\u000a    auc_manual_txt = visual.TextStim(win=win, ori=0, name='auc_manual_txt',\u000a        text=u'Thank you! This completes the experiment. Please get the experimenter, who will run the auction and calculate your final payment.\u005cn\u005cnCorrect: ' + str(correct_counter) + '\u005cnIncorrect: ' + str(incorrect_counter),    font=u'Arial',\u000a        pos=[0, 0], height=0.07, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    #------Prepare to start Routine "auc_manual"-------\u000a    t = 0\u000a    auc_manualClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    auc_manualComponents = []\u000a    auc_manualComponents.append(auc_manual_txt)\u000a    for thisComponent in auc_manualComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "auc_manual"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = auc_manualClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *auc_manual_txt* updates\u000a        if t >= 0.0 and auc_manual_txt.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            auc_manual_txt.tStart = t  # underestimates by a little under one frame\u000a            auc_manual_txt.frameNStart = frameN  # exact frame index\u000a            auc_manual_txt.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in auc_manualComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "auc_manual"-------\u000a    for thisComponent in auc_manualComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000athisExp.nextEntry()\u000a\u000aio.quit() # Close iohub\u000a\u000a\u000awin.close()\u000acore.quit()\u000a
p9383
sg9108
(lp9384
sg9110
I84422992
sg10
S'block_loop'
p9385
sg6
g9112
sg9113
I3
sg52
I01
sg53
g54
sg9114
g1
(g9115
g9116
(dp9386
g9118
g9119
(g9120
g93
g9121
S'b'
tRp9387
(I1
(I1
I3
tg9123
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00'
Ntbsg9126
g9119
(g9120
g93
g9121
S'b'
tRp9388
(I1
(I1
I3
tg9123
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00@'
S'\x00\x00\x00'
NtbstRp9389
(dp9390
g9131
(dp9391
g9118
I01
sg9126
I01
ssg9133
g9381
sg9134
(lp9392
g9118
ag9126
asg9136
(lp9393
I1
aI3
asbsg9138
g9253
sg9140
g92
(g93
(I0
tS'b'
tRp9394
(I1
(I1
I3
tg99
I00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
tbsg9142
I01
sg9143
I3
sg9144
I-1
sg9145
(lp9395
Nasg9228
Nsg9229
g6365
sg9230
I3
sg9231
I0
sg9232
I3
sg9233
I01
sbag1
(g9103
g3
NtRp9396
(dp9397
g9106
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a\u000a######################## CITATIONS ########################## \u000a##### Binary choice, BDM, auction routines, and instructions are modified from:\u000a##### \u000a##### De Martino, B., Fleming, S. M., Garrett, N., & Dolan, R. J. (2012). Confidence in value-based choice. Nature Neuroscience, 16(1), 105-110. \u000a#####\u000a##### Food item images are original.\u000a\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.80.01), July 16, 2014, at 03:20\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things bdm STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000afrom pyglet.window import key # to detect key state, whether key is held down, to move slider on key hold\u000aimport pandas as pd\u000aimport datetime\u000afrom psychopy.iohub import launchHubServer\u000aimport pylink\u000a\u000a# Initialize IOHub for eye tracker\u000aio=launchHubServer(iohub_config_name='iohub_config.yaml')\u000atracker = io.devices.tracker\u000a\u000a# Store info about the experiment session\u000aexpName = 'infer_design1'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u'', u'eye': u'', u'glasses': u'', u'contacts': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Setup filename for saving\u000afilename = 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# set up variable to track current state of key press, to move slider when keys held down\u000akeyState=key.KeyStateHandler()\u000a\u000a# Setup the Window\u000ascreenwidth = 1920\u000ascreenheight = 1080\u000awin = visual.Window(size=(screenwidth, screenheight), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color='black', colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000awin.winHandle.push_handlers(keyState)\u000a\u000a\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a\u000a######################## COMPONENTS ##########################\u000a\u000a# Set up directory path for stimuli. This avoids us having to put the entire image path in the conditions spreadsheet.\u000adir_path = 'stimuli/itempics/modified/small/'\u000a\u000a# Initialize components for Routine "instr_main"\u000ainstr_mainClock = core.Clock()\u000ainstr_main_txt = visual.TextStim(win=win, ori=0, name='instr_main_txt',\u000a    text=u'Welcome!\u005cn\u005cnPlease read the instructions carefully and get the experimenter when you\u005c're finished. Take as much time as you need.',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "instr_bdm"\u000ainstr_bdmClock = core.Clock()\u000ainstr_bdm_txt = visual.TextStim(win=win, ori=0, name='instr_bdm_txt',\u000a    text=u'The bidding task is about to begin. Use the LEFT and RIGHT arrow keys to move the cursor along the slider, then press the DOWN arrow to enter your bid.\u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "fixation"\u000afixationClock = core.Clock()\u000afixation_text = visual.TextStim(win=win, ori=0, name='fixation_text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "bdm"\u000abdmClock = core.Clock()\u000abdm_pic = visual.ImageStim(win=win, name='bdm_pic',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=0.0)\u000abdm_bid = visual.RatingScale(win=win, name='bdm_bid', marker=u'triangle', markerColor=u'orange', leftKeys=None, rightKeys=None,\u000a    size=1.0, pos=[0.0, -0.6], low=0, high=3, precision=100, labels=[u'\u005cxa30', u'\u005cxa33'],\u000a    scale=u'', markerStart=u'1.5', tickHeight=u'1', showAccept=False, acceptKeys=[u'down', u'return'])\u000a\u000a# Initialize components for Routine "instr_choice"\u000ainstr_choiceClock = core.Clock()\u000ainstr_choice_txt = visual.TextStim(win=win, ori=0, name='instr_choice_txt',\u000a    text=u'The choice task is about to begin. Choose your preferred item by pressing the LEFT or RIGHT arrow keys, then use the slider to indicate how confident you are that you made the best choice.\u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "choice"\u000achoiceClock = core.Clock()\u000achoice_pic_left = visual.ImageStim(win=win, name='choice_pic_left',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[-0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=0.0)\u000achoice_pic_right = visual.ImageStim(win=win, name='choice_pic_right',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=-1.0)\u000a\u000a# Initialize components for Routine "choice_selection"\u000achoice_selectionClock = core.Clock()\u000astar_left_selection = visual.TextStim(win=win, ori=0, name='star_left_selection',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[-0.5, -0.8], height=0.5, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=-2.0)\u000astar_right_selection = visual.TextStim(win=win, ori=0, name='star_right_selection',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[0.5, -0.8], height=0.5, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=-3.0)\u000a\u000a# Initialize components for Routine "confidence"\u000aconfidenceClock = core.Clock()\u000aconfidence_rating = visual.RatingScale(win=win, name='confidence_rating', marker=u'triangle', markerColor=u'orange', leftKeys=None, rightKeys=None,\u000a    size=1.0, pos=[0.0, 0.0], low=1, high=6, precision=20,\u000a    scale=u'', markerStart=u'3.5', tickHeight=u'1', showAccept=False, acceptKeys=[u'down', u'return'])\u000a\u000a# Initialize components for Routine "instr_infer_intro"\u000ainstr_infer_introClock = core.Clock()\u000ainstr_infer_intro_txt = visual.TextStim(win=win, ori=0, name='instr_infer_intro_txt',\u000a    text=u'Thanks! Now please get the experimenter, who will give you the instructions for the second part of the experiment. \u005cn\u005cnPlease read these instructions carefully and get the experimenter again when you\u005c're finished. Take as much time as you need.',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=1.5,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "instr_infer_practice"\u000ainstr_infer_practiceClock = core.Clock()\u000ainstr_infer_practice_txt = visual.TextStim(win=win, ori=0, name='instr_infer_practice_txt',\u000a    text=u'First, you\u005c'll do some practice trials. These are just for you to get used to the task; your responses won\u005c't count. Unlike in the real trials, the choices you will be learning here were generated randomly by a computer.\u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=1.5,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "instr_infer"\u000ainstr_inferClock = core.Clock()\u000ainstr_infer_txt = visual.TextStim(win=win, ori=0, name='instr_infer_txt',\u000a    text=u'Great! Now that you\u005c've done some practice trials, we\u005c're ready to start the real trials. If you have any questions, please get the experimenter now. Otherwise, you can begin whenever you\u005c're ready. \u005cn\u005cnUnlike in the practice trials, the choices you will be learning here were made by an actual person.\u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=1.5,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "get_ready"\u000aget_readyClock = core.Clock()\u000aget_ready_text = visual.TextStim(win=win, ori=0, name='get_ready_text',\u000a    text=u'Get ready!',    font=u'Arial',\u000a    pos=[0, 0], height=0.12, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000aimg_left_infer = visual.ImageStim(win=win, name='img_left_infer',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[-0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=0.0)\u000aimg_right_infer = visual.ImageStim(win=win, name='img_right_infer',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=-1.0)\u000a\u000a# Initialize components for Routine "trial_post_response"\u000atrial_post_responseClock = core.Clock()\u000aselection_arrow_left = visual.TextStim(win=win, ori=0, name='selection_arrow_left',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[-0.5, -0.09], height=0.5, wrapWidth=None,\u000a    color=u'red', colorSpace=u'rgb', opacity=1,\u000a    depth=-2.0)\u000aselection_arrow_right = visual.TextStim(win=win, ori=0, name='selection_arrow_right',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[0.5, -0.09], height=0.5, wrapWidth=None,\u000a    color=u'red', colorSpace=u'rgb', opacity=1,\u000a    depth=-3.0)\u000afeedback_box_left = visual.Rect(win=win, name='feedback_box_left',\u000a    width=[0.9, 0.9][0], height=[0.9, 0.9][1],\u000a    ori=0, pos=[-0.5, 0],\u000a    lineWidth=5, lineColor=u'yellow', lineColorSpace=u'rgb',\u000a    fillColor=None, fillColorSpace=u'rgb',\u000a    opacity=1, depth=-4.0, interpolate=True)\u000afeedback_box_right = visual.Rect(win=win, name='feedback_box_right',\u000a    width=[0.9, 0.9][0], height=[0.9, 0.9][1],\u000a    ori=0, pos=[0.5, 0],\u000a    lineWidth=5, lineColor=u'yellow', lineColorSpace=u'rgb',\u000a    fillColor=None, fillColorSpace=u'rgb',\u000a    opacity=1, depth=-5.0, interpolate=True)\u000a\u000a# Initialize components for Routine "rest_prompt"\u000arest_promptClock = core.Clock()\u000arest_prompt_txt = visual.TextStim(win=win, ori=0, name='rest_prompt_txt',\u000a    text=u'Great! Now take a rest and press the space bar when you\u005cu2019re ready to begin the next block.',    font=u'Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create counters for the number of correct and incorrect guesses made by subjects to determine extra payment.\u000acorrect_counter = 0\u000aincorrect_counter = 0\u000a\u000a# Create list of lists to store binary choice and BDM data to generate food reward at the end of the experiment\u000aprefs = [['left', 'right', 'choice', 'bid']]\u000abids = [['item', 'bid']] # For the bids collected during the first BDM routine, at the beginning of the experiment\u000a\u000a### CHOICE & INFERENCE RANDOMIZATION ###\u000a\u000a# Define two functions to generate constrained pseudorandom sequences of item pair presentations for the binary choice and inference\u000a# parts of the task. The constraint ensures that the same pair of items does not appear twice in a row (flipped or not).\u000a# In the conditions spreadsheet that the item pairs are drawn from, the flipped version of the same item pair is 20\u000a# rows apart.\u000a\u000a# Binary choice randomization\u000adef genseq_choice():\u000a    done = False\u000a    while done==False:\u000a        counter = 0\u000a        ans = np.random.choice(40, 40, replace=False) # Generate a pseudorandom sequence of 40 numbers\u000a        for x in range(1,40):\u000a            if (ans[x]-ans[x-1]) % 20 == 0: # Is the difference between any sequential numbers divisible by 20?\u000a                counter += 1\u000a        if counter==0: # If not, end the loop and return the array\u000a            done = True\u000a            return ans\u000a        else: # If so, continue the loop and try again\u000a            done = False\u000a\u000a# Inference practice block randomization\u000adef genseq_infer_practice():\u000a    done = False\u000a    while done==False:\u000a        counter = 0\u000a        ans = np.random.choice(14, 14, replace=False) # Generate a pseudorandom sequence of 200 numbers\u000a        for x in range(1,14):\u000a            if (ans[x]-ans[x-1]) % 7 == 0: # Is the difference between any sequential numbers divisible by 20?\u000a                counter += 1\u000a        if counter==0: # If not, end the loop and return the array\u000a            done = True\u000a            return ans\u000a        else: # If so, continue the loop and try again\u000a            done = False\u000a\u000a# Inference randomization\u000adef genseq_infer():\u000a    done = False\u000a    while done==False:\u000a        counter = 0\u000a        ans = np.random.choice(200, 200, replace=False) # Generate a pseudorandom sequence of 200 numbers\u000a        for x in range(1,200):\u000a            if (ans[x]-ans[x-1]) % 20 == 0: # Is the difference between any sequential numbers divisible by 20?\u000a                counter += 1\u000a        if counter==0: # If not, end the loop and return the array\u000a            done = True\u000a            return ans\u000a        else: # If so, continue the loop and try again\u000a            done = False\u000a\u000a\u000a# Set independent sequences for each of the two choice blocks, the inference practice block, and the three inference rest blocks. Each rest block contains 10 presentations of\u000a# each pair.\u000a\u000achoiceseq = genseq_choice()\u000apracticeseq = genseq_infer_practice()\u000ablock1seq = genseq_infer()\u000ablock2seq = genseq_infer()\u000ablock3seq = genseq_infer()\u000a\u000a\u000a# Choose a pilot participant whose choices will form the basis of the learning task\u000apartners = ['P1','P2','P3','P4','P5','P6','P8','P9','P10','P11','P12'] # List of pilot participants, P7 excluded for perfectly inconsistent choices\u000apartner = np.random.choice(partners,1) # Choose one at random\u000apartner_file = 'conditions/choices/infer_design1_value_pairs_' + partner[0] + '.csv' # Path to that participant's choice data\u000a\u000a# Create separate CSV files, one for each choice, practice, and rest block, with the item pairs in the pseudorandomly generated order.\u000a# These CSV files will be used as PsychoPy's conditions spreadsheets and run sequentially in the choice, practice, and inference loops below.\u000a\u000a\u000achoicecond_src = pd.read_csv('conditions/choice_design1_binary.csv', index_col=None, header=0)\u000achoicecond = choicecond_src.copy()\u000afor x in range(40):\u000a    seq = choiceseq[x]\u000a    choicecond.iloc[x] = choicecond_src.iloc[seq]\u000achoicecond.to_csv(path_or_buf=filename+'_choicecond.csv', index=False)\u000a\u000apracticecond_src = pd.read_csv('conditions/choices/infer_design1_value_pairs_practice.csv', index_col=None, header=0)\u000apracticecond = practicecond_src.copy()\u000afor x in range(14):\u000a    seq = practiceseq[x]\u000a    practicecond.iloc[x] = practicecond_src.iloc[seq]\u000apracticecond.to_csv(path_or_buf=filename+'_practicecond.csv', index=False)\u000a\u000ablock1cond_src = pd.read_csv(partner_file, index_col=None, header=0)\u000ablock1cond = block1cond_src.copy()\u000afor x in range(200):\u000a    seq = block1seq[x]\u000a    block1cond.iloc[x] = block1cond_src.iloc[seq]\u000ablock1cond.to_csv(path_or_buf=filename+'_block1cond.csv', index=False)\u000a\u000ablock2cond_src = pd.read_csv(partner_file, index_col=None, header=0)\u000ablock2cond = block2cond_src.copy()\u000afor x in range(200):\u000a    seq = block2seq[x]\u000a    block2cond.iloc[x] = block2cond_src.iloc[seq]\u000ablock2cond.to_csv(path_or_buf=filename+'_block2cond.csv', index=False)\u000a\u000ablock3cond_src = pd.read_csv(partner_file, index_col=None, header=0)\u000ablock3cond = block3cond_src.copy()\u000afor x in range(200):\u000a    seq = block3seq[x]\u000a    block3cond.iloc[x] = block3cond_src.iloc[seq]\u000ablock3cond.to_csv(path_or_buf=filename+'_block3cond.csv', index=False)\u000a\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instr_main"-------\u000at = 0\u000ainstr_mainClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_main_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_main_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_mainComponents = []\u000ainstr_mainComponents.append(instr_main_txt)\u000ainstr_mainComponents.append(instr_main_resp)\u000afor thisComponent in instr_mainComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_main"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_mainClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_main_txt* updates\u000a    if t >= 0.0 and instr_main_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_main_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_main_txt.frameNStart = frameN  # exact frame index\u000a        instr_main_txt.setAutoDraw(True)\u000a    \u000a    # *instr_main_resp* updates\u000a    if t >= 5.0 and instr_main_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_main_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_main_resp.frameNStart = frameN  # exact frame index\u000a        instr_main_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_main_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_main_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_main_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_main_resp.rt = instr_main_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_mainComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_main"-------\u000afor thisComponent in instr_mainComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_main_resp.keys in ['', [], None]:  # No response was made\u000a   instr_main_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_main_resp.keys',instr_main_resp.keys)\u000aif instr_main_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_main_resp.rt', instr_main_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a\u000a#------Prepare to start Routine "instr_bdm"-------\u000at = 0\u000ainstr_bdmClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_bdm_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_bdm_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_bdmComponents = []\u000ainstr_bdmComponents.append(instr_bdm_txt)\u000ainstr_bdmComponents.append(instr_bdm_resp)\u000afor thisComponent in instr_bdmComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_bdm"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_bdmClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_bdm_txt* updates\u000a    if t >= 0.0 and instr_bdm_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_bdm_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_bdm_txt.frameNStart = frameN  # exact frame index\u000a        instr_bdm_txt.setAutoDraw(True)\u000a    \u000a    # *instr_bdm_resp* updates\u000a    if t >= 2.0 and instr_bdm_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_bdm_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_bdm_resp.frameNStart = frameN  # exact frame index\u000a        instr_bdm_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_bdm_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_bdm_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space', 's'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_bdm_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_bdm_resp.rt = instr_bdm_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_bdmComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_bdm"-------\u000afor thisComponent in instr_bdmComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_bdm_resp.keys in ['', [], None]:  # No response was made\u000a   instr_bdm_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_bdm_resp.keys',instr_bdm_resp.keys)\u000athisExp.addData('partnered_pilot_participant', partner)\u000aif instr_bdm_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_bdm_resp.rt', instr_bdm_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## BDM LOOP 1 ##########################\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000abdm_loop1 = data.TrialHandler(nReps=1, method=u'random', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'conditions/choice_design1_bdm.xlsx'),\u000a    seed=None, name='bdm_loop1')\u000athisExp.addLoop(bdm_loop1)  # add the loop to the experiment\u000athisbdm_loop1 = bdm_loop1.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisbdm_loop1.rgb)\u000aif thisbdm_loop1 != None:\u000a    for paramName in thisbdm_loop1.keys():\u000a        exec(paramName + '= thisbdm_loop1.' + paramName)\u000a\u000a# Check if the 'skip' key was pressed in the instructions routine; if so, end the loop and move on to the inference task\u000aif instr_bdm_resp.keys=='s':\u000a    bdm_loop1.finished = True\u000a\u000afor thisbdm_loop1 in bdm_loop1:\u000a    currentLoop = bdm_loop1\u000a    # abbreviate parameter names if possible (e.g. rgb = thisbdm_loop1.rgb)\u000a    if thisbdm_loop1 != None:\u000a        for paramName in thisbdm_loop1.keys():\u000a            exec(paramName + '= thisbdm_loop1.' + paramName)\u000a    \u000a    #------Prepare to start Routine "bdm"-------\u000a    t = 0\u000a    bdmClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    bdm_pic.setImage(dir_path+bdm_img)\u000a    bdm_bid.reset()\u000a    # jitter the starting position of the BDM scale from a uniform distribution between 1 and 2, rounded to the nearest decimal place\u000a    bdm_marker_start = float(np.round(np.random.uniform(1, 2, 1)[0], 1))\u000a    bdm_bid.setMarkerPos(bdm_marker_start)\u000a    # keep track of which components have finished\u000a    bdmComponents = []\u000a    bdmComponents.append(fixation_text)\u000a    bdmComponents.append(bdm_pic)\u000a    bdmComponents.append(bdm_bid)\u000a    for thisComponent in bdmComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "bdm"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = bdmClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation_text* updates\u000a        if t >= 0 and fixation_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation_text.tStart = t  # underestimates by a little under one frame\u000a            fixation_text.frameNStart = frameN  # exact frame index\u000a            fixation_text.setAutoDraw(True)\u000a        elif fixation_text.status == STARTED and t>= (0 + (1.0-win.monitorFramePeriod*0.75)):\u000a            fixation_text.setAutoDraw(False)\u000a\u000a        # *bdm_pic* updates\u000a        if t >= 1.0 and bdm_pic.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bdm_pic.tStart = t  # underestimates by a little under one frame\u000a            bdm_pic.frameNStart = frameN  # exact frame index\u000a            bdm_pic.setAutoDraw(True)\u000a        # *bdm_bid* updates\u000a        if t >= 1.0:\u000a            bdm_bid.draw()\u000a            continueRoutine = bdm_bid.noResponse\u000a            if bdm_bid.noResponse == False:\u000a                bdm_bid.response = bdm_bid.getRating()\u000a                bdm_bid.rt = bdm_bid.getRT()\u000a            elif bdm_bid.noResponse==True:\u000a                if keyState[key.LEFT]==True and bdm_bid.markerPlacedAt >0.01:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt - 0.02\u000a                    bdm_bid.draw()\u000a                elif keyState[key.LEFT]==True and bdm_bid.markerPlacedAt==0.01:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt - 0.01\u000a                    bdm_bid.draw()\u000a                elif keyState[key.RIGHT]==True and bdm_bid.markerPlacedAt <2.99:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt + 0.02\u000a                    bdm_bid.draw()\u000a                elif keyState[key.RIGHT]==True and bdm_bid.markerPlacedAt==2.99:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt + 0.01\u000a                    bdm_bid.draw()\u000a                    \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in bdmComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "bdm"-------\u000a    for thisComponent in bdmComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # store data for bdm (TrialHandler)\u000a    bdm_loop1.addData('bdm_bid1.response', bdm_bid.getRating())\u000a    bdm_loop1.addData('bdm_bid1.rt', bdm_bid.getRT())\u000a    bdm_loop1.addData('bdm_marker_start', bdm_marker_start)\u000a\u000a    # Add the item and the subject's bid to the 'bids' list, which will be merged with the 'prefs' list later in order to run the auction\u000a    bids.append([bdm_img, bdm_bid.response])\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeat of 'bdm_loop1'\u000a\u000a\u000a#------Prepare to start Routine "instr_choice"-------\u000at = 0\u000ainstr_choiceClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_choice_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_choice_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_choiceComponents = []\u000ainstr_choiceComponents.append(instr_choice_txt)\u000ainstr_choiceComponents.append(instr_choice_resp)\u000afor thisComponent in instr_choiceComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_choice"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_choiceClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_choice_txt* updates\u000a    if t >= 0.0 and instr_choice_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_choice_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_choice_txt.frameNStart = frameN  # exact frame index\u000a        instr_choice_txt.setAutoDraw(True)\u000a    \u000a    # *instr_choice_resp* updates\u000a    if t >= 2.0 and instr_choice_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_choice_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_choice_resp.frameNStart = frameN  # exact frame index\u000a        instr_choice_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_choice_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_choice_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space', 's'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_choice_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_choice_resp.rt = instr_choice_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_choiceComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_choice"-------\u000afor thisComponent in instr_choiceComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_choice_resp.keys in ['', [], None]:  # No response was made\u000a   instr_choice_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_choice_resp.keys',instr_choice_resp.keys)\u000aif instr_choice_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_choice_resp.rt', instr_choice_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## BINARY LOOP ##########################\u000a\u000a# set up handler to look after randomisation of conditions etc\u000abinary = data.TrialHandler(nReps=1, method=u'sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(filename+'_choicecond.csv'),\u000a    seed=None, name='binary')\u000athisExp.addLoop(binary)  # add the loop to the experiment\u000athisBinary1 = binary.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBinary1.rgb)\u000aif thisBinary1 != None:\u000a    for paramName in thisBinary1.keys():\u000a        exec(paramName + '= thisBinary1.' + paramName)\u000a\u000a# Check if the 'skip' key was pressed in the instructions routine; if so, end the loop and move on to the BDM\u000aif instr_choice_resp.keys=='s':\u000a    binary.finished = True\u000a\u000afor thisBinary1 in binary:\u000a    currentLoop = binary\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBinary1.rgb)\u000a    if thisBinary1 != None:\u000a        for paramName in thisBinary1.keys():\u000a            exec(paramName + '= thisBinary1.' + paramName)\u000a    \u000a    #------Prepare to start Routine "choice"-------\u000a    t = 0\u000a    choiceClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    choice_pic_left.setImage(dir_path+choice_left)\u000a    choice_pic_right.setImage(dir_path+choice_right)\u000a    event.clearEvents(eventType='keyboard') # Clear keyboard event log to avoid last key press from prior loop being used\u000a    key_resp_choice = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_choice.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    choiceComponents = []\u000a    choiceComponents.append(fixation_text)\u000a    choiceComponents.append(choice_pic_left)\u000a    choiceComponents.append(choice_pic_right)\u000a    choiceComponents.append(key_resp_choice)\u000a    for thisComponent in choiceComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    \u000a    #-------Start Routine "choice"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = choiceClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation_text* updates\u000a        if t >= 0 and fixation_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation_text.tStart = t  # underestimates by a little under one frame\u000a            fixation_text.frameNStart = frameN  # exact frame index\u000a            fixation_text.setAutoDraw(True)\u000a        elif fixation_text.status == STARTED and t>= (0 + (1.0-win.monitorFramePeriod*0.75)):\u000a            fixation_text.setAutoDraw(False)\u000a\u000a        # *choice_pic_left* updates\u000a        if t >= 1.0 and choice_pic_left.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_left.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_left.frameNStart = frameN  # exact frame index\u000a            choice_pic_left.setAutoDraw(True)\u000a        \u000a        # *choice_pic_right* updates\u000a        if t >= 1.0 and choice_pic_right.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_right.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_right.frameNStart = frameN  # exact frame index\u000a            choice_pic_right.setAutoDraw(True)\u000a\u000a        # *key_resp_choice* updates\u000a        if t >= 1.0 and key_resp_choice.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_choice.tStart = t  # underestimates by a little under one frame\u000a            key_resp_choice.frameNStart = frameN  # exact frame index\u000a            key_resp_choice.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_choice.clock.reset()  # now t=0\u000a        if key_resp_choice.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_choice.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_choice.rt = key_resp_choice.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in choiceComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "choice"-------\u000a    for thisComponent in choiceComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_choice.keys in ['', [], None]:  # No response was made\u000a       key_resp_choice.keys=None\u000a    # store data for binary (TrialHandler)\u000a    binary.addData('key_resp_choice.keys',key_resp_choice.keys)\u000a    if key_resp_choice.keys != None:  # we had a response\u000a        binary.addData('key_resp_choice.rt', key_resp_choice.rt)\u000a\u000a    # define a function to append binary choices and the bid for the chosen item to the preference list\u000a    # lft is the left image displayed during that choice trial\u000a    # rt is the right image displayed\u000a    def rec_choice(lft, rt): \u000a        bd = False\u000a        if key_resp_choice.keys=='left':\u000a            chc = lft\u000a        elif key_resp_choice.keys=='right':\u000a            chc = rt\u000a        for x in range(len(bids)):\u000a            if bids[x][0]==chc:\u000a                bd = bids[x][1]\u000a        prefs.append([lft, rt, chc, bd])\u000a\u000a    # call the function\u000a    rec_choice(choice_left, choice_right)\u000a    \u000a\u000a    #------Prepare to start Routine "choice_selection"-------\u000a    t = 0\u000a    choice_selectionClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # keep track of which components have finished\u000a    choice_selectionComponents = []\u000a    choice_selectionComponents.append(choice_pic_left)\u000a    choice_selectionComponents.append(choice_pic_right)\u000a    choice_selectionComponents.append(star_left_selection)\u000a    choice_selectionComponents.append(star_right_selection)\u000a    for thisComponent in choice_selectionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "choice_selection"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = choice_selectionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *choice_pic_left* updates\u000a        if t >= 0.0 and choice_pic_left.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_left.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_left.frameNStart = frameN  # exact frame index\u000a            choice_pic_left.setAutoDraw(True)\u000a        elif choice_pic_left.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            choice_pic_left.setAutoDraw(False)\u000a        \u000a        # *choice_pic_right* updates\u000a        if t >= 0.0 and choice_pic_right.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_right.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_right.frameNStart = frameN  # exact frame index\u000a            choice_pic_right.setAutoDraw(True)\u000a        elif choice_pic_right.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            choice_pic_right.setAutoDraw(False)\u000a        \u000a        # *star_left_selection* updates\u000a        if key_resp_choice.keys=='left':\u000a            if t >= 0.0 and star_left_selection.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                star_left_selection.tStart = t  # underestimates by a little under one frame\u000a                star_left_selection.frameNStart = frameN  # exact frame index\u000a                star_left_selection.setAutoDraw(True)\u000a            elif star_left_selection.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                star_left_selection.setAutoDraw(False)\u000a        \u000a        # *star_right_selection* updates\u000a        if key_resp_choice.keys=='right':\u000a            if t >= 0.0 and star_right_selection.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                star_right_selection.tStart = t  # underestimates by a little under one frame\u000a                star_right_selection.frameNStart = frameN  # exact frame index\u000a                star_right_selection.setAutoDraw(True)\u000a            elif star_right_selection.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                star_right_selection.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in choice_selectionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "choice_selection"-------\u000a    for thisComponent in choice_selectionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    #thisExp.nextEntry()\u000a\u000a    #------Prepare to start Routine "confidence"-------\u000a    t = 0\u000a    confidenceClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    confidence_rating.reset()\u000a    # jitter the starting position of the confidence rating scale from a uniform distribution between 1.7 and 3.3 (the middle third of the scale), rounded to the nearest decimal place\u000a    confidence_marker_start = float(np.round(np.random.uniform(1.7, 3.3, 1)[0], 1))\u000a    confidence_rating.setMarkerPos(confidence_marker_start)\u000a    # keep track of which components have finished\u000a    confidenceComponents = []\u000a    confidenceComponents.append(confidence_rating)\u000a    for thisComponent in confidenceComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "confidence"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = confidenceClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *confidence_rating* updates\u000a        if t > 0.5:\u000a            confidence_rating.draw()\u000a            continueRoutine = confidence_rating.noResponse\u000a            if confidence_rating.noResponse == False:\u000a                confidence_rating.response = confidence_rating.getRating()\u000a                confidence_rating.rt = confidence_rating.getRT()\u000a            elif confidence_rating.noResponse==True:\u000a                if keyState[key.LEFT]==True and confidence_rating.markerPlacedAt >0:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt - 0.1\u000a                    confidence_rating.draw()\u000a                elif keyState[key.LEFT]==True and confidence_rating.markerPlacedAt==0.1:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt - 0.1\u000a                    confidence_rating.draw()\u000a                elif keyState[key.RIGHT]==True and confidence_rating.markerPlacedAt <4.9:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt + 0.1\u000a                    confidence_rating.draw()\u000a                elif keyState[key.RIGHT]==True and confidence_rating.markerPlacedAt==4.9:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt + 0.1\u000a                    confidence_rating.draw()\u000a                    \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in confidenceComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "confidence"-------\u000a    for thisComponent in confidenceComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # store data for confidence (TrialHandler)\u000a    binary.addData('confidence_rating1.response', confidence_rating.getRating())\u000a    binary.addData('confidence_rating1.rt', confidence_rating.getRT())\u000a    binary.addData('confidence_marker_start', confidence_marker_start+1) # Add 1 to convert from 0-5 to 1-6 scale\u000a\u000a    thisExp.nextEntry()\u000a\u000a\u000a# completed 1 repeat of 'binary'        \u000a\u000a#------Prepare to start Routine "instr_infer_intro"-------\u000at = 0\u000ainstr_infer_introClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_infer_intro_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_infer_intro_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_infer_introComponents = []\u000ainstr_infer_introComponents.append(instr_infer_intro_txt)\u000ainstr_infer_introComponents.append(instr_infer_intro_resp)\u000afor thisComponent in instr_infer_introComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_infer_intro"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_infer_introClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_infer_intro_txt* updates\u000a    if t >= 0.0 and instr_infer_intro_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_intro_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_intro_txt.frameNStart = frameN  # exact frame index\u000a        instr_infer_intro_txt.setAutoDraw(True)\u000a    \u000a    # *instr_infer_intro_resp* updates\u000a    if t >= 5.0 and instr_infer_intro_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_intro_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_intro_resp.frameNStart = frameN  # exact frame index\u000a        instr_infer_intro_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_infer_intro_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_infer_intro_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_infer_intro_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_infer_intro_resp.rt = instr_infer_intro_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_infer_introComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_infer_intro"-------\u000afor thisComponent in instr_infer_introComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_infer_intro_resp.keys in ['', [], None]:  # No response was made\u000a   instr_infer_intro_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_infer_intro_resp.keys',instr_infer_intro_resp.keys)\u000aif instr_infer_intro_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_infer_intro_resp.rt', instr_infer_intro_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a#------Prepare to start Routine "instr_infer_practice"-------\u000at = 0\u000ainstr_infer_practiceClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_infer_practice_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_infer_practice_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_infer_practiceComponents = []\u000ainstr_infer_practiceComponents.append(instr_infer_practice_txt)\u000ainstr_infer_practiceComponents.append(instr_infer_practice_resp)\u000afor thisComponent in instr_infer_practiceComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_infer_practice"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_infer_practiceClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_infer_practice_txt* updates\u000a    if t >= 0.0 and instr_infer_practice_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_practice_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_practice_txt.frameNStart = frameN  # exact frame index\u000a        instr_infer_practice_txt.setAutoDraw(True)\u000a    \u000a    # *instr_infer_practice_resp* updates\u000a    if t >= 5.0 and instr_infer_practice_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_practice_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_practice_resp.frameNStart = frameN  # exact frame index\u000a        instr_infer_practice_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_infer_practice_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_infer_practice_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_infer_practice_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_infer_practice_resp.rt = instr_infer_practice_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_infer_practiceComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_infer_practice"-------\u000afor thisComponent in instr_infer_practiceComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_infer_practice_resp.keys in ['', [], None]:  # No response was made\u000a   instr_infer_practice_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_infer_practice_resp.keys',instr_infer_practice_resp.keys)\u000aif instr_infer_practice_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_infer_practice_resp.rt', instr_infer_practice_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## PRACTICE LOOP ##########################\u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_loop = data.TrialHandler(nReps=1, method=u'sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(filename+'_practicecond.csv'),\u000a    seed=None, name='practice_loop')\u000athisExp.addLoop(practice_loop)  # add the loop to the experiment\u000athisPractice_loop = practice_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_loop.rgb)\u000aif thisPractice_loop != None:\u000a    for paramName in thisPractice_loop.keys():\u000a        exec(paramName + '= thisPractice_loop.' + paramName)\u000a\u000a  \u000afor thisPractice_loop in practice_loop:\u000a    currentLoop = practice_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_loop.rgb)\u000a    if thisPractice_loop != None:\u000a        for paramName in thisPractice_loop.keys():\u000a            exec(paramName + '= thisPractice_loop.' + paramName)    \u000a    \u000a        \u000a    # Define class for setting the feedback image\u000a    class set_feedback:\u000a        options = ['correct', 'wrong']\u000a        feedback = np.random.choice(options, replace=True, p=[0.8, 0.2])\u000a        if feedback=='correct':\u000a            feedback_img = img_correct\u000a        elif feedback=='wrong':\u000a            feedback_img = img_wrong\u000a\u000a        if feedback_img==img_left:\u000a            feedback_side = 'left'\u000a        elif feedback_img==img_right:\u000a            feedback_side = 'right'\u000a\u000a\u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialtime = datetime.datetime.now()\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    img_left_infer.setImage(dir_path+img_left)\u000a    img_right_infer.setImage(dir_path+img_right)\u000a    infer_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    infer_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(fixation_text)\u000a    trialComponents.append(img_left_infer)\u000a    trialComponents.append(img_right_infer)\u000a    trialComponents.append(infer_resp)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation_text* updates\u000a        if t >= 0 and fixation_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation_text.tStart = t  # underestimates by a little under one frame\u000a            fixation_text.frameNStart = frameN  # exact frame index\u000a            fixation_text.setAutoDraw(True)\u000a        elif fixation_text.status == STARTED and t>= (0 + (2.0-win.monitorFramePeriod*0.75)):\u000a            fixation_text.setAutoDraw(False)\u000a\u000a        # *img_left_infer* updates\u000a        if t >= 2.0 and img_left_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_left_infer.tStart = t  # underestimates by a little under one frame\u000a            img_left_infer.frameNStart = frameN  # exact frame index\u000a            img_left_infer.setAutoDraw(True)\u000a        \u000a        # *img_right_infer* updates\u000a        if t >= 2.0 and img_right_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_right_infer.tStart = t  # underestimates by a little under one frame\u000a            img_right_infer.frameNStart = frameN  # exact frame index\u000a            img_right_infer.setAutoDraw(True)\u000a                  \u000a        # *infer_resp* updates\u000a        if t >= 2.0 and infer_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            infer_resp.tStart = t  # underestimates by a little under one frame\u000a            infer_resp.frameNStart = frameN  # exact frame index\u000a            infer_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            infer_resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if infer_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                infer_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                infer_resp.rt = infer_resp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a\u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if infer_resp.keys in ['', [], None]:  # No response was made\u000a       infer_resp.keys=None\u000a    # # store data for practice_loop (TrialHandler)\u000a    # practice_loop.addData('infer_resp.keys',infer_resp.keys)\u000a    # if infer_resp.keys != None:  # we had a response\u000a    #     practice_loop.addData('infer_resp.rt', infer_resp.rt)\u000a    practice_loop.addData('set_feedback.feedback_img', set_feedback.feedback_img)\u000a    practice_loop.addData('trial_start_time', trialtime)\u000a    \u000a    # # Increase correct and incorrect response counters by 1 based on S's response\u000a    # if infer_resp.keys=='left' and img_correct==img_left:\u000a    #     correct_counter += 1\u000a    # elif infer_resp.keys=='left' and img_correct==img_right:\u000a    #     incorrect_counter += 1\u000a    # elif infer_resp.keys=='right' and img_correct==img_right:\u000a    #     correct_counter += 1\u000a    # elif infer_resp.keys=='right' and img_correct==img_left:\u000a    #     incorrect_counter += 1\u000a    \u000a\u000a    #------Prepare to start Routine "trial_post_response"-------\u000a    t = 0\u000a    trial_post_responseClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(3.000000)\u000a    # keep track of which components have finished\u000a    trial_post_responseComponents = []\u000a    trial_post_responseComponents.append(img_left_infer)\u000a    trial_post_responseComponents.append(img_right_infer)\u000a    trial_post_responseComponents.append(selection_arrow_left)\u000a    trial_post_responseComponents.append(selection_arrow_right)\u000a    trial_post_responseComponents.append(feedback_box_left)\u000a    trial_post_responseComponents.append(feedback_box_right)\u000a    for thisComponent in trial_post_responseComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial_post_response"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = trial_post_responseClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a\u000a        # *img_left_infer* updates\u000a        if t >= 0.0 and img_left_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_left_infer.tStart = t  # underestimates by a little under one frame\u000a            img_left_infer.frameNStart = frameN  # exact frame index\u000a            img_left_infer.setAutoDraw(True)\u000a        elif img_left_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            img_left_infer.setAutoDraw(False)\u000a        \u000a        # *img_right_infer* updates\u000a        if t >= 0.0 and img_right_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_right_infer.tStart = t  # underestimates by a little under one frame\u000a            img_right_infer.frameNStart = frameN  # exact frame index\u000a            img_right_infer.setAutoDraw(True)\u000a        elif img_right_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            img_right_infer.setAutoDraw(False)\u000a        \u000a        if infer_resp.keys == 'left':\u000a            # *selection_arrow_left* updates\u000a            if t >= 0.0 and selection_arrow_left.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                selection_arrow_left.tStart = t  # underestimates by a little under one frame\u000a                selection_arrow_left.frameNStart = frameN  # exact frame index\u000a                selection_arrow_left.setAutoDraw(True)\u000a            elif selection_arrow_left.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                selection_arrow_left.setAutoDraw(False)\u000a        \u000a        if infer_resp.keys == 'right':\u000a            # *selection_arrow_right* updates\u000a            if t >= 0.0 and selection_arrow_right.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                selection_arrow_right.tStart = t  # underestimates by a little under one frame\u000a                selection_arrow_right.frameNStart = frameN  # exact frame index\u000a                selection_arrow_right.setAutoDraw(True)\u000a            elif selection_arrow_right.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                selection_arrow_right.setAutoDraw(False)\u000a        \u000a        if set_feedback.feedback_side == 'left':\u000a            # *feedback_box_left* updates\u000a            if t >= 1.0 and feedback_box_left.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                feedback_box_left.tStart = t  # underestimates by a little under one frame\u000a                feedback_box_left.frameNStart = frameN  # exact frame index\u000a                feedback_box_left.setAutoDraw(True)\u000a            elif feedback_box_left.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                feedback_box_left.setAutoDraw(False)\u000a        \u000a        if set_feedback.feedback_side == 'right':\u000a            # *feedback_box_right* updates\u000a            if t >= 1.0 and feedback_box_right.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                feedback_box_right.tStart = t  # underestimates by a little under one frame\u000a                feedback_box_right.frameNStart = frameN  # exact frame index\u000a                feedback_box_right.setAutoDraw(True)\u000a            elif feedback_box_right.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period right\u000a                feedback_box_right.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trial_post_responseComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "trial_post_response"-------\u000a    for thisComponent in trial_post_responseComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000a    \u000a    thisExp.nextEntry()\u000a                        \u000a# completed 1 repeat of 'practice_loop'\u000a\u000a\u000a#------Prepare to start Routine "instr_infer"-------\u000at = 0\u000ainstr_inferClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_infer_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_infer_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_inferComponents = []\u000ainstr_inferComponents.append(instr_infer_txt)\u000ainstr_inferComponents.append(instr_infer_resp)\u000afor thisComponent in instr_inferComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_infer"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_inferClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_infer_txt* updates\u000a    if t >= 0.0 and instr_infer_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_txt.frameNStart = frameN  # exact frame index\u000a        instr_infer_txt.setAutoDraw(True)\u000a    \u000a    # *instr_infer_resp* updates\u000a    if t >= 5.0 and instr_infer_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_resp.frameNStart = frameN  # exact frame index\u000a        instr_infer_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_infer_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_infer_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_infer_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_infer_resp.rt = instr_infer_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_inferComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_infer"-------\u000afor thisComponent in instr_inferComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_infer_resp.keys in ['', [], None]:  # No response was made\u000a   instr_infer_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_infer_resp.keys',instr_infer_resp.keys)\u000aif instr_infer_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_infer_resp.rt', instr_infer_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## BLOCK LOOP ##########################\u000a\u000a# This loop runs a second nested loop that shows each item pair 10 times, followed by a rest break prompt.\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=3, method=u'sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=[None],\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000a# Set up counter to keep track of block loop cycle, so that the rest prompt is only shown twice\u000ablock_loop_counter = 0\u000a\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    # Increase loop counter by one\u000a    block_loop_counter += 1\u000a    \u000a    # Change the condition file for the feedback block based on which block loop we're on\u000a    condfilename = filename+u'_block'+str(block_loop_counter)+u'cond.csv'\u000a    \u000a    # Minimize the psychopy window so the calibration window can be seen\u000a    win.winHandle.minimize()\u000a    #Do the eye tracker setup at the beginning of each block\u000a    tracker.runSetupProcedure()\u000a    # Re-display the psychopy window after setup is completed\u000a    win.winHandle.maximize()\u000a    win.winHandle.activate()\u000a    \u000a\u000a    \u000a    #------Prepare to start Routine "get_ready"-------\u000a    t = 0\u000a    get_readyClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(3.000000)\u000a    # update component parameters for each repeat\u000a    get_ready_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    get_ready_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    get_readyComponents = []\u000a    get_readyComponents.append(get_ready_text)\u000a    get_readyComponents.append(get_ready_resp)\u000a    for thisComponent in get_readyComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    \u000a    #-------Start Routine "get_ready"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = get_readyClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *get_ready_text* updates\u000a        if t >= 0.0 and get_ready_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            get_ready_text.tStart = t  # underestimates by a little under one frame\u000a            get_ready_text.frameNStart = frameN  # exact frame index\u000a            get_ready_text.setAutoDraw(True)\u000a        \u000a        # *get_ready_resp* updates\u000a        if t >= 0.0 and get_ready_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            get_ready_resp.tStart = t  # underestimates by a little under one frame\u000a            get_ready_resp.frameNStart = frameN  # exact frame index\u000a            get_ready_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            get_ready_resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if get_ready_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['p'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                get_ready_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                get_ready_resp.rt = get_ready_resp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in get_readyComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "get_ready"-------\u000a    for thisComponent in get_readyComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if get_ready_resp.keys in ['', [], None]:  # No response was made\u000a       get_ready_resp.keys=None\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('get_ready_resp.keys',get_ready_resp.keys)\u000a    if get_ready_resp.keys != None:  # we had a response\u000a        thisExp.addData('get_ready_resp.rt', get_ready_resp.rt)\u000a    thisExp.nextEntry()\u000a\u000a    ######################## TRIAL LOOP ##########################\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    trial_loop = data.TrialHandler(nReps=1, method=u'sequential', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(condfilename),\u000a        seed=None, name='trial_loop')\u000a    thisExp.addLoop(trial_loop)  # add the loop to the experiment\u000a    thisTrial_loop = trial_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_loop.rgb)\u000a    if thisTrial_loop != None:\u000a        for paramName in thisTrial_loop.keys():\u000a            exec(paramName + '= thisTrial_loop.' + paramName)\u000a    \u000a      \u000a    for thisTrial_loop in trial_loop:\u000a        currentLoop = trial_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_loop.rgb)\u000a        if thisTrial_loop != None:\u000a            for paramName in thisTrial_loop.keys():\u000a                exec(paramName + '= thisTrial_loop.' + paramName)    \u000a        \u000a            \u000a        # Define class for setting the feedback image\u000a        class set_feedback:\u000a            options = ['correct', 'wrong']\u000a            feedback = np.random.choice(options, replace=True, p=[0.8, 0.2])\u000a            if feedback=='correct':\u000a                feedback_img = img_correct\u000a            elif feedback=='wrong':\u000a                feedback_img = img_wrong\u000a\u000a            if feedback_img==img_left:\u000a                feedback_side = 'left'\u000a            elif feedback_img==img_right:\u000a                feedback_side = 'right'\u000a                        \u000a        # Start getting data from the eye tracker\u000a        tracker.enableEventReporting(True)\u000a        # Send beginning-of-trial messages to eye tracker data file\u000a        trial_number = (block_loop.thisN * 200) + trial_loop.thisTrialN # Trial number out of 599 (starts at 0)\u000a        tracker.sendCommand("record_status_message 'INFERRING, Block %d/3, Trial %d/600 '" % (block_loop.thisN + 1, trial_number + 1))\u000a        tracker.sendMessage("TRIALID %d" % trial_number)\u000a        tracker.sendMessage("!V TRIAL_VAR_DATA %d" % trial_number)\u000a\u000a        \u000a        #------Prepare to start Routine "trial"-------\u000a        t = 0\u000a        trialtime = datetime.datetime.now()\u000a        trialClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        img_left_infer.setImage(dir_path+img_left)\u000a        img_right_infer.setImage(dir_path+img_right)\u000a        infer_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        infer_resp.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trialComponents = []\u000a        trialComponents.append(fixation_text)\u000a        trialComponents.append(img_left_infer)\u000a        trialComponents.append(img_right_infer)\u000a        trialComponents.append(infer_resp)\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        # Set indicator variable for whether eye tracker messages were sent during the first loop of the routine\u000a        eye_sync_messages_sent = 0\u000a        \u000a        #-------Start Routine "trial"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = trialClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *fixation_text* updates\u000a            if t >= 0 and fixation_text.status == NOT_STARTED:\u000a                if eye_sync_messages_sent==0:\u000a                    startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                # keep track of start time/frame for later\u000a                fixation_text.tStart = t  # underestimates by a little under one frame\u000a                fixation_text.frameNStart = frameN  # exact frame index\u000a                fixation_text.setAutoDraw(True)\u000a                if eye_sync_messages_sent==0:\u000a                    drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                    tracker.sendMessage("%d DISPLAY ON" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                    tracker.sendMessage("SYNCTIME %d" %drawTime)\u000a                    eye_sync_messages_sent = 1\u000a            elif fixation_text.status == STARTED and t>= (0 + (2.0-win.monitorFramePeriod*0.75)):\u000a                fixation_text.setAutoDraw(False)\u000a            \u000a            # *img_left_infer* updates\u000a            if t >= 2.0 and img_left_infer.status == NOT_STARTED:\u000a                if eye_sync_messages_sent==1:\u000a                    startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                # keep track of start time/frame for later\u000a                img_left_infer.tStart = t  # underestimates by a little under one frame\u000a                img_left_infer.frameNStart = frameN  # exact frame index\u000a                img_left_infer.setAutoDraw(True)\u000a            \u000a            # *img_right_infer* updates\u000a            if t >= 2.0 and img_right_infer.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                img_right_infer.tStart = t  # underestimates by a little under one frame\u000a                img_right_infer.frameNStart = frameN  # exact frame index\u000a                img_right_infer.setAutoDraw(True)\u000a                if eye_sync_messages_sent==1:\u000a                    drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                    tracker.sendMessage("%d DISPLAY ON ITEMS" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                    eye_sync_messages_sent = 2\u000a                      \u000a            # *infer_resp* updates\u000a            if t >= 2.0 and infer_resp.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                infer_resp.tStart = t  # underestimates by a little under one frame\u000a                infer_resp.frameNStart = frameN  # exact frame index\u000a                infer_resp.status = STARTED\u000a                # keyboard checking is just starting\u000a                infer_resp.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            if infer_resp.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['left', 'right'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    infer_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                    infer_resp.rt = infer_resp.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trialComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                tracker.enableEventReporting(False) # End eye tracker data recording\u000a                tracker.sendMessage("EXPERIMENT ABORTED")\u000a                io.quit() # Close iohub\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial"-------\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if infer_resp.keys in ['', [], None]:  # No response was made\u000a           infer_resp.keys=None\u000a        # store data for trial_loop (TrialHandler)\u000a        trial_loop.addData('infer_resp.keys',infer_resp.keys)\u000a        if infer_resp.keys != None:  # we had a response\u000a            trial_loop.addData('infer_resp.rt', infer_resp.rt)\u000a        trial_loop.addData('set_feedback.feedback_img', set_feedback.feedback_img)\u000a        trial_loop.addData('trial_start_time', trialtime)\u000a        \u000a        # Increase correct and incorrect response counters by 1 based on S's response\u000a        if infer_resp.keys=='left' and img_correct==img_left:\u000a            correct_counter += 1\u000a        elif infer_resp.keys=='left' and img_correct==img_right:\u000a            incorrect_counter += 1\u000a        elif infer_resp.keys=='right' and img_correct==img_right:\u000a            correct_counter += 1\u000a        elif infer_resp.keys=='right' and img_correct==img_left:\u000a            incorrect_counter += 1\u000a        \u000a\u000a        #------Prepare to start Routine "trial_post_response"-------\u000a        t = 0\u000a        trial_post_responseClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(3.000000)\u000a        # keep track of which components have finished\u000a        trial_post_responseComponents = []\u000a        trial_post_responseComponents.append(img_left_infer)\u000a        trial_post_responseComponents.append(img_right_infer)\u000a        trial_post_responseComponents.append(selection_arrow_left)\u000a        trial_post_responseComponents.append(selection_arrow_right)\u000a        trial_post_responseComponents.append(feedback_box_left)\u000a        trial_post_responseComponents.append(feedback_box_right)\u000a        for thisComponent in trial_post_responseComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        # Set indicator variable for whether eye tracker messages were sent during the first loop of the routine\u000a        eye_sync_messages_sent = 0\u000a\u000a        #-------Start Routine "trial_post_response"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = trial_post_responseClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a\u000a            # *img_left_infer* updates\u000a            if t >= 0.0 and img_left_infer.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                img_left_infer.tStart = t  # underestimates by a little under one frame\u000a                img_left_infer.frameNStart = frameN  # exact frame index\u000a                img_left_infer.setAutoDraw(True)\u000a            elif img_left_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                img_left_infer.setAutoDraw(False)\u000a            \u000a            # *img_right_infer* updates\u000a            if t >= 0.0 and img_right_infer.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                img_right_infer.tStart = t  # underestimates by a little under one frame\u000a                img_right_infer.frameNStart = frameN  # exact frame index\u000a                img_right_infer.setAutoDraw(True)\u000a            elif img_right_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                img_right_infer.setAutoDraw(False)\u000a            \u000a            if infer_resp.keys == 'left':\u000a                # *selection_arrow_left* updates\u000a                if t >= 0.0 and selection_arrow_left.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==0:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    selection_arrow_left.tStart = t  # underestimates by a little under one frame\u000a                    selection_arrow_left.frameNStart = frameN  # exact frame index\u000a                    selection_arrow_left.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==0:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        tracker.sendMessage("%d DISPLAY ON SELECTION" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 1\u000a                elif selection_arrow_left.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    if eye_sync_messages_sent==1:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    selection_arrow_left.setAutoDraw(False)\u000a                    if eye_sync_messages_sent==1:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        tracker.sendMessage("%d DISPLAY ON SELECTION OFF" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 2\u000a            \u000a            if infer_resp.keys == 'right':\u000a                # *selection_arrow_right* updates\u000a                if t >= 0.0 and selection_arrow_right.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==0:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    selection_arrow_right.tStart = t  # underestimates by a little under one frame\u000a                    selection_arrow_right.frameNStart = frameN  # exact frame index\u000a                    selection_arrow_right.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==0:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        tracker.sendMessage("%d DISPLAY ON SELECTION" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 1\u000a                elif selection_arrow_right.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    if eye_sync_messages_sent==1:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    selection_arrow_right.setAutoDraw(False)\u000a                    if eye_sync_messages_sent==1:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        tracker.sendMessage("%d DISPLAY ON SELECTION OFF" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 2\u000a            \u000a            if set_feedback.feedback_side == 'left':\u000a                # *feedback_box_left* updates\u000a                if t >= 1.0 and feedback_box_left.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==2:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    feedback_box_left.tStart = t  # underestimates by a little under one frame\u000a                    feedback_box_left.frameNStart = frameN  # exact frame index\u000a                    feedback_box_left.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==2:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        tracker.sendMessage("%d DISPLAY ON FEEDBACK" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 3\u000a                elif feedback_box_left.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    feedback_box_left.setAutoDraw(False)\u000a            \u000a            if set_feedback.feedback_side == 'right':\u000a                # *feedback_box_right* updates\u000a                if t >= 1.0 and feedback_box_right.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==2:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    feedback_box_right.tStart = t  # underestimates by a little under one frame\u000a                    feedback_box_right.frameNStart = frameN  # exact frame index\u000a                    feedback_box_right.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==2:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        tracker.sendMessage("%d DISPLAY ON FEEDBACK" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 3\u000a                elif feedback_box_right.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period right\u000a                    feedback_box_right.setAutoDraw(False)\u000a\u000a\u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial_post_responseComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                tracker.enableEventReporting(False) # End eye tracker data recording\u000a                tracker.sendMessage("EXPERIMENT ABORTED")\u000a                io.quit() # Close iohub\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "trial_post_response"-------\u000a        for thisComponent in trial_post_responseComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a        thisExp.nextEntry()\u000a                            \u000a    # completed 5 repeats of 'trial_loop'\u000a    \u000a    if block_loop_counter <= 2: # If this is the first or second cycle of the loop, display the rest break prompt\u000a\u000a        #------Prepare to start Routine "rest_prompt"-------\u000a        t = 0\u000a        rest_promptClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        rest_prompt_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        rest_prompt_resp.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        rest_promptComponents = []\u000a        rest_promptComponents.append(rest_prompt_txt)\u000a        rest_promptComponents.append(rest_prompt_resp)\u000a        for thisComponent in rest_promptComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a\u000a        #-------Start Routine "rest_prompt"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = rest_promptClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *rest_prompt_txt* updates\u000a            if t >= 0.0 and rest_prompt_txt.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                rest_prompt_txt.tStart = t  # underestimates by a little under one frame\u000a                rest_prompt_txt.frameNStart = frameN  # exact frame index\u000a                rest_prompt_txt.setAutoDraw(True)\u000a            \u000a            # *rest_prompt_resp* updates\u000a            if t >= 2.0 and rest_prompt_resp.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                rest_prompt_resp.tStart = t  # underestimates by a little under one frame\u000a                rest_prompt_resp.frameNStart = frameN  # exact frame index\u000a                rest_prompt_resp.status = STARTED\u000a                # keyboard checking is just starting\u000a                rest_prompt_resp.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            if rest_prompt_resp.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    rest_prompt_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                    rest_prompt_resp.rt = rest_prompt_resp.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in rest_promptComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                tracker.enableEventReporting(False) # End eye tracker data recording\u000a                tracker.sendMessage("EXPERIMENT ABORTED")\u000a                io.quit() # CLose iohub\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a\u000a        #-------Ending Routine "rest_prompt"-------\u000a        for thisComponent in rest_promptComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if rest_prompt_resp.keys in ['', [], None]:  # No response was made\u000a           rest_prompt_resp.keys=None\u000a        # store data for thisExp (ExperimentHandler)\u000a        thisExp.addData('rest_prompt_resp.keys',rest_prompt_resp.keys)\u000a        if rest_prompt_resp.keys != None:  # we had a response\u000a            thisExp.addData('rest_prompt_resp.rt', rest_prompt_resp.rt)\u000a\u000a\u000a    thisExp.nextEntry()\u000a    \u000a# completed 3 repeats of 'block_loop'\u000a\u000a\u000a# store data for total number of correct and incorrect responses    \u000athisExp.addData('correct_counter', correct_counter)\u000athisExp.addData('incorrect_counter', incorrect_counter)\u000athisExp.nextEntry()     \u000a\u000atracker.setConnectionState(False) # Close and transfer eye-tracking data, then close down eye tracker connection\u000a\u000a\u000a######################## AUCTION ##########################\u000a\u000aif len(prefs)==41 and len(bids)==41: # If S completed the entire binary choice and BDM routines, run the auction\u000a\u000a    # run the auction\u000a    class auction:\u000a        rand_itm = randint(1, (len(prefs))) # pick index for S's chosen item from a random choice\u000a        price = float((randint(1, 300)))/100 # assign a price to the item randomly from between 0.01 and 3 pounds\u000a        bid = prefs[rand_itm][3]\u000a        # check if S's bid for that item was above or below the price\u000a        if bid >= price:\u000a            win_item=True\u000a        elif bid < price:\u000a            win_item=False\u000a\u000a        # set text for the auction screen\u000a        if win_item==True:\u000a            auc_res_txt = u'Congratulations! You won the following item at auction. \u005cnThis was your preferred item out of a randomly selected pair from one of the choice tasks.'\u000a            auc_prc_txt = u'Your bid of \u005cxa3' + '{0:.2f}'.format(bid) + u' matched or exceeded the randomly generated price of \u005cxa3' + '{0:.2f}'.format(price) + '.\u005cn\u005cn[Press space bar to continue]'\u000a            cost = price\u000a        elif win_item==False:\u000a            auc_res_txt = u'Sorry, you did not win the following item at auction. \u005cnThis was your preferred item out of a randomly selected pair from one of the choice tasks.'\u000a            auc_prc_txt = u'Your bid of \u005cxa3' + '{0:.2f}'.format(bid) + u' was lower than the randomly generated price of \u005cxa3' + '{0:.2f}'.format(price) + '.\u005cn\u005cn[Press space bar to continue]'\u000a            cost = 0\u000a\u000a        # find the image path of the auction item\u000a        rand_itm_img = prefs[rand_itm][2]\u000a\u000a    # add up each component of S's payment\u000a    class score:\u000a        base = 25\u000a        rwrd = 0.01\u000a        loss = 0\u000a        rwrd_tot = rwrd * correct_counter\u000a        loss_tot = loss * incorrect_counter\u000a        pre_pymt = base + rwrd_tot - loss_tot\u000a        final_pymt = pre_pymt - auction.cost\u000a\u000a        pymt_expl_bdwn = u'\u005cxa3' + '{0:.2f}'.format(base) + u' base payment'+ u'\u005cn+ \u005cxa3' + '{0:.2f}'.format(rwrd_tot) + ' reward for ' + str(correct_counter) + u' correct responses (\u005cxa3' + '{0:.2f}'.format(rwrd) + u' each)' + u'\u005cn- \u005cxa3' + '{0:.2f}'.format(auction.cost) + ' cost of auction item' \u000a        pymt_expl_tot = u'Your total payment is: \u005cxa3' + '{0:.2f}'.format(final_pymt) + '\u005cn\u005cnThank you for participating! Please call the experimenter into the room.'\u000a\u000a\u000a    # Initialize components for Routine "auc_disp"\u000a    auc_dispClock = core.Clock()\u000a    pic_auc_itm = visual.ImageStim(win=win, name='pic_auc_itm',\u000a        image=dir_path+auction.rand_itm_img, mask=None,\u000a        ori=0, pos=[0, 0], size=None,\u000a        color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a        flipHoriz=False, flipVert=False,\u000a        texRes=128, interpolate=False, depth=0.0)\u000a    auc_txt1 = visual.TextStim(win=win, ori=0, name='auc_txt1',\u000a        text=auction.auc_res_txt, font=u'Arial',\u000a        pos=[0, 0.6], height=0.07, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    auc_txt2 = visual.TextStim(win=win, ori=0, name='auc_txt2',\u000a        text=auction.auc_prc_txt, font=u'Arial',\u000a        pos=[0, -0.6], height=0.07, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a\u000a    #------Prepare to start Routine "auc_disp"-------\u000a    t = 0\u000a    auc_dispClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    key_resp_auc_disp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_auc_disp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    auc_dispComponents = []\u000a    auc_dispComponents.append(pic_auc_itm)\u000a    auc_dispComponents.append(auc_txt1)\u000a    auc_dispComponents.append(auc_txt2)\u000a    for thisComponent in auc_dispComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "auc_disp"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = auc_dispClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *pic_auc_itm* updates\u000a        if t >= 0.2 and pic_auc_itm.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            pic_auc_itm.tStart = t  # underestimates by a little under one frame\u000a            pic_auc_itm.frameNStart = frameN  # exact frame index\u000a            pic_auc_itm.setAutoDraw(True)\u000a        \u000a        # *auc_txt1* updates\u000a        if t >= 0.2 and auc_txt1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            auc_txt1.tStart = t  # underestimates by a little under one frame\u000a            auc_txt1.frameNStart = frameN  # exact frame index\u000a            auc_txt1.setAutoDraw(True)\u000a\u000a        # *auc_txt2* updates\u000a        if t >= 0.2 and auc_txt2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            auc_txt2.tStart = t  # underestimates by a little under one frame\u000a            auc_txt2.frameNStart = frameN  # exact frame index\u000a            auc_txt2.setAutoDraw(True)\u000a        \u000a        # *key_resp_auc_disp* updates\u000a        if t >= 0.2 and key_resp_auc_disp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_auc_disp.tStart = t  # underestimates by a little under one frame\u000a            key_resp_auc_disp.frameNStart = frameN  # exact frame index\u000a            key_resp_auc_disp.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_auc_disp.clock.reset()  # now t=0\u000a        if key_resp_auc_disp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_auc_disp.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_auc_disp.rt = key_resp_auc_disp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in auc_dispComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "auc_disp"-------\u000a    for thisComponent in auc_dispComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_auc_disp.keys in ['', [], None]:  # No response was made\u000a       key_resp_auc_disp.keys=None\u000a    # store data for thisExp (TrialHandler)\u000a    thisExp.addData('auction.win_item', auction.win_item)\u000a    thisExp.addData('auction.price', auction.price)\u000a    thisExp.addData('auction.bid', auction.bid)\u000a    thisExp.addData('auction.rand_itm_img', auction.rand_itm_img)\u000a    thisExp.addData('score.base', score.base)\u000a    thisExp.addData('score.rwrd', score.rwrd)\u000a    thisExp.addData('score.loss', score.loss)\u000a    thisExp.addData('correct_counter', correct_counter)\u000a    thisExp.addData('incorrect_counter', incorrect_counter)\u000a    thisExp.addData('score.final_pymt', score.final_pymt)\u000a    thisExp.nextEntry()\u000a\u000a\u000a    # Initialize components for Routine "pymt_disp"\u000a    pymt_dispClock = core.Clock()\u000a    pymt_disp_txt1 = visual.TextStim(win=win, ori=0, name='pymt_disp_txt1',\u000a        text=score.pymt_expl_bdwn, font=u'Arial',\u000a        pos=[0, 0.6], height=0.07, wrapWidth=1.5,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    pymt_disp_txt2 = visual.TextStim(win=win, ori=0, name='pymt_disp_txt2',\u000a        text=score.pymt_expl_tot, font=u'Arial',\u000a        pos=[0, -0.65], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    #------Prepare to start Routine "pymt_disp"-------\u000a    t = 0\u000a    pymt_dispClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    key_resp_pymt_disp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_pymt_disp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    pymt_dispComponents = []\u000a    pymt_dispComponents.append(pic_auc_itm)\u000a    pymt_dispComponents.append(pymt_disp_txt1)\u000a    pymt_dispComponents.append(pymt_disp_txt2)\u000a    pymt_dispComponents.append(key_resp_pymt_disp)\u000a    for thisComponent in pymt_dispComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "pymt_disp"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = pymt_dispClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        if auction.win_item==True:\u000a            # *pic_auc_itm* updates\u000a            if t >= 0.0 and pic_auc_itm.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                pic_auc_itm.tStart = t  # underestimates by a little under one frame\u000a                pic_auc_itm.frameNStart = frameN  # exact frame index\u000a                pic_auc_itm.setAutoDraw(True)\u000a\u000a        # *pymt_disp_txt1* updates\u000a        if t >= 0.0 and pymt_disp_txt1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            pymt_disp_txt1.tStart = t  # underestimates by a little under one frame\u000a            pymt_disp_txt1.frameNStart = frameN  # exact frame index\u000a            pymt_disp_txt1.setAutoDraw(True)\u000a\u000a        # *pymt_disp_txt2* updates\u000a        if t >= 0.0 and pymt_disp_txt2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            pymt_disp_txt2.tStart = t  # underestimates by a little under one frame\u000a            pymt_disp_txt2.frameNStart = frameN  # exact frame index\u000a            pymt_disp_txt2.setAutoDraw(True)\u000a        \u000a        # *key_resp_pymt_disp* updates\u000a        if t >= 3.0 and key_resp_pymt_disp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_pymt_disp.tStart = t  # underestimates by a little under one frame\u000a            key_resp_pymt_disp.frameNStart = frameN  # exact frame index\u000a            key_resp_pymt_disp.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_pymt_disp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if key_resp_pymt_disp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_pymt_disp.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_pymt_disp.rt = key_resp_pymt_disp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in pymt_dispComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "pymt_disp"-------\u000a    for thisComponent in pymt_dispComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_pymt_disp.keys in ['', [], None]:  # No response was made\u000a       key_resp_pymt_disp.keys=None\u000a\u000aelse: # If S didn't complete the entire binary choice and BDM routines during this session, prompt a manual auction\u000a    # Initialize components for Routine "auc_manual"\u000a    auc_manualClock = core.Clock()\u000a    auc_manual_txt = visual.TextStim(win=win, ori=0, name='auc_manual_txt',\u000a        text=u'Thank you! This completes the experiment. Please get the experimenter, who will run the auction and calculate your final payment.\u005cn\u005cnCorrect: ' + str(correct_counter) + '\u005cnIncorrect: ' + str(incorrect_counter),    font=u'Arial',\u000a        pos=[0, 0], height=0.07, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    #------Prepare to start Routine "auc_manual"-------\u000a    t = 0\u000a    auc_manualClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    auc_manualComponents = []\u000a    auc_manualComponents.append(auc_manual_txt)\u000a    for thisComponent in auc_manualComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "auc_manual"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = auc_manualClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *auc_manual_txt* updates\u000a        if t >= 0.0 and auc_manual_txt.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            auc_manual_txt.tStart = t  # underestimates by a little under one frame\u000a            auc_manual_txt.frameNStart = frameN  # exact frame index\u000a            auc_manual_txt.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in auc_manualComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "auc_manual"-------\u000a    for thisComponent in auc_manualComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000athisExp.nextEntry()\u000a\u000aio.quit() # Close iohub\u000a\u000a\u000awin.close()\u000acore.quit()\u000a
p9398
sg9108
(lp9399
sg9110
I84422992
sg10
S'trial_loop'
p9400
sg6
g9112
sg9113
I1
sg52
I01
sg53
g54
sg9114
g1
(g9115
g9116
(dp9401
g33
g9119
(g9120
g93
g9121
S'b'
tRp9402
(I1
(I200
I1
tg9245
I00
S'PV\xa2\x0c@W\xa2\x0c\x00\xff\xa1\x0cxr\xa2\x0c8\xff\xa1\x0c\xa0r\xa2\x0cXt\xa2\x0c\xf0r\xa2\x0c8\xff\xa1\x0c\xa0`\xf6\x0bxr\xa2\x0c\xc8r\xa2\x0c\x80V\xa2\x0c\xc8r\xa2\x0cp\xff\xa1\x0c\x00\xff\xa1\x0c\x18s\xa2\x0c\xb0V\xa2\x0c\xe0V\xa2\x0cxr\xa2\x0c\xf0r\xa2\x0c@W\xa2\x0c\xa0W\xa2\x0c a\xf6\x0b\x10W\xa2\x0c8\xff\xa1\x0c\xb0V\xa2\x0c\xa0r\xa2\x0c\x00\xff\xa1\x0c\xa0r\xa2\x0c\x80V\xa2\x0c\xa0`\xf6\x0b\x00\xff\xa1\x0c\x80V\xa2\x0cxr\xa2\x0c\xa8t\xa2\x0c\x80\xe6\xf5\x0b@W\xa2\x0cPV\xa2\x0c@s\xa2\x0c\xb0V\xa2\x0c\x80t\xa2\x0c\xf0r\xa2\x0chs\xa2\x0cpW\xa2\x0cxr\xa2\x0c\x18s\xa2\x0c\x08t\xa2\x0c\x90s\xa2\x0c\xa0`\xf6\x0b\xe0V\xa2\x0c\xa0`\xf6\x0b\x90s\xa2\x0c a\xf6\x0b0X\xa2\x0cpW\xa2\x0c\xa8t\xa2\x0c\x00X\xa2\x0c\xf0r\xa2\x0c\xc8r\xa2\x0c\xb0V\xa2\x0c0t\xa2\x0c@W\xa2\x0c\x80V\xa2\x0cPV\xa2\x0c@s\xa2\x0cPV\xa2\x0cX\x80\xa2\x0c\xc8\xfe\xa1\x0c a\xf6\x0b\x00X\xa2\x0c@\xe4\xf5\x0b\xb0V\xa2\x0c\xe0V\xa2\x0c\x90s\xa2\x0c@o\xf6\x0b`\xe8\xf5\x0b\xd0W\xa2\x0cxr\xa2\x0c@W\xa2\x0c\x80V\xa2\x0c8\xff\xa1\x0c\xa0`\xf6\x0b\x00\xff\xa1\x0cp\xff\xa1\x0c\xe0s\xa2\x0cXt\xa2\x0c\x10W\xa2\x0c\x00\xff\xa1\x0c@s\xa2\x0c@\xe4\xf5\x0b\x10W\xa2\x0c\x90s\xa2\x0c\xe0s\xa2\x0cX\x80\xa2\x0c\x18s\xa2\x0c\xe0V\xa2\x0c\xa8\xff\xa1\x0c a\xf6\x0b\xf0r\xa2\x0c\xa0`\xf6\x0b`\xe8\xf5\x0b\x18s\xa2\x0cPV\xa2\x0c\xc8r\xa2\x0c\xb0V\xa2\x0c\xa0r\xa2\x0cXt\xa2\x0c\xa0r\xa2\x0c\x18s\xa2\x0chs\xa2\x0c\xe0V\xa2\x0c@\xe4\xf5\x0b@s\xa2\x0c\xc8r\xa2\x0c\x08t\xa2\x0c8\xff\xa1\x0c a\xf6\x0b\xa0r\xa2\x0c\x90s\xa2\x0c@s\xa2\x0c\xa0`\xf6\x0b\xa0r\xa2\x0cp\xff\xa1\x0c\xf0r\xa2\x0c\x90s\xa2\x0c8\xff\xa1\x0c\xa0`\xf6\x0bhs\xa2\x0c8\xff\xa1\x0cp\xff\xa1\x0c\x10W\xa2\x0c a\xf6\x0b\xe0s\xa2\x0c\xc8r\xa2\x0c\xe0V\xa2\x0c0X\xa2\x0c\x00\xff\xa1\x0c\xa0W\xa2\x0c\x18s\xa2\x0chs\xa2\x0c\x00\xff\xa1\x0cPV\xa2\x0c\xa8t\xa2\x0chs\xa2\x0c\x90s\xa2\x0c\x10W\xa2\x0c\xc8\xfe\xa1\x0c`X\xa2\x0c\xf0r\xa2\x0cxr\xa2\x0chs\xa2\x0c\xc8r\xa2\x0c\x80\xe6\xf5\x0b\xa8\xff\xa1\x0c a\xf6\x0b\xf0r\xa2\x0c\xa8\xff\xa1\x0c`\xe8\xf5\x0b\x10W\xa2\x0c8\xff\xa1\x0c\xa0`\xf6\x0b`X\xa2\x0c\xe0V\xa2\x0c@s\xa2\x0chs\xa2\x0c\xf0r\xa2\x0c\x80V\xa2\x0c\x90s\xa2\x0c\x80\xe6\xf5\x0bhs\xa2\x0c\x80V\xa2\x0c\xc8\xfe\xa1\x0c\xa0r\xa2\x0cxr\xa2\x0cp\xff\xa1\x0c@s\xa2\x0c\xb0V\xa2\x0c\x00X\xa2\x0c@\xe4\xf5\x0b\xe0V\xa2\x0c@\xe4\xf5\x0b\xc8\xfe\xa1\x0c\xd0t\xa2\x0cpW\xa2\x0c\xd0t\xa2\x0c8\xff\xa1\x0c\xa8t\xa2\x0cp\xff\xa1\x0c@\xe4\xf5\x0b\xc8\xfe\xa1\x0cxr\xa2\x0c\x00X\xa2\x0cPV\xa2\x0cp\xff\xa1\x0c\xd0W\xa2\x0c@s\xa2\x0c8\xff\xa1\x0c\xb0V\xa2\x0c\xa8\xff\xa1\x0c'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg9118
g9119
(g9120
g93
g9121
S'b'
tRp9403
(I1
(I200
I1
tg9123
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg38
g9119
(g9120
g93
g9121
S'b'
tRp9404
(I1
(I200
I1
tg9245
I00
S'@\x0b\x89\x0c\xe0\x08\x89\x0c\x80\x05\x89\x0c@\x01\x89\x0c`\n\x89\x0c\xc0\n\x89\x0c\x80\x06\x89\x0c\xc0\x0c\x89\x0c\x00\x01\x89\x0c\xe0\x01\x89\x0c\xa0\t\x89\x0c@\x05\x89\x0c@\x0c\x89\x0c\xe0\x07\x89\x0c\xe0\n\x89\x0c\xc0\t\x89\x0c\x80\n\x89\x0c \n\x89\x0c \x01\x89\x0c`\x0b\x89\x0c@\x08\x89\x0c\xe0\r\x89\x0c\xa0\x0c\x89\x0c@\t\x89\x0c@\r\x89\x0c\x00ki\x0c@mi\x0c@ni\x0c@li\x0c@oi\x0c\xe0fi\x0c\x00ni\x0c\xc0ei\x0c\x00li\x0c`ei\x0c\xc0li\x0c\xc0ni\x0c\xc0ji\x0c gi\x0c@ji\x0c@ki\x0c\x00oi\x0c\x00mi\x0c\xa0fi\x0c`gi\x0c\xc0mi\x0c\xa0`i\x0c\x00hi\x0c\x80ni\x0c\x80hi\x0c\xc0ki\x0c\x80ji\x0c@fi\x0c\x80`i\x0c\x80fi\x0c@`i\x0c\xc0ii\x0c\xc0gi\x0c@ii\x0c``i\x0c\x00ii\x0c\xc0hi\x0c\x00ai\x0c\xc0`i\x0c\x80li\x0c\x00ji\x0c@hi\x0c ai\x0c\x00fi\x0c\x80ki\x0c\xc0\xdeh\x0c \xd3h\x0c\xe0\xd1h\x0c`\xdeh\x0c@\xdfh\x0c \xdfh\x0c\xa0\xdeh\x0c\x00\xd2h\x0c`\xdfh\x0c\xc0\xdfh\x0c\xe0\xdfh\x0c \xd2h\x0c@\xd1h\x0c \xd1h\x0c\xa0\xdbh\x0c`\xd1h\x0c\x80\xd1h\x0c@\xdeh\x0c\xc0\xd1h\x0c\xa0\xd1h\x0c\x80\xd2h\x0c`\xd2h\x0c`\xd0h\x0c\x00\xd3h\x0c\xe0\xd2h\x0c\x00\xdfh\x0c`\xd3h\x0c\xc0\xd2h\x0c\x00\xd1h\x0c\xe0\xdeh\x0c\x00\xd4h\x0c@\xd3h\x0c\xa0\xd3h\x0c\x80\xdch\x0c\xa0\xdfh\x0c\xe0\xd3h\x0c \xd4h\x0c\xa0 5\x03\xe0`i\x0c\x80\xdeh\x0c\xa0\xd2h\x0c\x80mi\x0c\x80ii\x0c\xc0\xb0g\x0c\x00(6\x03@\xd2h\x0c\x00\x9bf\x0c@\x90f\x0c@(6\x03\x80\xd3h\x0c\x80\xdfh\x0c \xdeh\x0c`\rh\x0c \x0eh\x0c\x00\x0fh\x0c\x00\x9cf\x0c\x80\x05h\x0c\xe0\x0eh\x0c \xb6g\x0c\xc0\x0b\x89\x0c@\x0e\x89\x0c\x80\x07\x89\x0c \x0b\x89\x0c\xa0\n\x89\x0c\x00\x0c\x89\x0c \x08\x89\x0c\xa0\xc1i\x0c \t\x89\x0c\xa0\r\x89\x0c\x00\x06\x89\x0c\x80\x0c\x89\x0c\xe0\t\x89\x0c\x80\x0b\x89\x0c`\t\x89\x0c\xe0\x0e\x89\x0c\xa0\x0b\x89\x0c@\n\x89\x0c`\x0c\x89\x0c`\x0f\x89\x0c\xc0\x0e\x89\x0c\x00\r\x89\x0c\x00\x0b\x89\x0c \x0e\x89\x0c\xa0\x0e\x89\x0c\x00\x08\x89\x0c`\x0e\x89\x0c \x0f\x89\x0c \x0c\x89\x0c\x80\r\x89\x0c@\x0f\x89\x0c\x80\x0e\x89\x0c`\r\x89\x0c\x00\x0e\x89\x0c\xe0\x0c\x89\x0c\xe0\x0f\x89\x0c\x00\n\x89\x0c\x00\x0f\x89\x0c\xc0\xd3h\x0c\xe0\x0b\x89\x0c\xa0\x0fh\x0c be\x1b\xa0`e\x1b`ae\x1b\x00ae\x1b@`e\x1b\xc0ae\x1b@be\x1b\xa0ae\x1b\xc0`e\x1b\x80be\x1b`be\x1b\xe0be\x1b\xc0be\x1b\x80ae\x1b\x00ce\x1b ce\x1b\x80ce\x1b`ce\x1b ae\x1b\xa0ce\x1b\x00de\x1b\xe0?\r\x0c\xe08\r\x0c\xe09\r\x0c@=\r\x0c\xc08\r\x0c`9\r\x0c =\r\x0c\x808\r\x0c@8\r\x0c'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg9126
g9119
(g9120
g93
g9121
S'b'
tRp9405
(I1
(I200
I1
tg9123
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00@\x00\x00@@\x00\x00\x80@\x00\x00\xa0@\x00\x00\xc0@\x00\x00\xe0@\x00\x00\x00A\x00\x00\x10A\x00\x00 A\x00\x000A\x00\x00@A\x00\x00PA\x00\x00`A\x00\x00pA\x00\x00\x80A\x00\x00\x88A\x00\x00\x90A\x00\x00\x98A\x00\x00\xa0A\x00\x00\xa8A\x00\x00\xb0A\x00\x00\xb8A\x00\x00\xc0A\x00\x00\xc8A\x00\x00\xd0A\x00\x00\xd8A\x00\x00\xe0A\x00\x00\xe8A\x00\x00\xf0A\x00\x00\xf8A\x00\x00\x00B\x00\x00\x04B\x00\x00\x08B\x00\x00\x0cB\x00\x00\x10B\x00\x00\x14B\x00\x00\x18B\x00\x00\x1cB\x00\x00 B\x00\x00$B\x00\x00(B\x00\x00,B\x00\x000B\x00\x004B\x00\x008B\x00\x00<B\x00\x00@B\x00\x00DB\x00\x00HB\x00\x00LB\x00\x00PB\x00\x00TB\x00\x00XB\x00\x00\\B\x00\x00`B\x00\x00dB\x00\x00hB\x00\x00lB\x00\x00pB\x00\x00tB\x00\x00xB\x00\x00|B\x00\x00\x80B\x00\x00\x82B\x00\x00\x84B\x00\x00\x86B\x00\x00\x88B\x00\x00\x8aB\x00\x00\x8cB\x00\x00\x8eB\x00\x00\x90B\x00\x00\x92B\x00\x00\x94B\x00\x00\x96B\x00\x00\x98B\x00\x00\x9aB\x00\x00\x9cB\x00\x00\x9eB\x00\x00\xa0B\x00\x00\xa2B\x00\x00\xa4B\x00\x00\xa6B\x00\x00\xa8B\x00\x00\xaaB\x00\x00\xacB\x00\x00\xaeB\x00\x00\xb0B\x00\x00\xb2B\x00\x00\xb4B\x00\x00\xb6B\x00\x00\xb8B\x00\x00\xbaB\x00\x00\xbcB\x00\x00\xbeB\x00\x00\xc0B\x00\x00\xc2B\x00\x00\xc4B\x00\x00\xc6B\x00\x00\xc8B\x00\x00\xcaB\x00\x00\xccB\x00\x00\xceB\x00\x00\xd0B\x00\x00\xd2B\x00\x00\xd4B\x00\x00\xd6B\x00\x00\xd8B\x00\x00\xdaB\x00\x00\xdcB\x00\x00\xdeB\x00\x00\xe0B\x00\x00\xe2B\x00\x00\xe4B\x00\x00\xe6B\x00\x00\xe8B\x00\x00\xeaB\x00\x00\xecB\x00\x00\xeeB\x00\x00\xf0B\x00\x00\xf2B\x00\x00\xf4B\x00\x00\xf6B\x00\x00\xf8B\x00\x00\xfaB\x00\x00\xfcB\x00\x00\xfeB\x00\x00\x00C\x00\x00\x01C\x00\x00\x02C\x00\x00\x03C\x00\x00\x04C\x00\x00\x05C\x00\x00\x06C\x00\x00\x07C\x00\x00\x08C\x00\x00\tC\x00\x00\nC\x00\x00\x0bC\x00\x00\x0cC\x00\x00\rC\x00\x00\x0eC\x00\x00\x0fC\x00\x00\x10C\x00\x00\x11C\x00\x00\x12C\x00\x00\x13C\x00\x00\x14C\x00\x00\x15C\x00\x00\x16C\x00\x00\x17C\x00\x00\x18C\x00\x00\x19C\x00\x00\x1aC\x00\x00\x1bC\x00\x00\x1cC\x00\x00\x1dC\x00\x00\x1eC\x00\x00\x1fC\x00\x00 C\x00\x00!C\x00\x00"C\x00\x00#C\x00\x00$C\x00\x00%C\x00\x00&C\x00\x00\'C\x00\x00(C\x00\x00)C\x00\x00*C\x00\x00+C\x00\x00,C\x00\x00-C\x00\x00.C\x00\x00/C\x00\x000C\x00\x001C\x00\x002C\x00\x003C\x00\x004C\x00\x005C\x00\x006C\x00\x007C\x00\x008C\x00\x009C\x00\x00:C\x00\x00;C\x00\x00<C\x00\x00=C\x00\x00>C\x00\x00?C\x00\x00@C\x00\x00AC\x00\x00BC\x00\x00CC\x00\x00DC\x00\x00EC\x00\x00FC\x00\x00GC'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg39
g9119
(g9120
g93
g9121
S'b'
tRp9406
(I1
(I200
I1
tg9123
I00
S'\xe3\xda\x1d@\xf8\xcc\x8c?\xf8p\x97?d\xb7\xbb?\xaf\xed\x8e?J\xf3\x1e@v\x1d\xa2?\xe1\xee\x8e?\xbf\xb6{?Q\xc9\x8c?\xb4\xc6\xbb?!\xa5j?\xcb\xc7\xac?\xaf \x82?\x92\x12\xb1?\\w\x97?\xd9\x84(@DB\xa4?>\xec\xae?\x03\xa9\x1a@\xf8u\x97?fR\x05@e3s?\x9a\x0e\xb1?\xe9B\xa4?\xef\x93\x88?\xbarw?\x08\x0b\x91?\x14\xd6]?\xb4\xa0j?\xbdN\xc4?G\x87\x88?\t\xde]?\xbe0\xd3?\xff`f?L\x87\x88?A\xb3{?y\x84\x88?\xbb\xfe_@R\xe2\x8e?$\xdd\xfd?o\x1cb?\xcc\x87Y?\x06/\x93?%0\xf3?\xb9v7?0\x0e\xd1?\x03\xd7]?\xd6T\x95?W\xfa\x7f?\x15\xf7\xee?tC\x84?\xc4\x10\x91?G\xa6\xca?\xcdJf?\xf1\x87\x08@)\xd9]?\xbb3s?K\xfb??\t\xcc\x8c?vRU?\xe6\xda\x1d?\x80=D?\x03\xfd\x7f?.\x8fY?\xc8\xdcn?\xbb!\x82?M\x8f\x88?**3?\x0c\x93Y?\xb6\xb7\x9b?\xbc\x87\x88?`\xc7L?\x8evw?\xdd@\x84?%=D?\xbeAD@\xd7\xeb\x8e?cG3?\xb9\xe6.?\xc7\xad{?\xf6\xc9\x8c?\x87\x1ab?\xcaC\xa4?\x10Q\x95?wlw?#\x85\x88?\x9c\xd7]?\x06.\x82?\t<\x84?\xd0\x12Q?\xa8\x97)@\xba\xefn?\\\x99Y?`\xf8\x9f?2\xed\x8e?i\xb4{?\xd9\x85\x88?/\x9cY?\xd3\xc5L?\xaa\xe8\xae?80\xb3?6\xbb;?\xd9v\xd7?9\xca\xec?~\x07Q?M\xbfL?`wH?\xb3\xa7J@\xa1i&?\x90$\x82?\xa6\x1d\xc2?\xe6BD?\xc9\tb?\xdbT\x95?\x7f\xb3;?\'DD?\xda\xf9??\xf4\xb4\xbb?\xb6\xa3j?\x08g7?\xa1\x1bb?\xc3\xcf]?\xfe/\x93?czf?cx7?\xbd\xb9;?\x0f\xd8\x1d?\x90\xc5L?\xbf\xbc;?\xe2c\x8e@\xf6\x97\xd9?3CD?0\x11Q?"\xd6]?6\xaaj?U\xefP?\xb9\xb1*?\xb6\xb4;?\xbd\xb1;?\xa353?\x88\xaa*?E`f?\x7f\xd5\x1d?a\x88H?\x90\xe9.?V\x92Y?\xe1\x17@?g\xb7;?\xd4w7?\xb1\xde\x1d?\xbab\x86?l\xfd??\xb3\xb0Y?+p7?\xb3^&?\xbb\x1cb?\x9e\xc3L?\x0c\xa2j?\xa1 \x82?!rw?\x15\xdd]?\x1a\xee.?{\x1f\x82?\xd7T\xac?J\xa2j?m\xa9*?{@\xc4?\xc3\x1b"?}\x1a"?\xd7\xb4;?\x86\x10\xb1?#d&?\x8f"3?\xb7\x1c"?b\x11\xf1?9\x7fY?\x0e\xa5*?\xa1\xc4L?\x84\x0f\xd1?\xd3""?\xfcKs?@\x99\x19?\xd0\xa2*?\x9a\x1e\xa2?\xa8 "?g~H?(\x0b@?\xe7\xbd;?\xe3\xd9]?\xbb\xe7.?\xb7O\x15?x\xd4]?\xd4\xb2Y?/\xa9*?\x86\x81H?\xe8\x8f*?\xee.3?\xd5\x0eQ?\xa0N\x84?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg34
g9119
(g9120
g93
g9121
S'b'
tRp9407
(I1
(I200
I1
tg9245
I00
S'\xa8R\x0b\x05\x00U\x0b\x05\xb8:\xbb\x040;\xbb\x04\x884\xbb\x04\x88=\xbb\x04P<\xbb\x04\x908\xbb\x0408\xbb\x04H5\xbb\x04 3\xbb\x04\xf86\xbb\x04\xc08\xbb\x04\x989\xbb\x04\xa8;\xbb\x04\xd01\xbb\x04\xd8>\xbb\x04\xa0:\xbb\x04\x008\xbb\x04\xe84\xbb\x04\x005\xbb\x04\x809\xbb\x04\x80<\xbb\x04\x90;\xbb\x04(4\xbb\x04\x10\xaa\xbc\x04\x08\xa6\xbc\x04\x18\xa2\xbc\x04\xa8\xa5\xbc\x04H\xab\xbc\x04\xb0\xac\xbc\x04\x08\xaf\xbc\x04\xd0\xad\xbc\x04(\xaa\xbc\x04\x98\xac\xbc\x04 \xaf\xbc\x048\xa6\xbc\x04\xd0\xaa\xbc\x04\xc8\xa9\xbc\x04x\xa8\xbc\x04\x08\xa9\xbc\x04P\xaf\xbc\x04\xe0\xa9\xbc\x04\x00\xa8\xbc\x04\x80\xa0\xbc\x04\xe8\xa7\xbc\x04h\xa3\xbc\x04\xd8\xa2\xbc\x04h\xa9\xbc\x04`\xae\xbc\x04\xd8\xae\xbc\x04p\xaa\xbc\x04\x80\xaf\xbc\x04\xe0\xac\xbc\x04\xf8\xac\xbc\x04 \xa9\xbc\x04`\xa8\xbc\x04(\xad\xbc\x04x\xa5\xbc\x04\x08\xac\xbc\x04\xe8\xaa\xbc\x040\xa2\xbc\x04\x18\xa8\xbc\x04\xc0\xa2\xbc\x04\x98\xa0\xbc\x040\xa5\xbc\x04\xf0\xae\xbc\x04\x88\xa7\xbc\x04\x18\xab\xbc\x04x\xae\xbc\x04\x10\xa4\xbc\x04\x08\xa3\xbc\x04H\xa8\xbc\x04`\xa5\xbc\x04\x98\xa6\xbc\x04\xf8\xa6\xbc\x04\x10\xa7\xbc\x04x\xab\xbc\x04\x98\xa9\xbc\x04\xd0\xa4\xbc\x04p\xa1\xbc\x04\x80\xa3\xbc\x04\xb8\xa4\xbc\x04h\xac\xbc\x04\xc8\xa6\xbc\x04\xb0\xa6\xbc\x04\xa0\xa4\xbc\x04\xd8\xa8\xbc\x04P\xa0\xbc\x040\xab\xbc\x04\xe8\xa4\xbc\x04X\xa4\xbc\x04\xf0\xab\xbc\x04\x00\xa5\xbc\x04\xa0\xa7\xbc\x04\x90\xa2\xbc\x04\x90\xa8\xbc\x04x\xa2\xbc\x04\xb8\xa1\xbc\x04\xb0\xaf\xbc\x04`\xa2\xbc\x04\x00\xa2\xbc\x04\xb0\xa0\xbc\x04\xa8\xa2\xbc\x04h\xaf\xbc\x04(\xa1\xbc\x04\x90\xa5\xbc\x048\xa0\xbc\x04\xe0\xa0\xbc\x04\xd0\xa7\xbc\x04\xf8\xa3\xbc\x04\x80\xa9\xbc\x04(\xa4\xbc\x04@\xaa\xbc\x04\x88\xaa\xbc\x04\x18\xa5\xbc\x04\xe0\xa6\xbc\x04\x88\xa1\xbc\x04\xb8\xaa\xbc\x04 \xa0\xbc\x04\x90\xab\xbc\x04\xf8\xa0\xbc\x04@\xa7\xbc\x04h\xa0\xbc\x04P\xa3\xbc\x04\xc8\xa3\xbc\x04H\xae\xbc\x04\xe8\xad\xbc\x04H\xa2\xbc\x04p\xa4\xbc\x04@\xa1\xbc\x04X\xad\xbc\x04\xf8\xa9\xbc\x04\xa0\xa1\xbc\x04\x18\xae\xbc\x04\x10\xad\xbc\x04\xa8\xa8\xbc\x04X\xa7\xbc\x04 \xa3\xbc\x040\xae\xbc\x04@\xad\xbc\x04X\xaa\xbc\x048\xa9\xbc\x04\x00\xae\xbc\x04\x88\xad\xbc\x04\xe8\xa1\xbc\x04P\xac\xbc\x048\xac\xbc\x04\x80\xac\xbc\x04\xb0\xa9\xbc\x04(\xa7\xbc\x04\xc0\xa8\xbc\x04\x80\xa6\xbc\x04X\xa1\xbc\x04@\xa4\xbc\x048\xaf\xbc\x04\xc0\xab\xbc\x04P\xa9\xbc\x04\x10\xa1\xbc\x04\x98\xaf\xbc\x04\xc8\xac\xbc\x04\xc0\xa5\xbc\x04\xc0\xae\xbc\x04\xa8\xae\xbc\x04 \xac\xbc\x04\x00\xab\xbc\x04\x88\xa4\xbc\x04`\xab\xbc\x04\xb8\xad\xbc\x04\xd8\xa5\xbc\x04P\xa6\xbc\x04\xc8\xaf\xbc\x04\xe0\xaf\xbc\x04\xc8\xa0\xbc\x04\xf0\xa2\xbc\x04\xd8\xab\xbc\x04p\xad\xbc\x04 \xa6\xbc\x04\xa0\xad\xbc\x04\xf0\xa8\xbc\x04\xa8\xab\xbc\x04\xa0\xaa\xbc\x048ie\x02\xe0\xa3\xbc\x04\x98O\xbc\x04P\x83\xda\x048\xa3\xbc\x04\xd0\xa1\xbc\x040\xa8\xbc\x04\xb0\xa3\xbc\x04\x08O\xbc\x04\x88M\xbc\x04 F\xbc\x04\x80L\xbc\x04\x98I\xbc\x04 L\xbc\x04 O\xbc\x04\xc0K\xbc\x04\xc8O\xbc\x04\xb8M\xbc\x04'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp9408
(dp9409
g9131
(dp9410
g9118
I01
sg38
I00
sg33
I00
sg9126
I01
sg39
I01
sg34
I00
ssg9133
g9396
sg9134
(lp9411
g9118
ag9126
ag38
ag39
ag33
ag34
asg9136
(lp9412
I200
aI1
asbsg9138
g9253
sg9140
g92
(g93
(I0
tS'b'
tRp9413
(I1
(I200
I1
tg99
I00
S'\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00\x04\x00\x00\x00\x05\x00\x00\x00\x06\x00\x00\x00\x07\x00\x00\x00\x08\x00\x00\x00\t\x00\x00\x00\n\x00\x00\x00\x0b\x00\x00\x00\x0c\x00\x00\x00\r\x00\x00\x00\x0e\x00\x00\x00\x0f\x00\x00\x00\x10\x00\x00\x00\x11\x00\x00\x00\x12\x00\x00\x00\x13\x00\x00\x00\x14\x00\x00\x00\x15\x00\x00\x00\x16\x00\x00\x00\x17\x00\x00\x00\x18\x00\x00\x00\x19\x00\x00\x00\x1a\x00\x00\x00\x1b\x00\x00\x00\x1c\x00\x00\x00\x1d\x00\x00\x00\x1e\x00\x00\x00\x1f\x00\x00\x00 \x00\x00\x00!\x00\x00\x00"\x00\x00\x00#\x00\x00\x00$\x00\x00\x00%\x00\x00\x00&\x00\x00\x00\'\x00\x00\x00(\x00\x00\x00)\x00\x00\x00*\x00\x00\x00+\x00\x00\x00,\x00\x00\x00-\x00\x00\x00.\x00\x00\x00/\x00\x00\x000\x00\x00\x001\x00\x00\x002\x00\x00\x003\x00\x00\x004\x00\x00\x005\x00\x00\x006\x00\x00\x007\x00\x00\x008\x00\x00\x009\x00\x00\x00:\x00\x00\x00;\x00\x00\x00<\x00\x00\x00=\x00\x00\x00>\x00\x00\x00?\x00\x00\x00@\x00\x00\x00A\x00\x00\x00B\x00\x00\x00C\x00\x00\x00D\x00\x00\x00E\x00\x00\x00F\x00\x00\x00G\x00\x00\x00H\x00\x00\x00I\x00\x00\x00J\x00\x00\x00K\x00\x00\x00L\x00\x00\x00M\x00\x00\x00N\x00\x00\x00O\x00\x00\x00P\x00\x00\x00Q\x00\x00\x00R\x00\x00\x00S\x00\x00\x00T\x00\x00\x00U\x00\x00\x00V\x00\x00\x00W\x00\x00\x00X\x00\x00\x00Y\x00\x00\x00Z\x00\x00\x00[\x00\x00\x00\\\x00\x00\x00]\x00\x00\x00^\x00\x00\x00_\x00\x00\x00`\x00\x00\x00a\x00\x00\x00b\x00\x00\x00c\x00\x00\x00d\x00\x00\x00e\x00\x00\x00f\x00\x00\x00g\x00\x00\x00h\x00\x00\x00i\x00\x00\x00j\x00\x00\x00k\x00\x00\x00l\x00\x00\x00m\x00\x00\x00n\x00\x00\x00o\x00\x00\x00p\x00\x00\x00q\x00\x00\x00r\x00\x00\x00s\x00\x00\x00t\x00\x00\x00u\x00\x00\x00v\x00\x00\x00w\x00\x00\x00x\x00\x00\x00y\x00\x00\x00z\x00\x00\x00{\x00\x00\x00|\x00\x00\x00}\x00\x00\x00~\x00\x00\x00\x7f\x00\x00\x00\x80\x00\x00\x00\x81\x00\x00\x00\x82\x00\x00\x00\x83\x00\x00\x00\x84\x00\x00\x00\x85\x00\x00\x00\x86\x00\x00\x00\x87\x00\x00\x00\x88\x00\x00\x00\x89\x00\x00\x00\x8a\x00\x00\x00\x8b\x00\x00\x00\x8c\x00\x00\x00\x8d\x00\x00\x00\x8e\x00\x00\x00\x8f\x00\x00\x00\x90\x00\x00\x00\x91\x00\x00\x00\x92\x00\x00\x00\x93\x00\x00\x00\x94\x00\x00\x00\x95\x00\x00\x00\x96\x00\x00\x00\x97\x00\x00\x00\x98\x00\x00\x00\x99\x00\x00\x00\x9a\x00\x00\x00\x9b\x00\x00\x00\x9c\x00\x00\x00\x9d\x00\x00\x00\x9e\x00\x00\x00\x9f\x00\x00\x00\xa0\x00\x00\x00\xa1\x00\x00\x00\xa2\x00\x00\x00\xa3\x00\x00\x00\xa4\x00\x00\x00\xa5\x00\x00\x00\xa6\x00\x00\x00\xa7\x00\x00\x00\xa8\x00\x00\x00\xa9\x00\x00\x00\xaa\x00\x00\x00\xab\x00\x00\x00\xac\x00\x00\x00\xad\x00\x00\x00\xae\x00\x00\x00\xaf\x00\x00\x00\xb0\x00\x00\x00\xb1\x00\x00\x00\xb2\x00\x00\x00\xb3\x00\x00\x00\xb4\x00\x00\x00\xb5\x00\x00\x00\xb6\x00\x00\x00\xb7\x00\x00\x00\xb8\x00\x00\x00\xb9\x00\x00\x00\xba\x00\x00\x00\xbb\x00\x00\x00\xbc\x00\x00\x00\xbd\x00\x00\x00\xbe\x00\x00\x00\xbf\x00\x00\x00\xc0\x00\x00\x00\xc1\x00\x00\x00\xc2\x00\x00\x00\xc3\x00\x00\x00\xc4\x00\x00\x00\xc5\x00\x00\x00\xc6\x00\x00\x00\xc7\x00\x00\x00'
tbsg9142
I01
sg9143
I1
sg9144
I-1
sg9145
(lp9414
g1
(g9147
g9116
(dp9415
g907
g900
sg895
g896
sg909
g910
sg904
g905
stRp9416
ag1
(g9147
g9116
(dp9417
g907
g926
sg895
g916
sg909
g920
sg904
g924
stRp9418
ag1
(g9147
g9116
(dp9419
g907
g937
sg895
g933
sg909
g944
sg904
g941
stRp9420
ag1
(g9147
g9116
(dp9421
g907
g954
sg895
g950
sg909
g961
sg904
g958
stRp9422
ag1
(g9147
g9116
(dp9423
g907
g971
sg895
g967
sg909
g978
sg904
g975
stRp9424
ag1
(g9147
g9116
(dp9425
g907
g988
sg895
g984
sg909
g995
sg904
g992
stRp9426
ag1
(g9147
g9116
(dp9427
g907
g1011
sg895
g1001
sg909
g1005
sg904
g1009
stRp9428
ag1
(g9147
g9116
(dp9429
g907
g1022
sg895
g1018
sg909
g1029
sg904
g1026
stRp9430
ag1
(g9147
g9116
(dp9431
g907
g971
sg895
g1035
sg909
g978
sg904
g1042
stRp9432
ag1
(g9147
g9116
(dp9433
g907
g1054
sg895
g1050
sg909
g1061
sg904
g1058
stRp9434
ag1
(g9147
g9116
(dp9435
g907
g954
sg895
g1067
sg909
g961
sg904
g1074
stRp9436
ag1
(g9147
g9116
(dp9437
g907
g1011
sg895
g1001
sg909
g1005
sg904
g1009
stRp9438
ag1
(g9147
g9116
(dp9439
g907
g1099
sg895
g1095
sg909
g1106
sg904
g1103
stRp9440
ag1
(g9147
g9116
(dp9441
g907
g1011
sg895
g1112
sg909
g1005
sg904
g1119
stRp9442
ag1
(g9147
g9116
(dp9443
g907
g1131
sg895
g1127
sg909
g1138
sg904
g1135
stRp9444
ag1
(g9147
g9116
(dp9445
g907
g937
sg895
g1144
sg909
g944
sg904
g1151
stRp9446
ag1
(g9147
g9116
(dp9447
g907
g1163
sg895
g1159
sg909
g1170
sg904
g1167
stRp9448
ag1
(g9147
g9116
(dp9449
g907
g1180
sg895
g1176
sg909
g1187
sg904
g1184
stRp9450
ag1
(g9147
g9116
(dp9451
g907
g1197
sg895
g1193
sg909
g1204
sg904
g1201
stRp9452
ag1
(g9147
g9116
(dp9453
g907
g954
sg895
g1067
sg909
g961
sg904
g1074
stRp9454
ag1
(g9147
g9116
(dp9455
g907
g1022
sg895
g1223
sg909
g1029
sg904
g1230
stRp9456
ag1
(g9147
g9116
(dp9457
g907
g926
sg895
g1238
sg909
g920
sg904
g1245
stRp9458
ag1
(g9147
g9116
(dp9459
g907
g1180
sg895
g1253
sg909
g1187
sg904
g1260
stRp9460
ag1
(g9147
g9116
(dp9461
g907
g1272
sg895
g1268
sg909
g1279
sg904
g1276
stRp9462
ag1
(g9147
g9116
(dp9463
g907
g1289
sg895
g1285
sg909
g1296
sg904
g1293
stRp9464
ag1
(g9147
g9116
(dp9465
g907
g971
sg895
g967
sg909
g978
sg904
g975
stRp9466
ag1
(g9147
g9116
(dp9467
g907
g1180
sg895
g1176
sg909
g1187
sg904
g1184
stRp9468
ag1
(g9147
g9116
(dp9469
g907
g988
sg895
g984
sg909
g995
sg904
g992
stRp9470
ag1
(g9147
g9116
(dp9471
g907
g937
sg895
g933
sg909
g944
sg904
g941
stRp9472
ag1
(g9147
g9116
(dp9473
g907
g988
sg895
g1354
sg909
g995
sg904
g1361
stRp9474
ag1
(g9147
g9116
(dp9475
g907
g1099
sg895
g1369
sg909
g1106
sg904
g1376
stRp9476
ag1
(g9147
g9116
(dp9477
g907
g1054
sg895
g1384
sg909
g1061
sg904
g1391
stRp9478
ag1
(g9147
g9116
(dp9479
g907
g937
sg895
g933
sg909
g944
sg904
g941
stRp9480
ag1
(g9147
g9116
(dp9481
g907
g1099
sg895
g1095
sg909
g1106
sg904
g1103
stRp9482
ag1
(g9147
g9116
(dp9483
g907
g954
sg895
g950
sg909
g961
sg904
g958
stRp9484
ag1
(g9147
g9116
(dp9485
g907
g1163
sg895
g1159
sg909
g1170
sg904
g1167
stRp9486
ag1
(g9147
g9116
(dp9487
g907
g1272
sg895
g1268
sg909
g1279
sg904
g1276
stRp9488
ag1
(g9147
g9116
(dp9489
g907
g926
sg895
g1238
sg909
g920
sg904
g1245
stRp9490
ag1
(g9147
g9116
(dp9491
g907
g900
sg895
g896
sg909
g910
sg904
g905
stRp9492
ag1
(g9147
g9116
(dp9493
g907
g1494
sg895
g1490
sg909
g1501
sg904
g1498
stRp9494
ag1
(g9147
g9116
(dp9495
g907
g1180
sg895
g1253
sg909
g1187
sg904
g1260
stRp9496
ag1
(g9147
g9116
(dp9497
g907
g1054
sg895
g1384
sg909
g1061
sg904
g1391
stRp9498
ag1
(g9147
g9116
(dp9499
g907
g1022
sg895
g1018
sg909
g1029
sg904
g1026
stRp9500
ag1
(g9147
g9116
(dp9501
g907
g1550
sg895
g1546
sg909
g1557
sg904
g1554
stRp9502
ag1
(g9147
g9116
(dp9503
g907
g1099
sg895
g1369
sg909
g1106
sg904
g1376
stRp9504
ag1
(g9147
g9116
(dp9505
g907
g954
sg895
g950
sg909
g961
sg904
g958
stRp9506
ag1
(g9147
g9116
(dp9507
g907
g1163
sg895
g1589
sg909
g1170
sg904
g1596
stRp9508
ag1
(g9147
g9116
(dp9509
g907
g937
sg895
g933
sg909
g944
sg904
g941
stRp9510
ag1
(g9147
g9116
(dp9511
g907
g1621
sg895
g1617
sg909
g1628
sg904
g1625
stRp9512
ag1
(g9147
g9116
(dp9513
g907
g1054
sg895
g1050
sg909
g1061
sg904
g1058
stRp9514
ag1
(g9147
g9116
(dp9515
g907
g1197
sg895
g1647
sg909
g1204
sg904
g1654
stRp9516
ag1
(g9147
g9116
(dp9517
g907
g1054
sg895
g1384
sg909
g1061
sg904
g1391
stRp9518
ag1
(g9147
g9116
(dp9519
g907
g1621
sg895
g1675
sg909
g1628
sg904
g1682
stRp9520
ag1
(g9147
g9116
(dp9521
g907
g1272
sg895
g1690
sg909
g1279
sg904
g1697
stRp9522
ag1
(g9147
g9116
(dp9523
g907
g1494
sg895
g1490
sg909
g1501
sg904
g1498
stRp9524
ag1
(g9147
g9116
(dp9525
g907
g1099
sg895
g1095
sg909
g1106
sg904
g1103
stRp9526
ag1
(g9147
g9116
(dp9527
g907
g1163
sg895
g1589
sg909
g1170
sg904
g1596
stRp9528
ag1
(g9147
g9116
(dp9529
g907
g1289
sg895
g1744
sg909
g1296
sg904
g1751
stRp9530
ag1
(g9147
g9116
(dp9531
g907
g1022
sg895
g1018
sg909
g1029
sg904
g1026
stRp9532
ag1
(g9147
g9116
(dp9533
g907
g1011
sg895
g1112
sg909
g1005
sg904
g1119
stRp9534
ag1
(g9147
g9116
(dp9535
g907
g1180
sg895
g1253
sg909
g1187
sg904
g1260
stRp9536
ag1
(g9147
g9116
(dp9537
g907
g954
sg895
g950
sg909
g961
sg904
g958
stRp9538
ag1
(g9147
g9116
(dp9539
g907
g926
sg895
g1238
sg909
g920
sg904
g1245
stRp9540
ag1
(g9147
g9116
(dp9541
g907
g1099
sg895
g1369
sg909
g1106
sg904
g1376
stRp9542
ag1
(g9147
g9116
(dp9543
g907
g900
sg895
g1837
sg909
g910
sg904
g1844
stRp9544
ag1
(g9147
g9116
(dp9545
g907
g1494
sg895
g1490
sg909
g1501
sg904
g1498
stRp9546
ag1
(g9147
g9116
(dp9547
g907
g900
sg895
g896
sg909
g910
sg904
g905
stRp9548
ag1
(g9147
g9116
(dp9549
g907
g988
sg895
g1354
sg909
g995
sg904
g1361
stRp9550
ag1
(g9147
g9116
(dp9551
g907
g926
sg895
g1238
sg909
g920
sg904
g1245
stRp9552
ag1
(g9147
g9116
(dp9553
g907
g1272
sg895
g1690
sg909
g1279
sg904
g1697
stRp9554
ag1
(g9147
g9116
(dp9555
g907
g1289
sg895
g1285
sg909
g1296
sg904
g1293
stRp9556
ag1
(g9147
g9116
(dp9557
g907
g1940
sg895
g1930
sg909
g1934
sg904
g1938
stRp9558
ag1
(g9147
g9116
(dp9559
g907
g1180
sg895
g1253
sg909
g1187
sg904
g1260
stRp9560
ag1
(g9147
g9116
(dp9561
g907
g1197
sg895
g1647
sg909
g1204
sg904
g1654
stRp9562
ag1
(g9147
g9116
(dp9563
g907
g1621
sg895
g1617
sg909
g1628
sg904
g1625
stRp9564
ag1
(g9147
g9116
(dp9565
g907
g1022
sg895
g1018
sg909
g1029
sg904
g1026
stRp9566
ag1
(g9147
g9116
(dp9567
g907
g1131
sg895
g1999
sg909
g1138
sg904
g2006
stRp9568
ag1
(g9147
g9116
(dp9569
g907
g1197
sg895
g1647
sg909
g1204
sg904
g1654
stRp9570
ag1
(g9147
g9116
(dp9571
g907
g954
sg895
g1067
sg909
g961
sg904
g1074
stRp9572
ag1
(g9147
g9116
(dp9573
g907
g926
sg895
g1238
sg909
g920
sg904
g1245
stRp9574
ag1
(g9147
g9116
(dp9575
g907
g1099
sg895
g1369
sg909
g1106
sg904
g1376
stRp9576
ag1
(g9147
g9116
(dp9577
g907
g971
sg895
g1035
sg909
g978
sg904
g1042
stRp9578
ag1
(g9147
g9116
(dp9579
g907
g1054
sg895
g1384
sg909
g1061
sg904
g1391
stRp9580
ag1
(g9147
g9116
(dp9581
g907
g937
sg895
g1144
sg909
g944
sg904
g1151
stRp9582
ag1
(g9147
g9116
(dp9583
g907
g1131
sg895
g1999
sg909
g1138
sg904
g2006
stRp9584
ag1
(g9147
g9116
(dp9585
g907
g900
sg895
g1837
sg909
g910
sg904
g1844
stRp9586
ag1
(g9147
g9116
(dp9587
g907
g1011
sg895
g1001
sg909
g1005
sg904
g1009
stRp9588
ag1
(g9147
g9116
(dp9589
g907
g1289
sg895
g1744
sg909
g1296
sg904
g1751
stRp9590
ag1
(g9147
g9116
(dp9591
g907
g937
sg895
g1144
sg909
g944
sg904
g1151
stRp9592
ag1
(g9147
g9116
(dp9593
g907
g1494
sg895
g2170
sg909
g1501
sg904
g2177
stRp9594
ag1
(g9147
g9116
(dp9595
g907
g1940
sg895
g1930
sg909
g1934
sg904
g1938
stRp9596
ag1
(g9147
g9116
(dp9597
g907
g1289
sg895
g1285
sg909
g1296
sg904
g1293
stRp9598
ag1
(g9147
g9116
(dp9599
g907
g1621
sg895
g1617
sg909
g1628
sg904
g1625
stRp9600
ag1
(g9147
g9116
(dp9601
g907
g900
sg895
g1837
sg909
g910
sg904
g1844
stRp9602
ag1
(g9147
g9116
(dp9603
g907
g988
sg895
g1354
sg909
g995
sg904
g1361
stRp9604
ag1
(g9147
g9116
(dp9605
g907
g1163
sg895
g1159
sg909
g1170
sg904
g1167
stRp9606
ag1
(g9147
g9116
(dp9607
g907
g1197
sg895
g1193
sg909
g1204
sg904
g1201
stRp9608
ag1
(g9147
g9116
(dp9609
g907
g1940
sg895
g2276
sg909
g1934
sg904
g2283
stRp9610
ag1
(g9147
g9116
(dp9611
g907
g1272
sg895
g1690
sg909
g1279
sg904
g1697
stRp9612
ag1
(g9147
g9116
(dp9613
g907
g1022
sg895
g1223
sg909
g1029
sg904
g1230
stRp9614
ag1
(g9147
g9116
(dp9615
g907
g1054
sg895
g1050
sg909
g1061
sg904
g1058
stRp9616
ag1
(g9147
g9116
(dp9617
g907
g1131
sg895
g1127
sg909
g1138
sg904
g1135
stRp9618
ag1
(g9147
g9116
(dp9619
g907
g1163
sg895
g1589
sg909
g1170
sg904
g1596
stRp9620
ag1
(g9147
g9116
(dp9621
g907
g900
sg895
g896
sg909
g910
sg904
g905
stRp9622
ag1
(g9147
g9116
(dp9623
g907
g1011
sg895
g1001
sg909
g1005
sg904
g1009
stRp9624
ag1
(g9147
g9116
(dp9625
g907
g1180
sg895
g1176
sg909
g1187
sg904
g1184
stRp9626
ag1
(g9147
g9116
(dp9627
g907
g988
sg895
g1354
sg909
g995
sg904
g1361
stRp9628
ag1
(g9147
g9116
(dp9629
g907
g1011
sg895
g1112
sg909
g1005
sg904
g1119
stRp9630
ag1
(g9147
g9116
(dp9631
g907
g988
sg895
g984
sg909
g995
sg904
g992
stRp9632
ag1
(g9147
g9116
(dp9633
g907
g1163
sg895
g1159
sg909
g1170
sg904
g1167
stRp9634
ag1
(g9147
g9116
(dp9635
g907
g1550
sg895
g2447
sg909
g1557
sg904
g2454
stRp9636
ag1
(g9147
g9116
(dp9637
g907
g1197
sg895
g1193
sg909
g1204
sg904
g1201
stRp9638
ag1
(g9147
g9116
(dp9639
g907
g1940
sg895
g2276
sg909
g1934
sg904
g2283
stRp9640
ag1
(g9147
g9116
(dp9641
g907
g1494
sg895
g2170
sg909
g1501
sg904
g2177
stRp9642
ag1
(g9147
g9116
(dp9643
g907
g1011
sg895
g1001
sg909
g1005
sg904
g1009
stRp9644
ag1
(g9147
g9116
(dp9645
g907
g937
sg895
g1144
sg909
g944
sg904
g1151
stRp9646
ag1
(g9147
g9116
(dp9647
g907
g971
sg895
g967
sg909
g978
sg904
g975
stRp9648
ag1
(g9147
g9116
(dp9649
g907
g1272
sg895
g1268
sg909
g1279
sg904
g1276
stRp9650
ag1
(g9147
g9116
(dp9651
g907
g988
sg895
g984
sg909
g995
sg904
g992
stRp9652
ag1
(g9147
g9116
(dp9653
g907
g1621
sg895
g1617
sg909
g1628
sg904
g1625
stRp9654
ag1
(g9147
g9116
(dp9655
g907
g1494
sg895
g2170
sg909
g1501
sg904
g2177
stRp9656
ag1
(g9147
g9116
(dp9657
g907
g1054
sg895
g1050
sg909
g1061
sg904
g1058
stRp9658
ag1
(g9147
g9116
(dp9659
g907
g988
sg895
g984
sg909
g995
sg904
g992
stRp9660
ag1
(g9147
g9116
(dp9661
g907
g1131
sg895
g1127
sg909
g1138
sg904
g1135
stRp9662
ag1
(g9147
g9116
(dp9663
g907
g1022
sg895
g1223
sg909
g1029
sg904
g1230
stRp9664
ag1
(g9147
g9116
(dp9665
g907
g1621
sg895
g1617
sg909
g1628
sg904
g1625
stRp9666
ag1
(g9147
g9116
(dp9667
g907
g971
sg895
g967
sg909
g978
sg904
g975
stRp9668
ag1
(g9147
g9116
(dp9669
g907
g1054
sg895
g1050
sg909
g1061
sg904
g1058
stRp9670
ag1
(g9147
g9116
(dp9671
g907
g1550
sg895
g1546
sg909
g1557
sg904
g1554
stRp9672
ag1
(g9147
g9116
(dp9673
g907
g971
sg895
g1035
sg909
g978
sg904
g1042
stRp9674
ag1
(g9147
g9116
(dp9675
g907
g1131
sg895
g1999
sg909
g1138
sg904
g2006
stRp9676
ag1
(g9147
g9116
(dp9677
g907
g1289
sg895
g1285
sg909
g1296
sg904
g1293
stRp9678
ag1
(g9147
g9116
(dp9679
g907
g1272
sg895
g1690
sg909
g1279
sg904
g1697
stRp9680
ag1
(g9147
g9116
(dp9681
g907
g900
sg895
g896
sg909
g910
sg904
g905
stRp9682
ag1
(g9147
g9116
(dp9683
g907
g1011
sg895
g1112
sg909
g1005
sg904
g1119
stRp9684
ag1
(g9147
g9116
(dp9685
g907
g1197
sg895
g1193
sg909
g1204
sg904
g1201
stRp9686
ag1
(g9147
g9116
(dp9687
g907
g1494
sg895
g2170
sg909
g1501
sg904
g2177
stRp9688
ag1
(g9147
g9116
(dp9689
g907
g937
sg895
g933
sg909
g944
sg904
g941
stRp9690
ag1
(g9147
g9116
(dp9691
g907
g1180
sg895
g1253
sg909
g1187
sg904
g1260
stRp9692
ag1
(g9147
g9116
(dp9693
g907
g1163
sg895
g1589
sg909
g1170
sg904
g1596
stRp9694
ag1
(g9147
g9116
(dp9695
g907
g1550
sg895
g1546
sg909
g1557
sg904
g1554
stRp9696
ag1
(g9147
g9116
(dp9697
g907
g937
sg895
g1144
sg909
g944
sg904
g1151
stRp9698
ag1
(g9147
g9116
(dp9699
g907
g900
sg895
g1837
sg909
g910
sg904
g1844
stRp9700
ag1
(g9147
g9116
(dp9701
g907
g1163
sg895
g1159
sg909
g1170
sg904
g1167
stRp9702
ag1
(g9147
g9116
(dp9703
g907
g1550
sg895
g2447
sg909
g1557
sg904
g2454
stRp9704
ag1
(g9147
g9116
(dp9705
g907
g1621
sg895
g1675
sg909
g1628
sg904
g1682
stRp9706
ag1
(g9147
g9116
(dp9707
g907
g1289
sg895
g1744
sg909
g1296
sg904
g1751
stRp9708
ag1
(g9147
g9116
(dp9709
g907
g926
sg895
g916
sg909
g920
sg904
g924
stRp9710
ag1
(g9147
g9116
(dp9711
g907
g1550
sg895
g2447
sg909
g1557
sg904
g2454
stRp9712
ag1
(g9147
g9116
(dp9713
g907
g1022
sg895
g1018
sg909
g1029
sg904
g1026
stRp9714
ag1
(g9147
g9116
(dp9715
g907
g954
sg895
g1067
sg909
g961
sg904
g1074
stRp9716
ag1
(g9147
g9116
(dp9717
g907
g1550
sg895
g1546
sg909
g1557
sg904
g1554
stRp9718
ag1
(g9147
g9116
(dp9719
g907
g1011
sg895
g1112
sg909
g1005
sg904
g1119
stRp9720
ag1
(g9147
g9116
(dp9721
g907
g1272
sg895
g1268
sg909
g1279
sg904
g1276
stRp9722
ag1
(g9147
g9116
(dp9723
g907
g1940
sg895
g1930
sg909
g1934
sg904
g1938
stRp9724
ag1
(g9147
g9116
(dp9725
g907
g1272
sg895
g1690
sg909
g1279
sg904
g1697
stRp9726
ag1
(g9147
g9116
(dp9727
g907
g1022
sg895
g1223
sg909
g1029
sg904
g1230
stRp9728
ag1
(g9147
g9116
(dp9729
g907
g1940
sg895
g2276
sg909
g1934
sg904
g2283
stRp9730
ag1
(g9147
g9116
(dp9731
g907
g1131
sg895
g1999
sg909
g1138
sg904
g2006
stRp9732
ag1
(g9147
g9116
(dp9733
g907
g1289
sg895
g1744
sg909
g1296
sg904
g1751
stRp9734
ag1
(g9147
g9116
(dp9735
g907
g971
sg895
g1035
sg909
g978
sg904
g1042
stRp9736
ag1
(g9147
g9116
(dp9737
g907
g1054
sg895
g1384
sg909
g1061
sg904
g1391
stRp9738
ag1
(g9147
g9116
(dp9739
g907
g1550
sg895
g1546
sg909
g1557
sg904
g1554
stRp9740
ag1
(g9147
g9116
(dp9741
g907
g1197
sg895
g1647
sg909
g1204
sg904
g1654
stRp9742
ag1
(g9147
g9116
(dp9743
g907
g1494
sg895
g2170
sg909
g1501
sg904
g2177
stRp9744
ag1
(g9147
g9116
(dp9745
g907
g1550
sg895
g2447
sg909
g1557
sg904
g2454
stRp9746
ag1
(g9147
g9116
(dp9747
g907
g1022
sg895
g1223
sg909
g1029
sg904
g1230
stRp9748
ag1
(g9147
g9116
(dp9749
g907
g1099
sg895
g1095
sg909
g1106
sg904
g1103
stRp9750
ag1
(g9147
g9116
(dp9751
g907
g1621
sg895
g1675
sg909
g1628
sg904
g1682
stRp9752
ag1
(g9147
g9116
(dp9753
g907
g1272
sg895
g1268
sg909
g1279
sg904
g1276
stRp9754
ag1
(g9147
g9116
(dp9755
g907
g1550
sg895
g2447
sg909
g1557
sg904
g2454
stRp9756
ag1
(g9147
g9116
(dp9757
g907
g1099
sg895
g1095
sg909
g1106
sg904
g1103
stRp9758
ag1
(g9147
g9116
(dp9759
g907
g926
sg895
g916
sg909
g920
sg904
g924
stRp9760
ag1
(g9147
g9116
(dp9761
g907
g988
sg895
g1354
sg909
g995
sg904
g1361
stRp9762
ag1
(g9147
g9116
(dp9763
g907
g954
sg895
g1067
sg909
g961
sg904
g1074
stRp9764
ag1
(g9147
g9116
(dp9765
g907
g1131
sg895
g1999
sg909
g1138
sg904
g2006
stRp9766
ag1
(g9147
g9116
(dp9767
g907
g1494
sg895
g1490
sg909
g1501
sg904
g1498
stRp9768
ag1
(g9147
g9116
(dp9769
g907
g1180
sg895
g1176
sg909
g1187
sg904
g1184
stRp9770
ag1
(g9147
g9116
(dp9771
g907
g1289
sg895
g1285
sg909
g1296
sg904
g1293
stRp9772
ag1
(g9147
g9116
(dp9773
g907
g1940
sg895
g1930
sg909
g1934
sg904
g1938
stRp9774
ag1
(g9147
g9116
(dp9775
g907
g1197
sg895
g1193
sg909
g1204
sg904
g1201
stRp9776
ag1
(g9147
g9116
(dp9777
g907
g1940
sg895
g2276
sg909
g1934
sg904
g2283
stRp9778
ag1
(g9147
g9116
(dp9779
g907
g926
sg895
g916
sg909
g920
sg904
g924
stRp9780
ag1
(g9147
g9116
(dp9781
g907
g1621
sg895
g1675
sg909
g1628
sg904
g1682
stRp9782
ag1
(g9147
g9116
(dp9783
g907
g1099
sg895
g1369
sg909
g1106
sg904
g1376
stRp9784
ag1
(g9147
g9116
(dp9785
g907
g1621
sg895
g1675
sg909
g1628
sg904
g1682
stRp9786
ag1
(g9147
g9116
(dp9787
g907
g971
sg895
g1035
sg909
g978
sg904
g1042
stRp9788
ag1
(g9147
g9116
(dp9789
g907
g1163
sg895
g1589
sg909
g1170
sg904
g1596
stRp9790
ag1
(g9147
g9116
(dp9791
g907
g1131
sg895
g1127
sg909
g1138
sg904
g1135
stRp9792
ag1
(g9147
g9116
(dp9793
g907
g1940
sg895
g1930
sg909
g1934
sg904
g1938
stRp9794
ag1
(g9147
g9116
(dp9795
g907
g926
sg895
g916
sg909
g920
sg904
g924
stRp9796
ag1
(g9147
g9116
(dp9797
g907
g954
sg895
g950
sg909
g961
sg904
g958
stRp9798
ag1
(g9147
g9116
(dp9799
g907
g1289
sg895
g1744
sg909
g1296
sg904
g1751
stRp9800
ag1
(g9147
g9116
(dp9801
g907
g900
sg895
g1837
sg909
g910
sg904
g1844
stRp9802
ag1
(g9147
g9116
(dp9803
g907
g1131
sg895
g1127
sg909
g1138
sg904
g1135
stRp9804
ag1
(g9147
g9116
(dp9805
g907
g1197
sg895
g1647
sg909
g1204
sg904
g1654
stRp9806
ag1
(g9147
g9116
(dp9807
g907
g1494
sg895
g1490
sg909
g1501
sg904
g1498
stRp9808
ag1
(g9147
g9116
(dp9809
g907
g971
sg895
g967
sg909
g978
sg904
g975
stRp9810
ag1
(g9147
g9116
(dp9811
g907
g1180
sg895
g1176
sg909
g1187
sg904
g1184
stRp9812
ag1
(g9147
g9116
(dp9813
g907
g1940
sg895
g2276
sg909
g1934
sg904
g2283
stRp9814
asg9228
Nsg9229
g3610
sg9230
I200
sg9231
I0
sg9232
I200
sg9233
I01
sbag1
(g9103
g3
NtRp9815
(dp9816
g9106
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a\u000a######################## CITATIONS ########################## \u000a##### Binary choice, BDM, auction routines, and instructions are modified from:\u000a##### \u000a##### De Martino, B., Fleming, S. M., Garrett, N., & Dolan, R. J. (2012). Confidence in value-based choice. Nature Neuroscience, 16(1), 105-110. \u000a#####\u000a##### Food item images are original.\u000a\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.80.01), July 16, 2014, at 03:20\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things bdm STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000afrom pyglet.window import key # to detect key state, whether key is held down, to move slider on key hold\u000aimport pandas as pd\u000aimport datetime\u000afrom psychopy.iohub import launchHubServer\u000aimport pylink\u000a\u000a# Initialize IOHub for eye tracker\u000aio=launchHubServer(iohub_config_name='iohub_config.yaml')\u000atracker = io.devices.tracker\u000a\u000a# Store info about the experiment session\u000aexpName = 'infer_design1'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u'', u'eye': u'', u'glasses': u'', u'contacts': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Setup filename for saving\u000afilename = 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# set up variable to track current state of key press, to move slider when keys held down\u000akeyState=key.KeyStateHandler()\u000a\u000a# Setup the Window\u000ascreenwidth = 1920\u000ascreenheight = 1080\u000awin = visual.Window(size=(screenwidth, screenheight), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color='black', colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000awin.winHandle.push_handlers(keyState)\u000a\u000a\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a\u000a######################## COMPONENTS ##########################\u000a\u000a# Set up directory path for stimuli. This avoids us having to put the entire image path in the conditions spreadsheet.\u000adir_path = 'stimuli/itempics/modified/small/'\u000a\u000a# Initialize components for Routine "instr_main"\u000ainstr_mainClock = core.Clock()\u000ainstr_main_txt = visual.TextStim(win=win, ori=0, name='instr_main_txt',\u000a    text=u'Welcome!\u005cn\u005cnPlease read the instructions carefully and get the experimenter when you\u005c're finished. Take as much time as you need.',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "instr_bdm"\u000ainstr_bdmClock = core.Clock()\u000ainstr_bdm_txt = visual.TextStim(win=win, ori=0, name='instr_bdm_txt',\u000a    text=u'The bidding task is about to begin. Use the LEFT and RIGHT arrow keys to move the cursor along the slider, then press the DOWN arrow to enter your bid.\u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "fixation"\u000afixationClock = core.Clock()\u000afixation_text = visual.TextStim(win=win, ori=0, name='fixation_text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "bdm"\u000abdmClock = core.Clock()\u000abdm_pic = visual.ImageStim(win=win, name='bdm_pic',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=0.0)\u000abdm_bid = visual.RatingScale(win=win, name='bdm_bid', marker=u'triangle', markerColor=u'orange', leftKeys=None, rightKeys=None,\u000a    size=1.0, pos=[0.0, -0.6], low=0, high=3, precision=100, labels=[u'\u005cxa30', u'\u005cxa33'],\u000a    scale=u'', markerStart=u'1.5', tickHeight=u'1', showAccept=False, acceptKeys=[u'down', u'return'])\u000a\u000a# Initialize components for Routine "instr_choice"\u000ainstr_choiceClock = core.Clock()\u000ainstr_choice_txt = visual.TextStim(win=win, ori=0, name='instr_choice_txt',\u000a    text=u'The choice task is about to begin. Choose your preferred item by pressing the LEFT or RIGHT arrow keys, then use the slider to indicate how confident you are that you made the best choice.\u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "choice"\u000achoiceClock = core.Clock()\u000achoice_pic_left = visual.ImageStim(win=win, name='choice_pic_left',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[-0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=0.0)\u000achoice_pic_right = visual.ImageStim(win=win, name='choice_pic_right',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=-1.0)\u000a\u000a# Initialize components for Routine "choice_selection"\u000achoice_selectionClock = core.Clock()\u000astar_left_selection = visual.TextStim(win=win, ori=0, name='star_left_selection',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[-0.5, -0.8], height=0.5, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=-2.0)\u000astar_right_selection = visual.TextStim(win=win, ori=0, name='star_right_selection',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[0.5, -0.8], height=0.5, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=-3.0)\u000a\u000a# Initialize components for Routine "confidence"\u000aconfidenceClock = core.Clock()\u000aconfidence_rating = visual.RatingScale(win=win, name='confidence_rating', marker=u'triangle', markerColor=u'orange', leftKeys=None, rightKeys=None,\u000a    size=1.0, pos=[0.0, 0.0], low=1, high=6, precision=20,\u000a    scale=u'', markerStart=u'3.5', tickHeight=u'1', showAccept=False, acceptKeys=[u'down', u'return'])\u000a\u000a# Initialize components for Routine "instr_infer_intro"\u000ainstr_infer_introClock = core.Clock()\u000ainstr_infer_intro_txt = visual.TextStim(win=win, ori=0, name='instr_infer_intro_txt',\u000a    text=u'Thanks! Now please get the experimenter, who will give you the instructions for the second part of the experiment. \u005cn\u005cnPlease read these instructions carefully and get the experimenter again when you\u005c're finished. Take as much time as you need.',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=1.5,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "instr_infer_practice"\u000ainstr_infer_practiceClock = core.Clock()\u000ainstr_infer_practice_txt = visual.TextStim(win=win, ori=0, name='instr_infer_practice_txt',\u000a    text=u'First, you\u005c'll do some practice trials. These are just for you to get used to the task; your responses won\u005c't count. Unlike in the real trials, the choices you will be learning here were generated randomly by a computer.\u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=1.5,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "instr_infer"\u000ainstr_inferClock = core.Clock()\u000ainstr_infer_txt = visual.TextStim(win=win, ori=0, name='instr_infer_txt',\u000a    text=u'Great! Now that you\u005c've done some practice trials, we\u005c're ready to start the real trials. If you have any questions, please get the experimenter now. Otherwise, you can begin whenever you\u005c're ready. \u005cn\u005cnUnlike in the practice trials, the choices you will be learning here were made by an actual person.\u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=1.5,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "get_ready"\u000aget_readyClock = core.Clock()\u000aget_ready_text = visual.TextStim(win=win, ori=0, name='get_ready_text',\u000a    text=u'Get ready!',    font=u'Arial',\u000a    pos=[0, 0], height=0.12, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000aimg_left_infer = visual.ImageStim(win=win, name='img_left_infer',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[-0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=0.0)\u000aimg_right_infer = visual.ImageStim(win=win, name='img_right_infer',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=-1.0)\u000a\u000a# Initialize components for Routine "trial_post_response"\u000atrial_post_responseClock = core.Clock()\u000aselection_arrow_left = visual.TextStim(win=win, ori=0, name='selection_arrow_left',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[-0.5, -0.09], height=0.5, wrapWidth=None,\u000a    color=u'red', colorSpace=u'rgb', opacity=1,\u000a    depth=-2.0)\u000aselection_arrow_right = visual.TextStim(win=win, ori=0, name='selection_arrow_right',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[0.5, -0.09], height=0.5, wrapWidth=None,\u000a    color=u'red', colorSpace=u'rgb', opacity=1,\u000a    depth=-3.0)\u000afeedback_box_left = visual.Rect(win=win, name='feedback_box_left',\u000a    width=[0.9, 0.9][0], height=[0.9, 0.9][1],\u000a    ori=0, pos=[-0.5, 0],\u000a    lineWidth=5, lineColor=u'yellow', lineColorSpace=u'rgb',\u000a    fillColor=None, fillColorSpace=u'rgb',\u000a    opacity=1, depth=-4.0, interpolate=True)\u000afeedback_box_right = visual.Rect(win=win, name='feedback_box_right',\u000a    width=[0.9, 0.9][0], height=[0.9, 0.9][1],\u000a    ori=0, pos=[0.5, 0],\u000a    lineWidth=5, lineColor=u'yellow', lineColorSpace=u'rgb',\u000a    fillColor=None, fillColorSpace=u'rgb',\u000a    opacity=1, depth=-5.0, interpolate=True)\u000a\u000a# Initialize components for Routine "rest_prompt"\u000arest_promptClock = core.Clock()\u000arest_prompt_txt = visual.TextStim(win=win, ori=0, name='rest_prompt_txt',\u000a    text=u'Great! Now take a rest and press the space bar when you\u005cu2019re ready to begin the next block.',    font=u'Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create counters for the number of correct and incorrect guesses made by subjects to determine extra payment.\u000acorrect_counter = 0\u000aincorrect_counter = 0\u000a\u000a# Create list of lists to store binary choice and BDM data to generate food reward at the end of the experiment\u000aprefs = [['left', 'right', 'choice', 'bid']]\u000abids = [['item', 'bid']] # For the bids collected during the first BDM routine, at the beginning of the experiment\u000a\u000a### CHOICE & INFERENCE RANDOMIZATION ###\u000a\u000a# Define two functions to generate constrained pseudorandom sequences of item pair presentations for the binary choice and inference\u000a# parts of the task. The constraint ensures that the same pair of items does not appear twice in a row (flipped or not).\u000a# In the conditions spreadsheet that the item pairs are drawn from, the flipped version of the same item pair is 20\u000a# rows apart.\u000a\u000a# Binary choice randomization\u000adef genseq_choice():\u000a    done = False\u000a    while done==False:\u000a        counter = 0\u000a        ans = np.random.choice(40, 40, replace=False) # Generate a pseudorandom sequence of 40 numbers\u000a        for x in range(1,40):\u000a            if (ans[x]-ans[x-1]) % 20 == 0: # Is the difference between any sequential numbers divisible by 20?\u000a                counter += 1\u000a        if counter==0: # If not, end the loop and return the array\u000a            done = True\u000a            return ans\u000a        else: # If so, continue the loop and try again\u000a            done = False\u000a\u000a# Inference practice block randomization\u000adef genseq_infer_practice():\u000a    done = False\u000a    while done==False:\u000a        counter = 0\u000a        ans = np.random.choice(14, 14, replace=False) # Generate a pseudorandom sequence of 200 numbers\u000a        for x in range(1,14):\u000a            if (ans[x]-ans[x-1]) % 7 == 0: # Is the difference between any sequential numbers divisible by 20?\u000a                counter += 1\u000a        if counter==0: # If not, end the loop and return the array\u000a            done = True\u000a            return ans\u000a        else: # If so, continue the loop and try again\u000a            done = False\u000a\u000a# Inference randomization\u000adef genseq_infer():\u000a    done = False\u000a    while done==False:\u000a        counter = 0\u000a        ans = np.random.choice(200, 200, replace=False) # Generate a pseudorandom sequence of 200 numbers\u000a        for x in range(1,200):\u000a            if (ans[x]-ans[x-1]) % 20 == 0: # Is the difference between any sequential numbers divisible by 20?\u000a                counter += 1\u000a        if counter==0: # If not, end the loop and return the array\u000a            done = True\u000a            return ans\u000a        else: # If so, continue the loop and try again\u000a            done = False\u000a\u000a\u000a# Set independent sequences for each of the two choice blocks, the inference practice block, and the three inference rest blocks. Each rest block contains 10 presentations of\u000a# each pair.\u000a\u000achoiceseq = genseq_choice()\u000apracticeseq = genseq_infer_practice()\u000ablock1seq = genseq_infer()\u000ablock2seq = genseq_infer()\u000ablock3seq = genseq_infer()\u000a\u000a\u000a# Choose a pilot participant whose choices will form the basis of the learning task\u000apartners = ['P1','P2','P3','P4','P5','P6','P8','P9','P10','P11','P12'] # List of pilot participants, P7 excluded for perfectly inconsistent choices\u000apartner = np.random.choice(partners,1) # Choose one at random\u000apartner_file = 'conditions/choices/infer_design1_value_pairs_' + partner[0] + '.csv' # Path to that participant's choice data\u000a\u000a# Create separate CSV files, one for each choice, practice, and rest block, with the item pairs in the pseudorandomly generated order.\u000a# These CSV files will be used as PsychoPy's conditions spreadsheets and run sequentially in the choice, practice, and inference loops below.\u000a\u000a\u000achoicecond_src = pd.read_csv('conditions/choice_design1_binary.csv', index_col=None, header=0)\u000achoicecond = choicecond_src.copy()\u000afor x in range(40):\u000a    seq = choiceseq[x]\u000a    choicecond.iloc[x] = choicecond_src.iloc[seq]\u000achoicecond.to_csv(path_or_buf=filename+'_choicecond.csv', index=False)\u000a\u000apracticecond_src = pd.read_csv('conditions/choices/infer_design1_value_pairs_practice.csv', index_col=None, header=0)\u000apracticecond = practicecond_src.copy()\u000afor x in range(14):\u000a    seq = practiceseq[x]\u000a    practicecond.iloc[x] = practicecond_src.iloc[seq]\u000apracticecond.to_csv(path_or_buf=filename+'_practicecond.csv', index=False)\u000a\u000ablock1cond_src = pd.read_csv(partner_file, index_col=None, header=0)\u000ablock1cond = block1cond_src.copy()\u000afor x in range(200):\u000a    seq = block1seq[x]\u000a    block1cond.iloc[x] = block1cond_src.iloc[seq]\u000ablock1cond.to_csv(path_or_buf=filename+'_block1cond.csv', index=False)\u000a\u000ablock2cond_src = pd.read_csv(partner_file, index_col=None, header=0)\u000ablock2cond = block2cond_src.copy()\u000afor x in range(200):\u000a    seq = block2seq[x]\u000a    block2cond.iloc[x] = block2cond_src.iloc[seq]\u000ablock2cond.to_csv(path_or_buf=filename+'_block2cond.csv', index=False)\u000a\u000ablock3cond_src = pd.read_csv(partner_file, index_col=None, header=0)\u000ablock3cond = block3cond_src.copy()\u000afor x in range(200):\u000a    seq = block3seq[x]\u000a    block3cond.iloc[x] = block3cond_src.iloc[seq]\u000ablock3cond.to_csv(path_or_buf=filename+'_block3cond.csv', index=False)\u000a\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instr_main"-------\u000at = 0\u000ainstr_mainClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_main_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_main_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_mainComponents = []\u000ainstr_mainComponents.append(instr_main_txt)\u000ainstr_mainComponents.append(instr_main_resp)\u000afor thisComponent in instr_mainComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_main"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_mainClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_main_txt* updates\u000a    if t >= 0.0 and instr_main_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_main_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_main_txt.frameNStart = frameN  # exact frame index\u000a        instr_main_txt.setAutoDraw(True)\u000a    \u000a    # *instr_main_resp* updates\u000a    if t >= 5.0 and instr_main_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_main_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_main_resp.frameNStart = frameN  # exact frame index\u000a        instr_main_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_main_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_main_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_main_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_main_resp.rt = instr_main_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_mainComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_main"-------\u000afor thisComponent in instr_mainComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_main_resp.keys in ['', [], None]:  # No response was made\u000a   instr_main_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_main_resp.keys',instr_main_resp.keys)\u000aif instr_main_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_main_resp.rt', instr_main_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a\u000a#------Prepare to start Routine "instr_bdm"-------\u000at = 0\u000ainstr_bdmClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_bdm_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_bdm_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_bdmComponents = []\u000ainstr_bdmComponents.append(instr_bdm_txt)\u000ainstr_bdmComponents.append(instr_bdm_resp)\u000afor thisComponent in instr_bdmComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_bdm"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_bdmClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_bdm_txt* updates\u000a    if t >= 0.0 and instr_bdm_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_bdm_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_bdm_txt.frameNStart = frameN  # exact frame index\u000a        instr_bdm_txt.setAutoDraw(True)\u000a    \u000a    # *instr_bdm_resp* updates\u000a    if t >= 2.0 and instr_bdm_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_bdm_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_bdm_resp.frameNStart = frameN  # exact frame index\u000a        instr_bdm_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_bdm_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_bdm_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space', 's'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_bdm_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_bdm_resp.rt = instr_bdm_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_bdmComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_bdm"-------\u000afor thisComponent in instr_bdmComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_bdm_resp.keys in ['', [], None]:  # No response was made\u000a   instr_bdm_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_bdm_resp.keys',instr_bdm_resp.keys)\u000athisExp.addData('partnered_pilot_participant', partner)\u000aif instr_bdm_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_bdm_resp.rt', instr_bdm_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## BDM LOOP 1 ##########################\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000abdm_loop1 = data.TrialHandler(nReps=1, method=u'random', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'conditions/choice_design1_bdm.xlsx'),\u000a    seed=None, name='bdm_loop1')\u000athisExp.addLoop(bdm_loop1)  # add the loop to the experiment\u000athisbdm_loop1 = bdm_loop1.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisbdm_loop1.rgb)\u000aif thisbdm_loop1 != None:\u000a    for paramName in thisbdm_loop1.keys():\u000a        exec(paramName + '= thisbdm_loop1.' + paramName)\u000a\u000a# Check if the 'skip' key was pressed in the instructions routine; if so, end the loop and move on to the inference task\u000aif instr_bdm_resp.keys=='s':\u000a    bdm_loop1.finished = True\u000a\u000afor thisbdm_loop1 in bdm_loop1:\u000a    currentLoop = bdm_loop1\u000a    # abbreviate parameter names if possible (e.g. rgb = thisbdm_loop1.rgb)\u000a    if thisbdm_loop1 != None:\u000a        for paramName in thisbdm_loop1.keys():\u000a            exec(paramName + '= thisbdm_loop1.' + paramName)\u000a    \u000a    #------Prepare to start Routine "bdm"-------\u000a    t = 0\u000a    bdmClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    bdm_pic.setImage(dir_path+bdm_img)\u000a    bdm_bid.reset()\u000a    # jitter the starting position of the BDM scale from a uniform distribution between 1 and 2, rounded to the nearest decimal place\u000a    bdm_marker_start = float(np.round(np.random.uniform(1, 2, 1)[0], 1))\u000a    bdm_bid.setMarkerPos(bdm_marker_start)\u000a    # keep track of which components have finished\u000a    bdmComponents = []\u000a    bdmComponents.append(fixation_text)\u000a    bdmComponents.append(bdm_pic)\u000a    bdmComponents.append(bdm_bid)\u000a    for thisComponent in bdmComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "bdm"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = bdmClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation_text* updates\u000a        if t >= 0 and fixation_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation_text.tStart = t  # underestimates by a little under one frame\u000a            fixation_text.frameNStart = frameN  # exact frame index\u000a            fixation_text.setAutoDraw(True)\u000a        elif fixation_text.status == STARTED and t>= (0 + (1.0-win.monitorFramePeriod*0.75)):\u000a            fixation_text.setAutoDraw(False)\u000a\u000a        # *bdm_pic* updates\u000a        if t >= 1.0 and bdm_pic.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bdm_pic.tStart = t  # underestimates by a little under one frame\u000a            bdm_pic.frameNStart = frameN  # exact frame index\u000a            bdm_pic.setAutoDraw(True)\u000a        # *bdm_bid* updates\u000a        if t >= 1.0:\u000a            bdm_bid.draw()\u000a            continueRoutine = bdm_bid.noResponse\u000a            if bdm_bid.noResponse == False:\u000a                bdm_bid.response = bdm_bid.getRating()\u000a                bdm_bid.rt = bdm_bid.getRT()\u000a            elif bdm_bid.noResponse==True:\u000a                if keyState[key.LEFT]==True and bdm_bid.markerPlacedAt >0.01:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt - 0.02\u000a                    bdm_bid.draw()\u000a                elif keyState[key.LEFT]==True and bdm_bid.markerPlacedAt==0.01:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt - 0.01\u000a                    bdm_bid.draw()\u000a                elif keyState[key.RIGHT]==True and bdm_bid.markerPlacedAt <2.99:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt + 0.02\u000a                    bdm_bid.draw()\u000a                elif keyState[key.RIGHT]==True and bdm_bid.markerPlacedAt==2.99:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt + 0.01\u000a                    bdm_bid.draw()\u000a                    \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in bdmComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "bdm"-------\u000a    for thisComponent in bdmComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # store data for bdm (TrialHandler)\u000a    bdm_loop1.addData('bdm_bid1.response', bdm_bid.getRating())\u000a    bdm_loop1.addData('bdm_bid1.rt', bdm_bid.getRT())\u000a    bdm_loop1.addData('bdm_marker_start', bdm_marker_start)\u000a\u000a    # Add the item and the subject's bid to the 'bids' list, which will be merged with the 'prefs' list later in order to run the auction\u000a    bids.append([bdm_img, bdm_bid.response])\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeat of 'bdm_loop1'\u000a\u000a\u000a#------Prepare to start Routine "instr_choice"-------\u000at = 0\u000ainstr_choiceClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_choice_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_choice_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_choiceComponents = []\u000ainstr_choiceComponents.append(instr_choice_txt)\u000ainstr_choiceComponents.append(instr_choice_resp)\u000afor thisComponent in instr_choiceComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_choice"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_choiceClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_choice_txt* updates\u000a    if t >= 0.0 and instr_choice_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_choice_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_choice_txt.frameNStart = frameN  # exact frame index\u000a        instr_choice_txt.setAutoDraw(True)\u000a    \u000a    # *instr_choice_resp* updates\u000a    if t >= 2.0 and instr_choice_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_choice_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_choice_resp.frameNStart = frameN  # exact frame index\u000a        instr_choice_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_choice_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_choice_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space', 's'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_choice_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_choice_resp.rt = instr_choice_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_choiceComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_choice"-------\u000afor thisComponent in instr_choiceComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_choice_resp.keys in ['', [], None]:  # No response was made\u000a   instr_choice_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_choice_resp.keys',instr_choice_resp.keys)\u000aif instr_choice_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_choice_resp.rt', instr_choice_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## BINARY LOOP ##########################\u000a\u000a# set up handler to look after randomisation of conditions etc\u000abinary = data.TrialHandler(nReps=1, method=u'sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(filename+'_choicecond.csv'),\u000a    seed=None, name='binary')\u000athisExp.addLoop(binary)  # add the loop to the experiment\u000athisBinary1 = binary.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBinary1.rgb)\u000aif thisBinary1 != None:\u000a    for paramName in thisBinary1.keys():\u000a        exec(paramName + '= thisBinary1.' + paramName)\u000a\u000a# Check if the 'skip' key was pressed in the instructions routine; if so, end the loop and move on to the BDM\u000aif instr_choice_resp.keys=='s':\u000a    binary.finished = True\u000a\u000afor thisBinary1 in binary:\u000a    currentLoop = binary\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBinary1.rgb)\u000a    if thisBinary1 != None:\u000a        for paramName in thisBinary1.keys():\u000a            exec(paramName + '= thisBinary1.' + paramName)\u000a    \u000a    #------Prepare to start Routine "choice"-------\u000a    t = 0\u000a    choiceClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    choice_pic_left.setImage(dir_path+choice_left)\u000a    choice_pic_right.setImage(dir_path+choice_right)\u000a    event.clearEvents(eventType='keyboard') # Clear keyboard event log to avoid last key press from prior loop being used\u000a    key_resp_choice = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_choice.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    choiceComponents = []\u000a    choiceComponents.append(fixation_text)\u000a    choiceComponents.append(choice_pic_left)\u000a    choiceComponents.append(choice_pic_right)\u000a    choiceComponents.append(key_resp_choice)\u000a    for thisComponent in choiceComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    \u000a    #-------Start Routine "choice"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = choiceClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation_text* updates\u000a        if t >= 0 and fixation_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation_text.tStart = t  # underestimates by a little under one frame\u000a            fixation_text.frameNStart = frameN  # exact frame index\u000a            fixation_text.setAutoDraw(True)\u000a        elif fixation_text.status == STARTED and t>= (0 + (1.0-win.monitorFramePeriod*0.75)):\u000a            fixation_text.setAutoDraw(False)\u000a\u000a        # *choice_pic_left* updates\u000a        if t >= 1.0 and choice_pic_left.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_left.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_left.frameNStart = frameN  # exact frame index\u000a            choice_pic_left.setAutoDraw(True)\u000a        \u000a        # *choice_pic_right* updates\u000a        if t >= 1.0 and choice_pic_right.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_right.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_right.frameNStart = frameN  # exact frame index\u000a            choice_pic_right.setAutoDraw(True)\u000a\u000a        # *key_resp_choice* updates\u000a        if t >= 1.0 and key_resp_choice.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_choice.tStart = t  # underestimates by a little under one frame\u000a            key_resp_choice.frameNStart = frameN  # exact frame index\u000a            key_resp_choice.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_choice.clock.reset()  # now t=0\u000a        if key_resp_choice.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_choice.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_choice.rt = key_resp_choice.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in choiceComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "choice"-------\u000a    for thisComponent in choiceComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_choice.keys in ['', [], None]:  # No response was made\u000a       key_resp_choice.keys=None\u000a    # store data for binary (TrialHandler)\u000a    binary.addData('key_resp_choice.keys',key_resp_choice.keys)\u000a    if key_resp_choice.keys != None:  # we had a response\u000a        binary.addData('key_resp_choice.rt', key_resp_choice.rt)\u000a\u000a    # define a function to append binary choices and the bid for the chosen item to the preference list\u000a    # lft is the left image displayed during that choice trial\u000a    # rt is the right image displayed\u000a    def rec_choice(lft, rt): \u000a        bd = False\u000a        if key_resp_choice.keys=='left':\u000a            chc = lft\u000a        elif key_resp_choice.keys=='right':\u000a            chc = rt\u000a        for x in range(len(bids)):\u000a            if bids[x][0]==chc:\u000a                bd = bids[x][1]\u000a        prefs.append([lft, rt, chc, bd])\u000a\u000a    # call the function\u000a    rec_choice(choice_left, choice_right)\u000a    \u000a\u000a    #------Prepare to start Routine "choice_selection"-------\u000a    t = 0\u000a    choice_selectionClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # keep track of which components have finished\u000a    choice_selectionComponents = []\u000a    choice_selectionComponents.append(choice_pic_left)\u000a    choice_selectionComponents.append(choice_pic_right)\u000a    choice_selectionComponents.append(star_left_selection)\u000a    choice_selectionComponents.append(star_right_selection)\u000a    for thisComponent in choice_selectionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "choice_selection"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = choice_selectionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *choice_pic_left* updates\u000a        if t >= 0.0 and choice_pic_left.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_left.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_left.frameNStart = frameN  # exact frame index\u000a            choice_pic_left.setAutoDraw(True)\u000a        elif choice_pic_left.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            choice_pic_left.setAutoDraw(False)\u000a        \u000a        # *choice_pic_right* updates\u000a        if t >= 0.0 and choice_pic_right.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_right.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_right.frameNStart = frameN  # exact frame index\u000a            choice_pic_right.setAutoDraw(True)\u000a        elif choice_pic_right.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            choice_pic_right.setAutoDraw(False)\u000a        \u000a        # *star_left_selection* updates\u000a        if key_resp_choice.keys=='left':\u000a            if t >= 0.0 and star_left_selection.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                star_left_selection.tStart = t  # underestimates by a little under one frame\u000a                star_left_selection.frameNStart = frameN  # exact frame index\u000a                star_left_selection.setAutoDraw(True)\u000a            elif star_left_selection.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                star_left_selection.setAutoDraw(False)\u000a        \u000a        # *star_right_selection* updates\u000a        if key_resp_choice.keys=='right':\u000a            if t >= 0.0 and star_right_selection.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                star_right_selection.tStart = t  # underestimates by a little under one frame\u000a                star_right_selection.frameNStart = frameN  # exact frame index\u000a                star_right_selection.setAutoDraw(True)\u000a            elif star_right_selection.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                star_right_selection.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in choice_selectionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "choice_selection"-------\u000a    for thisComponent in choice_selectionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    #thisExp.nextEntry()\u000a\u000a    #------Prepare to start Routine "confidence"-------\u000a    t = 0\u000a    confidenceClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    confidence_rating.reset()\u000a    # jitter the starting position of the confidence rating scale from a uniform distribution between 1.7 and 3.3 (the middle third of the scale), rounded to the nearest decimal place\u000a    confidence_marker_start = float(np.round(np.random.uniform(1.7, 3.3, 1)[0], 1))\u000a    confidence_rating.setMarkerPos(confidence_marker_start)\u000a    # keep track of which components have finished\u000a    confidenceComponents = []\u000a    confidenceComponents.append(confidence_rating)\u000a    for thisComponent in confidenceComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "confidence"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = confidenceClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *confidence_rating* updates\u000a        if t > 0.5:\u000a            confidence_rating.draw()\u000a            continueRoutine = confidence_rating.noResponse\u000a            if confidence_rating.noResponse == False:\u000a                confidence_rating.response = confidence_rating.getRating()\u000a                confidence_rating.rt = confidence_rating.getRT()\u000a            elif confidence_rating.noResponse==True:\u000a                if keyState[key.LEFT]==True and confidence_rating.markerPlacedAt >0:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt - 0.1\u000a                    confidence_rating.draw()\u000a                elif keyState[key.LEFT]==True and confidence_rating.markerPlacedAt==0.1:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt - 0.1\u000a                    confidence_rating.draw()\u000a                elif keyState[key.RIGHT]==True and confidence_rating.markerPlacedAt <4.9:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt + 0.1\u000a                    confidence_rating.draw()\u000a                elif keyState[key.RIGHT]==True and confidence_rating.markerPlacedAt==4.9:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt + 0.1\u000a                    confidence_rating.draw()\u000a                    \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in confidenceComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "confidence"-------\u000a    for thisComponent in confidenceComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # store data for confidence (TrialHandler)\u000a    binary.addData('confidence_rating1.response', confidence_rating.getRating())\u000a    binary.addData('confidence_rating1.rt', confidence_rating.getRT())\u000a    binary.addData('confidence_marker_start', confidence_marker_start+1) # Add 1 to convert from 0-5 to 1-6 scale\u000a\u000a    thisExp.nextEntry()\u000a\u000a\u000a# completed 1 repeat of 'binary'        \u000a\u000a#------Prepare to start Routine "instr_infer_intro"-------\u000at = 0\u000ainstr_infer_introClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_infer_intro_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_infer_intro_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_infer_introComponents = []\u000ainstr_infer_introComponents.append(instr_infer_intro_txt)\u000ainstr_infer_introComponents.append(instr_infer_intro_resp)\u000afor thisComponent in instr_infer_introComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_infer_intro"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_infer_introClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_infer_intro_txt* updates\u000a    if t >= 0.0 and instr_infer_intro_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_intro_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_intro_txt.frameNStart = frameN  # exact frame index\u000a        instr_infer_intro_txt.setAutoDraw(True)\u000a    \u000a    # *instr_infer_intro_resp* updates\u000a    if t >= 5.0 and instr_infer_intro_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_intro_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_intro_resp.frameNStart = frameN  # exact frame index\u000a        instr_infer_intro_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_infer_intro_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_infer_intro_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_infer_intro_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_infer_intro_resp.rt = instr_infer_intro_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_infer_introComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_infer_intro"-------\u000afor thisComponent in instr_infer_introComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_infer_intro_resp.keys in ['', [], None]:  # No response was made\u000a   instr_infer_intro_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_infer_intro_resp.keys',instr_infer_intro_resp.keys)\u000aif instr_infer_intro_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_infer_intro_resp.rt', instr_infer_intro_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a#------Prepare to start Routine "instr_infer_practice"-------\u000at = 0\u000ainstr_infer_practiceClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_infer_practice_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_infer_practice_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_infer_practiceComponents = []\u000ainstr_infer_practiceComponents.append(instr_infer_practice_txt)\u000ainstr_infer_practiceComponents.append(instr_infer_practice_resp)\u000afor thisComponent in instr_infer_practiceComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_infer_practice"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_infer_practiceClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_infer_practice_txt* updates\u000a    if t >= 0.0 and instr_infer_practice_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_practice_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_practice_txt.frameNStart = frameN  # exact frame index\u000a        instr_infer_practice_txt.setAutoDraw(True)\u000a    \u000a    # *instr_infer_practice_resp* updates\u000a    if t >= 5.0 and instr_infer_practice_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_practice_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_practice_resp.frameNStart = frameN  # exact frame index\u000a        instr_infer_practice_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_infer_practice_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_infer_practice_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_infer_practice_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_infer_practice_resp.rt = instr_infer_practice_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_infer_practiceComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_infer_practice"-------\u000afor thisComponent in instr_infer_practiceComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_infer_practice_resp.keys in ['', [], None]:  # No response was made\u000a   instr_infer_practice_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_infer_practice_resp.keys',instr_infer_practice_resp.keys)\u000aif instr_infer_practice_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_infer_practice_resp.rt', instr_infer_practice_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## PRACTICE LOOP ##########################\u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_loop = data.TrialHandler(nReps=1, method=u'sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(filename+'_practicecond.csv'),\u000a    seed=None, name='practice_loop')\u000athisExp.addLoop(practice_loop)  # add the loop to the experiment\u000athisPractice_loop = practice_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_loop.rgb)\u000aif thisPractice_loop != None:\u000a    for paramName in thisPractice_loop.keys():\u000a        exec(paramName + '= thisPractice_loop.' + paramName)\u000a\u000a  \u000afor thisPractice_loop in practice_loop:\u000a    currentLoop = practice_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_loop.rgb)\u000a    if thisPractice_loop != None:\u000a        for paramName in thisPractice_loop.keys():\u000a            exec(paramName + '= thisPractice_loop.' + paramName)    \u000a    \u000a        \u000a    # Define class for setting the feedback image\u000a    class set_feedback:\u000a        options = ['correct', 'wrong']\u000a        feedback = np.random.choice(options, replace=True, p=[0.8, 0.2])\u000a        if feedback=='correct':\u000a            feedback_img = img_correct\u000a        elif feedback=='wrong':\u000a            feedback_img = img_wrong\u000a\u000a        if feedback_img==img_left:\u000a            feedback_side = 'left'\u000a        elif feedback_img==img_right:\u000a            feedback_side = 'right'\u000a\u000a\u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialtime = datetime.datetime.now()\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    img_left_infer.setImage(dir_path+img_left)\u000a    img_right_infer.setImage(dir_path+img_right)\u000a    infer_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    infer_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(fixation_text)\u000a    trialComponents.append(img_left_infer)\u000a    trialComponents.append(img_right_infer)\u000a    trialComponents.append(infer_resp)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation_text* updates\u000a        if t >= 0 and fixation_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation_text.tStart = t  # underestimates by a little under one frame\u000a            fixation_text.frameNStart = frameN  # exact frame index\u000a            fixation_text.setAutoDraw(True)\u000a        elif fixation_text.status == STARTED and t>= (0 + (2.0-win.monitorFramePeriod*0.75)):\u000a            fixation_text.setAutoDraw(False)\u000a\u000a        # *img_left_infer* updates\u000a        if t >= 2.0 and img_left_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_left_infer.tStart = t  # underestimates by a little under one frame\u000a            img_left_infer.frameNStart = frameN  # exact frame index\u000a            img_left_infer.setAutoDraw(True)\u000a        \u000a        # *img_right_infer* updates\u000a        if t >= 2.0 and img_right_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_right_infer.tStart = t  # underestimates by a little under one frame\u000a            img_right_infer.frameNStart = frameN  # exact frame index\u000a            img_right_infer.setAutoDraw(True)\u000a                  \u000a        # *infer_resp* updates\u000a        if t >= 2.0 and infer_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            infer_resp.tStart = t  # underestimates by a little under one frame\u000a            infer_resp.frameNStart = frameN  # exact frame index\u000a            infer_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            infer_resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if infer_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                infer_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                infer_resp.rt = infer_resp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a\u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if infer_resp.keys in ['', [], None]:  # No response was made\u000a       infer_resp.keys=None\u000a    # # store data for practice_loop (TrialHandler)\u000a    # practice_loop.addData('infer_resp.keys',infer_resp.keys)\u000a    # if infer_resp.keys != None:  # we had a response\u000a    #     practice_loop.addData('infer_resp.rt', infer_resp.rt)\u000a    practice_loop.addData('set_feedback.feedback_img', set_feedback.feedback_img)\u000a    practice_loop.addData('trial_start_time', trialtime)\u000a    \u000a    # # Increase correct and incorrect response counters by 1 based on S's response\u000a    # if infer_resp.keys=='left' and img_correct==img_left:\u000a    #     correct_counter += 1\u000a    # elif infer_resp.keys=='left' and img_correct==img_right:\u000a    #     incorrect_counter += 1\u000a    # elif infer_resp.keys=='right' and img_correct==img_right:\u000a    #     correct_counter += 1\u000a    # elif infer_resp.keys=='right' and img_correct==img_left:\u000a    #     incorrect_counter += 1\u000a    \u000a\u000a    #------Prepare to start Routine "trial_post_response"-------\u000a    t = 0\u000a    trial_post_responseClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(3.000000)\u000a    # keep track of which components have finished\u000a    trial_post_responseComponents = []\u000a    trial_post_responseComponents.append(img_left_infer)\u000a    trial_post_responseComponents.append(img_right_infer)\u000a    trial_post_responseComponents.append(selection_arrow_left)\u000a    trial_post_responseComponents.append(selection_arrow_right)\u000a    trial_post_responseComponents.append(feedback_box_left)\u000a    trial_post_responseComponents.append(feedback_box_right)\u000a    for thisComponent in trial_post_responseComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial_post_response"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = trial_post_responseClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a\u000a        # *img_left_infer* updates\u000a        if t >= 0.0 and img_left_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_left_infer.tStart = t  # underestimates by a little under one frame\u000a            img_left_infer.frameNStart = frameN  # exact frame index\u000a            img_left_infer.setAutoDraw(True)\u000a        elif img_left_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            img_left_infer.setAutoDraw(False)\u000a        \u000a        # *img_right_infer* updates\u000a        if t >= 0.0 and img_right_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_right_infer.tStart = t  # underestimates by a little under one frame\u000a            img_right_infer.frameNStart = frameN  # exact frame index\u000a            img_right_infer.setAutoDraw(True)\u000a        elif img_right_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            img_right_infer.setAutoDraw(False)\u000a        \u000a        if infer_resp.keys == 'left':\u000a            # *selection_arrow_left* updates\u000a            if t >= 0.0 and selection_arrow_left.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                selection_arrow_left.tStart = t  # underestimates by a little under one frame\u000a                selection_arrow_left.frameNStart = frameN  # exact frame index\u000a                selection_arrow_left.setAutoDraw(True)\u000a            elif selection_arrow_left.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                selection_arrow_left.setAutoDraw(False)\u000a        \u000a        if infer_resp.keys == 'right':\u000a            # *selection_arrow_right* updates\u000a            if t >= 0.0 and selection_arrow_right.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                selection_arrow_right.tStart = t  # underestimates by a little under one frame\u000a                selection_arrow_right.frameNStart = frameN  # exact frame index\u000a                selection_arrow_right.setAutoDraw(True)\u000a            elif selection_arrow_right.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                selection_arrow_right.setAutoDraw(False)\u000a        \u000a        if set_feedback.feedback_side == 'left':\u000a            # *feedback_box_left* updates\u000a            if t >= 1.0 and feedback_box_left.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                feedback_box_left.tStart = t  # underestimates by a little under one frame\u000a                feedback_box_left.frameNStart = frameN  # exact frame index\u000a                feedback_box_left.setAutoDraw(True)\u000a            elif feedback_box_left.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                feedback_box_left.setAutoDraw(False)\u000a        \u000a        if set_feedback.feedback_side == 'right':\u000a            # *feedback_box_right* updates\u000a            if t >= 1.0 and feedback_box_right.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                feedback_box_right.tStart = t  # underestimates by a little under one frame\u000a                feedback_box_right.frameNStart = frameN  # exact frame index\u000a                feedback_box_right.setAutoDraw(True)\u000a            elif feedback_box_right.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period right\u000a                feedback_box_right.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trial_post_responseComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "trial_post_response"-------\u000a    for thisComponent in trial_post_responseComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000a    \u000a    thisExp.nextEntry()\u000a                        \u000a# completed 1 repeat of 'practice_loop'\u000a\u000a\u000a#------Prepare to start Routine "instr_infer"-------\u000at = 0\u000ainstr_inferClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_infer_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_infer_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_inferComponents = []\u000ainstr_inferComponents.append(instr_infer_txt)\u000ainstr_inferComponents.append(instr_infer_resp)\u000afor thisComponent in instr_inferComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_infer"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_inferClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_infer_txt* updates\u000a    if t >= 0.0 and instr_infer_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_txt.frameNStart = frameN  # exact frame index\u000a        instr_infer_txt.setAutoDraw(True)\u000a    \u000a    # *instr_infer_resp* updates\u000a    if t >= 5.0 and instr_infer_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_resp.frameNStart = frameN  # exact frame index\u000a        instr_infer_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_infer_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_infer_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_infer_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_infer_resp.rt = instr_infer_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_inferComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_infer"-------\u000afor thisComponent in instr_inferComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_infer_resp.keys in ['', [], None]:  # No response was made\u000a   instr_infer_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_infer_resp.keys',instr_infer_resp.keys)\u000aif instr_infer_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_infer_resp.rt', instr_infer_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## BLOCK LOOP ##########################\u000a\u000a# This loop runs a second nested loop that shows each item pair 10 times, followed by a rest break prompt.\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=3, method=u'sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=[None],\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000a# Set up counter to keep track of block loop cycle, so that the rest prompt is only shown twice\u000ablock_loop_counter = 0\u000a\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    # Increase loop counter by one\u000a    block_loop_counter += 1\u000a    \u000a    # Change the condition file for the feedback block based on which block loop we're on\u000a    condfilename = filename+u'_block'+str(block_loop_counter)+u'cond.csv'\u000a    \u000a    # Minimize the psychopy window so the calibration window can be seen\u000a    win.winHandle.minimize()\u000a    #Do the eye tracker setup at the beginning of each block\u000a    tracker.runSetupProcedure()\u000a    # Re-display the psychopy window after setup is completed\u000a    win.winHandle.maximize()\u000a    win.winHandle.activate()\u000a    \u000a\u000a    \u000a    #------Prepare to start Routine "get_ready"-------\u000a    t = 0\u000a    get_readyClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(3.000000)\u000a    # update component parameters for each repeat\u000a    get_ready_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    get_ready_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    get_readyComponents = []\u000a    get_readyComponents.append(get_ready_text)\u000a    get_readyComponents.append(get_ready_resp)\u000a    for thisComponent in get_readyComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    \u000a    #-------Start Routine "get_ready"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = get_readyClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *get_ready_text* updates\u000a        if t >= 0.0 and get_ready_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            get_ready_text.tStart = t  # underestimates by a little under one frame\u000a            get_ready_text.frameNStart = frameN  # exact frame index\u000a            get_ready_text.setAutoDraw(True)\u000a        \u000a        # *get_ready_resp* updates\u000a        if t >= 0.0 and get_ready_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            get_ready_resp.tStart = t  # underestimates by a little under one frame\u000a            get_ready_resp.frameNStart = frameN  # exact frame index\u000a            get_ready_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            get_ready_resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if get_ready_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['p'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                get_ready_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                get_ready_resp.rt = get_ready_resp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in get_readyComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "get_ready"-------\u000a    for thisComponent in get_readyComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if get_ready_resp.keys in ['', [], None]:  # No response was made\u000a       get_ready_resp.keys=None\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('get_ready_resp.keys',get_ready_resp.keys)\u000a    if get_ready_resp.keys != None:  # we had a response\u000a        thisExp.addData('get_ready_resp.rt', get_ready_resp.rt)\u000a    thisExp.nextEntry()\u000a\u000a    ######################## TRIAL LOOP ##########################\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    trial_loop = data.TrialHandler(nReps=1, method=u'sequential', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(condfilename),\u000a        seed=None, name='trial_loop')\u000a    thisExp.addLoop(trial_loop)  # add the loop to the experiment\u000a    thisTrial_loop = trial_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_loop.rgb)\u000a    if thisTrial_loop != None:\u000a        for paramName in thisTrial_loop.keys():\u000a            exec(paramName + '= thisTrial_loop.' + paramName)\u000a    \u000a      \u000a    for thisTrial_loop in trial_loop:\u000a        currentLoop = trial_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_loop.rgb)\u000a        if thisTrial_loop != None:\u000a            for paramName in thisTrial_loop.keys():\u000a                exec(paramName + '= thisTrial_loop.' + paramName)    \u000a        \u000a            \u000a        # Define class for setting the feedback image\u000a        class set_feedback:\u000a            options = ['correct', 'wrong']\u000a            feedback = np.random.choice(options, replace=True, p=[0.8, 0.2])\u000a            if feedback=='correct':\u000a                feedback_img = img_correct\u000a            elif feedback=='wrong':\u000a                feedback_img = img_wrong\u000a\u000a            if feedback_img==img_left:\u000a                feedback_side = 'left'\u000a            elif feedback_img==img_right:\u000a                feedback_side = 'right'\u000a                        \u000a        # Start getting data from the eye tracker\u000a        tracker.enableEventReporting(True)\u000a        # Send beginning-of-trial messages to eye tracker data file\u000a        trial_number = (block_loop.thisN * 200) + trial_loop.thisTrialN # Trial number out of 599 (starts at 0)\u000a        tracker.sendCommand("record_status_message 'INFERRING, Block %d/3, Trial %d/600 '" % (block_loop.thisN + 1, trial_number + 1))\u000a        tracker.sendMessage("TRIALID %d" % trial_number)\u000a        tracker.sendMessage("!V TRIAL_VAR_DATA %d" % trial_number)\u000a\u000a        \u000a        #------Prepare to start Routine "trial"-------\u000a        t = 0\u000a        trialtime = datetime.datetime.now()\u000a        trialClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        img_left_infer.setImage(dir_path+img_left)\u000a        img_right_infer.setImage(dir_path+img_right)\u000a        infer_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        infer_resp.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trialComponents = []\u000a        trialComponents.append(fixation_text)\u000a        trialComponents.append(img_left_infer)\u000a        trialComponents.append(img_right_infer)\u000a        trialComponents.append(infer_resp)\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        # Set indicator variable for whether eye tracker messages were sent during the first loop of the routine\u000a        eye_sync_messages_sent = 0\u000a        \u000a        #-------Start Routine "trial"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = trialClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *fixation_text* updates\u000a            if t >= 0 and fixation_text.status == NOT_STARTED:\u000a                if eye_sync_messages_sent==0:\u000a                    startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                # keep track of start time/frame for later\u000a                fixation_text.tStart = t  # underestimates by a little under one frame\u000a                fixation_text.frameNStart = frameN  # exact frame index\u000a                fixation_text.setAutoDraw(True)\u000a                if eye_sync_messages_sent==0:\u000a                    drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                    tracker.sendMessage("%d DISPLAY ON" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                    tracker.sendMessage("SYNCTIME %d" %drawTime)\u000a                    eye_sync_messages_sent = 1\u000a            elif fixation_text.status == STARTED and t>= (0 + (2.0-win.monitorFramePeriod*0.75)):\u000a                fixation_text.setAutoDraw(False)\u000a            \u000a            # *img_left_infer* updates\u000a            if t >= 2.0 and img_left_infer.status == NOT_STARTED:\u000a                if eye_sync_messages_sent==1:\u000a                    startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                # keep track of start time/frame for later\u000a                img_left_infer.tStart = t  # underestimates by a little under one frame\u000a                img_left_infer.frameNStart = frameN  # exact frame index\u000a                img_left_infer.setAutoDraw(True)\u000a            \u000a            # *img_right_infer* updates\u000a            if t >= 2.0 and img_right_infer.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                img_right_infer.tStart = t  # underestimates by a little under one frame\u000a                img_right_infer.frameNStart = frameN  # exact frame index\u000a                img_right_infer.setAutoDraw(True)\u000a                if eye_sync_messages_sent==1:\u000a                    drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                    tracker.sendMessage("%d DISPLAY ON ITEMS" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                    eye_sync_messages_sent = 2\u000a                      \u000a            # *infer_resp* updates\u000a            if t >= 2.0 and infer_resp.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                infer_resp.tStart = t  # underestimates by a little under one frame\u000a                infer_resp.frameNStart = frameN  # exact frame index\u000a                infer_resp.status = STARTED\u000a                # keyboard checking is just starting\u000a                infer_resp.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            if infer_resp.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['left', 'right'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    infer_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                    infer_resp.rt = infer_resp.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trialComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                tracker.enableEventReporting(False) # End eye tracker data recording\u000a                tracker.sendMessage("EXPERIMENT ABORTED")\u000a                io.quit() # Close iohub\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial"-------\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if infer_resp.keys in ['', [], None]:  # No response was made\u000a           infer_resp.keys=None\u000a        # store data for trial_loop (TrialHandler)\u000a        trial_loop.addData('infer_resp.keys',infer_resp.keys)\u000a        if infer_resp.keys != None:  # we had a response\u000a            trial_loop.addData('infer_resp.rt', infer_resp.rt)\u000a        trial_loop.addData('set_feedback.feedback_img', set_feedback.feedback_img)\u000a        trial_loop.addData('trial_start_time', trialtime)\u000a        \u000a        # Increase correct and incorrect response counters by 1 based on S's response\u000a        if infer_resp.keys=='left' and img_correct==img_left:\u000a            correct_counter += 1\u000a        elif infer_resp.keys=='left' and img_correct==img_right:\u000a            incorrect_counter += 1\u000a        elif infer_resp.keys=='right' and img_correct==img_right:\u000a            correct_counter += 1\u000a        elif infer_resp.keys=='right' and img_correct==img_left:\u000a            incorrect_counter += 1\u000a        \u000a\u000a        #------Prepare to start Routine "trial_post_response"-------\u000a        t = 0\u000a        trial_post_responseClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(3.000000)\u000a        # keep track of which components have finished\u000a        trial_post_responseComponents = []\u000a        trial_post_responseComponents.append(img_left_infer)\u000a        trial_post_responseComponents.append(img_right_infer)\u000a        trial_post_responseComponents.append(selection_arrow_left)\u000a        trial_post_responseComponents.append(selection_arrow_right)\u000a        trial_post_responseComponents.append(feedback_box_left)\u000a        trial_post_responseComponents.append(feedback_box_right)\u000a        for thisComponent in trial_post_responseComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        # Set indicator variable for whether eye tracker messages were sent during the first loop of the routine\u000a        eye_sync_messages_sent = 0\u000a\u000a        #-------Start Routine "trial_post_response"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = trial_post_responseClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a\u000a            # *img_left_infer* updates\u000a            if t >= 0.0 and img_left_infer.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                img_left_infer.tStart = t  # underestimates by a little under one frame\u000a                img_left_infer.frameNStart = frameN  # exact frame index\u000a                img_left_infer.setAutoDraw(True)\u000a            elif img_left_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                img_left_infer.setAutoDraw(False)\u000a            \u000a            # *img_right_infer* updates\u000a            if t >= 0.0 and img_right_infer.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                img_right_infer.tStart = t  # underestimates by a little under one frame\u000a                img_right_infer.frameNStart = frameN  # exact frame index\u000a                img_right_infer.setAutoDraw(True)\u000a            elif img_right_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                img_right_infer.setAutoDraw(False)\u000a            \u000a            if infer_resp.keys == 'left':\u000a                # *selection_arrow_left* updates\u000a                if t >= 0.0 and selection_arrow_left.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==0:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    selection_arrow_left.tStart = t  # underestimates by a little under one frame\u000a                    selection_arrow_left.frameNStart = frameN  # exact frame index\u000a                    selection_arrow_left.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==0:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        tracker.sendMessage("%d DISPLAY ON SELECTION" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 1\u000a                elif selection_arrow_left.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    if eye_sync_messages_sent==1:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    selection_arrow_left.setAutoDraw(False)\u000a                    if eye_sync_messages_sent==1:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        tracker.sendMessage("%d DISPLAY ON SELECTION OFF" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 2\u000a            \u000a            if infer_resp.keys == 'right':\u000a                # *selection_arrow_right* updates\u000a                if t >= 0.0 and selection_arrow_right.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==0:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    selection_arrow_right.tStart = t  # underestimates by a little under one frame\u000a                    selection_arrow_right.frameNStart = frameN  # exact frame index\u000a                    selection_arrow_right.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==0:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        tracker.sendMessage("%d DISPLAY ON SELECTION" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 1\u000a                elif selection_arrow_right.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    if eye_sync_messages_sent==1:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    selection_arrow_right.setAutoDraw(False)\u000a                    if eye_sync_messages_sent==1:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        tracker.sendMessage("%d DISPLAY ON SELECTION OFF" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 2\u000a            \u000a            if set_feedback.feedback_side == 'left':\u000a                # *feedback_box_left* updates\u000a                if t >= 1.0 and feedback_box_left.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==2:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    feedback_box_left.tStart = t  # underestimates by a little under one frame\u000a                    feedback_box_left.frameNStart = frameN  # exact frame index\u000a                    feedback_box_left.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==2:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        tracker.sendMessage("%d DISPLAY ON FEEDBACK" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 3\u000a                elif feedback_box_left.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    feedback_box_left.setAutoDraw(False)\u000a            \u000a            if set_feedback.feedback_side == 'right':\u000a                # *feedback_box_right* updates\u000a                if t >= 1.0 and feedback_box_right.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==2:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    feedback_box_right.tStart = t  # underestimates by a little under one frame\u000a                    feedback_box_right.frameNStart = frameN  # exact frame index\u000a                    feedback_box_right.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==2:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        tracker.sendMessage("%d DISPLAY ON FEEDBACK" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 3\u000a                elif feedback_box_right.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period right\u000a                    feedback_box_right.setAutoDraw(False)\u000a\u000a\u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial_post_responseComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                tracker.enableEventReporting(False) # End eye tracker data recording\u000a                tracker.sendMessage("EXPERIMENT ABORTED")\u000a                io.quit() # Close iohub\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "trial_post_response"-------\u000a        for thisComponent in trial_post_responseComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a        thisExp.nextEntry()\u000a                            \u000a    # completed 5 repeats of 'trial_loop'\u000a    \u000a    if block_loop_counter <= 2: # If this is the first or second cycle of the loop, display the rest break prompt\u000a\u000a        #------Prepare to start Routine "rest_prompt"-------\u000a        t = 0\u000a        rest_promptClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        rest_prompt_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        rest_prompt_resp.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        rest_promptComponents = []\u000a        rest_promptComponents.append(rest_prompt_txt)\u000a        rest_promptComponents.append(rest_prompt_resp)\u000a        for thisComponent in rest_promptComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a\u000a        #-------Start Routine "rest_prompt"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = rest_promptClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *rest_prompt_txt* updates\u000a            if t >= 0.0 and rest_prompt_txt.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                rest_prompt_txt.tStart = t  # underestimates by a little under one frame\u000a                rest_prompt_txt.frameNStart = frameN  # exact frame index\u000a                rest_prompt_txt.setAutoDraw(True)\u000a            \u000a            # *rest_prompt_resp* updates\u000a            if t >= 2.0 and rest_prompt_resp.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                rest_prompt_resp.tStart = t  # underestimates by a little under one frame\u000a                rest_prompt_resp.frameNStart = frameN  # exact frame index\u000a                rest_prompt_resp.status = STARTED\u000a                # keyboard checking is just starting\u000a                rest_prompt_resp.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            if rest_prompt_resp.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    rest_prompt_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                    rest_prompt_resp.rt = rest_prompt_resp.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in rest_promptComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                tracker.enableEventReporting(False) # End eye tracker data recording\u000a                tracker.sendMessage("EXPERIMENT ABORTED")\u000a                io.quit() # CLose iohub\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a\u000a        #-------Ending Routine "rest_prompt"-------\u000a        for thisComponent in rest_promptComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if rest_prompt_resp.keys in ['', [], None]:  # No response was made\u000a           rest_prompt_resp.keys=None\u000a        # store data for thisExp (ExperimentHandler)\u000a        thisExp.addData('rest_prompt_resp.keys',rest_prompt_resp.keys)\u000a        if rest_prompt_resp.keys != None:  # we had a response\u000a            thisExp.addData('rest_prompt_resp.rt', rest_prompt_resp.rt)\u000a\u000a\u000a    thisExp.nextEntry()\u000a    \u000a# completed 3 repeats of 'block_loop'\u000a\u000a\u000a# store data for total number of correct and incorrect responses    \u000athisExp.addData('correct_counter', correct_counter)\u000athisExp.addData('incorrect_counter', incorrect_counter)\u000athisExp.nextEntry()     \u000a\u000atracker.setConnectionState(False) # Close and transfer eye-tracking data, then close down eye tracker connection\u000a\u000a\u000a######################## AUCTION ##########################\u000a\u000aif len(prefs)==41 and len(bids)==41: # If S completed the entire binary choice and BDM routines, run the auction\u000a\u000a    # run the auction\u000a    class auction:\u000a        rand_itm = randint(1, (len(prefs))) # pick index for S's chosen item from a random choice\u000a        price = float((randint(1, 300)))/100 # assign a price to the item randomly from between 0.01 and 3 pounds\u000a        bid = prefs[rand_itm][3]\u000a        # check if S's bid for that item was above or below the price\u000a        if bid >= price:\u000a            win_item=True\u000a        elif bid < price:\u000a            win_item=False\u000a\u000a        # set text for the auction screen\u000a        if win_item==True:\u000a            auc_res_txt = u'Congratulations! You won the following item at auction. \u005cnThis was your preferred item out of a randomly selected pair from one of the choice tasks.'\u000a            auc_prc_txt = u'Your bid of \u005cxa3' + '{0:.2f}'.format(bid) + u' matched or exceeded the randomly generated price of \u005cxa3' + '{0:.2f}'.format(price) + '.\u005cn\u005cn[Press space bar to continue]'\u000a            cost = price\u000a        elif win_item==False:\u000a            auc_res_txt = u'Sorry, you did not win the following item at auction. \u005cnThis was your preferred item out of a randomly selected pair from one of the choice tasks.'\u000a            auc_prc_txt = u'Your bid of \u005cxa3' + '{0:.2f}'.format(bid) + u' was lower than the randomly generated price of \u005cxa3' + '{0:.2f}'.format(price) + '.\u005cn\u005cn[Press space bar to continue]'\u000a            cost = 0\u000a\u000a        # find the image path of the auction item\u000a        rand_itm_img = prefs[rand_itm][2]\u000a\u000a    # add up each component of S's payment\u000a    class score:\u000a        base = 25\u000a        rwrd = 0.01\u000a        loss = 0\u000a        rwrd_tot = rwrd * correct_counter\u000a        loss_tot = loss * incorrect_counter\u000a        pre_pymt = base + rwrd_tot - loss_tot\u000a        final_pymt = pre_pymt - auction.cost\u000a\u000a        pymt_expl_bdwn = u'\u005cxa3' + '{0:.2f}'.format(base) + u' base payment'+ u'\u005cn+ \u005cxa3' + '{0:.2f}'.format(rwrd_tot) + ' reward for ' + str(correct_counter) + u' correct responses (\u005cxa3' + '{0:.2f}'.format(rwrd) + u' each)' + u'\u005cn- \u005cxa3' + '{0:.2f}'.format(auction.cost) + ' cost of auction item' \u000a        pymt_expl_tot = u'Your total payment is: \u005cxa3' + '{0:.2f}'.format(final_pymt) + '\u005cn\u005cnThank you for participating! Please call the experimenter into the room.'\u000a\u000a\u000a    # Initialize components for Routine "auc_disp"\u000a    auc_dispClock = core.Clock()\u000a    pic_auc_itm = visual.ImageStim(win=win, name='pic_auc_itm',\u000a        image=dir_path+auction.rand_itm_img, mask=None,\u000a        ori=0, pos=[0, 0], size=None,\u000a        color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a        flipHoriz=False, flipVert=False,\u000a        texRes=128, interpolate=False, depth=0.0)\u000a    auc_txt1 = visual.TextStim(win=win, ori=0, name='auc_txt1',\u000a        text=auction.auc_res_txt, font=u'Arial',\u000a        pos=[0, 0.6], height=0.07, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    auc_txt2 = visual.TextStim(win=win, ori=0, name='auc_txt2',\u000a        text=auction.auc_prc_txt, font=u'Arial',\u000a        pos=[0, -0.6], height=0.07, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a\u000a    #------Prepare to start Routine "auc_disp"-------\u000a    t = 0\u000a    auc_dispClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    key_resp_auc_disp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_auc_disp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    auc_dispComponents = []\u000a    auc_dispComponents.append(pic_auc_itm)\u000a    auc_dispComponents.append(auc_txt1)\u000a    auc_dispComponents.append(auc_txt2)\u000a    for thisComponent in auc_dispComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "auc_disp"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = auc_dispClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *pic_auc_itm* updates\u000a        if t >= 0.2 and pic_auc_itm.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            pic_auc_itm.tStart = t  # underestimates by a little under one frame\u000a            pic_auc_itm.frameNStart = frameN  # exact frame index\u000a            pic_auc_itm.setAutoDraw(True)\u000a        \u000a        # *auc_txt1* updates\u000a        if t >= 0.2 and auc_txt1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            auc_txt1.tStart = t  # underestimates by a little under one frame\u000a            auc_txt1.frameNStart = frameN  # exact frame index\u000a            auc_txt1.setAutoDraw(True)\u000a\u000a        # *auc_txt2* updates\u000a        if t >= 0.2 and auc_txt2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            auc_txt2.tStart = t  # underestimates by a little under one frame\u000a            auc_txt2.frameNStart = frameN  # exact frame index\u000a            auc_txt2.setAutoDraw(True)\u000a        \u000a        # *key_resp_auc_disp* updates\u000a        if t >= 0.2 and key_resp_auc_disp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_auc_disp.tStart = t  # underestimates by a little under one frame\u000a            key_resp_auc_disp.frameNStart = frameN  # exact frame index\u000a            key_resp_auc_disp.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_auc_disp.clock.reset()  # now t=0\u000a        if key_resp_auc_disp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_auc_disp.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_auc_disp.rt = key_resp_auc_disp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in auc_dispComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "auc_disp"-------\u000a    for thisComponent in auc_dispComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_auc_disp.keys in ['', [], None]:  # No response was made\u000a       key_resp_auc_disp.keys=None\u000a    # store data for thisExp (TrialHandler)\u000a    thisExp.addData('auction.win_item', auction.win_item)\u000a    thisExp.addData('auction.price', auction.price)\u000a    thisExp.addData('auction.bid', auction.bid)\u000a    thisExp.addData('auction.rand_itm_img', auction.rand_itm_img)\u000a    thisExp.addData('score.base', score.base)\u000a    thisExp.addData('score.rwrd', score.rwrd)\u000a    thisExp.addData('score.loss', score.loss)\u000a    thisExp.addData('correct_counter', correct_counter)\u000a    thisExp.addData('incorrect_counter', incorrect_counter)\u000a    thisExp.addData('score.final_pymt', score.final_pymt)\u000a    thisExp.nextEntry()\u000a\u000a\u000a    # Initialize components for Routine "pymt_disp"\u000a    pymt_dispClock = core.Clock()\u000a    pymt_disp_txt1 = visual.TextStim(win=win, ori=0, name='pymt_disp_txt1',\u000a        text=score.pymt_expl_bdwn, font=u'Arial',\u000a        pos=[0, 0.6], height=0.07, wrapWidth=1.5,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    pymt_disp_txt2 = visual.TextStim(win=win, ori=0, name='pymt_disp_txt2',\u000a        text=score.pymt_expl_tot, font=u'Arial',\u000a        pos=[0, -0.65], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    #------Prepare to start Routine "pymt_disp"-------\u000a    t = 0\u000a    pymt_dispClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    key_resp_pymt_disp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_pymt_disp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    pymt_dispComponents = []\u000a    pymt_dispComponents.append(pic_auc_itm)\u000a    pymt_dispComponents.append(pymt_disp_txt1)\u000a    pymt_dispComponents.append(pymt_disp_txt2)\u000a    pymt_dispComponents.append(key_resp_pymt_disp)\u000a    for thisComponent in pymt_dispComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "pymt_disp"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = pymt_dispClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        if auction.win_item==True:\u000a            # *pic_auc_itm* updates\u000a            if t >= 0.0 and pic_auc_itm.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                pic_auc_itm.tStart = t  # underestimates by a little under one frame\u000a                pic_auc_itm.frameNStart = frameN  # exact frame index\u000a                pic_auc_itm.setAutoDraw(True)\u000a\u000a        # *pymt_disp_txt1* updates\u000a        if t >= 0.0 and pymt_disp_txt1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            pymt_disp_txt1.tStart = t  # underestimates by a little under one frame\u000a            pymt_disp_txt1.frameNStart = frameN  # exact frame index\u000a            pymt_disp_txt1.setAutoDraw(True)\u000a\u000a        # *pymt_disp_txt2* updates\u000a        if t >= 0.0 and pymt_disp_txt2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            pymt_disp_txt2.tStart = t  # underestimates by a little under one frame\u000a            pymt_disp_txt2.frameNStart = frameN  # exact frame index\u000a            pymt_disp_txt2.setAutoDraw(True)\u000a        \u000a        # *key_resp_pymt_disp* updates\u000a        if t >= 3.0 and key_resp_pymt_disp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_pymt_disp.tStart = t  # underestimates by a little under one frame\u000a            key_resp_pymt_disp.frameNStart = frameN  # exact frame index\u000a            key_resp_pymt_disp.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_pymt_disp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if key_resp_pymt_disp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_pymt_disp.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_pymt_disp.rt = key_resp_pymt_disp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in pymt_dispComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "pymt_disp"-------\u000a    for thisComponent in pymt_dispComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_pymt_disp.keys in ['', [], None]:  # No response was made\u000a       key_resp_pymt_disp.keys=None\u000a\u000aelse: # If S didn't complete the entire binary choice and BDM routines during this session, prompt a manual auction\u000a    # Initialize components for Routine "auc_manual"\u000a    auc_manualClock = core.Clock()\u000a    auc_manual_txt = visual.TextStim(win=win, ori=0, name='auc_manual_txt',\u000a        text=u'Thank you! This completes the experiment. Please get the experimenter, who will run the auction and calculate your final payment.\u005cn\u005cnCorrect: ' + str(correct_counter) + '\u005cnIncorrect: ' + str(incorrect_counter),    font=u'Arial',\u000a        pos=[0, 0], height=0.07, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    #------Prepare to start Routine "auc_manual"-------\u000a    t = 0\u000a    auc_manualClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    auc_manualComponents = []\u000a    auc_manualComponents.append(auc_manual_txt)\u000a    for thisComponent in auc_manualComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "auc_manual"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = auc_manualClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *auc_manual_txt* updates\u000a        if t >= 0.0 and auc_manual_txt.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            auc_manual_txt.tStart = t  # underestimates by a little under one frame\u000a            auc_manual_txt.frameNStart = frameN  # exact frame index\u000a            auc_manual_txt.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in auc_manualComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "auc_manual"-------\u000a    for thisComponent in auc_manualComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000athisExp.nextEntry()\u000a\u000aio.quit() # Close iohub\u000a\u000a\u000awin.close()\u000acore.quit()\u000a
p9817
sg9108
(lp9818
sg9110
I84422992
sg10
g9400
sg6
g9112
sg9113
I1
sg52
I01
sg53
g54
sg9114
g1
(g9115
g9116
(dp9819
g33
g9119
(g9120
g93
g9121
S'b'
tRp9820
(I1
(I200
I1
tg9245
I00
S'@Tm\x1b\x90\xed\xf4\x0bX\xee\xf4\x0b\xf8)\xf5\x0b0*\xf5\x0bpTm\x1b\xf8)\xf5\x0bX\xee\xf4\x0b\x98\xf5\xaa\x04\xa0Tm\x1b\xd0Tm\x1b\x90\xed\xf4\x0bh*\xf5\x0b\x00Um\x1b\xa0*\xf5\x0b \xdch\x0c\xc0Um\x1b0*\xf5\x0b@Tm\x1b@\xf8\xaa\x04\xb0\xeb\xf4\x0b\xd8*\xf5\x0b\x90Um\x1b\xa0\xd7h\x0c\x90\xed\xf4\x0b\xb0\xeb\xf4\x0bh*\xf5\x0b\x90\xed\xf4\x0b0*\xf5\x0b\xa0\xec\xf4\x0b\xa0*\xf5\x0b\x98\xe0\xf4\x0b@\xf8\xaa\x04\xb0\xeb\xf4\x0b \x956\x03\xd0Tm\x1b \xdch\x0c(\x926\x03\xd0Tm\x1b\xa8\x946\x03\xa0\xd7h\x0c\xa0\xec\xf4\x0b@Tm\x1b \x906\x03\x98\x10\xf5\x0b\x90\xed\xf4\x0b \x906\x03 \xdch\x0c\xa0Tm\x1bpTm\x1b \x906\x03 \x956\x03\xf8)\xf5\x0b`\xd7h\x0cPVm\x1b\xf8)\xf5\x0b\xa0\xec\xf4\x0bX\xee\xf4\x0b\xa8\x946\x03@Tm\x1b\xa0\xd7h\x0c\xd8*\xf5\x0b\x00Um\x1b\xa0\xd7h\x0c\xa0\xec\xf4\x0b@\xdch\x0c\xa0\xec\xf4\x0b\xd8*\xf5\x0b\xa8\x946\x03\xa0Tm\x1bpTm\x1b@\xdch\x0c@\xf8\xaa\x04pTm\x1b@\xf8\xaa\x040*\xf5\x0bX\xee\xf4\x0b\x00Um\x1b\xb0\xeb\xf4\x0b\xa0*\xf5\x0b\xa8\x946\x03 \x956\x03\xa0Tm\x1b\xd0Tm\x1b \xdch\x0c\x00Um\x1b\x98\xe0\xf4\x0b\xa0\xd7h\x0ch*\xf5\x0b\x90\xed\xf4\x0b\x90Um\x1b\xa0*\xf5\x0b \xd5h\x0cpTm\x1bh*\xf5\x0b\xa0\xec\xf4\x0b\x98\xe0\xf4\x0b \x956\x03\x98\xe0\xf4\x0b0Um\x1b\xf8)\xf5\x0b\xa0\xd7h\x0c\xa0\xec\xf4\x0b \x906\x030*\xf5\x0b0Um\x1b \x956\x03\x90Um\x1b\xf8)\xf5\x0b\xd8*\xf5\x0b\xa8\x946\x03X\xee\xf4\x0b\xd0Tm\x1b\xb0\xeb\xf4\x0bH+\xf5\x0bpTm\x1b\xa0*\xf5\x0b \xd5h\x0ch*\xf5\x0bH\x10\xf5\x0b\xa0*\xf5\x0b`Um\x1b0Um\x1bpTm\x1b \x956\x03 \x906\x03\xa0\xec\xf4\x0b\xd0Tm\x1b@Tm\x1b\x10+\xf5\x0b\xa0*\xf5\x0b\x98\xe0\xf4\x0b\xf8)\xf5\x0b\xf0Um\x1b\x00Um\x1b(\x926\x03\xa0Tm\x1b\xa8\x946\x03\xd0Tm\x1b\xa8\x946\x03\xf8)\xf5\x0b \x906\x03\xa0*\xf5\x0b@Tm\x1b`\xd7h\x0c@\xdch\x0cH\x10\xf5\x0b \xdch\x0c\xb0\xeb\xf4\x0b\xd8*\xf5\x0b\x98\xe0\xf4\x0b\x90\xed\xf4\x0b \x956\x03h*\xf5\x0b\xb0\xeb\xf4\x0b\xd0Tm\x1b\xf8)\xf5\x0b\x98\xe0\xf4\x0b \xdch\x0c\x90\xed\xf4\x0b`\xd7h\x0c\xa8\x946\x03 \x956\x03\xb0\xeb\xf4\x0b\xa0\xd7h\x0c\x00Um\x1bX\xee\xf4\x0b\xa0*\xf5\x0b Vm\x1b\x90\xed\xf4\x0b@Tm\x1b`\xd7h\x0c0*\xf5\x0b\x00Um\x1b\xa0*\xf5\x0b\x90\xed\xf4\x0bh*\xf5\x0b\xa0\xd7h\x0c\xf0Um\x1b\xa0Tm\x1b \x906\x03p\x10\xf5\x0b`Um\x1b\x00Um\x1b(\x926\x03\x98\xe0\xf4\x0b\xa0\xd7h\x0ch*\xf5\x0b \x906\x030Um\x1b \x956\x03\xa0Tm\x1b\xd0Tm\x1b0*\xf5\x0b\xa0\xec\xf4\x0b\x98\xf5\xaa\x04pTm\x1b\x98\xe0\xf4\x0b\x00Um\x1b@\xf8\xaa\x04'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg9118
g9119
(g9120
g93
g9121
S'b'
tRp9821
(I1
(I200
I1
tg9123
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg38
g9119
(g9120
g93
g9121
S'b'
tRp9822
(I1
(I200
I1
tg9245
I00
S'`ge\x1b\xa0ge\x1b\xa0fe\x1b\x80ge\x1b@fe\x1b\xe0ee\x1b@he\x1b`ee\x1b\x00he\x1b\x00ge\x1b\xc0fe\x1b\x80fe\x1b ge\x1b\xc0ee\x1b\xc0he\x1b@ge\x1b\x00fe\x1b`he\x1b\xa0he\x1b\xe0fe\x1b\x806\r\x0c`fe\x1b\x80he\x1b fe\x1b`je\x1b\xa0je\x1b@ie\x1b\xe0ge\x1b\xe0je\x1b@je\x1b\xe0he\x1b\xe0ie\x1b he\x1b\xa0ee\x1b\x00ie\x1b\x80ee\x1b@ke\x1b\x00ke\x1b`ke\x1b\xc0ke\x1b@le\x1b`le\x1b\x00le\x1b\xc0ie\x1b\xc0je\x1b\xc0ge\x1b\xe0ke\x1b me\x1b\x80ie\x1b`me\x1b\x80ke\x1b je\x1b\x00ne\x1b\xa0ie\x1b le\x1b`ne\x1b\x80me\x1b@me\x1b ke\x1b@ne\x1b\x00je\x1b ne\x1b`ie\x1b\xa0me\x1b\xc0ne\x1b\xc0me\x1b\x00oe\x1b\xa0le\x1b@oe\x1b\x80ne\x1b\xe0me\x1b`oe\x1b\xa0ne\x1b\x80je\x1b\xc0le\x1b\x80oe\x1b ie\x1b\xa0ke\x1b\xa0oe\x1b oe\x1b\xe0le\x1b\xe0oe\x1b`=\r\x0c\xe0ne\x1b@\x12\x8c\x1b \x12\x8c\x1b\xc0\x10\x8c\x1b@\x11\x8c\x1b\x00\x12\x8c\x1b\xe0\x10\x8c\x1b`\x10\x8c\x1b\x80le\x1b\xa0\x12\x8c\x1b\xc0\x12\x8c\x1b\xe0\x11\x8c\x1b`\x12\x8c\x1b\x80\x13\x8c\x1b\xe0\x12\x8c\x1b\x80\x11\x8c\x1b`\x11\x8c\x1b \x13\x8c\x1b \x14\x8c\x1b\x00\x11\x8c\x1b@\x14\x8c\x1b \x10\x8c\x1b\xc0\x13\x8c\x1b`\x13\x8c\x1b\xc0\x11\x8c\x1b\x00\x14\x8c\x1b\xa0\x13\x8c\x1b@\x10\x8c\x1b\xa0\x11\x8c\x1b`\x14\x8c\x1b \x15\x8c\x1b\x80\x12\x8c\x1b\xe0\x14\x8c\x1b\x80\x15\x8c\x1b\x80\x10\x8c\x1b \x11\x8c\x1b\x00\x13\x8c\x1b`\x15\x8c\x1b\xa0\x15\x8c\x1b\xc0\x16\x8c\x1b@\x16\x8c\x1b\xe0\x13\x8c\x1b\xc0\x15\x8c\x1b\xe0\x16\x8c\x1b@\x17\x8c\x1b\xe0\x15\x8c\x1b\xa0\x10\x8c\x1b\xa0\x17\x8c\x1b@\x13\x8c\x1b\x80\x14\x8c\x1b\x00\x15\x8c\x1b \x18\x8c\x1b\xc0\x17\x8c\x1b`\x16\x8c\x1b\xa0\x18\x8c\x1b@\x18\x8c\x1b\x00\x17\x8c\x1b\x80\x17\x8c\x1b\xa0\x14\x8c\x1b\xe0\x18\x8c\x1b`\x18\x8c\x1b \x19\x8c\x1b\xa0\x19\x8c\x1b\x80\x16\x8c\x1b\x00\x18\x8c\x1b`\x17\x8c\x1b\xe0\x17\x8c\x1b\xe0\x19\x8c\x1b\x00\x16\x8c\x1b\x00\x1a\x8c\x1b\xa0\x1a\x8c\x1b`\x19\x8c\x1b\x80\x1a\x8c\x1b\xc0\x14\x8c\x1b\x80\x18\x8c\x1b`\x1a\x8c\x1b@\x1b\x8c\x1b \x17\x8c\x1b@\x1a\x8c\x1b \x16\x8c\x1b\x80\x1b\x8c\x1b\x00\x1c\x8c\x1b \x1a\x8c\x1b\xc0\x1a\x8c\x1b\xe0\x1a\x8c\x1b\xc0\x1b\x8c\x1b\xe0\x1b\x8c\x1b \x1b\x8c\x1b`\x1b\x8c\x1b\x00\x1d\x8c\x1b \x1c\x8c\x1b\xc0\x1c\x8c\x1b\xc0\x18\x8c\x1b\xa0\x1c\x8c\x1b\xc0\x19\x8c\x1b@\x1c\x8c\x1b\xa0\x16\x8c\x1b\xa0\x1d\x8c\x1b\xc0\x1d\x8c\x1b`\x1d\x8c\x1b\x80\x1c\x8c\x1b\x80\x1d\x8c\x1b\x80\x19\x8c\x1b\xa0\x1b\x8c\x1b \x1d\x8c\x1b\xe0\x1e\x8c\x1b@\x15\x8c\x1b\xa0\x1e\x8c\x1b\x00\x1e\x8c\x1b@\x1d\x8c\x1b\x00\x1b\x8c\x1b\xa0\x1f\x8c\x1b@\x19\x8c\x1b\x00\x1f\x8c\x1b`\x1c\x8c\x1b\x80\x1e\x8c\x1b \x1e\x8c\x1b'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg9126
g9119
(g9120
g93
g9121
S'b'
tRp9823
(I1
(I200
I1
tg9123
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00@\x00\x00@@\x00\x00\x80@\x00\x00\xa0@\x00\x00\xc0@\x00\x00\xe0@\x00\x00\x00A\x00\x00\x10A\x00\x00 A\x00\x000A\x00\x00@A\x00\x00PA\x00\x00`A\x00\x00pA\x00\x00\x80A\x00\x00\x88A\x00\x00\x90A\x00\x00\x98A\x00\x00\xa0A\x00\x00\xa8A\x00\x00\xb0A\x00\x00\xb8A\x00\x00\xc0A\x00\x00\xc8A\x00\x00\xd0A\x00\x00\xd8A\x00\x00\xe0A\x00\x00\xe8A\x00\x00\xf0A\x00\x00\xf8A\x00\x00\x00B\x00\x00\x04B\x00\x00\x08B\x00\x00\x0cB\x00\x00\x10B\x00\x00\x14B\x00\x00\x18B\x00\x00\x1cB\x00\x00 B\x00\x00$B\x00\x00(B\x00\x00,B\x00\x000B\x00\x004B\x00\x008B\x00\x00<B\x00\x00@B\x00\x00DB\x00\x00HB\x00\x00LB\x00\x00PB\x00\x00TB\x00\x00XB\x00\x00\\B\x00\x00`B\x00\x00dB\x00\x00hB\x00\x00lB\x00\x00pB\x00\x00tB\x00\x00xB\x00\x00|B\x00\x00\x80B\x00\x00\x82B\x00\x00\x84B\x00\x00\x86B\x00\x00\x88B\x00\x00\x8aB\x00\x00\x8cB\x00\x00\x8eB\x00\x00\x90B\x00\x00\x92B\x00\x00\x94B\x00\x00\x96B\x00\x00\x98B\x00\x00\x9aB\x00\x00\x9cB\x00\x00\x9eB\x00\x00\xa0B\x00\x00\xa2B\x00\x00\xa4B\x00\x00\xa6B\x00\x00\xa8B\x00\x00\xaaB\x00\x00\xacB\x00\x00\xaeB\x00\x00\xb0B\x00\x00\xb2B\x00\x00\xb4B\x00\x00\xb6B\x00\x00\xb8B\x00\x00\xbaB\x00\x00\xbcB\x00\x00\xbeB\x00\x00\xc0B\x00\x00\xc2B\x00\x00\xc4B\x00\x00\xc6B\x00\x00\xc8B\x00\x00\xcaB\x00\x00\xccB\x00\x00\xceB\x00\x00\xd0B\x00\x00\xd2B\x00\x00\xd4B\x00\x00\xd6B\x00\x00\xd8B\x00\x00\xdaB\x00\x00\xdcB\x00\x00\xdeB\x00\x00\xe0B\x00\x00\xe2B\x00\x00\xe4B\x00\x00\xe6B\x00\x00\xe8B\x00\x00\xeaB\x00\x00\xecB\x00\x00\xeeB\x00\x00\xf0B\x00\x00\xf2B\x00\x00\xf4B\x00\x00\xf6B\x00\x00\xf8B\x00\x00\xfaB\x00\x00\xfcB\x00\x00\xfeB\x00\x00\x00C\x00\x00\x01C\x00\x00\x02C\x00\x00\x03C\x00\x00\x04C\x00\x00\x05C\x00\x00\x06C\x00\x00\x07C\x00\x00\x08C\x00\x00\tC\x00\x00\nC\x00\x00\x0bC\x00\x00\x0cC\x00\x00\rC\x00\x00\x0eC\x00\x00\x0fC\x00\x00\x10C\x00\x00\x11C\x00\x00\x12C\x00\x00\x13C\x00\x00\x14C\x00\x00\x15C\x00\x00\x16C\x00\x00\x17C\x00\x00\x18C\x00\x00\x19C\x00\x00\x1aC\x00\x00\x1bC\x00\x00\x1cC\x00\x00\x1dC\x00\x00\x1eC\x00\x00\x1fC\x00\x00 C\x00\x00!C\x00\x00"C\x00\x00#C\x00\x00$C\x00\x00%C\x00\x00&C\x00\x00\'C\x00\x00(C\x00\x00)C\x00\x00*C\x00\x00+C\x00\x00,C\x00\x00-C\x00\x00.C\x00\x00/C\x00\x000C\x00\x001C\x00\x002C\x00\x003C\x00\x004C\x00\x005C\x00\x006C\x00\x007C\x00\x008C\x00\x009C\x00\x00:C\x00\x00;C\x00\x00<C\x00\x00=C\x00\x00>C\x00\x00?C\x00\x00@C\x00\x00AC\x00\x00BC\x00\x00CC\x00\x00DC\x00\x00EC\x00\x00FC\x00\x00GC'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg39
g9119
(g9120
g93
g9121
S'b'
tRp9824
(I1
(I200
I1
tg9123
I00
S'\xa7;D?\x7f~H?\xe5\x0f"?\xbc>D?\xa5\xc4\x0c?\x9d\xe4\x1d?T\xe8.?`\xd4.?{\xf9??\xac\xa5\xaa?\xea\xa3*?\xd6\x89H?6+3?T\xb7\x9b?\x80\xf5??\xf3r7?\x89e\x86?\xef\x877?\x04d\x86?\x8f\xa5*?/\xed??\xdbr\xb7??D\xa4?P\x19"?\xb3\x93Y?\x96+3?\xf5ww?)\xd9\x1d?%\xa6H?\x1f\xc8L?\xe9?\x84?\x84\xd7\x1d?\x9f\x1ab?\xed\xb3;?F)Q?\xf0d\x86@n\xd6]?,\xf8??4n7?\xa0IU?\xec+3?\xe7\xce]?Db&?/\xa7*?M\rQ?*\x87H?\x1e\x99\x19?-\x97\x99?T\xb1{?\x8fn7?\x00\xef.?\xe3\xdfL?}\xfe??\xd1?D?\xef\xb6;?\xdb\xf7??\xf2\x9c*?\xceJD?\xfe\xed.?\xc5S\x95?qAD?\xa8\xe7n?\xd2p7?\xa7\xa9*?\xdc\x90Y?\xd7\xc9L?c\xe6.?\x81\x92\x19?\xb5\x94\x19?\xaf2s?\xa7\x94\x19?YA\x84?\r\x1b"?\xb6\xc5\x0c?\x83\xeen?\x9b\xf6]?\x05\x8eY?\t\xf1.? 23?D\xcc]?\xfad&?X\xa6*?\xdd\x07Q?\x1cn7?\xc6\xa8*?^R\x15?\x99\xc5L?\xf6\xee.?\x12\xaa\x8a?\xa6,3?)\xd9]?~\xaa;?j\x1c"?,f&?\xa2\xa5j?-m7?\xb4\xec.?\xa2\x98\x19?\x00\xd8\x1d?i\r"?\xec<D?f\x14"?b\xd7]?\xcda&?\x1bzw?\x91\xddn?\xdd\x1a"?\xf9\xc3L?\x88\xaa*?\x8b\x0e\x91?\x9f\x86H?\x99n&?\xde\xb5;?\xec\xa8*?c,3?q\xe8.?\xd1e\x86?\xc5J3?\xaa!"?\x92\xdd\x1d?2\xff??\x84\xd5\x1d?\xe0\xa9;?\x83\xe3\x0c?\x06/3?\xd4\xed\x0c? e7?\xec\x1a"?\tt\x97?\xc7TU?m,3?+p7?\x1123?\xb3s7?\x8e,3?%g&?m@\xa4?\x98c&?\xe3\xa6*?\x8a\xde\x1d?N<D?S\xdd\x1d?\xaa\xc6L?\x07\xc8L?\x97\xee\xae?N\xac*?/\x87\x08?\xb1\xd8\x1d?\xdc\xd8\x1d?\xf9\xb2{?\xbe?D?\xbc+3?\xa853?\x9e\x19@?\x06ff?_\x19"?\x08\xe8.?\x8e23?\x02s7?\xe8\xa6*?=\n\x11?\xe4\xe8.?\xc1^&?\x8e,3?\xcd*3?\xca\x907?L]7?+\xdc\x1d?\xf3\x19"?g23?\xc933?\xbdID?{,3?\xd4d&?5\xb6;?\x16\xea.?Bt7?\x15\xac*?ha&?\xa0\xa5\xaa?1M\x15?0\xa3*?k\xcc\x0c?\xf7m\x15?\xd2\xb8;?\x17a&?\xb7M\x15?G\xbc;?)\x0c\x11?\xacS7?\x14\x9b\x19?\xaf\x0cQ?\x11\xb5;?\xeb33?\x19\xbbL?\xa4\xac*?\xd6\x08\x11?,d&?9\xcc\x8c?_N\x15?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg34
g9119
(g9120
g93
g9121
S'b'
tRp9825
(I1
(I200
I1
tg9245
I00
S'\xf0H\xbc\x04\xb0L\xbc\x04\xa8^\x0b\x05P\\\x0b\x05\xd8^\x0b\x05\x88Z\x0b\x05\xb8W\x0b\x05\xe8Z\x0b\x05\xb0_\x0b\x05h_\x0b\x05\x18R\x0b\x05\x80_\x0b\x05PY\x0b\x058V\x0b\x05XZ\x0b\x05(]\x0b\x05\x80Y\x0b\x05\x08V\x0b\x05\x98_\x0b\x05\xa0T\x0b\x05HR\x0b\x05XQ\x0b\x05\x90X\x0b\x05\x98S\x0b\x05\xe0\\\x0b\x05(T\x0b\x05P_\x0b\x05\xe8T\x0b\x05\xd0Z\x0b\x05(W\x0b\x058_\x0b\x05\x18[\x0b\x05\x10Z\x0b\x058\\\x0b\x05\xd0W\x0b\x05x[\x0b\x05\x98\\\x0b\x05hY\x0b\x05xU\x0b\x05\x88T\x0b\x05p]\x0b\x05\xb8T\x0b\x05\xd8X\x0b\x05\xf0[\x0b\x05`X\x0b\x05\xc0[\x0b\x05\xa0]\x0b\x05\x18U\x0b\x05@Z\x0b\x05xX\x0b\x05\x10T\x0b\x058S\x0b\x05\xc8P\x0b\x05\xc0U\x0b\x05\xa0Z\x0b\x05\xf0R\x0b\x05\xe8W\x0b\x058P\x0b\x05\xf8P\x0b\x05\xe0S\x0b\x05@]\x0b\x05\xc0^\x0b\x05`[\x0b\x05\xa8[\x0b\x05\xc0R\x0b\x05pT\x0b\x05@W\x0b\x05\xc0X\x0b\x05(Q\x0b\x050R\x0b\x05\x88]\x0b\x05PS\x0b\x05@T\x0b\x05\xc8Y\x0b\x05\x80V\x0b\x05\x90[\x0b\x05\x98P\x0b\x05\xc0\x8b\xda\x04h\x89\xda\x04x\x88\xda\x04\xe0\x8c\xda\x04@\x87\xda\x04x\x82\xda\x04 \x86\xda\x04\xf8\x86\xda\x04\x00\x82\xda\x04(\x87\xda\x04\xc8\x86\xda\x04 \x83\xda\x04\xf0\x82\xda\x04\x08\x8c\xda\x04\xe0\xf0G\x02H\xfeG\x0202\xbb\x04\xe03\xbb\x04\xc05\xbb\x04\xf08\xbb\x04 6\xbb\x04@7\xbb\x04\xb03\xbb\x0483\xbb\x04h3\xbb\x04\x806\xbb\x04P3\xbb\x04X7\xbb\x04\xe81\xbb\x04\xe8:\xbb\x04P6\xbb\x04\xd0:\xbb\x04\xb87\xbb\x04\xe09\xbb\x04P9\xbb\x04\x18;\xbb\x04\xe06\xbb\x04`;\xbb\x04\xc0>\xbb\x04h0\xbb\x04\x18>\xbb\x04\xe00\xbb\x04\x107\xbb\x04\xf0>\xbb\x04(:\xbb\x04X4\xbb\x04\x002\xbb\x04\x086\xbb\x04\xc89\xbb\x04\xa88\xbb\x04\xe8=\xbb\x04\xc86\xbb\x04p=\xbb\x04\xa01\xbb\x04(=\xbb\x04x8\xbb\x04x>\xbb\x04p7\xbb\x04h?\xbb\x04@4\xbb\x04\xb00\xbb\x04P?\xbb\x04p:\xbb\x040>\xbb\x04P0\xbb\x04`>\xbb\x04\x887\xbb\x04p4\xbb\x04\x00;\xbb\x04`2\xbb\x04\xc8?\xbb\x04\xb8=\xbb\x04@=\xbb\x04\x88:\xbb\x04\x905\xbb\x04 ?\xbb\x04h9\xbb\x04\x983\xbb\x04\x10:\xbb\x04\xc8V\x0b\x05\x00R\x0b\x05\xd8U\x0b\x05hV\x0b\x050X\x0b\x05\xc8\\\x0b\x05h\\\x0b\x05PV\x0b\x05\xc8S\x0b\x05xR\x0b\x05\x98Y\x0b\x05\x08_\x0b\x05\xa0Q\x0b\x050[\x0b\x05pQ\x0b\x05\xc8_\x0b\x05\x10Q\x0b\x05\xb0Y\x0b\x05\xd8[\x0b\x058Y\x0b\x05\xf8Y\x0b\x05`U\x0b\x05pW\x0b\x05 _\x0b\x05\xb0S\x0b\x05\xb8Z\x0b\x050^\x0b\x05H^\x0b\x05\xb0\\\x0b\x05\x10W\x0b\x05 Y\x0b\x05\xe0P\x0b\x05HX\x0b\x05\xe0_\x0b\x05\xa0W\x0b\x05\xd0T\x0b\x05H[\x0b\x05\xe0V\x0b\x05\x00[\x0b\x05\xf8S\x0b\x05`^\x0b\x05\x90^\x0b\x05pZ\x0b\x05\x18^\x0b\x05'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp9826
(dp9827
g9131
(dp9828
g9118
I01
sg38
I00
sg33
I00
sg9126
I01
sg39
I01
sg34
I00
ssg9133
g9815
sg9134
(lp9829
g9118
ag9126
ag38
ag39
ag33
ag34
asg9136
(lp9830
I200
aI1
asbsg9138
g9253
sg9140
g92
(g93
(I0
tS'b'
tRp9831
(I1
(I200
I1
tg99
I00
S'\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00\x04\x00\x00\x00\x05\x00\x00\x00\x06\x00\x00\x00\x07\x00\x00\x00\x08\x00\x00\x00\t\x00\x00\x00\n\x00\x00\x00\x0b\x00\x00\x00\x0c\x00\x00\x00\r\x00\x00\x00\x0e\x00\x00\x00\x0f\x00\x00\x00\x10\x00\x00\x00\x11\x00\x00\x00\x12\x00\x00\x00\x13\x00\x00\x00\x14\x00\x00\x00\x15\x00\x00\x00\x16\x00\x00\x00\x17\x00\x00\x00\x18\x00\x00\x00\x19\x00\x00\x00\x1a\x00\x00\x00\x1b\x00\x00\x00\x1c\x00\x00\x00\x1d\x00\x00\x00\x1e\x00\x00\x00\x1f\x00\x00\x00 \x00\x00\x00!\x00\x00\x00"\x00\x00\x00#\x00\x00\x00$\x00\x00\x00%\x00\x00\x00&\x00\x00\x00\'\x00\x00\x00(\x00\x00\x00)\x00\x00\x00*\x00\x00\x00+\x00\x00\x00,\x00\x00\x00-\x00\x00\x00.\x00\x00\x00/\x00\x00\x000\x00\x00\x001\x00\x00\x002\x00\x00\x003\x00\x00\x004\x00\x00\x005\x00\x00\x006\x00\x00\x007\x00\x00\x008\x00\x00\x009\x00\x00\x00:\x00\x00\x00;\x00\x00\x00<\x00\x00\x00=\x00\x00\x00>\x00\x00\x00?\x00\x00\x00@\x00\x00\x00A\x00\x00\x00B\x00\x00\x00C\x00\x00\x00D\x00\x00\x00E\x00\x00\x00F\x00\x00\x00G\x00\x00\x00H\x00\x00\x00I\x00\x00\x00J\x00\x00\x00K\x00\x00\x00L\x00\x00\x00M\x00\x00\x00N\x00\x00\x00O\x00\x00\x00P\x00\x00\x00Q\x00\x00\x00R\x00\x00\x00S\x00\x00\x00T\x00\x00\x00U\x00\x00\x00V\x00\x00\x00W\x00\x00\x00X\x00\x00\x00Y\x00\x00\x00Z\x00\x00\x00[\x00\x00\x00\\\x00\x00\x00]\x00\x00\x00^\x00\x00\x00_\x00\x00\x00`\x00\x00\x00a\x00\x00\x00b\x00\x00\x00c\x00\x00\x00d\x00\x00\x00e\x00\x00\x00f\x00\x00\x00g\x00\x00\x00h\x00\x00\x00i\x00\x00\x00j\x00\x00\x00k\x00\x00\x00l\x00\x00\x00m\x00\x00\x00n\x00\x00\x00o\x00\x00\x00p\x00\x00\x00q\x00\x00\x00r\x00\x00\x00s\x00\x00\x00t\x00\x00\x00u\x00\x00\x00v\x00\x00\x00w\x00\x00\x00x\x00\x00\x00y\x00\x00\x00z\x00\x00\x00{\x00\x00\x00|\x00\x00\x00}\x00\x00\x00~\x00\x00\x00\x7f\x00\x00\x00\x80\x00\x00\x00\x81\x00\x00\x00\x82\x00\x00\x00\x83\x00\x00\x00\x84\x00\x00\x00\x85\x00\x00\x00\x86\x00\x00\x00\x87\x00\x00\x00\x88\x00\x00\x00\x89\x00\x00\x00\x8a\x00\x00\x00\x8b\x00\x00\x00\x8c\x00\x00\x00\x8d\x00\x00\x00\x8e\x00\x00\x00\x8f\x00\x00\x00\x90\x00\x00\x00\x91\x00\x00\x00\x92\x00\x00\x00\x93\x00\x00\x00\x94\x00\x00\x00\x95\x00\x00\x00\x96\x00\x00\x00\x97\x00\x00\x00\x98\x00\x00\x00\x99\x00\x00\x00\x9a\x00\x00\x00\x9b\x00\x00\x00\x9c\x00\x00\x00\x9d\x00\x00\x00\x9e\x00\x00\x00\x9f\x00\x00\x00\xa0\x00\x00\x00\xa1\x00\x00\x00\xa2\x00\x00\x00\xa3\x00\x00\x00\xa4\x00\x00\x00\xa5\x00\x00\x00\xa6\x00\x00\x00\xa7\x00\x00\x00\xa8\x00\x00\x00\xa9\x00\x00\x00\xaa\x00\x00\x00\xab\x00\x00\x00\xac\x00\x00\x00\xad\x00\x00\x00\xae\x00\x00\x00\xaf\x00\x00\x00\xb0\x00\x00\x00\xb1\x00\x00\x00\xb2\x00\x00\x00\xb3\x00\x00\x00\xb4\x00\x00\x00\xb5\x00\x00\x00\xb6\x00\x00\x00\xb7\x00\x00\x00\xb8\x00\x00\x00\xb9\x00\x00\x00\xba\x00\x00\x00\xbb\x00\x00\x00\xbc\x00\x00\x00\xbd\x00\x00\x00\xbe\x00\x00\x00\xbf\x00\x00\x00\xc0\x00\x00\x00\xc1\x00\x00\x00\xc2\x00\x00\x00\xc3\x00\x00\x00\xc4\x00\x00\x00\xc5\x00\x00\x00\xc6\x00\x00\x00\xc7\x00\x00\x00'
tbsg9142
I01
sg9143
I1
sg9144
I-1
sg9145
(lp9832
g1
(g9147
g9116
(dp9833
g3645
g3638
sg3633
g3634
sg3647
g3648
sg3642
g3643
stRp9834
ag1
(g9147
g9116
(dp9835
g3645
g3658
sg3633
g3654
sg3647
g3665
sg3642
g3662
stRp9836
ag1
(g9147
g9116
(dp9837
g3645
g3675
sg3633
g3671
sg3647
g3682
sg3642
g3679
stRp9838
ag1
(g9147
g9116
(dp9839
g3645
g3692
sg3633
g3688
sg3647
g3699
sg3642
g3696
stRp9840
ag1
(g9147
g9116
(dp9841
g3645
g3709
sg3633
g3705
sg3647
g3716
sg3642
g3713
stRp9842
ag1
(g9147
g9116
(dp9843
g3645
g3726
sg3633
g3722
sg3647
g3733
sg3642
g3730
stRp9844
ag1
(g9147
g9116
(dp9845
g3645
g3692
sg3633
g3739
sg3647
g3699
sg3642
g3746
stRp9846
ag1
(g9147
g9116
(dp9847
g3645
g3675
sg3633
g3671
sg3647
g3682
sg3642
g3679
stRp9848
ag1
(g9147
g9116
(dp9849
g3645
g3777
sg3633
g3767
sg3647
g3771
sg3642
g3775
stRp9850
ag1
(g9147
g9116
(dp9851
g3645
g3788
sg3633
g3784
sg3647
g3795
sg3642
g3792
stRp9852
ag1
(g9147
g9116
(dp9853
g3645
g3805
sg3633
g3801
sg3647
g3812
sg3642
g3809
stRp9854
ag1
(g9147
g9116
(dp9855
g3645
g3658
sg3633
g3818
sg3647
g3665
sg3642
g3825
stRp9856
ag1
(g9147
g9116
(dp9857
g3645
g3837
sg3633
g3833
sg3647
g3844
sg3642
g3841
stRp9858
ag1
(g9147
g9116
(dp9859
g3645
g3854
sg3633
g3850
sg3647
g3861
sg3642
g3858
stRp9860
ag1
(g9147
g9116
(dp9861
g3645
g3871
sg3633
g3867
sg3647
g3878
sg3642
g3875
stRp9862
ag1
(g9147
g9116
(dp9863
g3645
g3888
sg3633
g3884
sg3647
g3895
sg3642
g3892
stRp9864
ag1
(g9147
g9116
(dp9865
g3645
g3805
sg3633
g3901
sg3647
g3812
sg3642
g3908
stRp9866
ag1
(g9147
g9116
(dp9867
g3645
g3709
sg3633
g3916
sg3647
g3716
sg3642
g3923
stRp9868
ag1
(g9147
g9116
(dp9869
g3645
g3638
sg3633
g3931
sg3647
g3648
sg3642
g3938
stRp9870
ag1
(g9147
g9116
(dp9871
g3645
g3956
sg3633
g3946
sg3647
g3950
sg3642
g3954
stRp9872
ag1
(g9147
g9116
(dp9873
g3645
g3777
sg3633
g3767
sg3647
g3771
sg3642
g3775
stRp9874
ag1
(g9147
g9116
(dp9875
g3645
g3956
sg3633
g3976
sg3647
g3950
sg3642
g3983
stRp9876
ag1
(g9147
g9116
(dp9877
g3645
g3788
sg3633
g3784
sg3647
g3795
sg3642
g3792
stRp9878
ag1
(g9147
g9116
(dp9879
g3645
g4008
sg3633
g4004
sg3647
g4015
sg3642
g4012
stRp9880
ag1
(g9147
g9116
(dp9881
g3645
g3658
sg3633
g3818
sg3647
g3665
sg3642
g3825
stRp9882
ag1
(g9147
g9116
(dp9883
g3645
g3777
sg3633
g3767
sg3647
g3771
sg3642
g3775
stRp9884
ag1
(g9147
g9116
(dp9885
g3645
g3837
sg3633
g3833
sg3647
g3844
sg3642
g3841
stRp9886
ag1
(g9147
g9116
(dp9887
g3645
g3658
sg3633
g3818
sg3647
g3665
sg3642
g3825
stRp9888
ag1
(g9147
g9116
(dp9889
g3645
g3709
sg3633
g3916
sg3647
g3716
sg3642
g3923
stRp9890
ag1
(g9147
g9116
(dp9891
g3645
g4090
sg3633
g4086
sg3647
g4097
sg3642
g4094
stRp9892
ag1
(g9147
g9116
(dp9893
g3645
g3871
sg3633
g4103
sg3647
g3878
sg3642
g4110
stRp9894
ag1
(g9147
g9116
(dp9895
g3645
g4122
sg3633
g4118
sg3647
g4129
sg3642
g4126
stRp9896
ag1
(g9147
g9116
(dp9897
g3645
g3956
sg3633
g3976
sg3647
g3950
sg3642
g3983
stRp9898
ag1
(g9147
g9116
(dp9899
g3645
g3777
sg3633
g4148
sg3647
g3771
sg3642
g4155
stRp9900
ag1
(g9147
g9116
(dp9901
g3645
g4167
sg3633
g4163
sg3647
g4174
sg3642
g4171
stRp9902
ag1
(g9147
g9116
(dp9903
g3645
g3805
sg3633
g3901
sg3647
g3812
sg3642
g3908
stRp9904
ag1
(g9147
g9116
(dp9905
g3645
g3888
sg3633
g4193
sg3647
g3895
sg3642
g4200
stRp9906
ag1
(g9147
g9116
(dp9907
g3645
g3638
sg3633
g3634
sg3647
g3648
sg3642
g3643
stRp9908
ag1
(g9147
g9116
(dp9909
g3645
g3805
sg3633
g3901
sg3647
g3812
sg3642
g3908
stRp9910
ag1
(g9147
g9116
(dp9911
g3645
g4238
sg3633
g4234
sg3647
g4245
sg3642
g4242
stRp9912
ag1
(g9147
g9116
(dp9913
g3645
g4008
sg3633
g4004
sg3647
g4015
sg3642
g4012
stRp9914
ag1
(g9147
g9116
(dp9915
g3645
g4090
sg3633
g4086
sg3647
g4097
sg3642
g4094
stRp9916
ag1
(g9147
g9116
(dp9917
g3645
g3638
sg3633
g3634
sg3647
g3648
sg3642
g3643
stRp9918
ag1
(g9147
g9116
(dp9919
g3645
g4294
sg3633
g4290
sg3647
g4301
sg3642
g4298
stRp9920
ag1
(g9147
g9116
(dp9921
g3645
g4008
sg3633
g4307
sg3647
g4015
sg3642
g4314
stRp9922
ag1
(g9147
g9116
(dp9923
g3645
g3658
sg3633
g3654
sg3647
g3665
sg3642
g3662
stRp9924
ag1
(g9147
g9116
(dp9925
g3645
g4294
sg3633
g4335
sg3647
g4301
sg3642
g4342
stRp9926
ag1
(g9147
g9116
(dp9927
g3645
g3888
sg3633
g4193
sg3647
g3895
sg3642
g4200
stRp9928
ag1
(g9147
g9116
(dp9929
g3645
g3788
sg3633
g4363
sg3647
g3795
sg3642
g4370
stRp9930
ag1
(g9147
g9116
(dp9931
g3645
g3726
sg3633
g4378
sg3647
g3733
sg3642
g4385
stRp9932
ag1
(g9147
g9116
(dp9933
g3645
g4294
sg3633
g4335
sg3647
g4301
sg3642
g4342
stRp9934
ag1
(g9147
g9116
(dp9935
g3645
g4167
sg3633
g4406
sg3647
g4174
sg3642
g4413
stRp9936
ag1
(g9147
g9116
(dp9937
g3645
g3692
sg3633
g3739
sg3647
g3699
sg3642
g3746
stRp9938
ag1
(g9147
g9116
(dp9939
g3645
g3888
sg3633
g3884
sg3647
g3895
sg3642
g3892
stRp9940
ag1
(g9147
g9116
(dp9941
g3645
g4122
sg3633
g4447
sg3647
g4129
sg3642
g4454
stRp9942
ag1
(g9147
g9116
(dp9943
g3645
g3692
sg3633
g3688
sg3647
g3699
sg3642
g3696
stRp9944
ag1
(g9147
g9116
(dp9945
g3645
g4090
sg3633
g4475
sg3647
g4097
sg3642
g4482
stRp9946
ag1
(g9147
g9116
(dp9947
g3645
g3675
sg3633
g4490
sg3647
g3682
sg3642
g4497
stRp9948
ag1
(g9147
g9116
(dp9949
g3645
g4238
sg3633
g4234
sg3647
g4245
sg3642
g4242
stRp9950
ag1
(g9147
g9116
(dp9951
g3645
g3638
sg3633
g3931
sg3647
g3648
sg3642
g3938
stRp9952
ag1
(g9147
g9116
(dp9953
g3645
g4008
sg3633
g4004
sg3647
g4015
sg3642
g4012
stRp9954
ag1
(g9147
g9116
(dp9955
g3645
g3956
sg3633
g3976
sg3647
g3950
sg3642
g3983
stRp9956
ag1
(g9147
g9116
(dp9957
g3645
g3854
sg3633
g4557
sg3647
g3861
sg3642
g4564
stRp9958
ag1
(g9147
g9116
(dp9959
g3645
g4008
sg3633
g4004
sg3647
g4015
sg3642
g4012
stRp9960
ag1
(g9147
g9116
(dp9961
g3645
g4090
sg3633
g4086
sg3647
g4097
sg3642
g4094
stRp9962
ag1
(g9147
g9116
(dp9963
g3645
g3709
sg3633
g3916
sg3647
g3716
sg3642
g3923
stRp9964
ag1
(g9147
g9116
(dp9965
g3645
g4090
sg3633
g4475
sg3647
g4097
sg3642
g4482
stRp9966
ag1
(g9147
g9116
(dp9967
g3645
g3956
sg3633
g3946
sg3647
g3950
sg3642
g3954
stRp9968
ag1
(g9147
g9116
(dp9969
g3645
g4238
sg3633
g4637
sg3647
g4245
sg3642
g4644
stRp9970
ag1
(g9147
g9116
(dp9971
g3645
g3788
sg3633
g4363
sg3647
g3795
sg3642
g4370
stRp9972
ag1
(g9147
g9116
(dp9973
g3645
g3726
sg3633
g3722
sg3647
g3733
sg3642
g3730
stRp9974
ag1
(g9147
g9116
(dp9975
g3645
g3709
sg3633
g3705
sg3647
g3716
sg3642
g3713
stRp9976
ag1
(g9147
g9116
(dp9977
g3645
g3956
sg3633
g3946
sg3647
g3950
sg3642
g3954
stRp9978
ag1
(g9147
g9116
(dp9979
g3645
g3726
sg3633
g4378
sg3647
g3733
sg3642
g4385
stRp9980
ag1
(g9147
g9116
(dp9981
g3645
g3956
sg3633
g3946
sg3647
g3950
sg3642
g3954
stRp9982
ag1
(g9147
g9116
(dp9983
g3645
g3709
sg3633
g3705
sg3647
g3716
sg3642
g3713
stRp9984
ag1
(g9147
g9116
(dp9985
g3645
g3675
sg3633
g3671
sg3647
g3682
sg3642
g3679
stRp9986
ag1
(g9147
g9116
(dp9987
g3645
g3854
sg3633
g3850
sg3647
g3861
sg3642
g3858
stRp9988
ag1
(g9147
g9116
(dp9989
g3645
g3777
sg3633
g4148
sg3647
g3771
sg3642
g4155
stRp9990
ag1
(g9147
g9116
(dp9991
g3645
g3871
sg3633
g4103
sg3647
g3878
sg3642
g4110
stRp9992
ag1
(g9147
g9116
(dp9993
g3645
g4238
sg3633
g4637
sg3647
g4245
sg3642
g4644
stRp9994
ag1
(g9147
g9116
(dp9995
g3645
g4167
sg3633
g4163
sg3647
g4174
sg3642
g4171
stRp9996
ag1
(g9147
g9116
(dp9997
g3645
g3788
sg3633
g4363
sg3647
g3795
sg3642
g4370
stRp9998
ag1
(g9147
g9116
(dp9999
g3645
g3805
sg3633
g3901
sg3647
g3812
sg3642
g3908
stRp10000
ag1
(g9147
g9116
(dp10001
g3645
g3888
sg3633
g4193
sg3647
g3895
sg3642
g4200
stRp10002
ag1
(g9147
g9116
(dp10003
g3645
g3854
sg3633
g3850
sg3647
g3861
sg3642
g3858
stRp10004
ag1
(g9147
g9116
(dp10005
g3645
g4122
sg3633
g4447
sg3647
g4129
sg3642
g4454
stRp10006
ag1
(g9147
g9116
(dp10007
g3645
g4008
sg3633
g4307
sg3647
g4015
sg3642
g4314
stRp10008
ag1
(g9147
g9116
(dp10009
g3645
g3837
sg3633
g4899
sg3647
g3844
sg3642
g4906
stRp10010
ag1
(g9147
g9116
(dp10011
g3645
g3658
sg3633
g3654
sg3647
g3665
sg3642
g3662
stRp10012
ag1
(g9147
g9116
(dp10013
g3645
g3788
sg3633
g4363
sg3647
g3795
sg3642
g4370
stRp10014
ag1
(g9147
g9116
(dp10015
g3645
g3871
sg3633
g3867
sg3647
g3878
sg3642
g3875
stRp10016
ag1
(g9147
g9116
(dp10017
g3645
g4238
sg3633
g4234
sg3647
g4245
sg3642
g4242
stRp10018
ag1
(g9147
g9116
(dp10019
g3645
g3726
sg3633
g4378
sg3647
g3733
sg3642
g4385
stRp10020
ag1
(g9147
g9116
(dp10021
g3645
g3837
sg3633
g4899
sg3647
g3844
sg3642
g4906
stRp10022
ag1
(g9147
g9116
(dp10023
g3645
g4090
sg3633
g4475
sg3647
g4097
sg3642
g4482
stRp10024
ag1
(g9147
g9116
(dp10025
g3645
g4122
sg3633
g4118
sg3647
g4129
sg3642
g4126
stRp10026
ag1
(g9147
g9116
(dp10027
g3645
g4167
sg3633
g4406
sg3647
g4174
sg3642
g4413
stRp10028
ag1
(g9147
g9116
(dp10029
g3645
g4122
sg3633
g4447
sg3647
g4129
sg3642
g4454
stRp10030
ag1
(g9147
g9116
(dp10031
g3645
g3675
sg3633
g3671
sg3647
g3682
sg3642
g3679
stRp10032
ag1
(g9147
g9116
(dp10033
g3645
g3692
sg3633
g3739
sg3647
g3699
sg3642
g3746
stRp10034
ag1
(g9147
g9116
(dp10035
g3645
g4008
sg3633
g4004
sg3647
g4015
sg3642
g4012
stRp10036
ag1
(g9147
g9116
(dp10037
g3645
g4090
sg3633
g4086
sg3647
g4097
sg3642
g4094
stRp10038
ag1
(g9147
g9116
(dp10039
g3645
g4294
sg3633
g4290
sg3647
g4301
sg3642
g4298
stRp10040
ag1
(g9147
g9116
(dp10041
g3645
g3709
sg3633
g3705
sg3647
g3716
sg3642
g3713
stRp10042
ag1
(g9147
g9116
(dp10043
g3645
g3675
sg3633
g4490
sg3647
g3682
sg3642
g4497
stRp10044
ag1
(g9147
g9116
(dp10045
g3645
g4167
sg3633
g4163
sg3647
g4174
sg3642
g4171
stRp10046
ag1
(g9147
g9116
(dp10047
g3645
g3788
sg3633
g3784
sg3647
g3795
sg3642
g3792
stRp10048
ag1
(g9147
g9116
(dp10049
g3645
g3692
sg3633
g3739
sg3647
g3699
sg3642
g3746
stRp10050
ag1
(g9147
g9116
(dp10051
g3645
g3956
sg3633
g3976
sg3647
g3950
sg3642
g3983
stRp10052
ag1
(g9147
g9116
(dp10053
g3645
g4238
sg3633
g4637
sg3647
g4245
sg3642
g4644
stRp10054
ag1
(g9147
g9116
(dp10055
g3645
g3675
sg3633
g3671
sg3647
g3682
sg3642
g3679
stRp10056
ag1
(g9147
g9116
(dp10057
g3645
g3805
sg3633
g3801
sg3647
g3812
sg3642
g3809
stRp10058
ag1
(g9147
g9116
(dp10059
g3645
g3777
sg3633
g4148
sg3647
g3771
sg3642
g4155
stRp10060
ag1
(g9147
g9116
(dp10061
g3645
g4090
sg3633
g4475
sg3647
g4097
sg3642
g4482
stRp10062
ag1
(g9147
g9116
(dp10063
g3645
g3726
sg3633
g3722
sg3647
g3733
sg3642
g3730
stRp10064
ag1
(g9147
g9116
(dp10065
g3645
g3871
sg3633
g4103
sg3647
g3878
sg3642
g4110
stRp10066
ag1
(g9147
g9116
(dp10067
g3645
g4238
sg3633
g4637
sg3647
g4245
sg3642
g4644
stRp10068
ag1
(g9147
g9116
(dp10069
g3645
g3837
sg3633
g4899
sg3647
g3844
sg3642
g4906
stRp10070
ag1
(g9147
g9116
(dp10071
g3645
g4294
sg3633
g4335
sg3647
g4301
sg3642
g4342
stRp10072
ag1
(g9147
g9116
(dp10073
g3645
g3871
sg3633
g4103
sg3647
g3878
sg3642
g4110
stRp10074
ag1
(g9147
g9116
(dp10075
g3645
g3726
sg3633
g3722
sg3647
g3733
sg3642
g3730
stRp10076
ag1
(g9147
g9116
(dp10077
g3645
g3675
sg3633
g4490
sg3647
g3682
sg3642
g4497
stRp10078
ag1
(g9147
g9116
(dp10079
g3645
g3726
sg3633
g4378
sg3647
g3733
sg3642
g4385
stRp10080
ag1
(g9147
g9116
(dp10081
g3645
g4167
sg3633
g4163
sg3647
g4174
sg3642
g4171
stRp10082
ag1
(g9147
g9116
(dp10083
g3645
g4294
sg3633
g4335
sg3647
g4301
sg3642
g4342
stRp10084
ag1
(g9147
g9116
(dp10085
g3645
g4090
sg3633
g4086
sg3647
g4097
sg3642
g4094
stRp10086
ag1
(g9147
g9116
(dp10087
g3645
g3805
sg3633
g3801
sg3647
g3812
sg3642
g3809
stRp10088
ag1
(g9147
g9116
(dp10089
g3645
g3638
sg3633
g3931
sg3647
g3648
sg3642
g3938
stRp10090
ag1
(g9147
g9116
(dp10091
g3645
g3692
sg3633
g3688
sg3647
g3699
sg3642
g3696
stRp10092
ag1
(g9147
g9116
(dp10093
g3645
g3871
sg3633
g3867
sg3647
g3878
sg3642
g3875
stRp10094
ag1
(g9147
g9116
(dp10095
g3645
g4122
sg3633
g4447
sg3647
g4129
sg3642
g4454
stRp10096
ag1
(g9147
g9116
(dp10097
g3645
g3692
sg3633
g3688
sg3647
g3699
sg3642
g3696
stRp10098
ag1
(g9147
g9116
(dp10099
g3645
g3837
sg3633
g4899
sg3647
g3844
sg3642
g4906
stRp10100
ag1
(g9147
g9116
(dp10101
g3645
g3854
sg3633
g4557
sg3647
g3861
sg3642
g4564
stRp10102
ag1
(g9147
g9116
(dp10103
g3645
g3638
sg3633
g3931
sg3647
g3648
sg3642
g3938
stRp10104
ag1
(g9147
g9116
(dp10105
g3645
g3788
sg3633
g3784
sg3647
g3795
sg3642
g3792
stRp10106
ag1
(g9147
g9116
(dp10107
g3645
g4238
sg3633
g4637
sg3647
g4245
sg3642
g4644
stRp10108
ag1
(g9147
g9116
(dp10109
g3645
g3805
sg3633
g3901
sg3647
g3812
sg3642
g3908
stRp10110
ag1
(g9147
g9116
(dp10111
g3645
g4238
sg3633
g4234
sg3647
g4245
sg3642
g4242
stRp10112
ag1
(g9147
g9116
(dp10113
g3645
g3692
sg3633
g3688
sg3647
g3699
sg3642
g3696
stRp10114
ag1
(g9147
g9116
(dp10115
g3645
g4294
sg3633
g4335
sg3647
g4301
sg3642
g4342
stRp10116
ag1
(g9147
g9116
(dp10117
g3645
g3871
sg3633
g3867
sg3647
g3878
sg3642
g3875
stRp10118
ag1
(g9147
g9116
(dp10119
g3645
g3638
sg3633
g3634
sg3647
g3648
sg3642
g3643
stRp10120
ag1
(g9147
g9116
(dp10121
g3645
g3888
sg3633
g3884
sg3647
g3895
sg3642
g3892
stRp10122
ag1
(g9147
g9116
(dp10123
g3645
g3709
sg3633
g3916
sg3647
g3716
sg3642
g3923
stRp10124
ag1
(g9147
g9116
(dp10125
g3645
g4294
sg3633
g4290
sg3647
g4301
sg3642
g4298
stRp10126
ag1
(g9147
g9116
(dp10127
g3645
g3888
sg3633
g4193
sg3647
g3895
sg3642
g4200
stRp10128
ag1
(g9147
g9116
(dp10129
g3645
g3777
sg3633
g4148
sg3647
g3771
sg3642
g4155
stRp10130
ag1
(g9147
g9116
(dp10131
g3645
g3956
sg3633
g3976
sg3647
g3950
sg3642
g3983
stRp10132
ag1
(g9147
g9116
(dp10133
g3645
g4122
sg3633
g4447
sg3647
g4129
sg3642
g4454
stRp10134
ag1
(g9147
g9116
(dp10135
g3645
g3658
sg3633
g3654
sg3647
g3665
sg3642
g3662
stRp10136
ag1
(g9147
g9116
(dp10137
g3645
g4167
sg3633
g4163
sg3647
g4174
sg3642
g4171
stRp10138
ag1
(g9147
g9116
(dp10139
g3645
g3837
sg3633
g3833
sg3647
g3844
sg3642
g3841
stRp10140
ag1
(g9147
g9116
(dp10141
g3645
g3777
sg3633
g3767
sg3647
g3771
sg3642
g3775
stRp10142
ag1
(g9147
g9116
(dp10143
g3645
g3805
sg3633
g3801
sg3647
g3812
sg3642
g3809
stRp10144
ag1
(g9147
g9116
(dp10145
g3645
g3692
sg3633
g3739
sg3647
g3699
sg3642
g3746
stRp10146
ag1
(g9147
g9116
(dp10147
g3645
g4122
sg3633
g4118
sg3647
g4129
sg3642
g4126
stRp10148
ag1
(g9147
g9116
(dp10149
g3645
g3888
sg3633
g4193
sg3647
g3895
sg3642
g4200
stRp10150
ag1
(g9147
g9116
(dp10151
g3645
g3658
sg3633
g3654
sg3647
g3665
sg3642
g3662
stRp10152
ag1
(g9147
g9116
(dp10153
g3645
g3888
sg3633
g3884
sg3647
g3895
sg3642
g3892
stRp10154
ag1
(g9147
g9116
(dp10155
g3645
g4238
sg3633
g4234
sg3647
g4245
sg3642
g4242
stRp10156
ag1
(g9147
g9116
(dp10157
g3645
g4167
sg3633
g4406
sg3647
g4174
sg3642
g4413
stRp10158
ag1
(g9147
g9116
(dp10159
g3645
g3777
sg3633
g3767
sg3647
g3771
sg3642
g3775
stRp10160
ag1
(g9147
g9116
(dp10161
g3645
g4008
sg3633
g4307
sg3647
g4015
sg3642
g4314
stRp10162
ag1
(g9147
g9116
(dp10163
g3645
g3854
sg3633
g3850
sg3647
g3861
sg3642
g3858
stRp10164
ag1
(g9147
g9116
(dp10165
g3645
g3675
sg3633
g4490
sg3647
g3682
sg3642
g4497
stRp10166
ag1
(g9147
g9116
(dp10167
g3645
g3871
sg3633
g3867
sg3647
g3878
sg3642
g3875
stRp10168
ag1
(g9147
g9116
(dp10169
g3645
g3854
sg3633
g4557
sg3647
g3861
sg3642
g4564
stRp10170
ag1
(g9147
g9116
(dp10171
g3645
g3658
sg3633
g3818
sg3647
g3665
sg3642
g3825
stRp10172
ag1
(g9147
g9116
(dp10173
g3645
g3638
sg3633
g3634
sg3647
g3648
sg3642
g3643
stRp10174
ag1
(g9147
g9116
(dp10175
g3645
g3888
sg3633
g3884
sg3647
g3895
sg3642
g3892
stRp10176
ag1
(g9147
g9116
(dp10177
g3645
g3709
sg3633
g3916
sg3647
g3716
sg3642
g3923
stRp10178
ag1
(g9147
g9116
(dp10179
g3645
g3854
sg3633
g3850
sg3647
g3861
sg3642
g3858
stRp10180
ag1
(g9147
g9116
(dp10181
g3645
g3871
sg3633
g4103
sg3647
g3878
sg3642
g4110
stRp10182
ag1
(g9147
g9116
(dp10183
g3645
g3658
sg3633
g3818
sg3647
g3665
sg3642
g3825
stRp10184
ag1
(g9147
g9116
(dp10185
g3645
g3837
sg3633
g3833
sg3647
g3844
sg3642
g3841
stRp10186
ag1
(g9147
g9116
(dp10187
g3645
g4008
sg3633
g4307
sg3647
g4015
sg3642
g4314
stRp10188
ag1
(g9147
g9116
(dp10189
g3645
g3837
sg3633
g3833
sg3647
g3844
sg3642
g3841
stRp10190
ag1
(g9147
g9116
(dp10191
g3645
g3788
sg3633
g3784
sg3647
g3795
sg3642
g3792
stRp10192
ag1
(g9147
g9116
(dp10193
g3645
g4294
sg3633
g4290
sg3647
g4301
sg3642
g4298
stRp10194
ag1
(g9147
g9116
(dp10195
g3645
g4167
sg3633
g4406
sg3647
g4174
sg3642
g4413
stRp10196
ag1
(g9147
g9116
(dp10197
g3645
g3726
sg3633
g4378
sg3647
g3733
sg3642
g4385
stRp10198
ag1
(g9147
g9116
(dp10199
g3645
g3854
sg3633
g4557
sg3647
g3861
sg3642
g4564
stRp10200
ag1
(g9147
g9116
(dp10201
g3645
g3638
sg3633
g3931
sg3647
g3648
sg3642
g3938
stRp10202
ag1
(g9147
g9116
(dp10203
g3645
g4122
sg3633
g4118
sg3647
g4129
sg3642
g4126
stRp10204
ag1
(g9147
g9116
(dp10205
g3645
g4008
sg3633
g4307
sg3647
g4015
sg3642
g4314
stRp10206
ag1
(g9147
g9116
(dp10207
g3645
g3837
sg3633
g4899
sg3647
g3844
sg3642
g4906
stRp10208
ag1
(g9147
g9116
(dp10209
g3645
g4294
sg3633
g4290
sg3647
g4301
sg3642
g4298
stRp10210
ag1
(g9147
g9116
(dp10211
g3645
g3675
sg3633
g4490
sg3647
g3682
sg3642
g4497
stRp10212
ag1
(g9147
g9116
(dp10213
g3645
g4167
sg3633
g4406
sg3647
g4174
sg3642
g4413
stRp10214
ag1
(g9147
g9116
(dp10215
g3645
g3788
sg3633
g4363
sg3647
g3795
sg3642
g4370
stRp10216
ag1
(g9147
g9116
(dp10217
g3645
g3805
sg3633
g3801
sg3647
g3812
sg3642
g3809
stRp10218
ag1
(g9147
g9116
(dp10219
g3645
g3709
sg3633
g3705
sg3647
g3716
sg3642
g3713
stRp10220
ag1
(g9147
g9116
(dp10221
g3645
g4090
sg3633
g4475
sg3647
g4097
sg3642
g4482
stRp10222
ag1
(g9147
g9116
(dp10223
g3645
g3777
sg3633
g4148
sg3647
g3771
sg3642
g4155
stRp10224
ag1
(g9147
g9116
(dp10225
g3645
g3726
sg3633
g3722
sg3647
g3733
sg3642
g3730
stRp10226
ag1
(g9147
g9116
(dp10227
g3645
g4122
sg3633
g4118
sg3647
g4129
sg3642
g4126
stRp10228
ag1
(g9147
g9116
(dp10229
g3645
g3854
sg3633
g4557
sg3647
g3861
sg3642
g4564
stRp10230
ag1
(g9147
g9116
(dp10231
g3645
g3956
sg3633
g3946
sg3647
g3950
sg3642
g3954
stRp10232
asg9228
Nsg9229
g6348
sg9230
I200
sg9231
I0
sg9232
I200
sg9233
I01
sbag1
(g9103
g3
NtRp10233
(dp10234
g9106
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a\u000a######################## CITATIONS ########################## \u000a##### Binary choice, BDM, auction routines, and instructions are modified from:\u000a##### \u000a##### De Martino, B., Fleming, S. M., Garrett, N., & Dolan, R. J. (2012). Confidence in value-based choice. Nature Neuroscience, 16(1), 105-110. \u000a#####\u000a##### Food item images are original.\u000a\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.80.01), July 16, 2014, at 03:20\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things bdm STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000afrom pyglet.window import key # to detect key state, whether key is held down, to move slider on key hold\u000aimport pandas as pd\u000aimport datetime\u000afrom psychopy.iohub import launchHubServer\u000aimport pylink\u000a\u000a# Initialize IOHub for eye tracker\u000aio=launchHubServer(iohub_config_name='iohub_config.yaml')\u000atracker = io.devices.tracker\u000a\u000a# Store info about the experiment session\u000aexpName = 'infer_design1'  # from the Builder filename that created this script\u000aexpInfo = {u'session': u'001', u'participant': u'', u'eye': u'', u'glasses': u'', u'contacts': u''}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Setup filename for saving\u000afilename = 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# set up variable to track current state of key press, to move slider when keys held down\u000akeyState=key.KeyStateHandler()\u000a\u000a# Setup the Window\u000ascreenwidth = 1920\u000ascreenheight = 1080\u000awin = visual.Window(size=(screenwidth, screenheight), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color='black', colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000awin.winHandle.push_handlers(keyState)\u000a\u000a\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a\u000a######################## COMPONENTS ##########################\u000a\u000a# Set up directory path for stimuli. This avoids us having to put the entire image path in the conditions spreadsheet.\u000adir_path = 'stimuli/itempics/modified/small/'\u000a\u000a# Initialize components for Routine "instr_main"\u000ainstr_mainClock = core.Clock()\u000ainstr_main_txt = visual.TextStim(win=win, ori=0, name='instr_main_txt',\u000a    text=u'Welcome!\u005cn\u005cnPlease read the instructions carefully and get the experimenter when you\u005c're finished. Take as much time as you need.',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "instr_bdm"\u000ainstr_bdmClock = core.Clock()\u000ainstr_bdm_txt = visual.TextStim(win=win, ori=0, name='instr_bdm_txt',\u000a    text=u'The bidding task is about to begin. Use the LEFT and RIGHT arrow keys to move the cursor along the slider, then press the DOWN arrow to enter your bid.\u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "fixation"\u000afixationClock = core.Clock()\u000afixation_text = visual.TextStim(win=win, ori=0, name='fixation_text',\u000a    text=u'+',    font=u'Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "bdm"\u000abdmClock = core.Clock()\u000abdm_pic = visual.ImageStim(win=win, name='bdm_pic',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=0.0)\u000abdm_bid = visual.RatingScale(win=win, name='bdm_bid', marker=u'triangle', markerColor=u'orange', leftKeys=None, rightKeys=None,\u000a    size=1.0, pos=[0.0, -0.6], low=0, high=3, precision=100, labels=[u'\u005cxa30', u'\u005cxa33'],\u000a    scale=u'', markerStart=u'1.5', tickHeight=u'1', showAccept=False, acceptKeys=[u'down', u'return'])\u000a\u000a# Initialize components for Routine "instr_choice"\u000ainstr_choiceClock = core.Clock()\u000ainstr_choice_txt = visual.TextStim(win=win, ori=0, name='instr_choice_txt',\u000a    text=u'The choice task is about to begin. Choose your preferred item by pressing the LEFT or RIGHT arrow keys, then use the slider to indicate how confident you are that you made the best choice.\u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "choice"\u000achoiceClock = core.Clock()\u000achoice_pic_left = visual.ImageStim(win=win, name='choice_pic_left',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[-0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=0.0)\u000achoice_pic_right = visual.ImageStim(win=win, name='choice_pic_right',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=-1.0)\u000a\u000a# Initialize components for Routine "choice_selection"\u000achoice_selectionClock = core.Clock()\u000astar_left_selection = visual.TextStim(win=win, ori=0, name='star_left_selection',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[-0.5, -0.8], height=0.5, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=-2.0)\u000astar_right_selection = visual.TextStim(win=win, ori=0, name='star_right_selection',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[0.5, -0.8], height=0.5, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=-3.0)\u000a\u000a# Initialize components for Routine "confidence"\u000aconfidenceClock = core.Clock()\u000aconfidence_rating = visual.RatingScale(win=win, name='confidence_rating', marker=u'triangle', markerColor=u'orange', leftKeys=None, rightKeys=None,\u000a    size=1.0, pos=[0.0, 0.0], low=1, high=6, precision=20,\u000a    scale=u'', markerStart=u'3.5', tickHeight=u'1', showAccept=False, acceptKeys=[u'down', u'return'])\u000a\u000a# Initialize components for Routine "instr_infer_intro"\u000ainstr_infer_introClock = core.Clock()\u000ainstr_infer_intro_txt = visual.TextStim(win=win, ori=0, name='instr_infer_intro_txt',\u000a    text=u'Thanks! Now please get the experimenter, who will give you the instructions for the second part of the experiment. \u005cn\u005cnPlease read these instructions carefully and get the experimenter again when you\u005c're finished. Take as much time as you need.',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=1.5,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "instr_infer_practice"\u000ainstr_infer_practiceClock = core.Clock()\u000ainstr_infer_practice_txt = visual.TextStim(win=win, ori=0, name='instr_infer_practice_txt',\u000a    text=u'First, you\u005c'll do some practice trials. These are just for you to get used to the task; your responses won\u005c't count. Unlike in the real trials, the choices you will be learning here were generated randomly by a computer.\u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=1.5,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "instr_infer"\u000ainstr_inferClock = core.Clock()\u000ainstr_infer_txt = visual.TextStim(win=win, ori=0, name='instr_infer_txt',\u000a    text=u'Great! Now that you\u005c've done some practice trials, we\u005c're ready to start the real trials. If you have any questions, please get the experimenter now. Otherwise, you can begin whenever you\u005c're ready. \u005cn\u005cnUnlike in the practice trials, the choices you will be learning here were made by an actual person.\u005cn\u005cn[press space bar to begin]',    font=u'Arial',\u000a    pos=[0, 0], height=0.06, wrapWidth=1.5,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "get_ready"\u000aget_readyClock = core.Clock()\u000aget_ready_text = visual.TextStim(win=win, ori=0, name='get_ready_text',\u000a    text=u'Get ready!',    font=u'Arial',\u000a    pos=[0, 0], height=0.12, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000aimg_left_infer = visual.ImageStim(win=win, name='img_left_infer',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[-0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=0.0)\u000aimg_right_infer = visual.ImageStim(win=win, name='img_right_infer',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0.5, 0], size=None,\u000a    color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=False, depth=-1.0)\u000a\u000a# Initialize components for Routine "trial_post_response"\u000atrial_post_responseClock = core.Clock()\u000aselection_arrow_left = visual.TextStim(win=win, ori=0, name='selection_arrow_left',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[-0.5, -0.09], height=0.5, wrapWidth=None,\u000a    color=u'red', colorSpace=u'rgb', opacity=1,\u000a    depth=-2.0)\u000aselection_arrow_right = visual.TextStim(win=win, ori=0, name='selection_arrow_right',\u000a    text=u'*',    font=u'Arial',\u000a    pos=[0.5, -0.09], height=0.5, wrapWidth=None,\u000a    color=u'red', colorSpace=u'rgb', opacity=1,\u000a    depth=-3.0)\u000afeedback_box_left = visual.Rect(win=win, name='feedback_box_left',\u000a    width=[0.9, 0.9][0], height=[0.9, 0.9][1],\u000a    ori=0, pos=[-0.5, 0],\u000a    lineWidth=5, lineColor=u'yellow', lineColorSpace=u'rgb',\u000a    fillColor=None, fillColorSpace=u'rgb',\u000a    opacity=1, depth=-4.0, interpolate=True)\u000afeedback_box_right = visual.Rect(win=win, name='feedback_box_right',\u000a    width=[0.9, 0.9][0], height=[0.9, 0.9][1],\u000a    ori=0, pos=[0.5, 0],\u000a    lineWidth=5, lineColor=u'yellow', lineColorSpace=u'rgb',\u000a    fillColor=None, fillColorSpace=u'rgb',\u000a    opacity=1, depth=-5.0, interpolate=True)\u000a\u000a# Initialize components for Routine "rest_prompt"\u000arest_promptClock = core.Clock()\u000arest_prompt_txt = visual.TextStim(win=win, ori=0, name='rest_prompt_txt',\u000a    text=u'Great! Now take a rest and press the space bar when you\u005cu2019re ready to begin the next block.',    font=u'Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color=u'white', colorSpace=u'rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create counters for the number of correct and incorrect guesses made by subjects to determine extra payment.\u000acorrect_counter = 0\u000aincorrect_counter = 0\u000a\u000a# Create list of lists to store binary choice and BDM data to generate food reward at the end of the experiment\u000aprefs = [['left', 'right', 'choice', 'bid']]\u000abids = [['item', 'bid']] # For the bids collected during the first BDM routine, at the beginning of the experiment\u000a\u000a### CHOICE & INFERENCE RANDOMIZATION ###\u000a\u000a# Define two functions to generate constrained pseudorandom sequences of item pair presentations for the binary choice and inference\u000a# parts of the task. The constraint ensures that the same pair of items does not appear twice in a row (flipped or not).\u000a# In the conditions spreadsheet that the item pairs are drawn from, the flipped version of the same item pair is 20\u000a# rows apart.\u000a\u000a# Binary choice randomization\u000adef genseq_choice():\u000a    done = False\u000a    while done==False:\u000a        counter = 0\u000a        ans = np.random.choice(40, 40, replace=False) # Generate a pseudorandom sequence of 40 numbers\u000a        for x in range(1,40):\u000a            if (ans[x]-ans[x-1]) % 20 == 0: # Is the difference between any sequential numbers divisible by 20?\u000a                counter += 1\u000a        if counter==0: # If not, end the loop and return the array\u000a            done = True\u000a            return ans\u000a        else: # If so, continue the loop and try again\u000a            done = False\u000a\u000a# Inference practice block randomization\u000adef genseq_infer_practice():\u000a    done = False\u000a    while done==False:\u000a        counter = 0\u000a        ans = np.random.choice(14, 14, replace=False) # Generate a pseudorandom sequence of 200 numbers\u000a        for x in range(1,14):\u000a            if (ans[x]-ans[x-1]) % 7 == 0: # Is the difference between any sequential numbers divisible by 20?\u000a                counter += 1\u000a        if counter==0: # If not, end the loop and return the array\u000a            done = True\u000a            return ans\u000a        else: # If so, continue the loop and try again\u000a            done = False\u000a\u000a# Inference randomization\u000adef genseq_infer():\u000a    done = False\u000a    while done==False:\u000a        counter = 0\u000a        ans = np.random.choice(200, 200, replace=False) # Generate a pseudorandom sequence of 200 numbers\u000a        for x in range(1,200):\u000a            if (ans[x]-ans[x-1]) % 20 == 0: # Is the difference between any sequential numbers divisible by 20?\u000a                counter += 1\u000a        if counter==0: # If not, end the loop and return the array\u000a            done = True\u000a            return ans\u000a        else: # If so, continue the loop and try again\u000a            done = False\u000a\u000a\u000a# Set independent sequences for each of the two choice blocks, the inference practice block, and the three inference rest blocks. Each rest block contains 10 presentations of\u000a# each pair.\u000a\u000achoiceseq = genseq_choice()\u000apracticeseq = genseq_infer_practice()\u000ablock1seq = genseq_infer()\u000ablock2seq = genseq_infer()\u000ablock3seq = genseq_infer()\u000a\u000a\u000a# Choose a pilot participant whose choices will form the basis of the learning task\u000apartners = ['P1','P2','P3','P4','P5','P6','P8','P9','P10','P11','P12'] # List of pilot participants, P7 excluded for perfectly inconsistent choices\u000apartner = np.random.choice(partners,1) # Choose one at random\u000apartner_file = 'conditions/choices/infer_design1_value_pairs_' + partner[0] + '.csv' # Path to that participant's choice data\u000a\u000a# Create separate CSV files, one for each choice, practice, and rest block, with the item pairs in the pseudorandomly generated order.\u000a# These CSV files will be used as PsychoPy's conditions spreadsheets and run sequentially in the choice, practice, and inference loops below.\u000a\u000a\u000achoicecond_src = pd.read_csv('conditions/choice_design1_binary.csv', index_col=None, header=0)\u000achoicecond = choicecond_src.copy()\u000afor x in range(40):\u000a    seq = choiceseq[x]\u000a    choicecond.iloc[x] = choicecond_src.iloc[seq]\u000achoicecond.to_csv(path_or_buf=filename+'_choicecond.csv', index=False)\u000a\u000apracticecond_src = pd.read_csv('conditions/choices/infer_design1_value_pairs_practice.csv', index_col=None, header=0)\u000apracticecond = practicecond_src.copy()\u000afor x in range(14):\u000a    seq = practiceseq[x]\u000a    practicecond.iloc[x] = practicecond_src.iloc[seq]\u000apracticecond.to_csv(path_or_buf=filename+'_practicecond.csv', index=False)\u000a\u000ablock1cond_src = pd.read_csv(partner_file, index_col=None, header=0)\u000ablock1cond = block1cond_src.copy()\u000afor x in range(200):\u000a    seq = block1seq[x]\u000a    block1cond.iloc[x] = block1cond_src.iloc[seq]\u000ablock1cond.to_csv(path_or_buf=filename+'_block1cond.csv', index=False)\u000a\u000ablock2cond_src = pd.read_csv(partner_file, index_col=None, header=0)\u000ablock2cond = block2cond_src.copy()\u000afor x in range(200):\u000a    seq = block2seq[x]\u000a    block2cond.iloc[x] = block2cond_src.iloc[seq]\u000ablock2cond.to_csv(path_or_buf=filename+'_block2cond.csv', index=False)\u000a\u000ablock3cond_src = pd.read_csv(partner_file, index_col=None, header=0)\u000ablock3cond = block3cond_src.copy()\u000afor x in range(200):\u000a    seq = block3seq[x]\u000a    block3cond.iloc[x] = block3cond_src.iloc[seq]\u000ablock3cond.to_csv(path_or_buf=filename+'_block3cond.csv', index=False)\u000a\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instr_main"-------\u000at = 0\u000ainstr_mainClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_main_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_main_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_mainComponents = []\u000ainstr_mainComponents.append(instr_main_txt)\u000ainstr_mainComponents.append(instr_main_resp)\u000afor thisComponent in instr_mainComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_main"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_mainClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_main_txt* updates\u000a    if t >= 0.0 and instr_main_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_main_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_main_txt.frameNStart = frameN  # exact frame index\u000a        instr_main_txt.setAutoDraw(True)\u000a    \u000a    # *instr_main_resp* updates\u000a    if t >= 5.0 and instr_main_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_main_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_main_resp.frameNStart = frameN  # exact frame index\u000a        instr_main_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_main_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_main_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_main_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_main_resp.rt = instr_main_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_mainComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_main"-------\u000afor thisComponent in instr_mainComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_main_resp.keys in ['', [], None]:  # No response was made\u000a   instr_main_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_main_resp.keys',instr_main_resp.keys)\u000aif instr_main_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_main_resp.rt', instr_main_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a\u000a#------Prepare to start Routine "instr_bdm"-------\u000at = 0\u000ainstr_bdmClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_bdm_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_bdm_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_bdmComponents = []\u000ainstr_bdmComponents.append(instr_bdm_txt)\u000ainstr_bdmComponents.append(instr_bdm_resp)\u000afor thisComponent in instr_bdmComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_bdm"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_bdmClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_bdm_txt* updates\u000a    if t >= 0.0 and instr_bdm_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_bdm_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_bdm_txt.frameNStart = frameN  # exact frame index\u000a        instr_bdm_txt.setAutoDraw(True)\u000a    \u000a    # *instr_bdm_resp* updates\u000a    if t >= 2.0 and instr_bdm_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_bdm_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_bdm_resp.frameNStart = frameN  # exact frame index\u000a        instr_bdm_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_bdm_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_bdm_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space', 's'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_bdm_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_bdm_resp.rt = instr_bdm_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_bdmComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_bdm"-------\u000afor thisComponent in instr_bdmComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_bdm_resp.keys in ['', [], None]:  # No response was made\u000a   instr_bdm_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_bdm_resp.keys',instr_bdm_resp.keys)\u000athisExp.addData('partnered_pilot_participant', partner)\u000aif instr_bdm_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_bdm_resp.rt', instr_bdm_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## BDM LOOP 1 ##########################\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000abdm_loop1 = data.TrialHandler(nReps=1, method=u'random', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'conditions/choice_design1_bdm.xlsx'),\u000a    seed=None, name='bdm_loop1')\u000athisExp.addLoop(bdm_loop1)  # add the loop to the experiment\u000athisbdm_loop1 = bdm_loop1.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisbdm_loop1.rgb)\u000aif thisbdm_loop1 != None:\u000a    for paramName in thisbdm_loop1.keys():\u000a        exec(paramName + '= thisbdm_loop1.' + paramName)\u000a\u000a# Check if the 'skip' key was pressed in the instructions routine; if so, end the loop and move on to the inference task\u000aif instr_bdm_resp.keys=='s':\u000a    bdm_loop1.finished = True\u000a\u000afor thisbdm_loop1 in bdm_loop1:\u000a    currentLoop = bdm_loop1\u000a    # abbreviate parameter names if possible (e.g. rgb = thisbdm_loop1.rgb)\u000a    if thisbdm_loop1 != None:\u000a        for paramName in thisbdm_loop1.keys():\u000a            exec(paramName + '= thisbdm_loop1.' + paramName)\u000a    \u000a    #------Prepare to start Routine "bdm"-------\u000a    t = 0\u000a    bdmClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    bdm_pic.setImage(dir_path+bdm_img)\u000a    bdm_bid.reset()\u000a    # jitter the starting position of the BDM scale from a uniform distribution between 1 and 2, rounded to the nearest decimal place\u000a    bdm_marker_start = float(np.round(np.random.uniform(1, 2, 1)[0], 1))\u000a    bdm_bid.setMarkerPos(bdm_marker_start)\u000a    # keep track of which components have finished\u000a    bdmComponents = []\u000a    bdmComponents.append(fixation_text)\u000a    bdmComponents.append(bdm_pic)\u000a    bdmComponents.append(bdm_bid)\u000a    for thisComponent in bdmComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "bdm"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = bdmClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation_text* updates\u000a        if t >= 0 and fixation_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation_text.tStart = t  # underestimates by a little under one frame\u000a            fixation_text.frameNStart = frameN  # exact frame index\u000a            fixation_text.setAutoDraw(True)\u000a        elif fixation_text.status == STARTED and t>= (0 + (1.0-win.monitorFramePeriod*0.75)):\u000a            fixation_text.setAutoDraw(False)\u000a\u000a        # *bdm_pic* updates\u000a        if t >= 1.0 and bdm_pic.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            bdm_pic.tStart = t  # underestimates by a little under one frame\u000a            bdm_pic.frameNStart = frameN  # exact frame index\u000a            bdm_pic.setAutoDraw(True)\u000a        # *bdm_bid* updates\u000a        if t >= 1.0:\u000a            bdm_bid.draw()\u000a            continueRoutine = bdm_bid.noResponse\u000a            if bdm_bid.noResponse == False:\u000a                bdm_bid.response = bdm_bid.getRating()\u000a                bdm_bid.rt = bdm_bid.getRT()\u000a            elif bdm_bid.noResponse==True:\u000a                if keyState[key.LEFT]==True and bdm_bid.markerPlacedAt >0.01:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt - 0.02\u000a                    bdm_bid.draw()\u000a                elif keyState[key.LEFT]==True and bdm_bid.markerPlacedAt==0.01:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt - 0.01\u000a                    bdm_bid.draw()\u000a                elif keyState[key.RIGHT]==True and bdm_bid.markerPlacedAt <2.99:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt + 0.02\u000a                    bdm_bid.draw()\u000a                elif keyState[key.RIGHT]==True and bdm_bid.markerPlacedAt==2.99:\u000a                    bdm_bid.markerPlacedAt = bdm_bid.markerPlacedAt + 0.01\u000a                    bdm_bid.draw()\u000a                    \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in bdmComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "bdm"-------\u000a    for thisComponent in bdmComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # store data for bdm (TrialHandler)\u000a    bdm_loop1.addData('bdm_bid1.response', bdm_bid.getRating())\u000a    bdm_loop1.addData('bdm_bid1.rt', bdm_bid.getRT())\u000a    bdm_loop1.addData('bdm_marker_start', bdm_marker_start)\u000a\u000a    # Add the item and the subject's bid to the 'bids' list, which will be merged with the 'prefs' list later in order to run the auction\u000a    bids.append([bdm_img, bdm_bid.response])\u000a    \u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeat of 'bdm_loop1'\u000a\u000a\u000a#------Prepare to start Routine "instr_choice"-------\u000at = 0\u000ainstr_choiceClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_choice_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_choice_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_choiceComponents = []\u000ainstr_choiceComponents.append(instr_choice_txt)\u000ainstr_choiceComponents.append(instr_choice_resp)\u000afor thisComponent in instr_choiceComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_choice"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_choiceClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_choice_txt* updates\u000a    if t >= 0.0 and instr_choice_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_choice_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_choice_txt.frameNStart = frameN  # exact frame index\u000a        instr_choice_txt.setAutoDraw(True)\u000a    \u000a    # *instr_choice_resp* updates\u000a    if t >= 2.0 and instr_choice_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_choice_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_choice_resp.frameNStart = frameN  # exact frame index\u000a        instr_choice_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_choice_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_choice_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space', 's'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_choice_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_choice_resp.rt = instr_choice_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_choiceComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_choice"-------\u000afor thisComponent in instr_choiceComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_choice_resp.keys in ['', [], None]:  # No response was made\u000a   instr_choice_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_choice_resp.keys',instr_choice_resp.keys)\u000aif instr_choice_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_choice_resp.rt', instr_choice_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## BINARY LOOP ##########################\u000a\u000a# set up handler to look after randomisation of conditions etc\u000abinary = data.TrialHandler(nReps=1, method=u'sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(filename+'_choicecond.csv'),\u000a    seed=None, name='binary')\u000athisExp.addLoop(binary)  # add the loop to the experiment\u000athisBinary1 = binary.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBinary1.rgb)\u000aif thisBinary1 != None:\u000a    for paramName in thisBinary1.keys():\u000a        exec(paramName + '= thisBinary1.' + paramName)\u000a\u000a# Check if the 'skip' key was pressed in the instructions routine; if so, end the loop and move on to the BDM\u000aif instr_choice_resp.keys=='s':\u000a    binary.finished = True\u000a\u000afor thisBinary1 in binary:\u000a    currentLoop = binary\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBinary1.rgb)\u000a    if thisBinary1 != None:\u000a        for paramName in thisBinary1.keys():\u000a            exec(paramName + '= thisBinary1.' + paramName)\u000a    \u000a    #------Prepare to start Routine "choice"-------\u000a    t = 0\u000a    choiceClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    choice_pic_left.setImage(dir_path+choice_left)\u000a    choice_pic_right.setImage(dir_path+choice_right)\u000a    event.clearEvents(eventType='keyboard') # Clear keyboard event log to avoid last key press from prior loop being used\u000a    key_resp_choice = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_choice.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    choiceComponents = []\u000a    choiceComponents.append(fixation_text)\u000a    choiceComponents.append(choice_pic_left)\u000a    choiceComponents.append(choice_pic_right)\u000a    choiceComponents.append(key_resp_choice)\u000a    for thisComponent in choiceComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    \u000a    #-------Start Routine "choice"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = choiceClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation_text* updates\u000a        if t >= 0 and fixation_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation_text.tStart = t  # underestimates by a little under one frame\u000a            fixation_text.frameNStart = frameN  # exact frame index\u000a            fixation_text.setAutoDraw(True)\u000a        elif fixation_text.status == STARTED and t>= (0 + (1.0-win.monitorFramePeriod*0.75)):\u000a            fixation_text.setAutoDraw(False)\u000a\u000a        # *choice_pic_left* updates\u000a        if t >= 1.0 and choice_pic_left.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_left.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_left.frameNStart = frameN  # exact frame index\u000a            choice_pic_left.setAutoDraw(True)\u000a        \u000a        # *choice_pic_right* updates\u000a        if t >= 1.0 and choice_pic_right.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_right.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_right.frameNStart = frameN  # exact frame index\u000a            choice_pic_right.setAutoDraw(True)\u000a\u000a        # *key_resp_choice* updates\u000a        if t >= 1.0 and key_resp_choice.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_choice.tStart = t  # underestimates by a little under one frame\u000a            key_resp_choice.frameNStart = frameN  # exact frame index\u000a            key_resp_choice.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_choice.clock.reset()  # now t=0\u000a        if key_resp_choice.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_choice.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_choice.rt = key_resp_choice.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in choiceComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "choice"-------\u000a    for thisComponent in choiceComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_choice.keys in ['', [], None]:  # No response was made\u000a       key_resp_choice.keys=None\u000a    # store data for binary (TrialHandler)\u000a    binary.addData('key_resp_choice.keys',key_resp_choice.keys)\u000a    if key_resp_choice.keys != None:  # we had a response\u000a        binary.addData('key_resp_choice.rt', key_resp_choice.rt)\u000a\u000a    # define a function to append binary choices and the bid for the chosen item to the preference list\u000a    # lft is the left image displayed during that choice trial\u000a    # rt is the right image displayed\u000a    def rec_choice(lft, rt): \u000a        bd = False\u000a        if key_resp_choice.keys=='left':\u000a            chc = lft\u000a        elif key_resp_choice.keys=='right':\u000a            chc = rt\u000a        for x in range(len(bids)):\u000a            if bids[x][0]==chc:\u000a                bd = bids[x][1]\u000a        prefs.append([lft, rt, chc, bd])\u000a\u000a    # call the function\u000a    rec_choice(choice_left, choice_right)\u000a    \u000a\u000a    #------Prepare to start Routine "choice_selection"-------\u000a    t = 0\u000a    choice_selectionClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # keep track of which components have finished\u000a    choice_selectionComponents = []\u000a    choice_selectionComponents.append(choice_pic_left)\u000a    choice_selectionComponents.append(choice_pic_right)\u000a    choice_selectionComponents.append(star_left_selection)\u000a    choice_selectionComponents.append(star_right_selection)\u000a    for thisComponent in choice_selectionComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "choice_selection"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = choice_selectionClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *choice_pic_left* updates\u000a        if t >= 0.0 and choice_pic_left.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_left.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_left.frameNStart = frameN  # exact frame index\u000a            choice_pic_left.setAutoDraw(True)\u000a        elif choice_pic_left.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            choice_pic_left.setAutoDraw(False)\u000a        \u000a        # *choice_pic_right* updates\u000a        if t >= 0.0 and choice_pic_right.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            choice_pic_right.tStart = t  # underestimates by a little under one frame\u000a            choice_pic_right.frameNStart = frameN  # exact frame index\u000a            choice_pic_right.setAutoDraw(True)\u000a        elif choice_pic_right.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            choice_pic_right.setAutoDraw(False)\u000a        \u000a        # *star_left_selection* updates\u000a        if key_resp_choice.keys=='left':\u000a            if t >= 0.0 and star_left_selection.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                star_left_selection.tStart = t  # underestimates by a little under one frame\u000a                star_left_selection.frameNStart = frameN  # exact frame index\u000a                star_left_selection.setAutoDraw(True)\u000a            elif star_left_selection.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                star_left_selection.setAutoDraw(False)\u000a        \u000a        # *star_right_selection* updates\u000a        if key_resp_choice.keys=='right':\u000a            if t >= 0.0 and star_right_selection.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                star_right_selection.tStart = t  # underestimates by a little under one frame\u000a                star_right_selection.frameNStart = frameN  # exact frame index\u000a                star_right_selection.setAutoDraw(True)\u000a            elif star_right_selection.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                star_right_selection.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in choice_selectionComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "choice_selection"-------\u000a    for thisComponent in choice_selectionComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    #thisExp.nextEntry()\u000a\u000a    #------Prepare to start Routine "confidence"-------\u000a    t = 0\u000a    confidenceClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    confidence_rating.reset()\u000a    # jitter the starting position of the confidence rating scale from a uniform distribution between 1.7 and 3.3 (the middle third of the scale), rounded to the nearest decimal place\u000a    confidence_marker_start = float(np.round(np.random.uniform(1.7, 3.3, 1)[0], 1))\u000a    confidence_rating.setMarkerPos(confidence_marker_start)\u000a    # keep track of which components have finished\u000a    confidenceComponents = []\u000a    confidenceComponents.append(confidence_rating)\u000a    for thisComponent in confidenceComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "confidence"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = confidenceClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *confidence_rating* updates\u000a        if t > 0.5:\u000a            confidence_rating.draw()\u000a            continueRoutine = confidence_rating.noResponse\u000a            if confidence_rating.noResponse == False:\u000a                confidence_rating.response = confidence_rating.getRating()\u000a                confidence_rating.rt = confidence_rating.getRT()\u000a            elif confidence_rating.noResponse==True:\u000a                if keyState[key.LEFT]==True and confidence_rating.markerPlacedAt >0:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt - 0.1\u000a                    confidence_rating.draw()\u000a                elif keyState[key.LEFT]==True and confidence_rating.markerPlacedAt==0.1:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt - 0.1\u000a                    confidence_rating.draw()\u000a                elif keyState[key.RIGHT]==True and confidence_rating.markerPlacedAt <4.9:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt + 0.1\u000a                    confidence_rating.draw()\u000a                elif keyState[key.RIGHT]==True and confidence_rating.markerPlacedAt==4.9:\u000a                    confidence_rating.markerPlacedAt = confidence_rating.markerPlacedAt + 0.1\u000a                    confidence_rating.draw()\u000a                    \u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in confidenceComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "confidence"-------\u000a    for thisComponent in confidenceComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # store data for confidence (TrialHandler)\u000a    binary.addData('confidence_rating1.response', confidence_rating.getRating())\u000a    binary.addData('confidence_rating1.rt', confidence_rating.getRT())\u000a    binary.addData('confidence_marker_start', confidence_marker_start+1) # Add 1 to convert from 0-5 to 1-6 scale\u000a\u000a    thisExp.nextEntry()\u000a\u000a\u000a# completed 1 repeat of 'binary'        \u000a\u000a#------Prepare to start Routine "instr_infer_intro"-------\u000at = 0\u000ainstr_infer_introClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_infer_intro_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_infer_intro_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_infer_introComponents = []\u000ainstr_infer_introComponents.append(instr_infer_intro_txt)\u000ainstr_infer_introComponents.append(instr_infer_intro_resp)\u000afor thisComponent in instr_infer_introComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_infer_intro"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_infer_introClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_infer_intro_txt* updates\u000a    if t >= 0.0 and instr_infer_intro_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_intro_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_intro_txt.frameNStart = frameN  # exact frame index\u000a        instr_infer_intro_txt.setAutoDraw(True)\u000a    \u000a    # *instr_infer_intro_resp* updates\u000a    if t >= 5.0 and instr_infer_intro_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_intro_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_intro_resp.frameNStart = frameN  # exact frame index\u000a        instr_infer_intro_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_infer_intro_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_infer_intro_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_infer_intro_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_infer_intro_resp.rt = instr_infer_intro_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_infer_introComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_infer_intro"-------\u000afor thisComponent in instr_infer_introComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_infer_intro_resp.keys in ['', [], None]:  # No response was made\u000a   instr_infer_intro_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_infer_intro_resp.keys',instr_infer_intro_resp.keys)\u000aif instr_infer_intro_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_infer_intro_resp.rt', instr_infer_intro_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a#------Prepare to start Routine "instr_infer_practice"-------\u000at = 0\u000ainstr_infer_practiceClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_infer_practice_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_infer_practice_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_infer_practiceComponents = []\u000ainstr_infer_practiceComponents.append(instr_infer_practice_txt)\u000ainstr_infer_practiceComponents.append(instr_infer_practice_resp)\u000afor thisComponent in instr_infer_practiceComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_infer_practice"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_infer_practiceClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_infer_practice_txt* updates\u000a    if t >= 0.0 and instr_infer_practice_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_practice_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_practice_txt.frameNStart = frameN  # exact frame index\u000a        instr_infer_practice_txt.setAutoDraw(True)\u000a    \u000a    # *instr_infer_practice_resp* updates\u000a    if t >= 5.0 and instr_infer_practice_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_practice_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_practice_resp.frameNStart = frameN  # exact frame index\u000a        instr_infer_practice_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_infer_practice_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_infer_practice_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_infer_practice_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_infer_practice_resp.rt = instr_infer_practice_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_infer_practiceComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_infer_practice"-------\u000afor thisComponent in instr_infer_practiceComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_infer_practice_resp.keys in ['', [], None]:  # No response was made\u000a   instr_infer_practice_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_infer_practice_resp.keys',instr_infer_practice_resp.keys)\u000aif instr_infer_practice_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_infer_practice_resp.rt', instr_infer_practice_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## PRACTICE LOOP ##########################\u000a\u000a# set up handler to look after randomisation of conditions etc\u000apractice_loop = data.TrialHandler(nReps=1, method=u'sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(filename+'_practicecond.csv'),\u000a    seed=None, name='practice_loop')\u000athisExp.addLoop(practice_loop)  # add the loop to the experiment\u000athisPractice_loop = practice_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisPractice_loop.rgb)\u000aif thisPractice_loop != None:\u000a    for paramName in thisPractice_loop.keys():\u000a        exec(paramName + '= thisPractice_loop.' + paramName)\u000a\u000a  \u000afor thisPractice_loop in practice_loop:\u000a    currentLoop = practice_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisPractice_loop.rgb)\u000a    if thisPractice_loop != None:\u000a        for paramName in thisPractice_loop.keys():\u000a            exec(paramName + '= thisPractice_loop.' + paramName)    \u000a    \u000a        \u000a    # Define class for setting the feedback image\u000a    class set_feedback:\u000a        options = ['correct', 'wrong']\u000a        feedback = np.random.choice(options, replace=True, p=[0.8, 0.2])\u000a        if feedback=='correct':\u000a            feedback_img = img_correct\u000a        elif feedback=='wrong':\u000a            feedback_img = img_wrong\u000a\u000a        if feedback_img==img_left:\u000a            feedback_side = 'left'\u000a        elif feedback_img==img_right:\u000a            feedback_side = 'right'\u000a\u000a\u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialtime = datetime.datetime.now()\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    img_left_infer.setImage(dir_path+img_left)\u000a    img_right_infer.setImage(dir_path+img_right)\u000a    infer_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    infer_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(fixation_text)\u000a    trialComponents.append(img_left_infer)\u000a    trialComponents.append(img_right_infer)\u000a    trialComponents.append(infer_resp)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *fixation_text* updates\u000a        if t >= 0 and fixation_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            fixation_text.tStart = t  # underestimates by a little under one frame\u000a            fixation_text.frameNStart = frameN  # exact frame index\u000a            fixation_text.setAutoDraw(True)\u000a        elif fixation_text.status == STARTED and t>= (0 + (2.0-win.monitorFramePeriod*0.75)):\u000a            fixation_text.setAutoDraw(False)\u000a\u000a        # *img_left_infer* updates\u000a        if t >= 2.0 and img_left_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_left_infer.tStart = t  # underestimates by a little under one frame\u000a            img_left_infer.frameNStart = frameN  # exact frame index\u000a            img_left_infer.setAutoDraw(True)\u000a        \u000a        # *img_right_infer* updates\u000a        if t >= 2.0 and img_right_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_right_infer.tStart = t  # underestimates by a little under one frame\u000a            img_right_infer.frameNStart = frameN  # exact frame index\u000a            img_right_infer.setAutoDraw(True)\u000a                  \u000a        # *infer_resp* updates\u000a        if t >= 2.0 and infer_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            infer_resp.tStart = t  # underestimates by a little under one frame\u000a            infer_resp.frameNStart = frameN  # exact frame index\u000a            infer_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            infer_resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if infer_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                infer_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                infer_resp.rt = infer_resp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a\u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if infer_resp.keys in ['', [], None]:  # No response was made\u000a       infer_resp.keys=None\u000a    # # store data for practice_loop (TrialHandler)\u000a    # practice_loop.addData('infer_resp.keys',infer_resp.keys)\u000a    # if infer_resp.keys != None:  # we had a response\u000a    #     practice_loop.addData('infer_resp.rt', infer_resp.rt)\u000a    practice_loop.addData('set_feedback.feedback_img', set_feedback.feedback_img)\u000a    practice_loop.addData('trial_start_time', trialtime)\u000a    \u000a    # # Increase correct and incorrect response counters by 1 based on S's response\u000a    # if infer_resp.keys=='left' and img_correct==img_left:\u000a    #     correct_counter += 1\u000a    # elif infer_resp.keys=='left' and img_correct==img_right:\u000a    #     incorrect_counter += 1\u000a    # elif infer_resp.keys=='right' and img_correct==img_right:\u000a    #     correct_counter += 1\u000a    # elif infer_resp.keys=='right' and img_correct==img_left:\u000a    #     incorrect_counter += 1\u000a    \u000a\u000a    #------Prepare to start Routine "trial_post_response"-------\u000a    t = 0\u000a    trial_post_responseClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(3.000000)\u000a    # keep track of which components have finished\u000a    trial_post_responseComponents = []\u000a    trial_post_responseComponents.append(img_left_infer)\u000a    trial_post_responseComponents.append(img_right_infer)\u000a    trial_post_responseComponents.append(selection_arrow_left)\u000a    trial_post_responseComponents.append(selection_arrow_right)\u000a    trial_post_responseComponents.append(feedback_box_left)\u000a    trial_post_responseComponents.append(feedback_box_right)\u000a    for thisComponent in trial_post_responseComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial_post_response"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = trial_post_responseClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a\u000a        # *img_left_infer* updates\u000a        if t >= 0.0 and img_left_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_left_infer.tStart = t  # underestimates by a little under one frame\u000a            img_left_infer.frameNStart = frameN  # exact frame index\u000a            img_left_infer.setAutoDraw(True)\u000a        elif img_left_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            img_left_infer.setAutoDraw(False)\u000a        \u000a        # *img_right_infer* updates\u000a        if t >= 0.0 and img_right_infer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            img_right_infer.tStart = t  # underestimates by a little under one frame\u000a            img_right_infer.frameNStart = frameN  # exact frame index\u000a            img_right_infer.setAutoDraw(True)\u000a        elif img_right_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            img_right_infer.setAutoDraw(False)\u000a        \u000a        if infer_resp.keys == 'left':\u000a            # *selection_arrow_left* updates\u000a            if t >= 0.0 and selection_arrow_left.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                selection_arrow_left.tStart = t  # underestimates by a little under one frame\u000a                selection_arrow_left.frameNStart = frameN  # exact frame index\u000a                selection_arrow_left.setAutoDraw(True)\u000a            elif selection_arrow_left.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                selection_arrow_left.setAutoDraw(False)\u000a        \u000a        if infer_resp.keys == 'right':\u000a            # *selection_arrow_right* updates\u000a            if t >= 0.0 and selection_arrow_right.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                selection_arrow_right.tStart = t  # underestimates by a little under one frame\u000a                selection_arrow_right.frameNStart = frameN  # exact frame index\u000a                selection_arrow_right.setAutoDraw(True)\u000a            elif selection_arrow_right.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                selection_arrow_right.setAutoDraw(False)\u000a        \u000a        if set_feedback.feedback_side == 'left':\u000a            # *feedback_box_left* updates\u000a            if t >= 1.0 and feedback_box_left.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                feedback_box_left.tStart = t  # underestimates by a little under one frame\u000a                feedback_box_left.frameNStart = frameN  # exact frame index\u000a                feedback_box_left.setAutoDraw(True)\u000a            elif feedback_box_left.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                feedback_box_left.setAutoDraw(False)\u000a        \u000a        if set_feedback.feedback_side == 'right':\u000a            # *feedback_box_right* updates\u000a            if t >= 1.0 and feedback_box_right.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                feedback_box_right.tStart = t  # underestimates by a little under one frame\u000a                feedback_box_right.frameNStart = frameN  # exact frame index\u000a                feedback_box_right.setAutoDraw(True)\u000a            elif feedback_box_right.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period right\u000a                feedback_box_right.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trial_post_responseComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "trial_post_response"-------\u000a    for thisComponent in trial_post_responseComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000a    \u000a    thisExp.nextEntry()\u000a                        \u000a# completed 1 repeat of 'practice_loop'\u000a\u000a\u000a#------Prepare to start Routine "instr_infer"-------\u000at = 0\u000ainstr_inferClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstr_infer_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstr_infer_resp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstr_inferComponents = []\u000ainstr_inferComponents.append(instr_infer_txt)\u000ainstr_inferComponents.append(instr_infer_resp)\u000afor thisComponent in instr_inferComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instr_infer"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instr_inferClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instr_infer_txt* updates\u000a    if t >= 0.0 and instr_infer_txt.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_txt.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_txt.frameNStart = frameN  # exact frame index\u000a        instr_infer_txt.setAutoDraw(True)\u000a    \u000a    # *instr_infer_resp* updates\u000a    if t >= 5.0 and instr_infer_resp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instr_infer_resp.tStart = t  # underestimates by a little under one frame\u000a        instr_infer_resp.frameNStart = frameN  # exact frame index\u000a        instr_infer_resp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instr_infer_resp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instr_infer_resp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['space'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instr_infer_resp.keys = theseKeys[-1]  # just the last key pressed\u000a            instr_infer_resp.rt = instr_infer_resp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instr_inferComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a    else:  # this Routine was not non-slip safe so reset non-slip timer\u000a        routineTimer.reset()\u000a\u000a#-------Ending Routine "instr_infer"-------\u000afor thisComponent in instr_inferComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instr_infer_resp.keys in ['', [], None]:  # No response was made\u000a   instr_infer_resp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instr_infer_resp.keys',instr_infer_resp.keys)\u000aif instr_infer_resp.keys != None:  # we had a response\u000a    thisExp.addData('instr_infer_resp.rt', instr_infer_resp.rt)\u000athisExp.nextEntry()\u000a\u000a\u000a######################## BLOCK LOOP ##########################\u000a\u000a# This loop runs a second nested loop that shows each item pair 10 times, followed by a rest break prompt.\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock_loop = data.TrialHandler(nReps=3, method=u'sequential', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=[None],\u000a    seed=None, name='block_loop')\u000athisExp.addLoop(block_loop)  # add the loop to the experiment\u000athisBlock_loop = block_loop.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock_loop.rgb)\u000aif thisBlock_loop != None:\u000a    for paramName in thisBlock_loop.keys():\u000a        exec(paramName + '= thisBlock_loop.' + paramName)\u000a\u000a# Set up counter to keep track of block loop cycle, so that the rest prompt is only shown twice\u000ablock_loop_counter = 0\u000a\u000a\u000afor thisBlock_loop in block_loop:\u000a    currentLoop = block_loop\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock_loop.rgb)\u000a    if thisBlock_loop != None:\u000a        for paramName in thisBlock_loop.keys():\u000a            exec(paramName + '= thisBlock_loop.' + paramName)\u000a    \u000a    # Increase loop counter by one\u000a    block_loop_counter += 1\u000a    \u000a    # Change the condition file for the feedback block based on which block loop we're on\u000a    condfilename = filename+u'_block'+str(block_loop_counter)+u'cond.csv'\u000a    \u000a    # Minimize the psychopy window so the calibration window can be seen\u000a    win.winHandle.minimize()\u000a    #Do the eye tracker setup at the beginning of each block\u000a    tracker.runSetupProcedure()\u000a    # Re-display the psychopy window after setup is completed\u000a    win.winHandle.maximize()\u000a    win.winHandle.activate()\u000a    \u000a\u000a    \u000a    #------Prepare to start Routine "get_ready"-------\u000a    t = 0\u000a    get_readyClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(3.000000)\u000a    # update component parameters for each repeat\u000a    get_ready_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    get_ready_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    get_readyComponents = []\u000a    get_readyComponents.append(get_ready_text)\u000a    get_readyComponents.append(get_ready_resp)\u000a    for thisComponent in get_readyComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    \u000a    #-------Start Routine "get_ready"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = get_readyClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *get_ready_text* updates\u000a        if t >= 0.0 and get_ready_text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            get_ready_text.tStart = t  # underestimates by a little under one frame\u000a            get_ready_text.frameNStart = frameN  # exact frame index\u000a            get_ready_text.setAutoDraw(True)\u000a        \u000a        # *get_ready_resp* updates\u000a        if t >= 0.0 and get_ready_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            get_ready_resp.tStart = t  # underestimates by a little under one frame\u000a            get_ready_resp.frameNStart = frameN  # exact frame index\u000a            get_ready_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            get_ready_resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if get_ready_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['p'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                get_ready_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                get_ready_resp.rt = get_ready_resp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in get_readyComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "get_ready"-------\u000a    for thisComponent in get_readyComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if get_ready_resp.keys in ['', [], None]:  # No response was made\u000a       get_ready_resp.keys=None\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('get_ready_resp.keys',get_ready_resp.keys)\u000a    if get_ready_resp.keys != None:  # we had a response\u000a        thisExp.addData('get_ready_resp.rt', get_ready_resp.rt)\u000a    thisExp.nextEntry()\u000a\u000a    ######################## TRIAL LOOP ##########################\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    trial_loop = data.TrialHandler(nReps=1, method=u'sequential', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(condfilename),\u000a        seed=None, name='trial_loop')\u000a    thisExp.addLoop(trial_loop)  # add the loop to the experiment\u000a    thisTrial_loop = trial_loop.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_loop.rgb)\u000a    if thisTrial_loop != None:\u000a        for paramName in thisTrial_loop.keys():\u000a            exec(paramName + '= thisTrial_loop.' + paramName)\u000a    \u000a      \u000a    for thisTrial_loop in trial_loop:\u000a        currentLoop = trial_loop\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_loop.rgb)\u000a        if thisTrial_loop != None:\u000a            for paramName in thisTrial_loop.keys():\u000a                exec(paramName + '= thisTrial_loop.' + paramName)    \u000a        \u000a            \u000a        # Define class for setting the feedback image\u000a        class set_feedback:\u000a            options = ['correct', 'wrong']\u000a            feedback = np.random.choice(options, replace=True, p=[0.8, 0.2])\u000a            if feedback=='correct':\u000a                feedback_img = img_correct\u000a            elif feedback=='wrong':\u000a                feedback_img = img_wrong\u000a\u000a            if feedback_img==img_left:\u000a                feedback_side = 'left'\u000a            elif feedback_img==img_right:\u000a                feedback_side = 'right'\u000a                        \u000a        # Start getting data from the eye tracker\u000a        tracker.enableEventReporting(True)\u000a        # Send beginning-of-trial messages to eye tracker data file\u000a        trial_number = (block_loop.thisN * 200) + trial_loop.thisTrialN # Trial number out of 599 (starts at 0)\u000a        tracker.sendCommand("record_status_message 'INFERRING, Block %d/3, Trial %d/600 '" % (block_loop.thisN + 1, trial_number + 1))\u000a        tracker.sendMessage("TRIALID %d" % trial_number)\u000a        tracker.sendMessage("!V TRIAL_VAR_DATA %d" % trial_number)\u000a\u000a        \u000a        #------Prepare to start Routine "trial"-------\u000a        t = 0\u000a        trialtime = datetime.datetime.now()\u000a        trialClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        img_left_infer.setImage(dir_path+img_left)\u000a        img_right_infer.setImage(dir_path+img_right)\u000a        infer_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        infer_resp.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trialComponents = []\u000a        trialComponents.append(fixation_text)\u000a        trialComponents.append(img_left_infer)\u000a        trialComponents.append(img_right_infer)\u000a        trialComponents.append(infer_resp)\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        # Set indicator variable for whether eye tracker messages were sent during the first loop of the routine\u000a        eye_sync_messages_sent = 0\u000a        \u000a        #-------Start Routine "trial"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = trialClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *fixation_text* updates\u000a            if t >= 0 and fixation_text.status == NOT_STARTED:\u000a                if eye_sync_messages_sent==0:\u000a                    startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                # keep track of start time/frame for later\u000a                fixation_text.tStart = t  # underestimates by a little under one frame\u000a                fixation_text.frameNStart = frameN  # exact frame index\u000a                fixation_text.setAutoDraw(True)\u000a                if eye_sync_messages_sent==0:\u000a                    drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                    tracker.sendMessage("%d DISPLAY ON" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                    tracker.sendMessage("SYNCTIME %d" %drawTime)\u000a                    eye_sync_messages_sent = 1\u000a            elif fixation_text.status == STARTED and t>= (0 + (2.0-win.monitorFramePeriod*0.75)):\u000a                fixation_text.setAutoDraw(False)\u000a            \u000a            # *img_left_infer* updates\u000a            if t >= 2.0 and img_left_infer.status == NOT_STARTED:\u000a                if eye_sync_messages_sent==1:\u000a                    startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                # keep track of start time/frame for later\u000a                img_left_infer.tStart = t  # underestimates by a little under one frame\u000a                img_left_infer.frameNStart = frameN  # exact frame index\u000a                img_left_infer.setAutoDraw(True)\u000a            \u000a            # *img_right_infer* updates\u000a            if t >= 2.0 and img_right_infer.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                img_right_infer.tStart = t  # underestimates by a little under one frame\u000a                img_right_infer.frameNStart = frameN  # exact frame index\u000a                img_right_infer.setAutoDraw(True)\u000a                if eye_sync_messages_sent==1:\u000a                    drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                    tracker.sendMessage("%d DISPLAY ON ITEMS" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                    eye_sync_messages_sent = 2\u000a                      \u000a            # *infer_resp* updates\u000a            if t >= 2.0 and infer_resp.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                infer_resp.tStart = t  # underestimates by a little under one frame\u000a                infer_resp.frameNStart = frameN  # exact frame index\u000a                infer_resp.status = STARTED\u000a                # keyboard checking is just starting\u000a                infer_resp.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            if infer_resp.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['left', 'right'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    infer_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                    infer_resp.rt = infer_resp.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trialComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                tracker.enableEventReporting(False) # End eye tracker data recording\u000a                tracker.sendMessage("EXPERIMENT ABORTED")\u000a                io.quit() # Close iohub\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial"-------\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if infer_resp.keys in ['', [], None]:  # No response was made\u000a           infer_resp.keys=None\u000a        # store data for trial_loop (TrialHandler)\u000a        trial_loop.addData('infer_resp.keys',infer_resp.keys)\u000a        if infer_resp.keys != None:  # we had a response\u000a            trial_loop.addData('infer_resp.rt', infer_resp.rt)\u000a        trial_loop.addData('set_feedback.feedback_img', set_feedback.feedback_img)\u000a        trial_loop.addData('trial_start_time', trialtime)\u000a        \u000a        # Increase correct and incorrect response counters by 1 based on S's response\u000a        if infer_resp.keys=='left' and img_correct==img_left:\u000a            correct_counter += 1\u000a        elif infer_resp.keys=='left' and img_correct==img_right:\u000a            incorrect_counter += 1\u000a        elif infer_resp.keys=='right' and img_correct==img_right:\u000a            correct_counter += 1\u000a        elif infer_resp.keys=='right' and img_correct==img_left:\u000a            incorrect_counter += 1\u000a        \u000a\u000a        #------Prepare to start Routine "trial_post_response"-------\u000a        t = 0\u000a        trial_post_responseClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(3.000000)\u000a        # keep track of which components have finished\u000a        trial_post_responseComponents = []\u000a        trial_post_responseComponents.append(img_left_infer)\u000a        trial_post_responseComponents.append(img_right_infer)\u000a        trial_post_responseComponents.append(selection_arrow_left)\u000a        trial_post_responseComponents.append(selection_arrow_right)\u000a        trial_post_responseComponents.append(feedback_box_left)\u000a        trial_post_responseComponents.append(feedback_box_right)\u000a        for thisComponent in trial_post_responseComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        # Set indicator variable for whether eye tracker messages were sent during the first loop of the routine\u000a        eye_sync_messages_sent = 0\u000a\u000a        #-------Start Routine "trial_post_response"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = trial_post_responseClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a\u000a            # *img_left_infer* updates\u000a            if t >= 0.0 and img_left_infer.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                img_left_infer.tStart = t  # underestimates by a little under one frame\u000a                img_left_infer.frameNStart = frameN  # exact frame index\u000a                img_left_infer.setAutoDraw(True)\u000a            elif img_left_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                img_left_infer.setAutoDraw(False)\u000a            \u000a            # *img_right_infer* updates\u000a            if t >= 0.0 and img_right_infer.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                img_right_infer.tStart = t  # underestimates by a little under one frame\u000a                img_right_infer.frameNStart = frameN  # exact frame index\u000a                img_right_infer.setAutoDraw(True)\u000a            elif img_right_infer.status == STARTED and t >= (0.0 + (3.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                img_right_infer.setAutoDraw(False)\u000a            \u000a            if infer_resp.keys == 'left':\u000a                # *selection_arrow_left* updates\u000a                if t >= 0.0 and selection_arrow_left.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==0:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    selection_arrow_left.tStart = t  # underestimates by a little under one frame\u000a                    selection_arrow_left.frameNStart = frameN  # exact frame index\u000a                    selection_arrow_left.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==0:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        tracker.sendMessage("%d DISPLAY ON SELECTION" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 1\u000a                elif selection_arrow_left.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    if eye_sync_messages_sent==1:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    selection_arrow_left.setAutoDraw(False)\u000a                    if eye_sync_messages_sent==1:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        tracker.sendMessage("%d DISPLAY ON SELECTION OFF" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 2\u000a            \u000a            if infer_resp.keys == 'right':\u000a                # *selection_arrow_right* updates\u000a                if t >= 0.0 and selection_arrow_right.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==0:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    selection_arrow_right.tStart = t  # underestimates by a little under one frame\u000a                    selection_arrow_right.frameNStart = frameN  # exact frame index\u000a                    selection_arrow_right.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==0:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        tracker.sendMessage("%d DISPLAY ON SELECTION" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 1\u000a                elif selection_arrow_right.status == STARTED and t >= (0.0 + (0.5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    if eye_sync_messages_sent==1:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    selection_arrow_right.setAutoDraw(False)\u000a                    if eye_sync_messages_sent==1:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        tracker.sendMessage("%d DISPLAY ON SELECTION OFF" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 2\u000a            \u000a            if set_feedback.feedback_side == 'left':\u000a                # *feedback_box_left* updates\u000a                if t >= 1.0 and feedback_box_left.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==2:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    feedback_box_left.tStart = t  # underestimates by a little under one frame\u000a                    feedback_box_left.frameNStart = frameN  # exact frame index\u000a                    feedback_box_left.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==2:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        tracker.sendMessage("%d DISPLAY ON FEEDBACK" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 3\u000a                elif feedback_box_left.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                    feedback_box_left.setAutoDraw(False)\u000a            \u000a            if set_feedback.feedback_side == 'right':\u000a                # *feedback_box_right* updates\u000a                if t >= 1.0 and feedback_box_right.status == NOT_STARTED:\u000a                    if eye_sync_messages_sent==2:\u000a                        startTime = pylink.currentTime() # Get time at start of stimulus drawing\u000a                    # keep track of start time/frame for later\u000a                    feedback_box_right.tStart = t  # underestimates by a little under one frame\u000a                    feedback_box_right.frameNStart = frameN  # exact frame index\u000a                    feedback_box_right.setAutoDraw(True)\u000a                    if eye_sync_messages_sent==2:\u000a                        drawTime = (pylink.currentTime() - startTime) # Calculate time it took to draw both items\u000a                        tracker.sendMessage("%d DISPLAY ON FEEDBACK" %drawTime) # Send messages to eye tracker data file to mark stimulus onset\u000a                        eye_sync_messages_sent = 3\u000a                elif feedback_box_right.status == STARTED and t >= (1.0 + (2.0-win.monitorFramePeriod*0.75)): #most of one frame period right\u000a                    feedback_box_right.setAutoDraw(False)\u000a\u000a\u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trial_post_responseComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                tracker.enableEventReporting(False) # End eye tracker data recording\u000a                tracker.sendMessage("EXPERIMENT ABORTED")\u000a                io.quit() # Close iohub\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "trial_post_response"-------\u000a        for thisComponent in trial_post_responseComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a\u000a\u000a\u000a        thisExp.nextEntry()\u000a                            \u000a    # completed 5 repeats of 'trial_loop'\u000a    \u000a    if block_loop_counter <= 2: # If this is the first or second cycle of the loop, display the rest break prompt\u000a\u000a        #------Prepare to start Routine "rest_prompt"-------\u000a        t = 0\u000a        rest_promptClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        rest_prompt_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        rest_prompt_resp.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        rest_promptComponents = []\u000a        rest_promptComponents.append(rest_prompt_txt)\u000a        rest_promptComponents.append(rest_prompt_resp)\u000a        for thisComponent in rest_promptComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a\u000a        #-------Start Routine "rest_prompt"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = rest_promptClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *rest_prompt_txt* updates\u000a            if t >= 0.0 and rest_prompt_txt.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                rest_prompt_txt.tStart = t  # underestimates by a little under one frame\u000a                rest_prompt_txt.frameNStart = frameN  # exact frame index\u000a                rest_prompt_txt.setAutoDraw(True)\u000a            \u000a            # *rest_prompt_resp* updates\u000a            if t >= 2.0 and rest_prompt_resp.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                rest_prompt_resp.tStart = t  # underestimates by a little under one frame\u000a                rest_prompt_resp.frameNStart = frameN  # exact frame index\u000a                rest_prompt_resp.status = STARTED\u000a                # keyboard checking is just starting\u000a                rest_prompt_resp.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            if rest_prompt_resp.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['space'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    rest_prompt_resp.keys = theseKeys[-1]  # just the last key pressed\u000a                    rest_prompt_resp.rt = rest_prompt_resp.clock.getTime()\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in rest_promptComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                tracker.enableEventReporting(False) # End eye tracker data recording\u000a                tracker.sendMessage("EXPERIMENT ABORTED")\u000a                io.quit() # CLose iohub\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a\u000a        #-------Ending Routine "rest_prompt"-------\u000a        for thisComponent in rest_promptComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if rest_prompt_resp.keys in ['', [], None]:  # No response was made\u000a           rest_prompt_resp.keys=None\u000a        # store data for thisExp (ExperimentHandler)\u000a        thisExp.addData('rest_prompt_resp.keys',rest_prompt_resp.keys)\u000a        if rest_prompt_resp.keys != None:  # we had a response\u000a            thisExp.addData('rest_prompt_resp.rt', rest_prompt_resp.rt)\u000a\u000a\u000a    thisExp.nextEntry()\u000a    \u000a# completed 3 repeats of 'block_loop'\u000a\u000a\u000a# store data for total number of correct and incorrect responses    \u000athisExp.addData('correct_counter', correct_counter)\u000athisExp.addData('incorrect_counter', incorrect_counter)\u000athisExp.nextEntry()     \u000a\u000atracker.setConnectionState(False) # Close and transfer eye-tracking data, then close down eye tracker connection\u000a\u000a\u000a######################## AUCTION ##########################\u000a\u000aif len(prefs)==41 and len(bids)==41: # If S completed the entire binary choice and BDM routines, run the auction\u000a\u000a    # run the auction\u000a    class auction:\u000a        rand_itm = randint(1, (len(prefs))) # pick index for S's chosen item from a random choice\u000a        price = float((randint(1, 300)))/100 # assign a price to the item randomly from between 0.01 and 3 pounds\u000a        bid = prefs[rand_itm][3]\u000a        # check if S's bid for that item was above or below the price\u000a        if bid >= price:\u000a            win_item=True\u000a        elif bid < price:\u000a            win_item=False\u000a\u000a        # set text for the auction screen\u000a        if win_item==True:\u000a            auc_res_txt = u'Congratulations! You won the following item at auction. \u005cnThis was your preferred item out of a randomly selected pair from one of the choice tasks.'\u000a            auc_prc_txt = u'Your bid of \u005cxa3' + '{0:.2f}'.format(bid) + u' matched or exceeded the randomly generated price of \u005cxa3' + '{0:.2f}'.format(price) + '.\u005cn\u005cn[Press space bar to continue]'\u000a            cost = price\u000a        elif win_item==False:\u000a            auc_res_txt = u'Sorry, you did not win the following item at auction. \u005cnThis was your preferred item out of a randomly selected pair from one of the choice tasks.'\u000a            auc_prc_txt = u'Your bid of \u005cxa3' + '{0:.2f}'.format(bid) + u' was lower than the randomly generated price of \u005cxa3' + '{0:.2f}'.format(price) + '.\u005cn\u005cn[Press space bar to continue]'\u000a            cost = 0\u000a\u000a        # find the image path of the auction item\u000a        rand_itm_img = prefs[rand_itm][2]\u000a\u000a    # add up each component of S's payment\u000a    class score:\u000a        base = 25\u000a        rwrd = 0.01\u000a        loss = 0\u000a        rwrd_tot = rwrd * correct_counter\u000a        loss_tot = loss * incorrect_counter\u000a        pre_pymt = base + rwrd_tot - loss_tot\u000a        final_pymt = pre_pymt - auction.cost\u000a\u000a        pymt_expl_bdwn = u'\u005cxa3' + '{0:.2f}'.format(base) + u' base payment'+ u'\u005cn+ \u005cxa3' + '{0:.2f}'.format(rwrd_tot) + ' reward for ' + str(correct_counter) + u' correct responses (\u005cxa3' + '{0:.2f}'.format(rwrd) + u' each)' + u'\u005cn- \u005cxa3' + '{0:.2f}'.format(auction.cost) + ' cost of auction item' \u000a        pymt_expl_tot = u'Your total payment is: \u005cxa3' + '{0:.2f}'.format(final_pymt) + '\u005cn\u005cnThank you for participating! Please call the experimenter into the room.'\u000a\u000a\u000a    # Initialize components for Routine "auc_disp"\u000a    auc_dispClock = core.Clock()\u000a    pic_auc_itm = visual.ImageStim(win=win, name='pic_auc_itm',\u000a        image=dir_path+auction.rand_itm_img, mask=None,\u000a        ori=0, pos=[0, 0], size=None,\u000a        color=[1,1,1], colorSpace=u'rgb', opacity=1,\u000a        flipHoriz=False, flipVert=False,\u000a        texRes=128, interpolate=False, depth=0.0)\u000a    auc_txt1 = visual.TextStim(win=win, ori=0, name='auc_txt1',\u000a        text=auction.auc_res_txt, font=u'Arial',\u000a        pos=[0, 0.6], height=0.07, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    auc_txt2 = visual.TextStim(win=win, ori=0, name='auc_txt2',\u000a        text=auction.auc_prc_txt, font=u'Arial',\u000a        pos=[0, -0.6], height=0.07, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a\u000a    #------Prepare to start Routine "auc_disp"-------\u000a    t = 0\u000a    auc_dispClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    key_resp_auc_disp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_auc_disp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    auc_dispComponents = []\u000a    auc_dispComponents.append(pic_auc_itm)\u000a    auc_dispComponents.append(auc_txt1)\u000a    auc_dispComponents.append(auc_txt2)\u000a    for thisComponent in auc_dispComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "auc_disp"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = auc_dispClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *pic_auc_itm* updates\u000a        if t >= 0.2 and pic_auc_itm.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            pic_auc_itm.tStart = t  # underestimates by a little under one frame\u000a            pic_auc_itm.frameNStart = frameN  # exact frame index\u000a            pic_auc_itm.setAutoDraw(True)\u000a        \u000a        # *auc_txt1* updates\u000a        if t >= 0.2 and auc_txt1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            auc_txt1.tStart = t  # underestimates by a little under one frame\u000a            auc_txt1.frameNStart = frameN  # exact frame index\u000a            auc_txt1.setAutoDraw(True)\u000a\u000a        # *auc_txt2* updates\u000a        if t >= 0.2 and auc_txt2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            auc_txt2.tStart = t  # underestimates by a little under one frame\u000a            auc_txt2.frameNStart = frameN  # exact frame index\u000a            auc_txt2.setAutoDraw(True)\u000a        \u000a        # *key_resp_auc_disp* updates\u000a        if t >= 0.2 and key_resp_auc_disp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_auc_disp.tStart = t  # underestimates by a little under one frame\u000a            key_resp_auc_disp.frameNStart = frameN  # exact frame index\u000a            key_resp_auc_disp.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_auc_disp.clock.reset()  # now t=0\u000a        if key_resp_auc_disp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_auc_disp.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_auc_disp.rt = key_resp_auc_disp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in auc_dispComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "auc_disp"-------\u000a    for thisComponent in auc_dispComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_auc_disp.keys in ['', [], None]:  # No response was made\u000a       key_resp_auc_disp.keys=None\u000a    # store data for thisExp (TrialHandler)\u000a    thisExp.addData('auction.win_item', auction.win_item)\u000a    thisExp.addData('auction.price', auction.price)\u000a    thisExp.addData('auction.bid', auction.bid)\u000a    thisExp.addData('auction.rand_itm_img', auction.rand_itm_img)\u000a    thisExp.addData('score.base', score.base)\u000a    thisExp.addData('score.rwrd', score.rwrd)\u000a    thisExp.addData('score.loss', score.loss)\u000a    thisExp.addData('correct_counter', correct_counter)\u000a    thisExp.addData('incorrect_counter', incorrect_counter)\u000a    thisExp.addData('score.final_pymt', score.final_pymt)\u000a    thisExp.nextEntry()\u000a\u000a\u000a    # Initialize components for Routine "pymt_disp"\u000a    pymt_dispClock = core.Clock()\u000a    pymt_disp_txt1 = visual.TextStim(win=win, ori=0, name='pymt_disp_txt1',\u000a        text=score.pymt_expl_bdwn, font=u'Arial',\u000a        pos=[0, 0.6], height=0.07, wrapWidth=1.5,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    pymt_disp_txt2 = visual.TextStim(win=win, ori=0, name='pymt_disp_txt2',\u000a        text=score.pymt_expl_tot, font=u'Arial',\u000a        pos=[0, -0.65], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    #------Prepare to start Routine "pymt_disp"-------\u000a    t = 0\u000a    pymt_dispClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    key_resp_pymt_disp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    key_resp_pymt_disp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    pymt_dispComponents = []\u000a    pymt_dispComponents.append(pic_auc_itm)\u000a    pymt_dispComponents.append(pymt_disp_txt1)\u000a    pymt_dispComponents.append(pymt_disp_txt2)\u000a    pymt_dispComponents.append(key_resp_pymt_disp)\u000a    for thisComponent in pymt_dispComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "pymt_disp"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = pymt_dispClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        if auction.win_item==True:\u000a            # *pic_auc_itm* updates\u000a            if t >= 0.0 and pic_auc_itm.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                pic_auc_itm.tStart = t  # underestimates by a little under one frame\u000a                pic_auc_itm.frameNStart = frameN  # exact frame index\u000a                pic_auc_itm.setAutoDraw(True)\u000a\u000a        # *pymt_disp_txt1* updates\u000a        if t >= 0.0 and pymt_disp_txt1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            pymt_disp_txt1.tStart = t  # underestimates by a little under one frame\u000a            pymt_disp_txt1.frameNStart = frameN  # exact frame index\u000a            pymt_disp_txt1.setAutoDraw(True)\u000a\u000a        # *pymt_disp_txt2* updates\u000a        if t >= 0.0 and pymt_disp_txt2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            pymt_disp_txt2.tStart = t  # underestimates by a little under one frame\u000a            pymt_disp_txt2.frameNStart = frameN  # exact frame index\u000a            pymt_disp_txt2.setAutoDraw(True)\u000a        \u000a        # *key_resp_pymt_disp* updates\u000a        if t >= 3.0 and key_resp_pymt_disp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            key_resp_pymt_disp.tStart = t  # underestimates by a little under one frame\u000a            key_resp_pymt_disp.frameNStart = frameN  # exact frame index\u000a            key_resp_pymt_disp.status = STARTED\u000a            # keyboard checking is just starting\u000a            key_resp_pymt_disp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if key_resp_pymt_disp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['space'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                key_resp_pymt_disp.keys = theseKeys[-1]  # just the last key pressed\u000a                key_resp_pymt_disp.rt = key_resp_pymt_disp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in pymt_dispComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "pymt_disp"-------\u000a    for thisComponent in pymt_dispComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if key_resp_pymt_disp.keys in ['', [], None]:  # No response was made\u000a       key_resp_pymt_disp.keys=None\u000a\u000aelse: # If S didn't complete the entire binary choice and BDM routines during this session, prompt a manual auction\u000a    # Initialize components for Routine "auc_manual"\u000a    auc_manualClock = core.Clock()\u000a    auc_manual_txt = visual.TextStim(win=win, ori=0, name='auc_manual_txt',\u000a        text=u'Thank you! This completes the experiment. Please get the experimenter, who will run the auction and calculate your final payment.\u005cn\u005cnCorrect: ' + str(correct_counter) + '\u005cnIncorrect: ' + str(incorrect_counter),    font=u'Arial',\u000a        pos=[0, 0], height=0.07, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a\u000a    #------Prepare to start Routine "auc_manual"-------\u000a    t = 0\u000a    auc_manualClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    auc_manualComponents = []\u000a    auc_manualComponents.append(auc_manual_txt)\u000a    for thisComponent in auc_manualComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "auc_manual"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = auc_manualClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *auc_manual_txt* updates\u000a        if t >= 0.0 and auc_manual_txt.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            auc_manual_txt.tStart = t  # underestimates by a little under one frame\u000a            auc_manual_txt.frameNStart = frameN  # exact frame index\u000a            auc_manual_txt.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in auc_manualComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "auc_manual"-------\u000a    for thisComponent in auc_manualComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000athisExp.nextEntry()\u000a\u000aio.quit() # Close iohub\u000a\u000a\u000awin.close()\u000acore.quit()\u000a
p10235
sg9108
(lp10236
sg9110
I84422992
sg10
g9400
sg6
g9112
sg9113
I1
sg52
I01
sg53
g54
sg9114
g1
(g9115
g9116
(dp10237
g33
g9119
(g9120
g93
g9121
S'b'
tRp10238
(I1
(I200
I1
tg9245
I00
S'\x90\xfb\xb3\x1b\x90\xf3\xb4\x1b\xb8\xf3\xb4\x1b\xc0\xfb\xb3\x1bX~\xb4\x1b \x01\xb5\x1b\x80\x01\xb5\x1b\xc8~\xb4\x1bX~\xb4\x1b\xa0\x01\xb5\x1b\x00\x7f\xb4\x1b\xe0\xf3\xb4\x1b\x08\xf4\xb4\x1b\xe0\xf3\xb4\x1b0\xf4\xb4\x1b\xe0\xf3\xb4\x1b\xb8\xf3\xb4\x1bX\xf4\xb4\x1b\x08\xf4\xb4\x1b\xf0\xfb\xb3\x1b8\x7f\xb4\x1b \xfc\xb3\x1b0\xf4\xb4\x1b\xc8~\xb4\x1bX\xf4\xb4\x1bP\xfc\xb3\x1b8\x7f\xb4\x1b\x90\xf3\xb4\x1bP\xfc\xb3\x1b\xf0\xfb\xb3\x1b\x80\xfc\xb3\x1b\x90~\xb4\x1b\x08\xf4\xb4\x1b\x80\xfc\xb3\x1b\xc0\xf5\xb4\x1b\x90\xfb\xb3\x1b8\x7f\xb4\x1b\x90~\xb4\x1b\xf0\xfb\xb3\x1bH\xf5\xb4\x1b\xa8\xf4\xb4\x1b\x90\xf3\xb4\x1b\xa8\xf4\xb4\x1bP\xfc\xb3\x1b8\x7f\xb4\x1b@\x01\xb5\x1bX\xf4\xb4\x1b\x90\xfb\xb3\x1b\xc8~\xb4\x1bp\xfd\xb3\x1b\x00\x7f\xb4\x1b@\x01\xb5\x1b \xfc\xb3\x1bX~\xb4\x1b0\xf4\xb4\x1b\xf0\xfb\xb3\x1b\x00\x7f\xb4\x1b\xe0\xfc\xb3\x1bp\xfd\xb3\x1b\xa0\xfd\xb3\x1b\x90~\xb4\x1b\xc0\xfb\xb3\x1b\xc8~\xb4\x1b \x01\xb5\x1b\x80\xf4\xb4\x1bX\xf4\xb4\x1bH\xf5\xb4\x1b\xb0\xfc\xb3\x1b\xe8\xf5\xb4\x1b\xe0\xf3\xb4\x1b0\xf4\xb4\x1b\xc0\xf5\xb4\x1bH\xf5\xb4\x1b0\xf4\xb4\x1b@\x01\xb5\x1b\xa8\xf4\xb4\x1b\x80\xf4\xb4\x1b\x90\xf3\xb4\x1b\xb8\xf3\xb4\x1b\x90\xfb\xb3\x1b\xa0\xfd\xb3\x1b0\xf4\xb4\x1b\x90\xfb\xb3\x1b\xe8\xf5\xb4\x1bp\xf5\xb4\x1bX~\xb4\x1b \xfc\xb3\x1b\xb8\xf3\xb4\x1b8\x7f\xb4\x1b\x00\x7f\xb4\x1b\xa8\xf4\xb4\x1b\xf0\xfb\xb3\x1b\xc8~\xb4\x1b\xe0\xf3\xb4\x1b8\x7f\xb4\x1b\xc0\xfb\xb3\x1bX~\xb4\x1b@\x01\xb5\x1b\x08\xf4\xb4\x1b\x80\xf4\xb4\x1b\xe0\xf3\xb4\x1b\x80\x01\xb5\x1b\xc0\xfb\xb3\x1b\xa8\xf4\xb4\x1bP\xfc\xb3\x1b\x80\xfc\xb3\x1b\xb8\xf3\xb4\x1b\xc0\xfb\xb3\x1bp\xf5\xb4\x1b\xb0\xfc\xb3\x1bX\xf4\xb4\x1b\x00\x7f\xb4\x1b8\x7f\xb4\x1b\xf0\xfb\xb3\x1bX\xf4\xb4\x1b\xe0\xf3\xb4\x1b\xa8\xf4\xb4\x1b\x80\xf4\xb4\x1b\xa8\x7f\xb4\x1b\x10\xfd\xb3\x1b\x00\x7f\xb4\x1b\x90~\xb4\x1b\x98\xf5\xb4\x1b0\xf4\xb4\x1b \x01\xb5\x1b8\x7f\xb4\x1bX~\xb4\x1b\x98\xf5\xb4\x1b@\xfd\xb3\x1b\xe0\xf3\xb4\x1b\xa0\xfd\xb3\x1b\xc0\x01\xb5\x1b\xa8\xf4\xb4\x1b8\x7f\xb4\x1bH\xf5\xb4\x1b\xc0\xfb\xb3\x1b\x80\xf4\xb4\x1b\x00\x7f\xb4\x1b\xf8\xf4\xb4\x1bX~\xb4\x1b\xc8~\xb4\x1b\x90\xf3\xb4\x1b\x80\xf4\xb4\x1b\x10\xfd\xb3\x1b\x00\x7f\xb4\x1b@\xfd\xb3\x1b\xc8~\xb4\x1b\x00\x7f\xb4\x1b\x08\xf4\xb4\x1b\xb0\xfc\xb3\x1b\xe0\xfc\xb3\x1b\xb8\xf3\xb4\x1b\xf8\xf4\xb4\x1bp\x7f\xb4\x1b\x90\xf3\xb4\x1b\xb8\xf3\xb4\x1bX\xf4\xb4\x1b \x01\xb5\x1b \xfc\xb3\x1b \x01\xb5\x1b@\x01\xb5\x1b\x80\x01\xb5\x1b\xe0\xf3\xb4\x1b \xfc\xb3\x1b@\x01\xb5\x1b\x90~\xb4\x1b@\xfd\xb3\x1b\x90\xfb\xb3\x1b`\x01\xb5\x1b\x80\xf4\xb4\x1bP\xfc\xb3\x1bp\xf5\xb4\x1b\x90~\xb4\x1b0\xf4\xb4\x1b\x80\xf4\xb4\x1b\xf0\xfb\xb3\x1bp\xfd\xb3\x1bX~\xb4\x1b\xa0\x01\xb5\x1b\xb0\xfc\xb3\x1bp\xf5\xb4\x1b \xfc\xb3\x1b\xa0\x01\xb5\x1b \x01\xb5\x1b\xb8\xf3\xb4\x1b\xa8\xf4\xb4\x1bP\xfc\xb3\x1b\x90\xfb\xb3\x1bp\xfd\xb3\x1b \xf5\xb4\x1b\xb8\xf3\xb4\x1b\x90~\xb4\x1bP\xfc\xb3\x1b\xc8~\xb4\x1b\x08\xf4\xb4\x1bX~\xb4\x1b@\x01\xb5\x1b\x90\xf3\xb4\x1b\xf8\xf4\xb4\x1bX\xf4\xb4\x1b'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg9118
g9119
(g9120
g93
g9121
S'b'
tRp10239
(I1
(I200
I1
tg9123
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg38
g9119
(g9120
g93
g9121
S'b'
tRp10240
(I1
(I200
I1
tg9245
I00
S'@\x04\xb5\x1b\x80\x03\xb5\x1b\xa0\x03\xb5\x1b`\x02\xb5\x1b \x03\xb5\x1b\x00\x19\x8c\x1b\x00\x05\xb5\x1b\xe0\x04\xb5\x1b\xc0\x03\xb5\x1b\xe0\x01\xb5\x1b \x04\xb5\x1b\xa0\x02\xb5\x1b\xe0\x03\xb5\x1b@\x03\xb5\x1b\xa0\x05\xb5\x1b\xe0\x02\xb5\x1b\x80\x02\xb5\x1b\xa0\x04\xb5\x1b@\x05\xb5\x1b\xe0\x05\xb5\x1b`\x06\xb5\x1b\x00\x04\xb5\x1b \x06\xb5\x1b\x00\x06\xb5\x1b\x80\x05\xb5\x1b\xc0\x05\xb5\x1b\x80\x04\xb5\x1b`\x04\xb5\x1b@\x07\xb5\x1b\xc0\x04\xb5\x1b\xa0\x07\xb5\x1b\xe0\x06\xb5\x1b@\x02\xb5\x1b\xa0\x06\xb5\x1b\x00\x03\xb5\x1b\x80\x06\xb5\x1b`\x05\xb5\x1b\xc0\x06\xb5\x1b@\x08\xb5\x1b \x07\xb5\x1b\x00\x08\xb5\x1b`\x07\xb5\x1b\x00\t\xb5\x1b\x00\x07\xb5\x1b\xe0\x07\xb5\x1b`\x08\xb5\x1b\xa0\x08\xb5\x1b\xc0\x02\xb5\x1b \x08\xb5\x1b\x80\t\xb5\x1b\x80\x07\xb5\x1b\xe0\t\xb5\x1b\xa0\t\xb5\x1b \x02\xb5\x1b \n\xb5\x1b \t\xb5\x1b`\x03\xb5\x1b\xc0\x07\xb5\x1b\x00\x0b\xb5\x1b\xc0\x08\xb5\x1b\xe0\x08\xb5\x1b\x008\r\x0c\xc0\t\xb5\x1b`\n\xb5\x1b\xe0\x0b\xb5\x1b\xc0\n\xb5\x1b\x80\x08\xb5\x1b \x0c\xb5\x1b\xa0\n\xb5\x1b@\t\xb5\x1b`\x0b\xb5\x1b\x00\n\xb5\x1b\xa0\x0c\xb5\x1b\xe0\x0c\xb5\x1b \r\xb5\x1b`\x0c\xb5\x1b@\x0c\xb5\x1b\x80\n\xb5\x1b\xa0\x0b\xb5\x1b \x05\xb5\x1b\x80\x0b\xb5\x1b\x00\r\xb5\x1b\x80\r\xb5\x1b\xa0\r\xb5\x1b@\r\xb5\x1b \x0b\xb5\x1b\xc0\x0e\xb5\x1b\x80\x0e\xb5\x1b`\x0e\xb5\x1b\xe0\x0e\xb5\x1b\x80\x0c\xb5\x1b`\x0f\xb5\x1b`\t\xb5\x1b@\x0b\xb5\x1b \x0f\xb5\x1b\xe0\x0f\xb5\x1b\x00\x0c\xb5\x1b\xa0\x0f\xb5\x1b@\x0e\xb5\x1b@\x0f\xb5\x1b\xc0\r\xb5\x1b\x80\x0f\xb5\x1b\xc0\x0b\xb5\x1b\xe0\n\xb5\x1b@\n\xb5\x1b`\r\xb5\x1b\xc0\x0f\xb5\x1b\x00\x0e\xb5\x1b\x00\x0f\xb5\x1b\xa0\x0e\xb5\x1b@\x06\xb5\x1b\x009\r\x0c@\xb2\xd9\x1b \xb2\xd9\x1b\xc0\xb0\xd9\x1b@\xb1\xd9\x1b\x00\xb2\xd9\x1b\xe0\xb0\xd9\x1b`\xb0\xd9\x1b\x00\xb1\xd9\x1b@\xb0\xd9\x1b\xc0\xb2\xd9\x1b\xa0\xb2\xd9\x1b\x80\xb2\xd9\x1b\x00\xb3\xd9\x1b\xc0\x0c\xb5\x1b\xa0\xb0\xd9\x1b \xb3\xd9\x1b@\xb3\xd9\x1b`\xb3\xd9\x1b\xc0\xb1\xd9\x1b\xe0\xb1\xd9\x1b \xb4\xd9\x1b\x80\xb0\xd9\x1b`\xb2\xd9\x1b\x00\xb4\xd9\x1b\x80\xb4\xd9\x1b\xa0\xb3\xd9\x1b`\xb4\xd9\x1b\xc0\xb4\xd9\x1b\x80\xb1\xd9\x1b\xe0\xb4\xd9\x1b\xa0\xb5\xd9\x1b`\xb1\xd9\x1b \xb6\xd9\x1b \xb1\xd9\x1b\x80\xb6\xd9\x1b\xc0\xb5\xd9\x1b@\xb4\xd9\x1b\xa0\xb6\xd9\x1b\xc0\xb3\xd9\x1b\x80\xb5\xd9\x1b\x80\xb3\xd9\x1b\xc0\xb6\xd9\x1b\xe0\xb3\xd9\x1b\xa0\xb1\xd9\x1b`\xb5\xd9\x1b\xa0\xb7\xd9\x1b \xb7\xd9\x1b`\xb7\xd9\x1b\x80\xb7\xd9\x1b\xc0\xb7\xd9\x1b \xb8\xd9\x1b\x00\xb5\xd9\x1b \xb0\xd9\x1b\xa0\xb4\xd9\x1b@\xb5\xd9\x1b\xe0\xb8\xd9\x1b\x00\xb6\xd9\x1b@\xb6\xd9\x1b\xc0\xb8\xd9\x1b \x0e\xb5\x1b\x80\xb9\xd9\x1b\xa0\xb9\xd9\x1b\xe0\xb2\xd9\x1b`\xb8\xd9\x1b \xba\xd9\x1b \xb5\xd9\x1b`\xb6\xd9\x1b\x00\xba\xd9\x1b\xa0\xba\xd9\x1b \xb9\xd9\x1b@\xb9\xd9\x1b\x00\xb8\xd9\x1b\xe0\xb5\xd9\x1b@\xb7\xd9\x1b\xc0\xba\xd9\x1b\xe0\xb9\xd9\x1b@\xb8\xd9\x1b\x00\xb7\xd9\x1b`\xba\xd9\x1b@\xba\xd9\x1b\xe0\xb6\xd9\x1b\xc0\xbb\xd9\x1b@\xbc\xd9\x1b`\xb9\xd9\x1b\xa0\xbc\xd9\x1b\xe0\xb7\xd9\x1b\xc0\xbc\xd9\x1b`\xbc\xd9\x1b'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg9126
g9119
(g9120
g93
g9121
S'b'
tRp10241
(I1
(I200
I1
tg9123
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00@\x00\x00@@\x00\x00\x80@\x00\x00\xa0@\x00\x00\xc0@\x00\x00\xe0@\x00\x00\x00A\x00\x00\x10A\x00\x00 A\x00\x000A\x00\x00@A\x00\x00PA\x00\x00`A\x00\x00pA\x00\x00\x80A\x00\x00\x88A\x00\x00\x90A\x00\x00\x98A\x00\x00\xa0A\x00\x00\xa8A\x00\x00\xb0A\x00\x00\xb8A\x00\x00\xc0A\x00\x00\xc8A\x00\x00\xd0A\x00\x00\xd8A\x00\x00\xe0A\x00\x00\xe8A\x00\x00\xf0A\x00\x00\xf8A\x00\x00\x00B\x00\x00\x04B\x00\x00\x08B\x00\x00\x0cB\x00\x00\x10B\x00\x00\x14B\x00\x00\x18B\x00\x00\x1cB\x00\x00 B\x00\x00$B\x00\x00(B\x00\x00,B\x00\x000B\x00\x004B\x00\x008B\x00\x00<B\x00\x00@B\x00\x00DB\x00\x00HB\x00\x00LB\x00\x00PB\x00\x00TB\x00\x00XB\x00\x00\\B\x00\x00`B\x00\x00dB\x00\x00hB\x00\x00lB\x00\x00pB\x00\x00tB\x00\x00xB\x00\x00|B\x00\x00\x80B\x00\x00\x82B\x00\x00\x84B\x00\x00\x86B\x00\x00\x88B\x00\x00\x8aB\x00\x00\x8cB\x00\x00\x8eB\x00\x00\x90B\x00\x00\x92B\x00\x00\x94B\x00\x00\x96B\x00\x00\x98B\x00\x00\x9aB\x00\x00\x9cB\x00\x00\x9eB\x00\x00\xa0B\x00\x00\xa2B\x00\x00\xa4B\x00\x00\xa6B\x00\x00\xa8B\x00\x00\xaaB\x00\x00\xacB\x00\x00\xaeB\x00\x00\xb0B\x00\x00\xb2B\x00\x00\xb4B\x00\x00\xb6B\x00\x00\xb8B\x00\x00\xbaB\x00\x00\xbcB\x00\x00\xbeB\x00\x00\xc0B\x00\x00\xc2B\x00\x00\xc4B\x00\x00\xc6B\x00\x00\xc8B\x00\x00\xcaB\x00\x00\xccB\x00\x00\xceB\x00\x00\xd0B\x00\x00\xd2B\x00\x00\xd4B\x00\x00\xd6B\x00\x00\xd8B\x00\x00\xdaB\x00\x00\xdcB\x00\x00\xdeB\x00\x00\xe0B\x00\x00\xe2B\x00\x00\xe4B\x00\x00\xe6B\x00\x00\xe8B\x00\x00\xeaB\x00\x00\xecB\x00\x00\xeeB\x00\x00\xf0B\x00\x00\xf2B\x00\x00\xf4B\x00\x00\xf6B\x00\x00\xf8B\x00\x00\xfaB\x00\x00\xfcB\x00\x00\xfeB\x00\x00\x00C\x00\x00\x01C\x00\x00\x02C\x00\x00\x03C\x00\x00\x04C\x00\x00\x05C\x00\x00\x06C\x00\x00\x07C\x00\x00\x08C\x00\x00\tC\x00\x00\nC\x00\x00\x0bC\x00\x00\x0cC\x00\x00\rC\x00\x00\x0eC\x00\x00\x0fC\x00\x00\x10C\x00\x00\x11C\x00\x00\x12C\x00\x00\x13C\x00\x00\x14C\x00\x00\x15C\x00\x00\x16C\x00\x00\x17C\x00\x00\x18C\x00\x00\x19C\x00\x00\x1aC\x00\x00\x1bC\x00\x00\x1cC\x00\x00\x1dC\x00\x00\x1eC\x00\x00\x1fC\x00\x00 C\x00\x00!C\x00\x00"C\x00\x00#C\x00\x00$C\x00\x00%C\x00\x00&C\x00\x00\'C\x00\x00(C\x00\x00)C\x00\x00*C\x00\x00+C\x00\x00,C\x00\x00-C\x00\x00.C\x00\x00/C\x00\x000C\x00\x001C\x00\x002C\x00\x003C\x00\x004C\x00\x005C\x00\x006C\x00\x007C\x00\x008C\x00\x009C\x00\x00:C\x00\x00;C\x00\x00<C\x00\x00=C\x00\x00>C\x00\x00?C\x00\x00@C\x00\x00AC\x00\x00BC\x00\x00CC\x00\x00DC\x00\x00EC\x00\x00FC\x00\x00GC'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg39
g9119
(g9120
g93
g9121
S'b'
tRp10242
(I1
(I200
I1
tg9123
I00
S'\xdd\xc1L?\x85\x98*?\x82\x8c\x08?\xc3\x17"?\xc0-3?\xbbU&?\xe8\xb3;?J\xb5;?\xcda&?~\xbb;?\x84\xa0*?q\xc2L?\\`&?\xc4hw?w\x92\x19?*\xe0.?\xec\\&?0\x15@?\x0bM\x15?\xde\xa7\x8a?\x0823?\xcdN\x15?^,3?u\xbb;?$\x91\x19?H\xed.?\xb8\xc6\x0c?\xd0\x10"?\x8c\x97\x19?\xaao\x15?9\x92*?>\x94\x19?\x9d*3?\x9f+D?8\xe8.?\xff\xac*?\xad@\x84?\xe2w7?\x8b\x9dj?)03?\xd5\xdb\x1d?\xe9\x9a*?}W\x15?\xc8\x19"?N\x82H?\xbb\xe9n?f\xaa*?\x80x7?\xc3\x98Y?"\xf8??\xea\x94Y?\xcb\x91Y?\xfe\x1c"?cv7?\xe5PU?\xaeo7?\xbc-3?\x8f\xa3j?n\xde\x1d?\xf5Q\x15?\x90\x1e"?\xc7EU?~?\x84?\x84\xfb??\xea_f?\xaa\x05/?\xb15s?\xd9\xcaL?\xb5r7?\xdfi7?\xb6\xd6]?\xaai&?\xd1=D?\xd4MU?\xa7r\xd7?\x04P\x15?\xe0_&?\xd7\xa9*?\x85p7?\x88\xb7;?\x89\x1b"?Z,3?S^f?\xee=D?\xf4\xda]?9\xba;?i\xc9\x8c?\xe5N\x15?\x89\xb3;?\x9e33?\x9f+3?\xbeNU?PTU? \x8bY?\xabVU?\xea\xabj?9_&?\x0f3\x93?WS\x15?\xb1\x11\x11?\xeb\x9d*?3:"?\x8f\x94\x19?\xd4Q\x15?\x98\x96\x19?\x87\x1a3?+\xe9.?\x01\x81&?\xd5\xa4*?\x1caf?r;D?\x9c\xe8.?\x9fff?\xd3\xe7.?\x8c\xe5.?\xbdzH?z\x93\x19?\xb9\xe4.?\x11\xe8.?\xf6\xf2.?\x18\xeb.?x\x0b\x11?R\xf8??\x01\xfa??\xc7\xfb??-6D?\x97\xd9\x1d?\x9b\xb5;?\x18\xed.?W\xce\x1d?#Q\x15?w\xb8;?\xfb\xd9\x1d?\x96M\x15?\xe3\x95\x19?\xe5N\x15?\xff\x1ab?d\xbe;?\x89\xc6L?5\x1e"?;\x93Y?B\x81\x19?\x08\xf7??\xc9\x00@?\xf3]&?\x82\tQ?Y\xea.?\xdf\xec.?\xd5\xa2j?\xb6\x93\x88?\x1b\x1d"?\x83\xee.?/\x87H?\xd3\x1d\x82?%c7?\xa0\xec.?\x9a+3?Gv7?\xb3`&?\x0ep7?\xba\x94Y?\x03E3?\xab\xad;?XO\x15?\x82\xb9\x0b@\xea\xcb]?\x8d\xc8L?\xdb=D?\xf4n7?\xcfO\x15?\x84\x1d\xa2?\xdfVf?\x10\xf0.?\xa2*3?\x04a&?(\x81\xa8?Z\x1b"?k\xbb;?}]D?]\x95Y?\xbb\xb4;?+\xa7*?D\x1e\x82?\xde\x12Q?\x9f\xb6\x19?\xaeo7?yM\x15?+\x0fQ?\xd3\x1c"?p\xb5;?\xd2\xdc\x1d?y`&?\x02o7?"A\x84?7\xa6j?m=D?h\x99\xd9?e\xf8P?\xb0v7?\t\x96\x19?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg34
g9119
(g9120
g93
g9121
S'b'
tRp10243
(I1
(I200
I1
tg9245
I00
S'@:\xbb\x04p1\xbb\x048\xac\x12\x0c\xc0\xae\x12\x0cx\xa5\x12\x0c(\xad\x12\x0c\xf0\xae\x12\x0c\x08\xa3\x12\x0cX\xa1\x12\x0c\x08\xac\x12\x0c\xa0\xa7\x12\x0c@\xad\x12\x0c\x10\xaa\x12\x0c\xd8\xa2\x12\x0cx\xab\x12\x0c\xa0\xa4\x12\x0c\x88\xad\x12\x0c8\xa6\x12\x0c\xa0\xad\x12\x0c \xa0\x12\x0cH\xa8\x12\x0c \xaf\x12\x0c\xd0\xaa\x12\x0c\xf0\xa2\x12\x0c\xe8\xa4\x12\x0c@\xa7\x12\x0c\x98\xa6\x12\x0c\xf0\xa8\x12\x0c\xf8\xac\x12\x0c\x18\xae\x12\x0c\xd8\xa5\x12\x0c \xa9\x12\x0c\xf0\xab\x12\x0ch\xa6\x12\x0c\xa8\xa2\x12\x0c\xb8\xaa\x12\x0c`\xa2\x12\x0cX\xa4\x12\x0c0\xa8\x12\x0c8\x9c\xf0\x04\x88\x94\xf0\x04\x90\x95\xf0\x04 \x9c\xf0\x04h\x90\xf0\x04\x10\x91\xf0\x04\xa8\x95\xf0\x04\x98\x90\xf0\x04\x18\x92\xf0\x04\xc8\x9f\xf0\x04\xd0\x94\xf0\x04\xb0\x90\xf0\x04\xd8\x9b\xf0\x04X\x9a\xf0\x04\x00\x9b\xf0\x04\x80\x93\xf0\x04\xb8\x97\xf0\x04\xc8\x93\xf0\x04 \x90\xf0\x04\xa0\x97\xf0\x04\xf0\x95\xf0\x04p\x9d\xf0\x04(\x97\xf0\x04\xd8\x98\xf0\x04\x88\x91\xf0\x04\xf0\x98\xf0\x04X\x94\xf0\x04`\x9b\xf0\x04\x90\x9b\xf0\x04H\x92\xf0\x04\xb0\x93\xf0\x04\x08\x9f\xf0\x04\xc0\x9b\xf0\x040\x98\xf0\x04`\x95\xf0\x04p\x94\xf0\x04\xd8\x95\xf0\x04\xd0\x9a\xf0\x04\x08\x93\xf0\x04x\x98\xf0\x04`\x98\xf0\x04H\x98\xf0\x04x\x95\xf0\x04\xf8\x93\xf0\x048\x99\xf0\x04\xb8\x9a\xf0\x04\xf8\x99\xf0\x04\xa0\x9d\xf0\x04P\x93\xf0\x04@\x97\xf0\x04\xa0\x91\xf0\x04\x10\x97\xf0\x04\xf8\x90\xf0\x04\xa8\x98\xf0\x04\xa8\x92\xf0\x04X\x91\xf0\x04`\x92\xf0\x04\xe0\x96\xf0\x04@\x94\xf0\x04\xb0\x99\xf0\x04\x80\x99\xf0\x04@\x9d\xf0\x048\x9f\xf0\x04\xe8\x97\xf0\x04\xf8\x96\xf0\x04\xe8\x94\xf0\x04\x10\x9a\xf0\x04\xd0\x97\xf0\x04`\x9e\xf0\x04(\x9d\xf0\x04\x90\x98\xf0\x04\x98\x99\xf0\x04\x98\x9c\xf0\x04\x00\x9e\xf0\x04\x18\x9b\xf0\x04\xc8\x99\xf0\x04\xc8\x96\xf0\x04x\x9b\xf0\x04\xb0\x96\xf0\x04\x08\x99\xf0\x04p\x91\xf0\x04\xc0\x9e\xf0\x04 \x96\xf0\x040\x92\xf0\x04h\x99\xf0\x04\x18\x9e\xf0\x04\xe0\x93\xf0\x040\x9e\xf0\x04\xd8\x9e\xf0\x04(\x94\xf0\x04 \x93\xf0\x04 \x99\xf0\x04\x18\x95\xf0\x04\x10\x94\xf0\x04\xb8\x91\xf0\x04P\x9c\xf0\x04h\x96\xf0\x04H\x9b\xf0\x048\x93\xf0\x04P\x90\xf0\x04\xc0\x95\xf0\x04\xf8\x9c\xf0\x04(\x9a\xf0\x04\x88\x97\xf0\x04\x00\x98\xf0\x04\xd0\x91\xf0\x04\xb8\x9d\xf0\x04\xa0\x94\xf0\x04\xe0\x9f\xf0\x04X\x9d\xf0\x04\xd8\x92\xf0\x04\x08\x9c\xf0\x04\x90\x9e\xf0\x04\xa0\x9a\xf0\x04\xc0\x98\xf0\x04\xb8\x94\xf0\x04\xc8\x9c\xf0\x04\x90\x92\xf0\x04\xc8\x90\xf0\x04\x88\x9d\xf0\x04H\x9e\xf0\x04x\x92\xf0\x04h\x9f\xf0\x04\x98\x96\xf0\x04h\x9c\xf0\x04\x18\x98\xf0\x04\x08\x96\xf0\x04\xf0\x9e\xf0\x04\xe0\x99\xf0\x04\x98\x93\xf0\x04\xb0\x9c\xf0\x04\xd0\x9d\xf0\x04\x80\x96\xf0\x04\xe8\x9a\xf0\x04p\x9a\xf0\x04\xb0\x9f\xf0\x04\x88\x9a\xf0\x04\xa8\x9e\xf0\x04H\x95\xf0\x04x\x9e\xf0\x04\x00\x95\xf0\x04p\x97\xf0\x040\x95\xf0\x04@\x9a\xf0\x04P\x99\xf0\x04\xe0\x9c\xf0\x04\xf0\x9b\xf0\x04\xe8\x9d\xf0\x04\xc0\x92\xf0\x04h\x93\xf0\x04\x98\x9f\xf0\x04P\x96\xf0\x040\x9b\xf0\x04 \x9f\xf0\x048\x96\xf0\x04\xf0\x92\xf0\x04\x80\x90\xf0\x04\x10\x9d\xf0\x04P\x9f\xf0\x04\x80\x9f\xf0\x04\x80\x9c\xf0\x04'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp10244
(dp10245
g9131
(dp10246
g9118
I01
sg38
I00
sg33
I00
sg9126
I01
sg39
I01
sg34
I00
ssg9133
g10233
sg9134
(lp10247
g9118
ag9126
ag38
ag39
ag33
ag34
asg9136
(lp10248
I200
aI1
asbsg9138
g9253
sg9140
g92
(g93
(I0
tS'b'
tRp10249
(I1
(I200
I1
tg99
I00
S'\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00\x04\x00\x00\x00\x05\x00\x00\x00\x06\x00\x00\x00\x07\x00\x00\x00\x08\x00\x00\x00\t\x00\x00\x00\n\x00\x00\x00\x0b\x00\x00\x00\x0c\x00\x00\x00\r\x00\x00\x00\x0e\x00\x00\x00\x0f\x00\x00\x00\x10\x00\x00\x00\x11\x00\x00\x00\x12\x00\x00\x00\x13\x00\x00\x00\x14\x00\x00\x00\x15\x00\x00\x00\x16\x00\x00\x00\x17\x00\x00\x00\x18\x00\x00\x00\x19\x00\x00\x00\x1a\x00\x00\x00\x1b\x00\x00\x00\x1c\x00\x00\x00\x1d\x00\x00\x00\x1e\x00\x00\x00\x1f\x00\x00\x00 \x00\x00\x00!\x00\x00\x00"\x00\x00\x00#\x00\x00\x00$\x00\x00\x00%\x00\x00\x00&\x00\x00\x00\'\x00\x00\x00(\x00\x00\x00)\x00\x00\x00*\x00\x00\x00+\x00\x00\x00,\x00\x00\x00-\x00\x00\x00.\x00\x00\x00/\x00\x00\x000\x00\x00\x001\x00\x00\x002\x00\x00\x003\x00\x00\x004\x00\x00\x005\x00\x00\x006\x00\x00\x007\x00\x00\x008\x00\x00\x009\x00\x00\x00:\x00\x00\x00;\x00\x00\x00<\x00\x00\x00=\x00\x00\x00>\x00\x00\x00?\x00\x00\x00@\x00\x00\x00A\x00\x00\x00B\x00\x00\x00C\x00\x00\x00D\x00\x00\x00E\x00\x00\x00F\x00\x00\x00G\x00\x00\x00H\x00\x00\x00I\x00\x00\x00J\x00\x00\x00K\x00\x00\x00L\x00\x00\x00M\x00\x00\x00N\x00\x00\x00O\x00\x00\x00P\x00\x00\x00Q\x00\x00\x00R\x00\x00\x00S\x00\x00\x00T\x00\x00\x00U\x00\x00\x00V\x00\x00\x00W\x00\x00\x00X\x00\x00\x00Y\x00\x00\x00Z\x00\x00\x00[\x00\x00\x00\\\x00\x00\x00]\x00\x00\x00^\x00\x00\x00_\x00\x00\x00`\x00\x00\x00a\x00\x00\x00b\x00\x00\x00c\x00\x00\x00d\x00\x00\x00e\x00\x00\x00f\x00\x00\x00g\x00\x00\x00h\x00\x00\x00i\x00\x00\x00j\x00\x00\x00k\x00\x00\x00l\x00\x00\x00m\x00\x00\x00n\x00\x00\x00o\x00\x00\x00p\x00\x00\x00q\x00\x00\x00r\x00\x00\x00s\x00\x00\x00t\x00\x00\x00u\x00\x00\x00v\x00\x00\x00w\x00\x00\x00x\x00\x00\x00y\x00\x00\x00z\x00\x00\x00{\x00\x00\x00|\x00\x00\x00}\x00\x00\x00~\x00\x00\x00\x7f\x00\x00\x00\x80\x00\x00\x00\x81\x00\x00\x00\x82\x00\x00\x00\x83\x00\x00\x00\x84\x00\x00\x00\x85\x00\x00\x00\x86\x00\x00\x00\x87\x00\x00\x00\x88\x00\x00\x00\x89\x00\x00\x00\x8a\x00\x00\x00\x8b\x00\x00\x00\x8c\x00\x00\x00\x8d\x00\x00\x00\x8e\x00\x00\x00\x8f\x00\x00\x00\x90\x00\x00\x00\x91\x00\x00\x00\x92\x00\x00\x00\x93\x00\x00\x00\x94\x00\x00\x00\x95\x00\x00\x00\x96\x00\x00\x00\x97\x00\x00\x00\x98\x00\x00\x00\x99\x00\x00\x00\x9a\x00\x00\x00\x9b\x00\x00\x00\x9c\x00\x00\x00\x9d\x00\x00\x00\x9e\x00\x00\x00\x9f\x00\x00\x00\xa0\x00\x00\x00\xa1\x00\x00\x00\xa2\x00\x00\x00\xa3\x00\x00\x00\xa4\x00\x00\x00\xa5\x00\x00\x00\xa6\x00\x00\x00\xa7\x00\x00\x00\xa8\x00\x00\x00\xa9\x00\x00\x00\xaa\x00\x00\x00\xab\x00\x00\x00\xac\x00\x00\x00\xad\x00\x00\x00\xae\x00\x00\x00\xaf\x00\x00\x00\xb0\x00\x00\x00\xb1\x00\x00\x00\xb2\x00\x00\x00\xb3\x00\x00\x00\xb4\x00\x00\x00\xb5\x00\x00\x00\xb6\x00\x00\x00\xb7\x00\x00\x00\xb8\x00\x00\x00\xb9\x00\x00\x00\xba\x00\x00\x00\xbb\x00\x00\x00\xbc\x00\x00\x00\xbd\x00\x00\x00\xbe\x00\x00\x00\xbf\x00\x00\x00\xc0\x00\x00\x00\xc1\x00\x00\x00\xc2\x00\x00\x00\xc3\x00\x00\x00\xc4\x00\x00\x00\xc5\x00\x00\x00\xc6\x00\x00\x00\xc7\x00\x00\x00'
tbsg9142
I01
sg9143
I1
sg9144
I-1
sg9145
(lp10250
g1
(g9147
g9116
(dp10251
g6383
g6376
sg6371
g6372
sg6385
g6386
sg6380
g6381
stRp10252
ag1
(g9147
g9116
(dp10253
g6383
g6396
sg6371
g6392
sg6385
g6403
sg6380
g6400
stRp10254
ag1
(g9147
g9116
(dp10255
g6383
g6413
sg6371
g6409
sg6385
g6420
sg6380
g6417
stRp10256
ag1
(g9147
g9116
(dp10257
g6383
g6430
sg6371
g6426
sg6385
g6437
sg6380
g6434
stRp10258
ag1
(g9147
g9116
(dp10259
g6383
g6447
sg6371
g6443
sg6385
g6454
sg6380
g6451
stRp10260
ag1
(g9147
g9116
(dp10261
g6383
g6464
sg6371
g6460
sg6385
g6471
sg6380
g6468
stRp10262
ag1
(g9147
g9116
(dp10263
g6383
g6487
sg6371
g6477
sg6385
g6481
sg6380
g6485
stRp10264
ag1
(g9147
g9116
(dp10265
g6383
g6498
sg6371
g6494
sg6385
g6505
sg6380
g6502
stRp10266
ag1
(g9147
g9116
(dp10267
g6383
g6447
sg6371
g6511
sg6385
g6454
sg6380
g6518
stRp10268
ag1
(g9147
g9116
(dp10269
g6383
g6536
sg6371
g6526
sg6385
g6530
sg6380
g6534
stRp10270
ag1
(g9147
g9116
(dp10271
g6383
g6547
sg6371
g6543
sg6385
g6554
sg6380
g6551
stRp10272
ag1
(g9147
g9116
(dp10273
g6383
g6564
sg6371
g6560
sg6385
g6571
sg6380
g6568
stRp10274
ag1
(g9147
g9116
(dp10275
g6383
g6581
sg6371
g6577
sg6385
g6588
sg6380
g6585
stRp10276
ag1
(g9147
g9116
(dp10277
g6383
g6564
sg6371
g6594
sg6385
g6571
sg6380
g6601
stRp10278
ag1
(g9147
g9116
(dp10279
g6383
g6613
sg6371
g6609
sg6385
g6620
sg6380
g6617
stRp10280
ag1
(g9147
g9116
(dp10281
g6383
g6564
sg6371
g6594
sg6385
g6571
sg6380
g6601
stRp10282
ag1
(g9147
g9116
(dp10283
g6383
g6413
sg6371
g6409
sg6385
g6420
sg6380
g6417
stRp10284
ag1
(g9147
g9116
(dp10285
g6383
g6656
sg6371
g6652
sg6385
g6663
sg6380
g6660
stRp10286
ag1
(g9147
g9116
(dp10287
g6383
g6581
sg6371
g6577
sg6385
g6588
sg6380
g6585
stRp10288
ag1
(g9147
g9116
(dp10289
g6383
g6686
sg6371
g6682
sg6385
g6693
sg6380
g6690
stRp10290
ag1
(g9147
g9116
(dp10291
g6383
g6703
sg6371
g6699
sg6385
g6710
sg6380
g6707
stRp10292
ag1
(g9147
g9116
(dp10293
g6383
g6720
sg6371
g6716
sg6385
g6727
sg6380
g6724
stRp10294
ag1
(g9147
g9116
(dp10295
g6383
g6613
sg6371
g6733
sg6385
g6620
sg6380
g6740
stRp10296
ag1
(g9147
g9116
(dp10297
g6383
g6498
sg6371
g6748
sg6385
g6505
sg6380
g6755
stRp10298
ag1
(g9147
g9116
(dp10299
g6383
g6656
sg6371
g6763
sg6385
g6663
sg6380
g6770
stRp10300
ag1
(g9147
g9116
(dp10301
g6383
g6782
sg6371
g6778
sg6385
g6789
sg6380
g6786
stRp10302
ag1
(g9147
g9116
(dp10303
g6383
g6703
sg6371
g6699
sg6385
g6710
sg6380
g6707
stRp10304
ag1
(g9147
g9116
(dp10305
g6383
g6396
sg6371
g6808
sg6385
g6403
sg6380
g6815
stRp10306
ag1
(g9147
g9116
(dp10307
g6383
g6782
sg6371
g6823
sg6385
g6789
sg6380
g6830
stRp10308
ag1
(g9147
g9116
(dp10309
g6383
g6686
sg6371
g6682
sg6385
g6693
sg6380
g6690
stRp10310
ag1
(g9147
g9116
(dp10311
g6383
g6396
sg6371
g6392
sg6385
g6403
sg6380
g6400
stRp10312
ag1
(g9147
g9116
(dp10313
g6383
g6487
sg6371
g6477
sg6385
g6481
sg6380
g6485
stRp10314
ag1
(g9147
g9116
(dp10315
g6383
g6581
sg6371
g6877
sg6385
g6588
sg6380
g6884
stRp10316
ag1
(g9147
g9116
(dp10317
g6383
g6396
sg6371
g6392
sg6385
g6403
sg6380
g6400
stRp10318
ag1
(g9147
g9116
(dp10319
g6383
g6915
sg6371
g6905
sg6385
g6909
sg6380
g6913
stRp10320
ag1
(g9147
g9116
(dp10321
g6383
g6376
sg6371
g6922
sg6385
g6386
sg6380
g6929
stRp10322
ag1
(g9147
g9116
(dp10323
g6383
g6703
sg6371
g6937
sg6385
g6710
sg6380
g6944
stRp10324
ag1
(g9147
g9116
(dp10325
g6383
g6487
sg6371
g6952
sg6385
g6481
sg6380
g6959
stRp10326
ag1
(g9147
g9116
(dp10327
g6383
g6686
sg6371
g6967
sg6385
g6693
sg6380
g6974
stRp10328
ag1
(g9147
g9116
(dp10329
g6383
g6464
sg6371
g6982
sg6385
g6471
sg6380
g6989
stRp10330
ag1
(g9147
g9116
(dp10331
g6383
g7001
sg6371
g6997
sg6385
g7008
sg6380
g7005
stRp10332
ag1
(g9147
g9116
(dp10333
g6383
g6396
sg6371
g6808
sg6385
g6403
sg6380
g6815
stRp10334
ag1
(g9147
g9116
(dp10335
g6383
g7001
sg6371
g6997
sg6385
g7008
sg6380
g7005
stRp10336
ag1
(g9147
g9116
(dp10337
g6383
g6782
sg6371
g6823
sg6385
g6789
sg6380
g6830
stRp10338
ag1
(g9147
g9116
(dp10339
g6383
g6703
sg6371
g6937
sg6385
g6710
sg6380
g6944
stRp10340
ag1
(g9147
g9116
(dp10341
g6383
g6536
sg6371
g7066
sg6385
g6530
sg6380
g7073
stRp10342
ag1
(g9147
g9116
(dp10343
g6383
g6656
sg6371
g6763
sg6385
g6663
sg6380
g6770
stRp10344
ag1
(g9147
g9116
(dp10345
g6383
g6376
sg6371
g6922
sg6385
g6386
sg6380
g6929
stRp10346
ag1
(g9147
g9116
(dp10347
g6383
g6498
sg6371
g6748
sg6385
g6505
sg6380
g6755
stRp10348
ag1
(g9147
g9116
(dp10349
g6383
g6720
sg6371
g7120
sg6385
g6727
sg6380
g7127
stRp10350
ag1
(g9147
g9116
(dp10351
g6383
g6547
sg6371
g7135
sg6385
g6554
sg6380
g7142
stRp10352
ag1
(g9147
g9116
(dp10353
g6383
g6536
sg6371
g7066
sg6385
g6530
sg6380
g7073
stRp10354
ag1
(g9147
g9116
(dp10355
g6383
g6720
sg6371
g7120
sg6385
g6727
sg6380
g7127
stRp10356
ag1
(g9147
g9116
(dp10357
g6383
g6447
sg6371
g6443
sg6385
g6454
sg6380
g6451
stRp10358
ag1
(g9147
g9116
(dp10359
g6383
g6613
sg6371
g6609
sg6385
g6620
sg6380
g6617
stRp10360
ag1
(g9147
g9116
(dp10361
g6383
g6686
sg6371
g6682
sg6385
g6693
sg6380
g6690
stRp10362
ag1
(g9147
g9116
(dp10363
g6383
g6547
sg6371
g6543
sg6385
g6554
sg6380
g6551
stRp10364
ag1
(g9147
g9116
(dp10365
g6383
g6498
sg6371
g6494
sg6385
g6505
sg6380
g6502
stRp10366
ag1
(g9147
g9116
(dp10367
g6383
g6720
sg6371
g6716
sg6385
g6727
sg6380
g6724
stRp10368
ag1
(g9147
g9116
(dp10369
g6383
g6782
sg6371
g6823
sg6385
g6789
sg6380
g6830
stRp10370
ag1
(g9147
g9116
(dp10371
g6383
g6487
sg6371
g6952
sg6385
g6481
sg6380
g6959
stRp10372
ag1
(g9147
g9116
(dp10373
g6383
g6430
sg6371
g7280
sg6385
g6437
sg6380
g7287
stRp10374
ag1
(g9147
g9116
(dp10375
g6383
g6498
sg6371
g6748
sg6385
g6505
sg6380
g6755
stRp10376
ag1
(g9147
g9116
(dp10377
g6383
g6464
sg6371
g6460
sg6385
g6471
sg6380
g6468
stRp10378
ag1
(g9147
g9116
(dp10379
g6383
g6915
sg6371
g7321
sg6385
g6909
sg6380
g7328
stRp10380
ag1
(g9147
g9116
(dp10381
g6383
g6656
sg6371
g6763
sg6385
g6663
sg6380
g6770
stRp10382
ag1
(g9147
g9116
(dp10383
g6383
g6464
sg6371
g6460
sg6385
g6471
sg6380
g6468
stRp10384
ag1
(g9147
g9116
(dp10385
g6383
g6430
sg6371
g6426
sg6385
g6437
sg6380
g6434
stRp10386
ag1
(g9147
g9116
(dp10387
g6383
g7001
sg6371
g7375
sg6385
g7008
sg6380
g7382
stRp10388
ag1
(g9147
g9116
(dp10389
g6383
g6564
sg6371
g6594
sg6385
g6571
sg6380
g6601
stRp10390
ag1
(g9147
g9116
(dp10391
g6383
g6613
sg6371
g6609
sg6385
g6620
sg6380
g6617
stRp10392
ag1
(g9147
g9116
(dp10393
g6383
g6915
sg6371
g7321
sg6385
g6909
sg6380
g7328
stRp10394
ag1
(g9147
g9116
(dp10395
g6383
g6464
sg6371
g6982
sg6385
g6471
sg6380
g6989
stRp10396
ag1
(g9147
g9116
(dp10397
g6383
g6613
sg6371
g6609
sg6385
g6620
sg6380
g6617
stRp10398
ag1
(g9147
g9116
(dp10399
g6383
g6536
sg6371
g7066
sg6385
g6530
sg6380
g7073
stRp10400
ag1
(g9147
g9116
(dp10401
g6383
g7001
sg6371
g6997
sg6385
g7008
sg6380
g7005
stRp10402
ag1
(g9147
g9116
(dp10403
g6383
g6915
sg6371
g6905
sg6385
g6909
sg6380
g6913
stRp10404
ag1
(g9147
g9116
(dp10405
g6383
g6396
sg6371
g6808
sg6385
g6403
sg6380
g6815
stRp10406
ag1
(g9147
g9116
(dp10407
g6383
g6413
sg6371
g7507
sg6385
g6420
sg6380
g7514
stRp10408
ag1
(g9147
g9116
(dp10409
g6383
g6376
sg6371
g6922
sg6385
g6386
sg6380
g6929
stRp10410
ag1
(g9147
g9116
(dp10411
g6383
g6782
sg6371
g6823
sg6385
g6789
sg6380
g6830
stRp10412
ag1
(g9147
g9116
(dp10413
g6383
g6613
sg6371
g6733
sg6385
g6620
sg6380
g6740
stRp10414
ag1
(g9147
g9116
(dp10415
g6383
g6376
sg6371
g6372
sg6385
g6386
sg6380
g6381
stRp10416
ag1
(g9147
g9116
(dp10417
g6383
g7001
sg6371
g7375
sg6385
g7008
sg6380
g7382
stRp10418
ag1
(g9147
g9116
(dp10419
g6383
g6581
sg6371
g6877
sg6385
g6588
sg6380
g6884
stRp10420
ag1
(g9147
g9116
(dp10421
g6383
g6447
sg6371
g6443
sg6385
g6454
sg6380
g6451
stRp10422
ag1
(g9147
g9116
(dp10423
g6383
g6720
sg6371
g7120
sg6385
g6727
sg6380
g7127
stRp10424
ag1
(g9147
g9116
(dp10425
g6383
g6413
sg6371
g7507
sg6385
g6420
sg6380
g7514
stRp10426
ag1
(g9147
g9116
(dp10427
g6383
g6703
sg6371
g6699
sg6385
g6710
sg6380
g6707
stRp10428
ag1
(g9147
g9116
(dp10429
g6383
g6547
sg6371
g6543
sg6385
g6554
sg6380
g6551
stRp10430
ag1
(g9147
g9116
(dp10431
g6383
g7001
sg6371
g7375
sg6385
g7008
sg6380
g7382
stRp10432
ag1
(g9147
g9116
(dp10433
g6383
g6686
sg6371
g6967
sg6385
g6693
sg6380
g6974
stRp10434
ag1
(g9147
g9116
(dp10435
g6383
g6498
sg6371
g6494
sg6385
g6505
sg6380
g6502
stRp10436
ag1
(g9147
g9116
(dp10437
g6383
g6564
sg6371
g6560
sg6385
g6571
sg6380
g6568
stRp10438
ag1
(g9147
g9116
(dp10439
g6383
g6703
sg6371
g6937
sg6385
g6710
sg6380
g6944
stRp10440
ag1
(g9147
g9116
(dp10441
g6383
g6430
sg6371
g7280
sg6385
g6437
sg6380
g7287
stRp10442
ag1
(g9147
g9116
(dp10443
g6383
g6447
sg6371
g6511
sg6385
g6454
sg6380
g6518
stRp10444
ag1
(g9147
g9116
(dp10445
g6383
g6536
sg6371
g7066
sg6385
g6530
sg6380
g7073
stRp10446
ag1
(g9147
g9116
(dp10447
g6383
g6581
sg6371
g6577
sg6385
g6588
sg6380
g6585
stRp10448
ag1
(g9147
g9116
(dp10449
g6383
g6915
sg6371
g7321
sg6385
g6909
sg6380
g7328
stRp10450
ag1
(g9147
g9116
(dp10451
g6383
g6564
sg6371
g6560
sg6385
g6571
sg6380
g6568
stRp10452
ag1
(g9147
g9116
(dp10453
g6383
g6487
sg6371
g6477
sg6385
g6481
sg6380
g6485
stRp10454
ag1
(g9147
g9116
(dp10455
g6383
g6430
sg6371
g7280
sg6385
g6437
sg6380
g7287
stRp10456
ag1
(g9147
g9116
(dp10457
g6383
g7001
sg6371
g6997
sg6385
g7008
sg6380
g7005
stRp10458
ag1
(g9147
g9116
(dp10459
g6383
g6782
sg6371
g6778
sg6385
g6789
sg6380
g6786
stRp10460
ag1
(g9147
g9116
(dp10461
g6383
g6396
sg6371
g6392
sg6385
g6403
sg6380
g6400
stRp10462
ag1
(g9147
g9116
(dp10463
g6383
g6413
sg6371
g7507
sg6385
g6420
sg6380
g7514
stRp10464
ag1
(g9147
g9116
(dp10465
g6383
g6430
sg6371
g6426
sg6385
g6437
sg6380
g6434
stRp10466
ag1
(g9147
g9116
(dp10467
g6383
g6581
sg6371
g6577
sg6385
g6588
sg6380
g6585
stRp10468
ag1
(g9147
g9116
(dp10469
g6383
g6430
sg6371
g6426
sg6385
g6437
sg6380
g6434
stRp10470
ag1
(g9147
g9116
(dp10471
g6383
g6656
sg6371
g6652
sg6385
g6663
sg6380
g6660
stRp10472
ag1
(g9147
g9116
(dp10473
g6383
g6547
sg6371
g7135
sg6385
g6554
sg6380
g7142
stRp10474
ag1
(g9147
g9116
(dp10475
g6383
g6703
sg6371
g6937
sg6385
g6710
sg6380
g6944
stRp10476
ag1
(g9147
g9116
(dp10477
g6383
g6686
sg6371
g6967
sg6385
g6693
sg6380
g6974
stRp10478
ag1
(g9147
g9116
(dp10479
g6383
g6656
sg6371
g6763
sg6385
g6663
sg6380
g6770
stRp10480
ag1
(g9147
g9116
(dp10481
g6383
g6564
sg6371
g6560
sg6385
g6571
sg6380
g6568
stRp10482
ag1
(g9147
g9116
(dp10483
g6383
g7001
sg6371
g6997
sg6385
g7008
sg6380
g7005
stRp10484
ag1
(g9147
g9116
(dp10485
g6383
g6915
sg6371
g7321
sg6385
g6909
sg6380
g7328
stRp10486
ag1
(g9147
g9116
(dp10487
g6383
g6564
sg6371
g6594
sg6385
g6571
sg6380
g6601
stRp10488
ag1
(g9147
g9116
(dp10489
g6383
g6613
sg6371
g6609
sg6385
g6620
sg6380
g6617
stRp10490
ag1
(g9147
g9116
(dp10491
g6383
g6547
sg6371
g6543
sg6385
g6554
sg6380
g6551
stRp10492
ag1
(g9147
g9116
(dp10493
g6383
g6487
sg6371
g6952
sg6385
g6481
sg6380
g6959
stRp10494
ag1
(g9147
g9116
(dp10495
g6383
g6656
sg6371
g6652
sg6385
g6663
sg6380
g6660
stRp10496
ag1
(g9147
g9116
(dp10497
g6383
g6613
sg6371
g6733
sg6385
g6620
sg6380
g6740
stRp10498
ag1
(g9147
g9116
(dp10499
g6383
g6464
sg6371
g6460
sg6385
g6471
sg6380
g6468
stRp10500
ag1
(g9147
g9116
(dp10501
g6383
g6703
sg6371
g6937
sg6385
g6710
sg6380
g6944
stRp10502
ag1
(g9147
g9116
(dp10503
g6383
g6447
sg6371
g6511
sg6385
g6454
sg6380
g6518
stRp10504
ag1
(g9147
g9116
(dp10505
g6383
g6656
sg6371
g6763
sg6385
g6663
sg6380
g6770
stRp10506
ag1
(g9147
g9116
(dp10507
g6383
g6686
sg6371
g6682
sg6385
g6693
sg6380
g6690
stRp10508
ag1
(g9147
g9116
(dp10509
g6383
g6564
sg6371
g6594
sg6385
g6571
sg6380
g6601
stRp10510
ag1
(g9147
g9116
(dp10511
g6383
g6782
sg6371
g6778
sg6385
g6789
sg6380
g6786
stRp10512
ag1
(g9147
g9116
(dp10513
g6383
g6703
sg6371
g6699
sg6385
g6710
sg6380
g6707
stRp10514
ag1
(g9147
g9116
(dp10515
g6383
g7001
sg6371
g7375
sg6385
g7008
sg6380
g7382
stRp10516
ag1
(g9147
g9116
(dp10517
g6383
g6703
sg6371
g6699
sg6385
g6710
sg6380
g6707
stRp10518
ag1
(g9147
g9116
(dp10519
g6383
g6464
sg6371
g6982
sg6385
g6471
sg6380
g6989
stRp10520
ag1
(g9147
g9116
(dp10521
g6383
g6430
sg6371
g7280
sg6385
g6437
sg6380
g7287
stRp10522
ag1
(g9147
g9116
(dp10523
g6383
g6915
sg6371
g6905
sg6385
g6909
sg6380
g6913
stRp10524
ag1
(g9147
g9116
(dp10525
g6383
g6547
sg6371
g7135
sg6385
g6554
sg6380
g7142
stRp10526
ag1
(g9147
g9116
(dp10527
g6383
g6376
sg6371
g6372
sg6385
g6386
sg6380
g6381
stRp10528
ag1
(g9147
g9116
(dp10529
g6383
g6447
sg6371
g6511
sg6385
g6454
sg6380
g6518
stRp10530
ag1
(g9147
g9116
(dp10531
g6383
g6498
sg6371
g6748
sg6385
g6505
sg6380
g6755
stRp10532
ag1
(g9147
g9116
(dp10533
g6383
g6396
sg6371
g6808
sg6385
g6403
sg6380
g6815
stRp10534
ag1
(g9147
g9116
(dp10535
g6383
g6915
sg6371
g6905
sg6385
g6909
sg6380
g6913
stRp10536
ag1
(g9147
g9116
(dp10537
g6383
g6613
sg6371
g6733
sg6385
g6620
sg6380
g6740
stRp10538
ag1
(g9147
g9116
(dp10539
g6383
g6547
sg6371
g7135
sg6385
g6554
sg6380
g7142
stRp10540
ag1
(g9147
g9116
(dp10541
g6383
g6686
sg6371
g6967
sg6385
g6693
sg6380
g6974
stRp10542
ag1
(g9147
g9116
(dp10543
g6383
g6498
sg6371
g6494
sg6385
g6505
sg6380
g6502
stRp10544
ag1
(g9147
g9116
(dp10545
g6383
g6547
sg6371
g7135
sg6385
g6554
sg6380
g7142
stRp10546
ag1
(g9147
g9116
(dp10547
g6383
g6581
sg6371
g6877
sg6385
g6588
sg6380
g6884
stRp10548
ag1
(g9147
g9116
(dp10549
g6383
g6430
sg6371
g7280
sg6385
g6437
sg6380
g7287
stRp10550
ag1
(g9147
g9116
(dp10551
g6383
g6498
sg6371
g6494
sg6385
g6505
sg6380
g6502
stRp10552
ag1
(g9147
g9116
(dp10553
g6383
g6413
sg6371
g6409
sg6385
g6420
sg6380
g6417
stRp10554
ag1
(g9147
g9116
(dp10555
g6383
g6376
sg6371
g6922
sg6385
g6386
sg6380
g6929
stRp10556
ag1
(g9147
g9116
(dp10557
g6383
g6547
sg6371
g6543
sg6385
g6554
sg6380
g6551
stRp10558
ag1
(g9147
g9116
(dp10559
g6383
g6396
sg6371
g6808
sg6385
g6403
sg6380
g6815
stRp10560
ag1
(g9147
g9116
(dp10561
g6383
g6413
sg6371
g6409
sg6385
g6420
sg6380
g6417
stRp10562
ag1
(g9147
g9116
(dp10563
g6383
g6656
sg6371
g6652
sg6385
g6663
sg6380
g6660
stRp10564
ag1
(g9147
g9116
(dp10565
g6383
g6464
sg6371
g6982
sg6385
g6471
sg6380
g6989
stRp10566
ag1
(g9147
g9116
(dp10567
g6383
g6720
sg6371
g7120
sg6385
g6727
sg6380
g7127
stRp10568
ag1
(g9147
g9116
(dp10569
g6383
g6464
sg6371
g6982
sg6385
g6471
sg6380
g6989
stRp10570
ag1
(g9147
g9116
(dp10571
g6383
g6536
sg6371
g6526
sg6385
g6530
sg6380
g6534
stRp10572
ag1
(g9147
g9116
(dp10573
g6383
g6487
sg6371
g6477
sg6385
g6481
sg6380
g6485
stRp10574
ag1
(g9147
g9116
(dp10575
g6383
g6564
sg6371
g6560
sg6385
g6571
sg6380
g6568
stRp10576
ag1
(g9147
g9116
(dp10577
g6383
g6720
sg6371
g6716
sg6385
g6727
sg6380
g6724
stRp10578
ag1
(g9147
g9116
(dp10579
g6383
g6536
sg6371
g6526
sg6385
g6530
sg6380
g6534
stRp10580
ag1
(g9147
g9116
(dp10581
g6383
g6487
sg6371
g6952
sg6385
g6481
sg6380
g6959
stRp10582
ag1
(g9147
g9116
(dp10583
g6383
g6686
sg6371
g6682
sg6385
g6693
sg6380
g6690
stRp10584
ag1
(g9147
g9116
(dp10585
g6383
g6376
sg6371
g6922
sg6385
g6386
sg6380
g6929
stRp10586
ag1
(g9147
g9116
(dp10587
g6383
g6413
sg6371
g7507
sg6385
g6420
sg6380
g7514
stRp10588
ag1
(g9147
g9116
(dp10589
g6383
g6915
sg6371
g7321
sg6385
g6909
sg6380
g7328
stRp10590
ag1
(g9147
g9116
(dp10591
g6383
g6782
sg6371
g6823
sg6385
g6789
sg6380
g6830
stRp10592
ag1
(g9147
g9116
(dp10593
g6383
g6581
sg6371
g6877
sg6385
g6588
sg6380
g6884
stRp10594
ag1
(g9147
g9116
(dp10595
g6383
g6487
sg6371
g6952
sg6385
g6481
sg6380
g6959
stRp10596
ag1
(g9147
g9116
(dp10597
g6383
g6613
sg6371
g6733
sg6385
g6620
sg6380
g6740
stRp10598
ag1
(g9147
g9116
(dp10599
g6383
g6915
sg6371
g6905
sg6385
g6909
sg6380
g6913
stRp10600
ag1
(g9147
g9116
(dp10601
g6383
g6686
sg6371
g6967
sg6385
g6693
sg6380
g6974
stRp10602
ag1
(g9147
g9116
(dp10603
g6383
g6720
sg6371
g6716
sg6385
g6727
sg6380
g6724
stRp10604
ag1
(g9147
g9116
(dp10605
g6383
g6447
sg6371
g6443
sg6385
g6454
sg6380
g6451
stRp10606
ag1
(g9147
g9116
(dp10607
g6383
g6536
sg6371
g7066
sg6385
g6530
sg6380
g7073
stRp10608
ag1
(g9147
g9116
(dp10609
g6383
g6430
sg6371
g6426
sg6385
g6437
sg6380
g6434
stRp10610
ag1
(g9147
g9116
(dp10611
g6383
g6581
sg6371
g6577
sg6385
g6588
sg6380
g6585
stRp10612
ag1
(g9147
g9116
(dp10613
g6383
g6720
sg6371
g7120
sg6385
g6727
sg6380
g7127
stRp10614
ag1
(g9147
g9116
(dp10615
g6383
g6536
sg6371
g6526
sg6385
g6530
sg6380
g6534
stRp10616
ag1
(g9147
g9116
(dp10617
g6383
g6464
sg6371
g6460
sg6385
g6471
sg6380
g6468
stRp10618
ag1
(g9147
g9116
(dp10619
g6383
g6413
sg6371
g6409
sg6385
g6420
sg6380
g6417
stRp10620
ag1
(g9147
g9116
(dp10621
g6383
g7001
sg6371
g7375
sg6385
g7008
sg6380
g7382
stRp10622
ag1
(g9147
g9116
(dp10623
g6383
g6782
sg6371
g6778
sg6385
g6789
sg6380
g6786
stRp10624
ag1
(g9147
g9116
(dp10625
g6383
g6376
sg6371
g6372
sg6385
g6386
sg6380
g6381
stRp10626
ag1
(g9147
g9116
(dp10627
g6383
g6720
sg6371
g6716
sg6385
g6727
sg6380
g6724
stRp10628
ag1
(g9147
g9116
(dp10629
g6383
g6447
sg6371
g6511
sg6385
g6454
sg6380
g6518
stRp10630
ag1
(g9147
g9116
(dp10631
g6383
g6413
sg6371
g7507
sg6385
g6420
sg6380
g7514
stRp10632
ag1
(g9147
g9116
(dp10633
g6383
g6487
sg6371
g6477
sg6385
g6481
sg6380
g6485
stRp10634
ag1
(g9147
g9116
(dp10635
g6383
g6782
sg6371
g6778
sg6385
g6789
sg6380
g6786
stRp10636
ag1
(g9147
g9116
(dp10637
g6383
g6498
sg6371
g6748
sg6385
g6505
sg6380
g6755
stRp10638
ag1
(g9147
g9116
(dp10639
g6383
g6581
sg6371
g6877
sg6385
g6588
sg6380
g6884
stRp10640
ag1
(g9147
g9116
(dp10641
g6383
g6447
sg6371
g6443
sg6385
g6454
sg6380
g6451
stRp10642
ag1
(g9147
g9116
(dp10643
g6383
g6536
sg6371
g6526
sg6385
g6530
sg6380
g6534
stRp10644
ag1
(g9147
g9116
(dp10645
g6383
g6396
sg6371
g6392
sg6385
g6403
sg6380
g6400
stRp10646
ag1
(g9147
g9116
(dp10647
g6383
g6376
sg6371
g6372
sg6385
g6386
sg6380
g6381
stRp10648
ag1
(g9147
g9116
(dp10649
g6383
g6656
sg6371
g6652
sg6385
g6663
sg6380
g6660
stRp10650
asg9228
Nsg9229
g9086
sg9230
I200
sg9231
I0
sg9232
I200
sg9233
I01
sbasS'savePickle'
p10651
I00
sb.